<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@3.5.0/dist/jquery.min.js"></script>
    <script src="https://www.lactame.com/lib/image-js/0.21.2/image.min.js"></script> 
    <script src="https://rawgit.com/kawanet/msgpack-lite/master/dist/msgpack.min.js"></script>
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
    <script src="../dist/mindar.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gpu.js@latest/dist/gpu-browser.min.js"></script>
    <script>
      const getGreyImage = (image) => {
        const greyImage = {
          width: image.width,
          height: image.height,
          data: []
        }
        for (let i = 0; i < image.data.length; i+=4) {
          greyImage.data.push( Math.floor((image.data[i] + image.data[i+1] + image.data[i+2]) / 3));
        }
        return greyImage;
      }

      AFRAME.registerSystem('ar-system', {
        AR_PROCESS_DIMENSION_MAX: 640,
        //AR_PROCESS_DIMENSION_MAX: 320,

        container: null,
        video: null,
        processReady: false,
        processingImage: false,

        init: function() {
          this.anchorEntities = [];
        },

        tick: function() {
          if (this.mainStats) this.mainStats.update();

          if (this.processReady) {
            if (!this.processingImage) {
              if (this.workerStats) this.workerStats.update();
              this.processingImage = true;
              this._processImage();
            }
          }
        },

        registerAnchor: function(el) {
          const markerIndex = this.anchorEntities.length;
          this.anchorEntities.push(el);
          return markerIndex;
        },

        start: function() {
          this.container = this.el.sceneEl.parentNode;

          this.mainStats = new Stats();
          this.mainStats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
          this.mainStats.domElement.style.cssText = 'position:absolute;top:0px;left:0px;z-index:999';
          this.workerStats = new Stats();
          this.workerStats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
          this.workerStats.domElement.style.cssText = 'position:absolute;top:0px;left:80px;z-index:999';

          this.container.appendChild(this.mainStats.domElement);
          this.container.appendChild(this.workerStats.domElement);

          this._startVideo();
        },
        stop: function() {
          this.processReady = false;
          this.video.pause();
        },

        _startVideo: function() {
          this.video = document.createElement('video');

          this.video.setAttribute('autoplay', '');
          this.video.setAttribute('muted', '');
          this.video.setAttribute('playsinline', '');
          this.video.style.position = 'absolute'
          this.video.style.top = '0px'
          this.video.style.left = '0px'
          this.video.style.zIndex = '-2'
          this.container.appendChild(this.video);

          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            // TODO: show unsupported error
            return;
          }

          navigator.mediaDevices.getUserMedia({audio: false, video: {
            facingMode: 'environment',
            //width: {ideal: 480},
            //height: {ideal: 640},
          }}).then((stream) => {
            this.video.srcObject = stream;
            this.video.addEventListener( 'loadedmetadata', () => {
              console.log("video ready...", this.video);
              this._startAR();
            });
          });
        },

        __startVideo: function() {
          this.img = document.createElement('img');
          this.img.onload = () => {
            this.video.videoWidth = this.video.width;
            this.video.videoHeight = this.video.height;
            this._startAR();
          }
          this.img.src = "./assets/test.png";
          this.img.style.position = 'absolute'
          //this.img.style.top = '0px';
          //this.img.style.left = '0px';
          //this.img.style.width = '100%';
          //this.img.style.height = '100%';
          this.img.style.zIndex = '-2';
          this.container.appendChild(this.img);

          this.video = this.img;
        },

        _startAR: async function() {
          this.controller = new MINDAR.Controller({});
          //this.controller = new MINDAR.Controller({useworker: false});
          //await this.controller.setup(this.AR_PROCESS_WIDTH, this.AR_PROCESS_HEIGHT);

          this._computeSizes(this.container, this.video);

          const {vw, vh, pw, ph, cw, ch, cx, cy, sw, sh, sx, sy, tw, th, tx, ty} = this.sizes;
          //await this.controller.setup({inputWidth: pw, inputHeight: ph, smartMatching: true});
          await this.controller.setup({inputWidth: pw, inputHeight: ph, smartMatching: false});

          const proj = this.controller.getProjectionMatrix();
          //const fov = 2 * Math.atan(1/proj[5]) * 180 / Math.PI; // vertical fov
          //const fov = 2 * Math.atan(1/proj[5] * ph / vh / vh * this.container.clientHeight ) * 180 / Math.PI; // vertical fov
          //const fov = 2 * Math.atan(1/proj[5] / vh * this.container.clientHeight ) * 180 / Math.PI; // vertical fov
          const fov = 2 * Math.atan(1/proj[5] / vh * this.container.clientHeight ) * 180 / Math.PI; // vertical fov
          const near = proj[14] / (proj[10] - 1.0);
          const far = proj[14] / (proj[10] + 1.0);
          const ratio = proj[5] / proj[0]; // (r-l) / (t-b)
          console.log("loaded proj: ", proj, ". fov: ", fov, ". near: ", near, ". far: ", far, ". ratio: ", ratio);
          //const newRatio = ratio / ((this.AR_PROCESS_WIDTH/this.AR_PROCESS_HEIGHT)/(this.container.clientWidth/this.container.clientHeight));
          const newRatio = ratio / ((pw/ph)/(this.container.clientWidth/this.container.clientHeight));

          //const newRatio = ratio;
          const newFov = fov;
          //const focal = (this.AR_PROCESS_HEIGHT/2) / Math.tan(fov/2 * Math.PI / 180);
          //const newFov = 2 * Math.atan( (this.container.clientHeight/2) / focal) * 180 / Math.PI;

          //const newCam = new AFRAME.THREE.PerspectiveCamera(fov, ratio, 10, 10000);
          console.log("newCam", newFov, newRatio);
          const newCam = new AFRAME.THREE.PerspectiveCamera(newFov, newRatio, 10, 10000);

          const camera = this.container.getElementsByTagName("a-camera")[0];
          camera.getObject3D('camera').projectionMatrix = newCam.projectionMatrix;
          //camera.setObject3D('camera', newCam);
          //document.getElementById('#camera').getObject3D('camera');
          //this.el.sceneEl.camera.el.setObject3D('camera', newCam);

          this.video.style.top = (-(vh - this.container.clientHeight) / 2) + "px";
          this.video.style.left = (-(vw - this.container.clientWidth) / 2) + "px";
          this.video.style.width = vw + "px";
          this.video.style.height = vh + "px";

          const processCanvas = document.createElement('canvas');
          this.workerProcessContext = processCanvas.getContext('2d');
          processCanvas.width = pw;
          processCanvas.height = ph;
          processCanvas.style.position = "absolute";
          processCanvas.style.left = 0;
          processCanvas.style.bottom = 0;
          processCanvas.style.width = '200px';
          this.container.appendChild(processCanvas);

          const processCanvas2 = document.createElement('canvas');
          this.workerProcessContext2 = processCanvas2.getContext('2d');
          processCanvas2.width = pw;
          processCanvas2.height = ph;
          processCanvas2.style.position = "absolute";
          processCanvas2.style.right = 0;
          processCanvas2.style.bottom = 0;
          processCanvas2.style.width = '200px';
          this.container.appendChild(processCanvas2);

          const compiledMSP = await fetch('./assets/newcard1.msp');
          const compiled = msgpack.decode(new Uint8Array(await compiledMSP.arrayBuffer()));
          await this.controller.addImageTarget({type: 'compiled', input: compiled});
          this.processReady = true;
        },

        _processImage: async function() {
          var _start = new Date().getTime();

          const {vw, vh, pw, ph, cw, ch, cx, cy, sw, sh, sx, sy, tw, th, tx, ty} = this.sizes;

          const processContext = this.workerProcessContext;
          //processContext.drawImage(this.video, sx, sy, sw, sh, tx, ty, tw, th);
          processContext.drawImage(this.video, 0, 0, pw, ph);

          const imageData = processContext.getImageData(0, 0, pw, ph);
          var _end = new Date().getTime();

          const processData = new Uint8Array(pw * ph);
          for (let i = 0; i < processData.length; i++) {
            const offset = i * 4;
            processData[i] = Math.floor((imageData.data[offset] + imageData.data[offset+1] + imageData.data[i+2])/3);
          }

          /*
          const greyImageData = new Uint8Array(imageData.data.length / 4);
          for (let i = 0; i < imageData.data.length; i += 4) {
            greyImageData[i/4] = Math.floor((imageData.data[i]+imageData.data[i+1]+imageData.data[i+2])/3);
            //greyImageData[i/4] = (imageData.data[i] * 3 + imageData.data[i+1] + imageData.data[i+2] * 4) >> 3;
          }
          //console.log("process data", greyImageData);
          */
          /*
          const debugImageData = this.workerProcessContext2.getImageData(0, 0, pw, ph);
          for (let i = 0; i < greyImageData.length; i++) {
            debugImageData.data[i*4+0] = greyImageData[i];
            debugImageData.data[i*4+1] = greyImageData[i];
            debugImageData.data[i*4+2] = greyImageData[i];
            debugImageData.data[i*4+3] = 255;
          }
          this.workerProcessContext2.putImageData(debugImageData, 0, 0);
          */
          var _end2 = new Date().getTime();

          //const result = await this.controller.process(greyImageData);
          const result = await this.controller.process(processData);
          
          //console.log('exec time process Image: ', _start, _end, _end - _start);
          var _end3 = new Date().getTime();
          $("#debug").html("<span>process time: " + (_end - _start) + "/" + (_end2 - _end) + "/" + (_end3 - _end2) + "</span>");

          //console.log("result: ", result);
          for (let i = 0; i < this.anchorEntities.length; i++) {
            this.anchorEntities[i].updateWorldMatrix(result[i].worldMatrix);
          }

          this.processingImage = false;
        },

        _computeSizes: function(container, video) {
          $("#debug").html("<span>video size: " + video.videoWidth + ", " + video.videoHeight + "</span>");
          console.log("video video size: ", video.videoWidth, video.videoHeight);

          // clip video is the portion of the video for ar process
          let vw, vh; // display css width, height
          let sx, sy; // clip video offset x, y for ar process
          let sw, sh; // clip video width, height for ar process
          const videoRatio = video.videoWidth / video.videoHeight;
          const containerRatio = container.clientWidth / container.clientHeight;
          if (videoRatio > containerRatio) {
            vh = container.clientHeight;
            vw = vh * videoRatio;

            sh = video.videoHeight;
            sw = sh * containerRatio;
            sy = 0;
            sx = (video.videoWidth - sw) / 2;
          } else {
            vw = container.clientWidth;
            vh = vw / videoRatio;

            sw = video.videoWidth;
            sh = sw / containerRatio;
            sx = 0;
            sy = (video.videoHeight - sh) / 2;
          }
        
          let vpRatio = Math.max(1, Math.max(video.videoWidth, video.videoHeight) / this.AR_PROCESS_DIMENSION_MAX);
          let pw = video.videoWidth / vpRatio;
          let ph = video.videoHeight / vpRatio;
          let pRatio = pw / ph;

          // fit the clip video source into the ar process size, keeping the ratio
          const sRatio = sw / sh; // clip ratio (= container ratio)
          let tw, th; // process context width, height
          let tx, ty; // process context offset x, y
          if (sRatio > pRatio) {
            tw = pw;
            th = tw / sRatio;
            tx = 0;
            ty = (ph - th) / 2;
          } else {
            th = ph;
            tw = th * sRatio;
            ty = 0;
            tx = (pw - tw) / 2;
          }

          let cw, ch; // draw canvas width, height
          let cx, cy; // draw canvas style offset left, top
          if (sRatio > pRatio) {
            cw = container.clientWidth;
            ch = cw / pRatio;
            cx = 0;
            cy = (ch - container.clientHeight) / 2;
          } else {
            ch = container.clientHeight;
            cw = ch * pRatio;
            cy = 0;
            cx = (cw - container.clientWidth) / 2;
          }

          const sizes = {
            vw, vh, pw, ph,
            cw, ch, cx, cy,
            sw, sh, sx, sy, tw, th, tx, ty
          }

          console.log('recompute sizes: ', sizes);
          this.sizes = sizes;
        }
      });

      AFRAME.registerComponent('ar', {
        dependencies: ['ar-system'],

        schema: {
          stats: {type: 'boolean', default: "false"}
        },

        init: function() {
          const arSystem = this.el.sceneEl.systems['ar-system'];
          this.el.sceneEl.addEventListener('renderstart', () => {
            // arSystem.start();
          });
        }
      });

      AFRAME.registerComponent('ar-nft-anchor', {
        dependencies: ['ar-system'],

        postMatrix: null, // rescale the anchor to make width of 1 unit = physical width of card

        init: function() {
          var root = this.el.object3D;
          root.matrixAutoUpdate = false;

          this.marker = {
            width: 674,
            height: 372,
            //dpi: 72,
          };

          const arSystem = this.el.sceneEl.systems['ar-system'];
          this.markerIndex = arSystem.registerAnchor(this);

          //const markerWidth = this.marker.width / this.marker.dpi * 2.54 * 10; // in mm
          //const markerHeight = this.marker.height / this.marker.dpi * 2.54 * 10; // in mm
          const markerWidth = this.marker.width;
          const markerHeight = this.marker.height
          const position = new AFRAME.THREE.Vector3();
          const quaternion = new AFRAME.THREE.Quaternion();
          const scale = new AFRAME.THREE.Vector3();
          position.x = markerWidth / 2;
          position.y = markerWidth / 2 + (markerHeight - markerWidth) / 2;
          scale.x = markerWidth;
          scale.y = markerWidth;
          scale.z = markerWidth;
          this.postMatrix = new AFRAME.THREE.Matrix4();
          this.postMatrix.compose(position, quaternion, scale);
        },

        updateWorldMatrix(worldMatrix) {
          this.el.object3D.visible = worldMatrix !== null;
          //if (worldMatrix !== null) this.el.object3D.visible = true;
          if (worldMatrix === null) {
            return;
          }
          var m = new AFRAME.THREE.Matrix4();
          m.elements = worldMatrix; 
          m.multiply(this.postMatrix);

          this.el.object3D.matrix = m;
        }
      });
    </script>

    <script>
      $(document).ready(function() {
        let started = false;
        $("#playButton").click(() => {
          const sceneEl = document.querySelector('a-scene');
          const arSystem = sceneEl.systems['ar-system'];
          if (!started) {
            arSystem.start();
            started = true;
          } else {
            arSystem.stop();
          }
        });
      });
    </script>

    <style>
      body {
        margin: 0;
      }
      .displayAR-container {
        overflow: hidden;
        position: absolute;
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <button id="playButton">Play</button>
    <span id="debug"></span>
    <div class="displayAR-container">
      <a-scene ar embedded color-space="sRGB" renderer="colorManagement: true, physicallyCorrectLights" vr-mode-ui="enabled: false">
        <a-assets>
          <img id="card" src="./assets/card1.png" />
        </a-assets>

        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

        <a-entity ar-nft-anchor>
          <a-plane src="#card" position="0 0 0" height="0.552" width="1" rotation="0 0 0">
          </a-plane>
          <a-entity rotation="90 0 0">
            <a-cylinder position="0.5 0.5 0" rotation="0 0 0" radius="0.1" height="1" color="#FFC65D"></a-cylinder>
          </a-entity>
        </a-entity>
      </a-scene>
    </div>
  </body>
</html>
