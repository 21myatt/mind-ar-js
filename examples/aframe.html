<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@3.5.0/dist/jquery.min.js"></script>
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
    <script src="../dist/mindar.js"></script>

    <script>
      var _start;
      var _last;
      var debugFrameMessage = '';
      const clearLogTime =  () => {
        _start = new Date().getTime();
        _last = new Date().getTime();
        debugFrameMessage = '';
      }; 
      const logTime = (title) => {
        return;
        debugFrameMessage += title + ':' + (new Date().getTime() - _last).toString().padStart(3, '0') + ". ";
        _last = new Date().getTime();
      }
      const logTotalTime = (title) => {
        return;
        debugFrameMessage += title + ':' + (new Date().getTime() - _start) + ". ";
      }

      AFRAME.registerSystem('mindar-system', {
        container: null,
        video: null,
        processReady: false,
        processingImage: false,

        init: function() {
          this.anchorEntities = [];
        },

        tick: function() {
          if (this.mainStats) this.mainStats.update();

          if (this.processReady) {
            if (!this.processingImage) {
              if (this.workerStats) this.workerStats.update();
              this.processingImage = true;
              this._processImage();
            }
          }
        },

        setup: function({imageTargetSrc, showStats}) {
          this.imageTargetSrc = imageTargetSrc;
          this.showStats = showStats;
        },

        registerAnchor: function(el, targetIndex) {
          this.anchorEntities.push({el: el, targetIndex: targetIndex});
        },

        start: function() {
          this.container = this.el.sceneEl.parentNode;

          if (this.showStats) {
            this.mainStats = new Stats();
            this.mainStats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
            this.mainStats.domElement.style.cssText = 'position:absolute;top:0px;left:0px;z-index:999';
            this.workerStats = new Stats();
            this.workerStats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
            this.workerStats.domElement.style.cssText = 'position:absolute;top:0px;left:80px;z-index:999';
            this.container.appendChild(this.mainStats.domElement);
            this.container.appendChild(this.workerStats.domElement);
          }

          this._startVideo();
        },

        stop: function() {
          this.processReady = false;
          this.video.pause();
        },

        _startVideo: function() {
          console.log("start video");
          this.video = document.createElement('video');

          this.video.setAttribute('autoplay', '');
          this.video.setAttribute('muted', '');
          this.video.setAttribute('playsinline', '');
          this.video.style.position = 'absolute'
          this.video.style.top = '0px'
          this.video.style.left = '0px'
          this.video.style.zIndex = '-2'
          this.container.appendChild(this.video);

          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            // TODO: show unsupported error
            return;
          }

          navigator.mediaDevices.getUserMedia({audio: false, video: {
            facingMode: 'environment',
          }}).then((stream) => {
            this.video.addEventListener( 'loadedmetadata', () => {
              console.log("video ready...", this.video);
              this.video.setAttribute('width', this.video.videoWidth);
              this.video.setAttribute('height', this.video.videoHeight);
              this._startAR();
            });
            this.video.srcObject = stream;
          }).catch((err) => {
            console.log("getUserMedia error", err);
          });
        },

        _startAR: async function() {
          const video = this.video;
          const container = this.container;

          let vw, vh; // display css width, height
          const videoRatio = video.videoWidth / video.videoHeight;
          const containerRatio = container.clientWidth / container.clientHeight;
          if (videoRatio > containerRatio) {
            vh = container.clientHeight;
            vw = vh * videoRatio;
          } else {
            vw = container.clientWidth;
            vh = vw / videoRatio;
          }

          this.controller = new MINDAR.Controller(video.videoWidth, video.videoHeight);

          const proj = this.controller.getProjectionMatrix();
          const fov = 2 * Math.atan(1/proj[5] / vh * container.clientHeight ) * 180 / Math.PI; // vertical fov
          const near = proj[14] / (proj[10] - 1.0);
          const far = proj[14] / (proj[10] + 1.0);
          const ratio = proj[5] / proj[0]; // (r-l) / (t-b)
          console.log("loaded proj: ", proj, ". fov: ", fov, ". near: ", near, ". far: ", far, ". ratio: ", ratio);
          const newRatio = container.clientWidth / container.clientHeight;
          console.log("newCam", fov, ratio, newRatio);
          const newCam = new AFRAME.THREE.PerspectiveCamera(fov, newRatio, near, far);

          const camera = container.getElementsByTagName("a-camera")[0];
          camera.getObject3D('camera').projectionMatrix = newCam.projectionMatrix;

          this.video.style.top = (-(vh - container.clientHeight) / 2) + "px";
          this.video.style.left = (-(vw - container.clientWidth) / 2) + "px";
          this.video.style.width = vw + "px";
          this.video.style.height = vh + "px";

          await this.controller.addImageTargets(this.imageTargetSrc);
          const imageTargetDimensions = this.controller.getImageTargetDimensions();

          for (let i = 0; i < this.anchorEntities.length; i++) {
            const {el, targetIndex} = this.anchorEntities[i];
            if (targetIndex < imageTargetDimensions.length) {
              el.setupMarker(imageTargetDimensions[targetIndex]);
            }
          }
          this.processReady = true;
        },

        _processImage: async function() {
          clearLogTime();

          logTime('input');

          const result = await this.controller.process(this.video);
          //const result = [{worldMatrix: null}];

          logTotalTime('total');
          
          $("#debug").html(debugFrameMessage);

          for (let i = 0; i < this.anchorEntities.length; i++) {
            const {el, targetIndex} = this.anchorEntities[i];
            if (targetIndex < result.length) {
              el.updateWorldMatrix(result[targetIndex].worldMatrix);
            }
          }

          this.processingImage = false;
        }
     });

      AFRAME.registerComponent('mindar', {
        dependencies: ['mindar-system'],

        schema: {
          imageTargetSrc: {type: 'string'},
          showStats: {type: 'boolean', default: "false"}
        },

        init: function() {
          const arSystem = this.el.sceneEl.systems['mindar-system'];
          arSystem.setup({imageTargetSrc: this.data.imageTargetSrc, showStats: this.data.showStats});
          this.el.sceneEl.addEventListener('renderstart', () => {
            // arSystem.start();
          });
        }
      });

      AFRAME.registerComponent('mindar-image-target', {
        dependencies: ['mindar-system'],

        postMatrix: null, // rescale the anchor to make width of 1 unit = physical width of card

        init: function() {
          const arSystem = this.el.sceneEl.systems['mindar-system'];
          arSystem.registerAnchor(this, this.data.targetIndex);

          const root = this.el.object3D;
          root.matrixAutoUpdate = false;
        },

        setupMarker([markerWidth, markerHeight]) {
          const position = new AFRAME.THREE.Vector3();
          const quaternion = new AFRAME.THREE.Quaternion();
          const scale = new AFRAME.THREE.Vector3();
          position.x = markerWidth / 2;
          position.y = markerWidth / 2 + (markerHeight - markerWidth) / 2;
          scale.x = markerWidth;
          scale.y = markerWidth;
          scale.z = markerWidth;
          this.postMatrix = new AFRAME.THREE.Matrix4();
          this.postMatrix.compose(position, quaternion, scale);
        },

        updateWorldMatrix(worldMatrix) {
          this.el.object3D.visible = worldMatrix !== null;
          if (worldMatrix === null) {
            return;
          }
          var m = new AFRAME.THREE.Matrix4();
          m.elements = worldMatrix; 
          m.multiply(this.postMatrix);
          this.el.object3D.matrix = m;
        }
      });
    </script>

    <script>
      $(document).ready(function() {
        let started = false;
        $("#playButton").click(() => {
          const sceneEl = document.querySelector('a-scene');
          const arSystem = sceneEl.systems['mindar-system'];
          if (!started) {
            arSystem.start();
            started = true;
          } else {
            arSystem.stop();
          }
        });
      });
    </script>

    <style>
      body {
        margin: 0;
      }
      .displayAR-container {
        overflow: hidden;
        position: absolute;
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <button id="playButton">Play</button>
    <span id="debug"></span>

    <div class="displayAR-container">
      <a-scene mindar="imageTargetSrc: ./assets/card1.mind; showStats: true" embedded color-space="sRGB" renderer="colorManagement: true, physicallyCorrectLights" vr-mode-ui="enabled: false">
        <a-assets>
          <img id="card" src="./assets/card1.png" />
        </a-assets>

        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

        <a-entity mindar-image-target="targetIndex: 0">
          <a-plane src="#card" position="0 0 0" height="0.552" width="1" rotation="0 0 0">
        </a-entity>

        <a-entity mindar-image-target="targetIndex: 2">
          <a-plane src="#card" position="0 0 0" height="0.552" width="1" rotation="0 0 0">
          </a-plane>
          <a-entity rotation="90 0 0">
            <a-cylinder position="0.5 0.5 0" rotation="0 0 0" radius="0.1" height="1" color="#FFC65D"></a-cylinder>
          </a-entity>
        </a-entity>
      </a-scene>
    </div>
    <div id="container">
    </div>
  </body>
</html>
