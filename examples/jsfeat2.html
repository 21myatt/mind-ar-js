<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <script src="https://www.lactame.com/lib/image-js/0.21.2/image.min.js"></script> 
  </head>
  <body>
      <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
      <script src="https://inspirit.github.io/jsfeat/js/compatibility.js"></script>
      <script src="https://inspirit.github.io/jsfeat/js/dat.gui.min.js"></script>

      <script src="../dist/mindar.js"></script>
      <script type="text/javascript">
        const jsfeat = MINDAR.jsfeat;

        //const pw = 320;
        //const ph = 240;
        const pw = 620;
        const ph = 460;
        const levImages = [];
        const levCorners = [];
        const levDescs = [];

        const options = {};
        options.blur_size = 5;
        options.lap_thres = 30;
        options.eigen_thres = 25;
        options.match_threshold = 48;

        var match_t = (function () {
          function match_t(screen_idx, pattern_lev, pattern_idx, distance) {
            if (typeof screen_idx === "undefined") { screen_idx=0; }
            if (typeof pattern_lev === "undefined") { pattern_lev=0; }
            if (typeof pattern_idx === "undefined") { pattern_idx=0; }
            if (typeof distance === "undefined") { distance=0; }

            this.screen_idx = screen_idx;
            this.pattern_lev = pattern_lev;
            this.pattern_idx = pattern_idx;
            this.distance = distance;
          }
          return match_t;
        })();

        const readImage = async (targetFilename) => {
          let targetImage = await IJS.Image.load('./assets/' + targetFilename + '.png');
          //document.getElementById('target-image').src = targetImage.toDataURL();
          console.log("targetImage",  targetImage);
          let img_u8 = new jsfeat.matrix_t(targetImage.width, targetImage.height, jsfeat.U8_t | jsfeat.C1_t);
          jsfeat.imgproc.grayscale(targetImage.data, targetImage.width, targetImage.height, img_u8);
          return img_u8;
        }

        const showImage = (targetImage, targetCorners, queryImage, queryCorners, matches) => {
          var canvas = document.getElementById('canvas');
          canvas.width  = targetImage.cols + queryImage.cols;
          canvas.height = Math.max(targetImage.rows, queryImage.rows);

          ctx = canvas.getContext('2d');
          var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          var data_u32 = new Uint32Array(imageData.data.buffer);
          var alpha = (0xff << 24);

          for (let c = 0; c < targetImage.cols; c++) {
            for (let r = 0; r < targetImage.rows; r++) {
              pix = targetImage.data[r * targetImage.cols + c];
              data_u32[r * canvas.width + c] = alpha | (pix << 16) | (pix << 8) | pix;
            }
          }
          for (let c = 0; c < queryImage.cols; c++) {
            for (let r = 0; r < queryImage.rows; r++) {
              pix = queryImage.data[r * queryImage.cols + c];
              data_u32[r * canvas.width + targetImage.cols + c] = alpha | (pix << 16) | (pix << 8) | pix;
            }
          }

          var pix = (0xff << 24) | (0x00 << 16) | (0xff << 8) | 0x00;
          for (var i=0; i < targetCorners.length; ++i) {
            var x = targetCorners[i].x;
            var y = targetCorners[i].y;
            var off = (x + y * canvas.width);
            data_u32[off] = pix;
            for (var size = 1; size <= 3; size++) {
              data_u32[off-size] = pix;
              data_u32[off+size] = pix;
              data_u32[off-size*canvas.width] = pix;
              data_u32[off+size*canvas.width] = pix;
            }
          }

          for (var i=0; i < queryCorners.length; ++i) {
            var x = queryCorners[i].x;
            var y = queryCorners[i].y;
            var off = (targetImage.cols + x + y * canvas.width);
            data_u32[off] = pix;
            for (var size = 1; size <= 3; size++) {
              data_u32[off-size] = pix;
              data_u32[off+size] = pix;
              data_u32[off-size*canvas.width] = pix;
              data_u32[off+size*canvas.width] = pix;
            }
          }

          ctx.putImageData(imageData, 0, 0);

          console.log("ctx", ctx);
          for (let i = 0; i < matches.length; ++i) {
          //for (let i = 0; i < 2; ++i) {
            var m = matches[i];
            var s_kp = queryCorners[m.screen_idx];
            var p_kp = targetCorners[m.pattern_idx];
            console.log("line", p_kp, s_kp);
            ctx.strokeStyle = "rgb(255,0,0)";
            ctx.beginPath();
            ctx.moveTo(p_kp.x, p_kp.y);
            ctx.lineTo(s_kp.x + targetImage.cols, s_kp.y);
            ctx.lineWidth=1;
            ctx.stroke();
          }
        }

        const detectCorners = (targetImage) => {
          var corners = [];
          var laplacian_threshold = 30;
          var min_eigen_value_threshold = 25;
           
          // choose threshold values
          jsfeat.yape06.laplacian_threshold = laplacian_threshold;
          jsfeat.yape06.min_eigen_value_threshold = min_eigen_value_threshold;
           
          // you should use preallocated keypoint_t array
          for (var i = 0; i < targetImage.cols * targetImage.rows; i++) {
            corners[i] = new jsfeat.keypoint_t(0, 0, 0, 0);
          }
           
          // perform detection
          // returns the amount of detected corners
          var count = jsfeat.yape06.detect(targetImage, corners, 5);
          for(var i = 0; i < count; ++i) {
            corners[i].angle = ic_angle(targetImage, corners[i].x, corners[i].y);
          }

          // prune features in 10x10 buckets
          const nBucketsPerDimension = 10;
          const nCornersPerBuckets = 5;
          const buckets = [];
          for (let i = 0; i < nBucketsPerDimension; i++) {
            for (let j = 0; j < nBucketsPerDimension; j++) {
              buckets.push([]);
            }
          }
          const bucketWidth = targetImage.cols / nBucketsPerDimension;
          const bucketHeight = targetImage.rows / nBucketsPerDimension;
          for (let c = 0; c < count; c++) {
            const bucketX = Math.floor(corners[c].x / bucketWidth);
            const bucketY = Math.floor(corners[c].y / bucketHeight);
            buckets[bucketY * nBucketsPerDimension + bucketX].push(corners[c]);
          }
          const finalCorners = [];
          for (let i = 0; i < buckets.length; i++) {
            jsfeat.math.qsort(buckets[i], 0, buckets[i].length-1, function(a,b) {return (b.score<a.score);});

            for (let j = 0; j < Math.min(buckets[i].length, nCornersPerBuckets); j++) {
              finalCorners.push(buckets[i][j]);
            }
          }
          return finalCorners;
        }

        // non zero bits count
        const popcnt32 = (n) => {
          n -= ((n >> 1) & 0x55555555);
          n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
          return (((n + (n >> 4))& 0xF0F0F0F)* 0x1010101) >> 24;
        }

        // central difference using image moments to find dominant orientation
        function ic_angle(img, px, py) {
          var u_max = new Int32Array([15,15,15,15,14,14,14,13,13,12,11,10,9,8,6,3,0]);
          var half_k = 15; // half patch size
          var m_01 = 0, m_10 = 0;
          var src=img.data, step=img.cols;
          var u=0, v=0, center_off=(py*step + px)|0;
          var v_sum=0,d=0,val_plus=0,val_minus=0;

          // Treat the center line differently, v=0
          for (u = -half_k; u <= half_k; ++u)
              m_10 += u * src[center_off+u];

          // Go line by line in the circular patch
          for (v = 1; v <= half_k; ++v) {
              // Proceed over the two lines
              v_sum = 0;
              d = u_max[v];
              for (u = -d; u <= d; ++u) {
                  val_plus = src[center_off+u+v*step];
                  val_minus = src[center_off+u-v*step];
                  v_sum += (val_plus - val_minus);
                  m_10 += u * (val_plus + val_minus);
              }
              m_01 += v * v_sum;
          }

          return Math.atan2(m_01, m_10);
        }

        const train = (img_u8) => {
          var num_train_levels = 4;
          var lev=0, i=0;
          //var sc = 1.0;
          var max_pattern_size = 512;
          var max_per_level = 300;
          var sc_inc = Math.sqrt(2.0); // magic number ;)
          var lev0_img = new jsfeat.matrix_t(img_u8.cols, img_u8.rows, jsfeat.U8_t | jsfeat.C1_t);
          var new_width=0, new_height=0;
          var lev_corners, lev_descr;
          var corners_num = 0;

          var sc = Math.min(max_pattern_size/img_u8.cols, max_pattern_size/img_u8.rows);
          for (let lev = 0; lev < num_train_levels; lev++) {
            new_width = (img_u8.cols * sc) | 0;
            new_height = (img_u8.rows * sc) | 0;

            var levImage = new jsfeat.matrix_t(new_width, new_height, jsfeat.U8_t | jsfeat.C1_t);
            jsfeat.imgproc.resample(img_u8, levImage, new_width, new_height);
            jsfeat.imgproc.gaussian_blur(levImage, levImage, options.blur_size|0);
            var corners = detectCorners(levImage);
            var desc = new jsfeat.matrix_t(32, corners.length, jsfeat.U8_t | jsfeat.C1_t);
            jsfeat.orb.describe(levImage, corners, corners.length, desc);

            console.log("lev", lev, levImage, corners, desc);
            sc /= sc_inc;

            levImages.push(levImage);
            levCorners.push(corners);
            levDescs.push(desc);
          }
        };

        // naive brute-force matching.
        // each on screen point is compared to all pattern points
        // to find the closest match
        const matchPattern = (screen_descriptors, pattern_descriptors, match_lev) => {
            var q_cnt = screen_descriptors.rows;
            var query_du8 = screen_descriptors.data;
            var query_u32 = screen_descriptors.buffer.i32; // cast to integer buffer
            var qd_off = 0;
            var qidx=0,lev=0,pidx=0,k=0;
            var num_matches = 0;

            var matches = [];
            
            for(qidx = 0; qidx < q_cnt; ++qidx) {
                var best_dist = 256;
                var best_dist2 = 256;
                var best_idx = -1;
                var best_lev = -1;

                for(lev = 0; lev < pattern_descriptors.length; ++lev) {
                  if (lev !== match_lev) continue;
                    var lev_descr = pattern_descriptors[lev];
                    var ld_cnt = lev_descr.rows;
                    var ld_i32 = lev_descr.buffer.i32; // cast to integer buffer
                    var ld_off = 0;

                    for(pidx = 0; pidx < ld_cnt; ++pidx) {

                        var curr_d = 0;
                        // our descriptor is 32 bytes so we have 8 Integers
                        for(k=0; k < 8; ++k) {
                            curr_d += popcnt32( query_u32[qd_off+k]^ld_i32[ld_off+k] );
                        }

                        if(curr_d < best_dist) {
                            best_dist2 = best_dist;
                            best_dist = curr_d;
                            best_lev = lev;
                            best_idx = pidx;
                        } else if(curr_d < best_dist2) {
                            best_dist2 = curr_d;
                        }

                        ld_off += 8; // next descriptor
                    }
                }


                // filter out by some threshold
                if(best_dist < options.match_threshold) {
                  const match = new match_t();
                  match.screen_idx = qidx;
                  match.pattern_lev = best_lev;
                  match.pattern_idx = best_idx;
                  matches.push(match)
                }
                //

              /*
                // filter using the ratio between 2 closest matches
                if(best_dist < 0.7*best_dist2) {
                  const match = new match_t();
                  match.screen_idx = qidx;
                  match.pattern_lev = best_lev;
                  match.pattern_idx = best_idx;
                  matches.push(match);
                }
                */
                qd_off += 8; // next query descriptor
            }
            return matches;
        }

        // estimate homography transform between matched points
        const findTransform = (matches, screen_corners, pattern_corners) => {
          // motion kernel
          var mm_kernel = new jsfeat.motion_model.homography2d();
          // ransac params
          var num_model_points = 4;
          var reproj_threshold = 3;
          var ransac_param = new jsfeat.ransac_params_t(num_model_points, reproj_threshold, 0.5, 0.99);

          var pattern_xy = [];
          var screen_xy = [];

          // construct correspondences
          for(var i = 0; i < matches.length; ++i) {
              var m = matches[i];
              var s_kp = screen_corners[m.screen_idx];
              var p_kp = pattern_corners[m.pattern_lev][m.pattern_idx];
              pattern_xy[i] = {"x":p_kp.x, "y":p_kp.y};
              screen_xy[i] =  {"x":s_kp.x, "y":s_kp.y};
          }

          const homo3x3 = new jsfeat.matrix_t(3,3,jsfeat.F32C1_t);
          const match_mask = new jsfeat.matrix_t(matches.length,1,jsfeat.U8C1_t);

          // estimate motion
          var ok = false;
          ok = jsfeat.motion_estimator.ransac(ransac_param, mm_kernel,
                                              pattern_xy, screen_xy, matches.length, homo3x3, match_mask, 1000);

          // extract good matches and re-estimate
          var good_cnt = 0;
          if(ok) {
              for(var i=0; i < matches.length; ++i) {
                  if(match_mask.data[i]) {
                      pattern_xy[good_cnt].x = pattern_xy[i].x;
                      pattern_xy[good_cnt].y = pattern_xy[i].y;
                      screen_xy[good_cnt].x = screen_xy[i].x;
                      screen_xy[good_cnt].y = screen_xy[i].y;

                      console.log("good match", pattern_xy[good_cnt], screen_xy[good_cnt]);

                      good_cnt++;

                  }
              }
              // run kernel directly with inliers only
              mm_kernel.run(pattern_xy, screen_xy, homo3x3, good_cnt);
          } else {
              jsfeat.matmath.identity_3x3(homo3x3, 1.0);
          }
          console.log("H: ", homo3x3.data);
          return match_mask;
        }

        async function process() {
          var start = new Date().getTime();
          const targetImage = await readImage("card1");
          train(targetImage);

          const _queryImage = await readImage("card1_2");

          var _start = new Date().getTime();
          const queryImage = new jsfeat.matrix_t(pw, ph, jsfeat.U8_t | jsfeat.C1_t);
          jsfeat.imgproc.resample(_queryImage, queryImage, pw, ph);
          const queryCorners = detectCorners(queryImage);
          console.log("query", queryImage, queryCorners);

          var queryDesc = new jsfeat.matrix_t(32, queryCorners.length, jsfeat.U8_t | jsfeat.C1_t);
          jsfeat.orb.describe(queryImage, queryCorners, queryCorners.length, queryDesc);
          //console.log("query corners: ", corners);

          var lev = 1;
          var matches = matchPattern(queryDesc, levDescs, lev);
          console.log("matches", matches);

          showImage(levImages[lev], levCorners[lev], queryImage, queryCorners, matches);

          const matchMask = findTransform(matches, queryCorners, levCorners);
          console.log("match mask", matchMask);
          console.log('exec time match: ', new Date().getTime() - _start);

          console.log('exec time: ', new Date().getTime() - start);
        }
        $(window).load(function() {
          process();


          let showLevel = null;
          $("#show").click(() => {
            if (showLevel === null) {
              showLevel = 0;
            } else {
              showLevel = (showLevel + 1) % levImages.length;
            }
            showImage(levImages[showLevel0], levCorners[showLevel], queryImage, queryCorners, matches);
          });
        });
      </script>

      <div>
        <button id="show">Show</button>
      </div>
      <canvas id="canvas"></canvas>
  </body>
</html>
