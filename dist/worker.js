/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/~hiukim/projects/WebCards/mind-ar-js/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/compiler.worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/gpu.js/dist/gpu-browser.js":
/*!*************************************************!*\
  !*** ./node_modules/gpu.js/dist/gpu-browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/**
 * gpu.js
 * http://gpu.rocks/
 *
 * GPU Accelerated JavaScript
 *
 * @version 2.9.4
 * @date Sat May 02 2020 11:46:49 GMT-0400 (Eastern Daylight Time)
 *
 * @license MIT
 * The MIT License
 *
 * Copyright (c) 2020 gpu.js Team
 */(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.acorn = {}));
}(this, function (exports) { 'use strict';


  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };


  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

  var keywords = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };

  var keywordRelationalOperator = /^in(stanceof)?$/;


  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;


  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];

  function isInAstralSet(code, set) {
    var pos = 0x10000;
    for (var i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code) { return false }
      pos += set[i + 1];
      if (pos >= code) { return true }
    }
  }


  function isIdentifierStart(code, astral) {
    if (code < 65) { return code === 36 }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes)
  }


  function isIdentifierChar(code, astral) {
    if (code < 48) { return code === 36 }
    if (code < 58) { return true }
    if (code < 65) { return false }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
  }





  var TokenType = function TokenType(label, conf) {
    if ( conf === void 0 ) conf = {};

    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };

  function binop(name, prec) {
    return new TokenType(name, {beforeExpr: true, binop: prec})
  }
  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};


  var keywords$1 = {};

  function kw(name, options) {
    if ( options === void 0 ) options = {};

    options.keyword = name;
    return keywords$1[name] = new TokenType(name, options)
  }

  var types = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    eof: new TokenType("eof"),

    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),


    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
    prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {beforeExpr: true}),

    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {isLoop: true, beforeExpr: true}),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {isLoop: true}),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {isLoop: true}),
    _with: kw("with"),
    _new: kw("new", {beforeExpr: true, startsExpr: true}),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {beforeExpr: true, binop: 7}),
    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
  };


  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");

  function isNewLine(code, ecma2019String) {
    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
  }

  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  var ref = Object.prototype;
  var hasOwnProperty = ref.hasOwnProperty;
  var toString = ref.toString;


  function has(obj, propName) {
    return hasOwnProperty.call(obj, propName)
  }

  var isArray = Array.isArray || (function (obj) { return (
    toString.call(obj) === "[object Array]"
  ); });

  function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
  }


  var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
  };

  Position.prototype.offset = function offset (n) {
    return new Position(this.line, this.column + n)
  };

  var SourceLocation = function SourceLocation(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) { this.source = p.sourceFile; }
  };


  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0;;) {
      lineBreakG.lastIndex = cur;
      var match = lineBreakG.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else {
        return new Position(line, offset - cur)
      }
    }
  }


  var defaultOptions = {
    ecmaVersion: 10,
    sourceType: "script",
    onInsertedSemicolon: null,
    onTrailingComma: null,
    allowReserved: null,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowAwaitOutsideFunction: false,
    allowHashBang: false,
    locations: false,
    onToken: null,
    onComment: null,
    ranges: false,
    program: null,
    sourceFile: null,
    directSourceFile: null,
    preserveParens: false
  };


  function getOptions(opts) {
    var options = {};

    for (var opt in defaultOptions)
      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

    if (options.ecmaVersion >= 2015)
      { options.ecmaVersion -= 2009; }

    if (options.allowReserved == null)
      { options.allowReserved = options.ecmaVersion < 5; }

    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function (token) { return tokens.push(token); };
    }
    if (isArray(options.onComment))
      { options.onComment = pushComment(options, options.onComment); }

    return options
  }

  function pushComment(options, array) {
    return function(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text,
        start: start,
        end: end
      };
      if (options.locations)
        { comment.loc = new SourceLocation(this, startLoc, endLoc); }
      if (options.ranges)
        { comment.range = [start, end]; }
      array.push(comment);
    }
  }

  var
      SCOPE_TOP = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
      SCOPE_ASYNC = 4,
      SCOPE_GENERATOR = 8,
      SCOPE_ARROW = 16,
      SCOPE_SIMPLE_CATCH = 32,
      SCOPE_SUPER = 64,
      SCOPE_DIRECT_SUPER = 128;

  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
  }

  var
      BIND_NONE = 0, 
      BIND_VAR = 1, 
      BIND_LEXICAL = 2, 
      BIND_FUNCTION = 3, 
      BIND_SIMPLE_CATCH = 4, 
      BIND_OUTSIDE = 5; 

  var Parser = function Parser(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
      for (var v = options.ecmaVersion;; v--)
        { if (reserved = reservedWords[v]) { break } }
      if (options.sourceType === "module") { reserved += " await"; }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);

    this.containsEsc = false;


    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }

    this.type = types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();

    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    this.context = this.initialContext();
    this.exprAllowed = true;

    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);

    this.potentialArrowAt = -1;

    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    this.labels = [];
    this.undefinedExports = {};

    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
      { this.skipLineComment(2); }

    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);

    this.regexpState = null;
  };

  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

  Parser.prototype.parse = function parse () {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node)
  };

  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
  prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

  Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

  Parser.extend = function extend () {
      var plugins = [], len = arguments.length;
      while ( len-- ) plugins[ len ] = arguments[ len ];

    var cls = this;
    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
    return cls
  };

  Parser.parse = function parse (input, options) {
    return new this(options, input).parse()
  };

  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression()
  };

  Parser.tokenizer = function tokenizer (input, options) {
    return new this(options, input)
  };

  Object.defineProperties( Parser.prototype, prototypeAccessors );

  var pp = Parser.prototype;


  var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
  pp.strictDirective = function(start) {
    for (;;) {
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match) { return false }
      if ((match[1] || match[2]) === "use strict") { return true }
      start += match[0].length;

      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";")
        { start++; }
    }
  };


  pp.eat = function(type) {
    if (this.type === type) {
      this.next();
      return true
    } else {
      return false
    }
  };


  pp.isContextual = function(name) {
    return this.type === types.name && this.value === name && !this.containsEsc
  };


  pp.eatContextual = function(name) {
    if (!this.isContextual(name)) { return false }
    this.next();
    return true
  };


  pp.expectContextual = function(name) {
    if (!this.eatContextual(name)) { this.unexpected(); }
  };


  pp.canInsertSemicolon = function() {
    return this.type === types.eof ||
      this.type === types.braceR ||
      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  pp.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon)
        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
      return true
    }
  };


  pp.semicolon = function() {
    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
  };

  pp.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma)
        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
      if (!notNext)
        { this.next(); }
      return true
    }
  };


  pp.expect = function(type) {
    this.eat(type) || this.unexpected();
  };


  pp.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };

  function DestructuringErrors() {
    this.shorthandAssign =
    this.trailingComma =
    this.parenthesizedAssign =
    this.parenthesizedBind =
    this.doubleProto =
      -1;
  }

  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) { return }
    if (refDestructuringErrors.trailingComma > -1)
      { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
  };

  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) { return false }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
    if (shorthandAssign >= 0)
      { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
    if (doubleProto >= 0)
      { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
  };

  pp.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
      { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
    if (this.awaitPos)
      { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
  };

  pp.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression")
      { return this.isSimpleAssignTarget(expr.expression) }
    return expr.type === "Identifier" || expr.type === "MemberExpression"
  };

  var pp$1 = Parser.prototype;



  pp$1.parseTopLevel = function(node) {
    var exports = {};
    if (!node.body) { node.body = []; }
    while (this.type !== types.eof) {
      var stmt = this.parseStatement(null, true, exports);
      node.body.push(stmt);
    }
    if (this.inModule)
      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
        {
          var name = list[i];

          this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
        } }
    this.adaptDirectivePrologue(node.body);
    this.next();
    node.sourceType = this.options.sourceType;
    return this.finishNode(node, "Program")
  };

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  pp$1.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    if (nextCh === 91) { return true } 
    if (context) { return false }

    if (nextCh === 123) { return true } 
    if (isIdentifierStart(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) { return true }
    }
    return false
  };

  pp$1.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
      { return false }

    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length;
    return !lineBreak.test(this.input.slice(this.pos, next)) &&
      this.input.slice(next, next + 8) === "function" &&
      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
  };


  pp$1.parseStatement = function(context, topLevel, exports) {
    var starttype = this.type, node = this.startNode(), kind;

    if (this.isLet(context)) {
      starttype = types._var;
      kind = "let";
    }


    switch (starttype) {
    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
    case types._debugger: return this.parseDebuggerStatement(node)
    case types._do: return this.parseDoStatement(node)
    case types._for: return this.parseForStatement(node)
    case types._function:
      if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
      return this.parseFunctionStatement(node, false, !context)
    case types._class:
      if (context) { this.unexpected(); }
      return this.parseClass(node, true)
    case types._if: return this.parseIfStatement(node)
    case types._return: return this.parseReturnStatement(node)
    case types._switch: return this.parseSwitchStatement(node)
    case types._throw: return this.parseThrowStatement(node)
    case types._try: return this.parseTryStatement(node)
    case types._const: case types._var:
      kind = kind || this.value;
      if (context && kind !== "var") { this.unexpected(); }
      return this.parseVarStatement(node, kind)
    case types._while: return this.parseWhileStatement(node)
    case types._with: return this.parseWithStatement(node)
    case types.braceL: return this.parseBlock(true, node)
    case types.semi: return this.parseEmptyStatement(node)
    case types._export:
    case types._import:
      if (this.options.ecmaVersion > 10 && starttype === types._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40) 
          { return this.parseExpressionStatement(node, this.parseExpression()) }
      }

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel)
          { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
        if (!this.inModule)
          { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
      }
      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    default:
      if (this.isAsyncFunction()) {
        if (context) { this.unexpected(); }
        this.next();
        return this.parseFunctionStatement(node, true, !context)
      }

      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
        { return this.parseLabeledStatement(node, maybeName, expr, context) }
      else { return this.parseExpressionStatement(node, expr) }
    }
  };

  pp$1.parseBreakContinueStatement = function(node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
    else if (this.type !== types.name) { this.unexpected(); }
    else {
      node.label = this.parseIdent();
      this.semicolon();
    }

    var i = 0;
    for (; i < this.labels.length; ++i) {
      var lab = this.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
        if (node.label && isBreak) { break }
      }
    }
    if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
  };

  pp$1.parseDebuggerStatement = function(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement")
  };

  pp$1.parseDoStatement = function(node) {
    this.next();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types._while);
    node.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6)
      { this.eat(types.semi); }
    else
      { this.semicolon(); }
    return this.finishNode(node, "DoWhileStatement")
  };


  pp$1.parseForStatement = function(node) {
    this.next();
    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types.parenL);
    if (this.type === types.semi) {
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, null)
    }
    var isLet = this.isLet();
    if (this.type === types._var || this.type === types._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types._in) {
            if (awaitAt > -1) { this.unexpected(awaitAt); }
          } else { node.await = awaitAt > -1; }
        }
        return this.parseForIn(node, init$1)
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init$1)
    }
    var refDestructuringErrors = new DestructuringErrors;
    var init = this.parseExpression(true, refDestructuringErrors);
    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      this.toAssignable(init, false, refDestructuringErrors);
      this.checkLVal(init);
      return this.parseForIn(node, init)
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init)
  };

  pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
  };

  pp$1.parseIfStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement")
  };

  pp$1.parseReturnStatement = function(node) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
      { this.raise(this.start, "'return' outside of function"); }
    this.next();


    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
    else { node.argument = this.parseExpression(); this.semicolon(); }
    return this.finishNode(node, "ReturnStatement")
  };

  pp$1.parseSwitchStatement = function(node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(types.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);


    var cur;
    for (var sawDefault = false; this.type !== types.braceR;) {
      if (this.type === types._case || this.type === types._default) {
        var isCase = this.type === types._case;
        if (cur) { this.finishNode(cur, "SwitchCase"); }
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types.colon);
      } else {
        if (!cur) { this.unexpected(); }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) { this.finishNode(cur, "SwitchCase"); }
    this.next(); 
    this.labels.pop();
    return this.finishNode(node, "SwitchStatement")
  };

  pp$1.parseThrowStatement = function(node) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
      { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement")
  };


  var empty = [];

  pp$1.parseTryStatement = function(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.type === types._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types.parenL)) {
        clause.param = this.parseBindingAtom();
        var simple = clause.param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types.parenR);
      } else {
        if (this.options.ecmaVersion < 10) { this.unexpected(); }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer)
      { this.raise(node.start, "Missing catch or finally clause"); }
    return this.finishNode(node, "TryStatement")
  };

  pp$1.parseVarStatement = function(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration")
  };

  pp$1.parseWhileStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node, "WhileStatement")
  };

  pp$1.parseWithStatement = function(node) {
    if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement("with");
    return this.finishNode(node, "WithStatement")
  };

  pp$1.parseEmptyStatement = function(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement")
  };

  pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
      {
      var label = list[i$1];

      if (label.name === maybeName)
        { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    } }
    var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
    for (var i = this.labels.length - 1; i >= 0; i--) {
      var label$1 = this.labels[i];
      if (label$1.statementStart === node.start) {
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else { break }
    }
    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement")
  };

  pp$1.parseExpressionStatement = function(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement")
  };


  pp$1.parseBlock = function(createNewLexicalScope, node) {
    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
    if ( node === void 0 ) node = this.startNode();

    node.body = [];
    this.expect(types.braceL);
    if (createNewLexicalScope) { this.enterScope(0); }
    while (!this.eat(types.braceR)) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    if (createNewLexicalScope) { this.exitScope(); }
    return this.finishNode(node, "BlockStatement")
  };


  pp$1.parseFor = function(node, init) {
    node.init = init;
    this.expect(types.semi);
    node.test = this.type === types.semi ? null : this.parseExpression();
    this.expect(types.semi);
    node.update = this.type === types.parenR ? null : this.parseExpression();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, "ForStatement")
  };


  pp$1.parseForIn = function(node, init) {
    var isForIn = this.type === types._in;
    this.next();

    if (
      init.type === "VariableDeclaration" &&
      init.declarations[0].init != null &&
      (
        !isForIn ||
        this.options.ecmaVersion < 8 ||
        this.strict ||
        init.kind !== "var" ||
        init.declarations[0].id.type !== "Identifier"
      )
    ) {
      this.raise(
        init.start,
        ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
      );
    } else if (init.type === "AssignmentPattern") {
      this.raise(init.start, "Invalid left-hand side in for-loop");
    }
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
  };


  pp$1.parseVar = function(node, isFor, kind) {
    node.declarations = [];
    node.kind = kind;
    for (;;) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
        this.unexpected();
      } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types.comma)) { break }
    }
    return node
  };

  pp$1.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };

  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;


  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
    this.initFunction(node);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
        { this.unexpected(); }
      node.generator = this.eat(types.star);
    }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    if (statement & FUNC_STATEMENT) {
      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
        { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
    }

    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node.async, node.generator));

    if (!(statement & FUNC_STATEMENT))
      { node.id = this.type === types.name ? this.parseIdent() : null; }

    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
  };

  pp$1.parseFunctionParams = function(node) {
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };


  pp$1.parseClass = function(node, isStatement) {
    this.next();

    var oldStrict = this.strict;
    this.strict = true;

    this.parseClassId(node, isStatement);
    this.parseClassSuper(node);
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      var element = this.parseClassElement(node.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
          hadConstructor = true;
        }
      }
    }
    node.body = this.finishNode(classBody, "ClassBody");
    this.strict = oldStrict;
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
  };

  pp$1.parseClassElement = function(constructorAllowsSuper) {
    var this$1 = this;

    if (this.eat(types.semi)) { return null }

    var method = this.startNode();
    var tryContextual = function (k, noLineBreak) {
      if ( noLineBreak === void 0 ) noLineBreak = false;

      var start = this$1.start, startLoc = this$1.startLoc;
      if (!this$1.eatContextual(k)) { return false }
      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
      if (method.key) { this$1.unexpected(); }
      method.computed = false;
      method.key = this$1.startNodeAt(start, startLoc);
      method.key.name = k;
      this$1.finishNode(method.key, "Identifier");
      return false
    };

    method.kind = "method";
    method.static = tryContextual("static");
    var isGenerator = this.eat(types.star);
    var isAsync = false;
    if (!isGenerator) {
      if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      } else if (tryContextual("get")) {
        method.kind = "get";
      } else if (tryContextual("set")) {
        method.kind = "set";
      }
    }
    if (!method.key) { this.parsePropertyName(method); }
    var key = method.key;
    var allowsDirectSuper = false;
    if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
        key.type === "Literal" && key.value === "constructor")) {
      if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
      if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
      if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
      method.kind = "constructor";
      allowsDirectSuper = constructorAllowsSuper;
    } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }
    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && method.value.params.length !== 0)
      { this.raiseRecoverable(method.value.start, "getter should have no params"); }
    if (method.kind === "set" && method.value.params.length !== 1)
      { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
    if (method.kind === "set" && method.value.params[0].type === "RestElement")
      { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
    return method
  };

  pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    return this.finishNode(method, "MethodDefinition")
  };

  pp$1.parseClassId = function(node, isStatement) {
    if (this.type === types.name) {
      node.id = this.parseIdent();
      if (isStatement)
        { this.checkLVal(node.id, BIND_LEXICAL, false); }
    } else {
      if (isStatement === true)
        { this.unexpected(); }
      node.id = null;
    }
  };

  pp$1.parseClassSuper = function(node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
  };


  pp$1.parseExport = function(node, exports) {
    this.next();
    if (this.eat(types.star)) {
      this.expectContextual("from");
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
      this.semicolon();
      return this.finishNode(node, "ExportAllDeclaration")
    }
    if (this.eat(types._default)) { 
      this.checkExport(exports, "default", this.lastTokStart);
      var isAsync;
      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) { this.next(); }
        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
      } else if (this.type === types._class) {
        var cNode = this.startNode();
        node.declaration = this.parseClass(cNode, "nullableID");
      } else {
        node.declaration = this.parseMaybeAssign();
        this.semicolon();
      }
      return this.finishNode(node, "ExportDefaultDeclaration")
    }
    if (this.shouldParseExportStatement()) {
      node.declaration = this.parseStatement(null);
      if (node.declaration.type === "VariableDeclaration")
        { this.checkVariableExport(exports, node.declaration.declarations); }
      else
        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
      node.specifiers = [];
      node.source = null;
    } else { 
      node.declaration = null;
      node.specifiers = this.parseExportSpecifiers(exports);
      if (this.eatContextual("from")) {
        if (this.type !== types.string) { this.unexpected(); }
        node.source = this.parseExprAtom();
      } else {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          var spec = list[i];

          this.checkUnreserved(spec.local);
          this.checkLocalExport(spec.local);
        }

        node.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration")
  };

  pp$1.checkExport = function(exports, name, pos) {
    if (!exports) { return }
    if (has(exports, name))
      { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
    exports[name] = true;
  };

  pp$1.checkPatternExport = function(exports, pat) {
    var type = pat.type;
    if (type === "Identifier")
      { this.checkExport(exports, pat.name, pat.start); }
    else if (type === "ObjectPattern")
      { for (var i = 0, list = pat.properties; i < list.length; i += 1)
        {
          var prop = list[i];

          this.checkPatternExport(exports, prop);
        } }
    else if (type === "ArrayPattern")
      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];

          if (elt) { this.checkPatternExport(exports, elt); }
      } }
    else if (type === "Property")
      { this.checkPatternExport(exports, pat.value); }
    else if (type === "AssignmentPattern")
      { this.checkPatternExport(exports, pat.left); }
    else if (type === "RestElement")
      { this.checkPatternExport(exports, pat.argument); }
    else if (type === "ParenthesizedExpression")
      { this.checkPatternExport(exports, pat.expression); }
  };

  pp$1.checkVariableExport = function(exports, decls) {
    if (!exports) { return }
    for (var i = 0, list = decls; i < list.length; i += 1)
      {
      var decl = list[i];

      this.checkPatternExport(exports, decl.id);
    }
  };

  pp$1.shouldParseExportStatement = function() {
    return this.type.keyword === "var" ||
      this.type.keyword === "const" ||
      this.type.keyword === "class" ||
      this.type.keyword === "function" ||
      this.isLet() ||
      this.isAsyncFunction()
  };


  pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node = this.startNode();
      node.local = this.parseIdent(true);
      node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
      this.checkExport(exports, node.exported.name, node.exported.start);
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    return nodes
  };


  pp$1.parseImport = function(node) {
    this.next();
    if (this.type === types.string) {
      node.specifiers = empty;
      node.source = this.parseExprAtom();
    } else {
      node.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration")
  };


  pp$1.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types.name) {
      var node = this.startNode();
      node.local = this.parseIdent();
      this.checkLVal(node.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
      if (!this.eat(types.comma)) { return nodes }
    }
    if (this.type === types.star) {
      var node$1 = this.startNode();
      this.next();
      this.expectContextual("as");
      node$1.local = this.parseIdent();
      this.checkLVal(node$1.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
      return nodes
    }
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node$2 = this.startNode();
      node$2.imported = this.parseIdent(true);
      if (this.eatContextual("as")) {
        node$2.local = this.parseIdent();
      } else {
        this.checkUnreserved(node$2.imported);
        node$2.local = node$2.imported;
      }
      this.checkLVal(node$2.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes
  };

  pp$1.adaptDirectivePrologue = function(statements) {
    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
      statements[i].directive = statements[i].expression.raw.slice(1, -1);
    }
  };
  pp$1.isDirectiveCandidate = function(statement) {
    return (
      statement.type === "ExpressionStatement" &&
      statement.expression.type === "Literal" &&
      typeof statement.expression.value === "string" &&
      (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
    )
  };

  var pp$2 = Parser.prototype;


  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) {
      switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await")
          { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
        break

      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break

      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];

        this.toAssignable(prop, isBinding);
          if (
            prop.type === "RestElement" &&
            (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
          ) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break

      case "Property":
        if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
        this.toAssignable(node.value, isBinding);
        break

      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        this.toAssignableList(node.elements, isBinding);
        break

      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern")
          { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
        break

      case "AssignmentExpression":
        if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);

      case "AssignmentPattern":
        break

      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break

      case "MemberExpression":
        if (!isBinding) { break }

      default:
        this.raise(node.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
    return node
  };


  pp$2.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i = 0; i < end; i++) {
      var elt = exprList[i];
      if (elt) { this.toAssignable(elt, isBinding); }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
        { this.unexpected(last.argument.start); }
    }
    return exprList
  };


  pp$2.parseSpread = function(refDestructuringErrors) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node, "SpreadElement")
  };

  pp$2.parseRestBinding = function() {
    var node = this.startNode();
    this.next();

    if (this.options.ecmaVersion === 6 && this.type !== types.name)
      { this.unexpected(); }

    node.argument = this.parseBindingAtom();

    return this.finishNode(node, "RestElement")
  };


  pp$2.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
      case types.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern")

      case types.braceL:
        return this.parseObj(true)
      }
    }
    return this.parseIdent()
  };

  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first) { first = false; }
      else { this.expect(types.comma); }
      if (allowEmpty && this.type === types.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
        break
      } else if (this.type === types.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        this.expect(close);
        break
      } else {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        elts.push(elem);
      }
    }
    return elts
  };

  pp$2.parseBindingListItem = function(param) {
    return param
  };


  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern")
  };


  pp$2.checkLVal = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    switch (expr.type) {
    case "Identifier":
      if (bindingType === BIND_LEXICAL && expr.name === "let")
        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
        { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
      if (checkClashes) {
        if (has(checkClashes, expr.name))
          { this.raiseRecoverable(expr.start, "Argument name clash"); }
        checkClashes[expr.name] = true;
      }
      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
      break

    case "MemberExpression":
      if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
      break

    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1)
        {
      var prop = list[i];

      this.checkLVal(prop, bindingType, checkClashes);
    }
      break

    case "Property":
      this.checkLVal(expr.value, bindingType, checkClashes);
      break

    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];

      if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
      }
      break

    case "AssignmentPattern":
      this.checkLVal(expr.left, bindingType, checkClashes);
      break

    case "RestElement":
      this.checkLVal(expr.argument, bindingType, checkClashes);
      break

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, bindingType, checkClashes);
      break

    default:
      this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
    }
  };


  var pp$3 = Parser.prototype;


  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
      { return }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
      { return }
    var key = prop.key;
    var name;
    switch (key.type) {
    case "Identifier": name = key.name; break
    case "Literal": name = String(key.value); break
    default: return
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors) {
            if (refDestructuringErrors.doubleProto < 0)
              { refDestructuringErrors.doubleProto = key.start; }
          } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
        }
        propHash.proto = true;
      }
      return
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition)
        { this.raiseRecoverable(key.start, "Redefinition of property"); }
    } else {
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };




  pp$3.parseExpression = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
    if (this.type === types.comma) {
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];
      while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
      return this.finishNode(node, "SequenceExpression")
    }
    return expr
  };


  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) { return this.parseYield(noIn) }
      else { this.exprAllowed = false; }
    }

    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors;
      ownDestructuringErrors = true;
    }

    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types.parenL || this.type === types.name)
      { this.potentialArrowAt = this.start; }
    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
    if (this.type.isAssign) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
      if (!ownDestructuringErrors) {
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
      }
      if (refDestructuringErrors.shorthandAssign >= node.left.start)
        { refDestructuringErrors.shorthandAssign = -1; } 
      this.checkLVal(left);
      this.next();
      node.right = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "AssignmentExpression")
    } else {
      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
    }
    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
    return left
  };


  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(noIn, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    if (this.eat(types.question)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(types.colon);
      node.alternate = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "ConditionalExpression")
    }
    return expr
  };


  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
  };


  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    var prec = this.type.binop;
    if (prec != null && (!noIn || this.type !== types._in)) {
      if (prec > minPrec) {
        var logical = this.type === types.logicalOR || this.type === types.logicalAND;
        var op = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
      }
    }
    return left
  };

  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.operator = op;
    node.right = right;
    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
  };


  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
      expr = this.parseAwait();
      sawUnary = true;
    } else if (this.type.prefix) {
      var node = this.startNode(), update = this.type === types.incDec;
      node.operator = this.value;
      node.prefix = true;
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) { this.checkLVal(node.argument); }
      else if (this.strict && node.operator === "delete" &&
               node.argument.type === "Identifier")
        { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
      else { sawUnary = true; }
      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.operator = this.value;
        node$1.prefix = false;
        node$1.argument = expr;
        this.checkLVal(expr);
        this.next();
        expr = this.finishNode(node$1, "UpdateExpression");
      }
    }

    if (!sawUnary && this.eat(types.starstar))
      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
    else
      { return expr }
  };


  pp$3.parseExprSubscripts = function(refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
      { return expr }
    var result = this.parseSubscripts(expr, startPos, startLoc);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
    }
    return result
  };

  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
        this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
      if (element === base || element.type === "ArrowFunctionExpression") { return element }
      base = element;
    }
  };

  pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
    var computed = this.eat(types.bracketL);
    if (computed || this.eat(types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
      node.computed = !!computed;
      if (computed) { this.expect(types.bracketR); }
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0)
          { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types.backQuote) {
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({isTagged: true});
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base
  };


  pp$3.parseExprAtom = function(refDestructuringErrors) {
    if (this.type === types.slash) { this.readRegexp(); }

    var node, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
    case types._super:
      if (!this.allowSuper)
        { this.raise(this.start, "'super' keyword outside a method"); }
      node = this.startNode();
      this.next();
      if (this.type === types.parenL && !this.allowDirectSuper)
        { this.raise(node.start, "super() call outside constructor of a subclass"); }
      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
        { this.unexpected(); }
      return this.finishNode(node, "Super")

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression")

    case types.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
        { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types.arrow))
          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types.arrow))
            { this.unexpected(); }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
        }
      }
      return id

    case types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = {pattern: value.pattern, flags: value.flags};
      return node

    case types.num: case types.string:
      return this.parseLiteral(this.value)

    case types._null: case types._true: case types._false:
      node = this.startNode();
      node.value = this.type === types._null ? null : this.type === types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal")

    case types.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
          { refDestructuringErrors.parenthesizedAssign = start; }
        if (refDestructuringErrors.parenthesizedBind < 0)
          { refDestructuringErrors.parenthesizedBind = start; }
      }
      return expr

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression")

    case types.braceL:
      return this.parseObj(false, refDestructuringErrors)

    case types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0)

    case types._class:
      return this.parseClass(this.startNode(), false)

    case types._new:
      return this.parseNew()

    case types.backQuote:
      return this.parseTemplate()

    case types._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport()
      } else {
        return this.unexpected()
      }

    default:
      this.unexpected();
    }
  };

  pp$3.parseExprImport = function() {
    var node = this.startNode();
    this.next(); 
    switch (this.type) {
    case types.parenL:
      return this.parseDynamicImport(node)
    default:
      this.unexpected();
    }
  };

  pp$3.parseDynamicImport = function(node) {
    this.next(); 

    node.source = this.parseMaybeAssign();

    if (!this.eat(types.parenR)) {
      var errorPos = this.start;
      if (this.eat(types.comma) && this.eat(types.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }

    return this.finishNode(node, "ImportExpression")
  };

  pp$3.parseLiteral = function(value) {
    var node = this.startNode();
    node.value = value;
    node.raw = this.input.slice(this.start, this.end);
    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
    this.next();
    return this.finishNode(node, "Literal")
  };

  pp$3.parseParenExpression = function() {
    this.expect(types.parenL);
    var val = this.parseExpression();
    this.expect(types.parenR);
    return val
  };

  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();

      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      while (this.type !== types.parenR) {
        first ? first = false : this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
          lastIsComma = true;
          break
        } else if (this.type === types.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
          break
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.start, innerEndLoc = this.startLoc;
      this.expect(types.parenR);

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList)
      }

      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
      if (spreadStart) { this.unexpected(spreadStart); }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }

    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression")
    } else {
      return val
    }
  };

  pp$3.parseParenItem = function(item) {
    return item
  };

  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
  };


  var empty$1 = [];

  pp$3.parseNew = function() {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
    var node = this.startNode();
    var meta = this.parseIdent(true);
    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
      node.meta = meta;
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "target" || containsEsc)
        { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
      if (!this.inNonArrowFunction())
        { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
      return this.finishNode(node, "MetaProperty")
    }
    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    if (isImport && node.callee.type === "ImportExpression") {
      this.raise(startPos, "Cannot use new with import()");
    }
    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
    else { node.arguments = empty$1; }
    return this.finishNode(node, "NewExpression")
  };


  pp$3.parseTemplateElement = function(ref) {
    var isTagged = ref.isTagged;

    var elem = this.startNode();
    if (this.type === types.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value,
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types.backQuote;
    return this.finishNode(elem, "TemplateElement")
  };

  pp$3.parseTemplate = function(ref) {
    if ( ref === void 0 ) ref = {};
    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement({isTagged: isTagged});
    node.quasis = [curElt];
    while (!curElt.tail) {
      if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
      this.expect(types.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(types.braceR);
      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral")
  };

  pp$3.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };


  pp$3.parseObj = function(isPattern, refDestructuringErrors) {
    var node = this.startNode(), first = true, propHash = {};
    node.properties = [];
    this.next();
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
      node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
  };

  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement")
      }
      if (this.type === types.parenL && refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0) {
          refDestructuringErrors.parenthesizedAssign = this.start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = this.start;
        }
      }
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      return this.finishNode(prop, "SpreadElement")
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern)
        { isGenerator = this.eat(types.star); }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      this.parsePropertyName(prop, refDestructuringErrors);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property")
  };

  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types.colon)
      { this.unexpected(); }

    if (this.eat(types.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
      if (isPattern) { this.unexpected(); }
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc &&
               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
               (prop.key.name === "get" || prop.key.name === "set") &&
               (this.type !== types.comma && this.type !== types.braceR)) {
      if (isGenerator || isAsync) { this.unexpected(); }
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get")
          { this.raiseRecoverable(start, "getter should have no params"); }
        else
          { this.raiseRecoverable(start, "setter should have exactly one param"); }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
          { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
      }
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) { this.unexpected(); }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = startPos; }
      prop.kind = "init";
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else if (this.type === types.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0)
          { refDestructuringErrors.shorthandAssign = this.start; }
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else {
        prop.value = prop.key;
      }
      prop.shorthand = true;
    } else { this.unexpected(); }
  };

  pp$3.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types.bracketR);
        return prop.key
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
  };


  pp$3.initFunction = function(node) {
    node.id = null;
    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
    if (this.options.ecmaVersion >= 8) { node.async = false; }
  };


  pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.initFunction(node);
    if (this.options.ecmaVersion >= 6)
      { node.generator = isGenerator; }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node, false, true);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "FunctionExpression")
  };


  pp$3.parseArrowExpression = function(node, params, isAsync) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node);
    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;

    node.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node, true, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "ArrowFunctionExpression")
  };


  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
    var isExpression = isArrowFunction && this.type !== types.braceL;
    var oldStrict = this.strict, useStrict = false;

    if (isExpression) {
      node.body = this.parseMaybeAssign();
      node.expression = true;
      this.checkParams(node, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        if (useStrict && nonSimple)
          { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
      }
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) { this.strict = true; }

      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
      node.body = this.parseBlock(false);
      node.expression = false;
      this.adaptDirectivePrologue(node.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();

    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
    this.strict = oldStrict;
  };

  pp$3.isSimpleParamList = function(params) {
    for (var i = 0, list = params; i < list.length; i += 1)
      {
      var param = list[i];

      if (param.type !== "Identifier") { return false
    } }
    return true
  };


  pp$3.checkParams = function(node, allowDuplicates) {
    var nameHash = {};
    for (var i = 0, list = node.params; i < list.length; i += 1)
      {
      var param = list[i];

      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };


  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (!first) {
        this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(close)) { break }
      } else { first = false; }

      var elt = (void 0);
      if (allowEmpty && this.type === types.comma)
        { elt = null; }
      else if (this.type === types.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
          { refDestructuringErrors.trailingComma = this.start; }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts
  };

  pp$3.checkUnreserved = function(ref) {
    var start = ref.start;
    var end = ref.end;
    var name = ref.name;

    if (this.inGenerator && name === "yield")
      { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
    if (this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
    if (this.keywords.test(name))
      { this.raise(start, ("Unexpected keyword '" + name + "'")); }
    if (this.options.ecmaVersion < 6 &&
      this.input.slice(start, end).indexOf("\\") !== -1) { return }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name)) {
      if (!this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
      this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
    }
  };


  pp$3.parseIdent = function(liberal, isBinding) {
    var node = this.startNode();
    if (this.type === types.name) {
      node.name = this.value;
    } else if (this.type.keyword) {
      node.name = this.type.keyword;

      if ((node.name === "class" || node.name === "function") &&
          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
    } else {
      this.unexpected();
    }
    this.next(!!liberal);
    this.finishNode(node, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node);
      if (node.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = node.start; }
    }
    return node
  };


  pp$3.parseYield = function(noIn) {
    if (!this.yieldPos) { this.yieldPos = this.start; }

    var node = this.startNode();
    this.next();
    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(types.star);
      node.argument = this.parseMaybeAssign(noIn);
    }
    return this.finishNode(node, "YieldExpression")
  };

  pp$3.parseAwait = function() {
    if (!this.awaitPos) { this.awaitPos = this.start; }

    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(null, false);
    return this.finishNode(node, "AwaitExpression")
  };

  var pp$4 = Parser.prototype;


  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
    throw err
  };

  pp$4.raiseRecoverable = pp$4.raise;

  pp$4.curPosition = function() {
    if (this.options.locations) {
      return new Position(this.curLine, this.pos - this.lineStart)
    }
  };

  var pp$5 = Parser.prototype;

  var Scope = function Scope(flags) {
    this.flags = flags;
    this.var = [];
    this.lexical = [];
    this.functions = [];
  };


  pp$5.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
  };

  pp$5.exitScope = function() {
    this.scopeStack.pop();
  };

  pp$5.treatFunctionsAsVarInScope = function(scope) {
    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
  };

  pp$5.declareName = function(name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope = this.currentScope();
      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      scope.lexical.push(name);
      if (this.inModule && (scope.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$1 = this.currentScope();
      scope$1.lexical.push(name);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar)
        { redeclared = scope$2.lexical.indexOf(name) > -1; }
      else
        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
      scope$2.functions.push(name);
    } else {
      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
        var scope$3 = this.scopeStack[i];
        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
          redeclared = true;
          break
        }
        scope$3.var.push(name);
        if (this.inModule && (scope$3.flags & SCOPE_TOP))
          { delete this.undefinedExports[name]; }
        if (scope$3.flags & SCOPE_VAR) { break }
      }
    }
    if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
  };

  pp$5.checkLocalExport = function(id) {
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
        this.scopeStack[0].var.indexOf(id.name) === -1) {
      this.undefinedExports[id.name] = id;
    }
  };

  pp$5.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1]
  };

  pp$5.currentVarScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR) { return scope }
    }
  };

  pp$5.currentThisScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
    }
  };

  var Node = function Node(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations)
      { this.loc = new SourceLocation(parser, loc); }
    if (parser.options.directSourceFile)
      { this.sourceFile = parser.options.directSourceFile; }
    if (parser.options.ranges)
      { this.range = [pos, 0]; }
  };


  var pp$6 = Parser.prototype;

  pp$6.startNode = function() {
    return new Node(this, this.start, this.startLoc)
  };

  pp$6.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc)
  };


  function finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    if (this.options.locations)
      { node.loc.end = loc; }
    if (this.options.ranges)
      { node.range[1] = pos; }
    return node
  }

  pp$6.finishNode = function(node, type) {
    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
  };


  pp$6.finishNodeAt = function(node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc)
  };


  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };

  var types$1 = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };

  var pp$7 = Parser.prototype;

  pp$7.initialContext = function() {
    return [types$1.b_stat]
  };

  pp$7.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types$1.f_expr || parent === types$1.f_stat)
      { return true }
    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
      { return !parent.isExpr }

    if (prevType === types._return || prevType === types.name && this.exprAllowed)
      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
      { return true }
    if (prevType === types.braceL)
      { return parent === types$1.b_stat }
    if (prevType === types._var || prevType === types._const || prevType === types.name)
      { return false }
    return !this.exprAllowed
  };

  pp$7.inGeneratorContext = function() {
    for (var i = this.context.length - 1; i >= 1; i--) {
      var context = this.context[i];
      if (context.token === "function")
        { return context.generator }
    }
    return false
  };

  pp$7.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types.dot)
      { this.exprAllowed = false; }
    else if (update = type.updateContext)
      { update.call(this, prevType); }
    else
      { this.exprAllowed = type.beforeExpr; }
  };


  types.parenR.updateContext = types.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return
    }
    var out = this.context.pop();
    if (out === types$1.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };

  types.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
    this.exprAllowed = true;
  };

  types.dollarBraceL.updateContext = function() {
    this.context.push(types$1.b_tmpl);
    this.exprAllowed = true;
  };

  types.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
    this.exprAllowed = true;
  };

  types.incDec.updateContext = function() {
  };

  types._function.updateContext = types._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
        !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
      { this.context.push(types$1.f_expr); }
    else
      { this.context.push(types$1.f_stat); }
    this.exprAllowed = false;
  };

  types.backQuote.updateContext = function() {
    if (this.curContext() === types$1.q_tmpl)
      { this.context.pop(); }
    else
      { this.context.push(types$1.q_tmpl); }
    this.exprAllowed = false;
  };

  types.star.updateContext = function(prevType) {
    if (prevType === types._function) {
      var index = this.context.length - 1;
      if (this.context[index] === types$1.f_expr)
        { this.context[index] = types$1.f_expr_gen; }
      else
        { this.context[index] = types$1.f_gen; }
    }
    this.exprAllowed = true;
  };

  types.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
      if (this.value === "of" && !this.exprAllowed ||
          this.value === "yield" && this.inGeneratorContext())
        { allowed = true; }
    }
    this.exprAllowed = allowed;
  };


  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties
  };

  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

  var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues
  };

  var data = {};
  function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;

    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  buildUnicodeData(9);
  buildUnicodeData(10);
  buildUnicodeData(11);

  var pp$8 = Parser.prototype;

  var RegExpValidationState = function RegExpValidationState(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = [];
    this.backReferenceNames = [];
  };

  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  };

  RegExpValidationState.prototype.raise = function raise (message) {
    this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
  };

  RegExpValidationState.prototype.at = function at (i) {
    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return -1
    }
    var c = s.charCodeAt(i);
    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
      return c
    }
    var next = s.charCodeAt(i + 1);
    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
  };

  RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return l
    }
    var c = s.charCodeAt(i), next;
    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
      return i + 1
    }
    return i + 2
  };

  RegExpValidationState.prototype.current = function current () {
    return this.at(this.pos)
  };

  RegExpValidationState.prototype.lookahead = function lookahead () {
    return this.at(this.nextIndex(this.pos))
  };

  RegExpValidationState.prototype.advance = function advance () {
    this.pos = this.nextIndex(this.pos);
  };

  RegExpValidationState.prototype.eat = function eat (ch) {
    if (this.current() === ch) {
      this.advance();
      return true
    }
    return false
  };

  function codePointToString(ch) {
    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
    ch -= 0x10000;
    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
  }

  pp$8.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;

    for (var i = 0; i < flags.length; i++) {
      var flag = flags.charAt(i);
      if (validFlags.indexOf(flag) === -1) {
        this.raise(state.start, "Invalid regular expression flag");
      }
      if (flags.indexOf(flag, i + 1) > -1) {
        this.raise(state.start, "Duplicate regular expression flag");
      }
    }
  };

  pp$8.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);

    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };

  pp$8.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames.length = 0;
    state.backReferenceNames.length = 0;

    this.regexp_disjunction(state);

    if (state.pos !== state.source.length) {
      if (state.eat(0x29 )) {
        state.raise("Unmatched ')'");
      }
      if (state.eat(0x5D ) || state.eat(0x7D )) {
        state.raise("Lone quantifier brackets");
      }
    }
    if (state.maxBackReference > state.numCapturingParens) {
      state.raise("Invalid escape");
    }
    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
      var name = list[i];

      if (state.groupNames.indexOf(name) === -1) {
        state.raise("Invalid named capture referenced");
      }
    }
  };

  pp$8.regexp_disjunction = function(state) {
    this.regexp_alternative(state);
    while (state.eat(0x7C )) {
      this.regexp_alternative(state);
    }

    if (this.regexp_eatQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    if (state.eat(0x7B )) {
      state.raise("Lone quantifier brackets");
    }
  };

  pp$8.regexp_alternative = function(state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state))
      { }
  };

  pp$8.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        if (state.switchU) {
          state.raise("Invalid quantifier");
        }
      }
      return true
    }

    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true
    }

    return false
  };

  pp$8.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;

    if (state.eat(0x5E ) || state.eat(0x24 )) {
      return true
    }

    if (state.eat(0x5C )) {
      if (state.eat(0x42 ) || state.eat(0x62 )) {
        return true
      }
      state.pos = start;
    }

    if (state.eat(0x28 ) && state.eat(0x3F )) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9) {
        lookbehind = state.eat(0x3C );
      }
      if (state.eat(0x3D ) || state.eat(0x21 )) {
        this.regexp_disjunction(state);
        if (!state.eat(0x29 )) {
          state.raise("Unterminated group");
        }
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true
      }
    }

    state.pos = start;
    return false
  };

  pp$8.regexp_eatQuantifier = function(state, noError) {
    if ( noError === void 0 ) noError = false;

    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(0x3F );
      return true
    }
    return false
  };

  pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
    return (
      state.eat(0x2A ) ||
      state.eat(0x2B ) ||
      state.eat(0x3F ) ||
      this.regexp_eatBracedQuantifier(state, noError)
    )
  };
  pp$8.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(0x7B )) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(0x2C ) && this.regexp_eatDecimalDigits(state)) {
          max = state.lastIntValue;
        }
        if (state.eat(0x7D )) {
          if (max !== -1 && max < min && !noError) {
            state.raise("numbers out of order in {} quantifier");
          }
          return true
        }
      }
      if (state.switchU && !noError) {
        state.raise("Incomplete quantifier");
      }
      state.pos = start;
    }
    return false
  };

  pp$8.regexp_eatAtom = function(state) {
    return (
      this.regexp_eatPatternCharacters(state) ||
      state.eat(0x2E ) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state)
    )
  };
  pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(0x5C )) {
      if (this.regexp_eatAtomEscape(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(0x28 )) {
      if (state.eat(0x3F ) && state.eat(0x3A )) {
        this.regexp_disjunction(state);
        if (state.eat(0x29 )) {
          return true
        }
        state.raise("Unterminated group");
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatCapturingGroup = function(state) {
    if (state.eat(0x28 )) {
      if (this.options.ecmaVersion >= 9) {
        this.regexp_groupSpecifier(state);
      } else if (state.current() === 0x3F ) {
        state.raise("Invalid group");
      }
      this.regexp_disjunction(state);
      if (state.eat(0x29 )) {
        state.numCapturingParens += 1;
        return true
      }
      state.raise("Unterminated group");
    }
    return false
  };

  pp$8.regexp_eatExtendedAtom = function(state) {
    return (
      state.eat(0x2E ) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state) ||
      this.regexp_eatInvalidBracedQuantifier(state) ||
      this.regexp_eatExtendedPatternCharacter(state)
    )
  };

  pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    return false
  };

  pp$8.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }
    return false
  };
  function isSyntaxCharacter(ch) {
    return (
      ch === 0x24  ||
      ch >= 0x28  && ch <= 0x2B  ||
      ch === 0x2E  ||
      ch === 0x3F  ||
      ch >= 0x5B  && ch <= 0x5E  ||
      ch >= 0x7B  && ch <= 0x7D 
    )
  }

  pp$8.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch = 0;
    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
      state.advance();
    }
    return state.pos !== start
  };

  pp$8.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (
      ch !== -1 &&
      ch !== 0x24  &&
      !(ch >= 0x28  && ch <= 0x2B ) &&
      ch !== 0x2E  &&
      ch !== 0x3F  &&
      ch !== 0x5B  &&
      ch !== 0x5E  &&
      ch !== 0x7C 
    ) {
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_groupSpecifier = function(state) {
    if (state.eat(0x3F )) {
      if (this.regexp_eatGroupName(state)) {
        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
          state.raise("Duplicate capture group name");
        }
        state.groupNames.push(state.lastStringValue);
        return
      }
      state.raise("Invalid group");
    }
  };

  pp$8.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(0x3C )) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E )) {
        return true
      }
      state.raise("Invalid capture group name");
    }
    return false
  };

  pp$8.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
      }
      return true
    }
    return false
  };

  pp$8.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var ch = state.current();
    state.advance();

    if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierStart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 0x24  || ch === 0x5F 
  }

  pp$8.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var ch = state.current();
    state.advance();

    if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierPart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 0x24  || ch === 0x5F  || ch === 0x200C  || ch === 0x200D 
  }

  pp$8.regexp_eatAtomEscape = function(state) {
    if (
      this.regexp_eatBackReference(state) ||
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state) ||
      (state.switchN && this.regexp_eatKGroupName(state))
    ) {
      return true
    }
    if (state.switchU) {
      if (state.current() === 0x63 ) {
        state.raise("Invalid unicode escape");
      }
      state.raise("Invalid escape");
    }
    return false
  };
  pp$8.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n = state.lastIntValue;
      if (state.switchU) {
        if (n > state.maxBackReference) {
          state.maxBackReference = n;
        }
        return true
      }
      if (n <= state.numCapturingParens) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatKGroupName = function(state) {
    if (state.eat(0x6B )) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true
      }
      state.raise("Invalid named reference");
    }
    return false
  };

  pp$8.regexp_eatCharacterEscape = function(state) {
    return (
      this.regexp_eatControlEscape(state) ||
      this.regexp_eatCControlLetter(state) ||
      this.regexp_eatZero(state) ||
      this.regexp_eatHexEscapeSequence(state) ||
      this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
      this.regexp_eatIdentityEscape(state)
    )
  };
  pp$8.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(0x63 )) {
      if (this.regexp_eatControlLetter(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatZero = function(state) {
    if (state.current() === 0x30  && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 0x74 ) {
      state.lastIntValue = 0x09; 
      state.advance();
      return true
    }
    if (ch === 0x6E ) {
      state.lastIntValue = 0x0A; 
      state.advance();
      return true
    }
    if (ch === 0x76 ) {
      state.lastIntValue = 0x0B; 
      state.advance();
      return true
    }
    if (ch === 0x66 ) {
      state.lastIntValue = 0x0C; 
      state.advance();
      return true
    }
    if (ch === 0x72 ) {
      state.lastIntValue = 0x0D; 
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };
  function isControlLetter(ch) {
    return (
      (ch >= 0x41  && ch <= 0x5A ) ||
      (ch >= 0x61  && ch <= 0x7A )
    )
  }

  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
    var start = state.pos;

    if (state.eat(0x75 )) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(0x5C ) && state.eat(0x75 ) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 0xDC00 && trail <= 0xDFFF) {
              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
              return true
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true
      }
      if (
        state.switchU &&
        state.eat(0x7B ) &&
        this.regexp_eatHexDigits(state) &&
        state.eat(0x7D ) &&
        isValidUnicode(state.lastIntValue)
      ) {
        return true
      }
      if (state.switchU) {
        state.raise("Invalid unicode escape");
      }
      state.pos = start;
    }

    return false
  };
  function isValidUnicode(ch) {
    return ch >= 0 && ch <= 0x10FFFF
  }

  pp$8.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state)) {
        return true
      }
      if (state.eat(0x2F )) {
        state.lastIntValue = 0x2F; 
        return true
      }
      return false
    }

    var ch = state.current();
    if (ch !== 0x63  && (!state.switchN || ch !== 0x6B )) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  pp$8.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 0x31  && ch <= 0x39 ) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );
        state.advance();
      } while ((ch = state.current()) >= 0x30  && ch <= 0x39 )
      return true
    }
    return false
  };

  pp$8.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();

    if (isCharacterClassEscape(ch)) {
      state.lastIntValue = -1;
      state.advance();
      return true
    }

    if (
      state.switchU &&
      this.options.ecmaVersion >= 9 &&
      (ch === 0x50  || ch === 0x70 )
    ) {
      state.lastIntValue = -1;
      state.advance();
      if (
        state.eat(0x7B ) &&
        this.regexp_eatUnicodePropertyValueExpression(state) &&
        state.eat(0x7D )
      ) {
        return true
      }
      state.raise("Invalid property name");
    }

    return false
  };
  function isCharacterClassEscape(ch) {
    return (
      ch === 0x64  ||
      ch === 0x44  ||
      ch === 0x73  ||
      ch === 0x53  ||
      ch === 0x77  ||
      ch === 0x57 
    )
  }

  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;

    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D )) {
      var name = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
        return true
      }
    }
    state.pos = start;

    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
      return true
    }
    return false
  };
  pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
    if (!has(state.unicodeProperties.nonBinary, name))
      { state.raise("Invalid property name"); }
    if (!state.unicodeProperties.nonBinary[name].test(value))
      { state.raise("Invalid property value"); }
  };
  pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (!state.unicodeProperties.binary.test(nameOrValue))
      { state.raise("Invalid property name"); }
  };

  pp$8.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 0x5F 
  }

  pp$8.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
  }

  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state)
  };

  pp$8.regexp_eatCharacterClass = function(state) {
    if (state.eat(0x5B )) {
      state.eat(0x5E );
      this.regexp_classRanges(state);
      if (state.eat(0x5D )) {
        return true
      }
      state.raise("Unterminated character class");
    }
    return false
  };

  pp$8.regexp_classRanges = function(state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(0x2D ) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1)) {
          state.raise("Invalid character class");
        }
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
      }
    }
  };

  pp$8.regexp_eatClassAtom = function(state) {
    var start = state.pos;

    if (state.eat(0x5C )) {
      if (this.regexp_eatClassEscape(state)) {
        return true
      }
      if (state.switchU) {
        var ch$1 = state.current();
        if (ch$1 === 0x63  || isOctalDigit(ch$1)) {
          state.raise("Invalid class escape");
        }
        state.raise("Invalid escape");
      }
      state.pos = start;
    }

    var ch = state.current();
    if (ch !== 0x5D ) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  pp$8.regexp_eatClassEscape = function(state) {
    var start = state.pos;

    if (state.eat(0x62 )) {
      state.lastIntValue = 0x08; 
      return true
    }

    if (state.switchU && state.eat(0x2D )) {
      state.lastIntValue = 0x2D; 
      return true
    }

    if (!state.switchU && state.eat(0x63 )) {
      if (this.regexp_eatClassControlLetter(state)) {
        return true
      }
      state.pos = start;
    }

    return (
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state)
    )
  };

  pp$8.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 0x5F ) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(0x78 )) {
      if (this.regexp_eatFixedHexDigits(state, 2)) {
        return true
      }
      if (state.switchU) {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return false
  };

  pp$8.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );
      state.advance();
    }
    return state.pos !== start
  };
  function isDecimalDigit(ch) {
    return ch >= 0x30  && ch <= 0x39 
  }

  pp$8.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isHexDigit(ch = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return state.pos !== start
  };
  function isHexDigit(ch) {
    return (
      (ch >= 0x30  && ch <= 0x39 ) ||
      (ch >= 0x41  && ch <= 0x46 ) ||
      (ch >= 0x61  && ch <= 0x66 )
    )
  }
  function hexToInt(ch) {
    if (ch >= 0x41  && ch <= 0x46 ) {
      return 10 + (ch - 0x41 )
    }
    if (ch >= 0x61  && ch <= 0x66 ) {
      return 10 + (ch - 0x61 )
    }
    return ch - 0x30 
  }

  pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
        } else {
          state.lastIntValue = n1 * 8 + n2;
        }
      } else {
        state.lastIntValue = n1;
      }
      return true
    }
    return false
  };

  pp$8.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
      state.lastIntValue = ch - 0x30; 
      state.advance();
      return true
    }
    state.lastIntValue = 0;
    return false
  };
  function isOctalDigit(ch) {
    return ch >= 0x30  && ch <= 0x37 
  }

  pp$8.regexp_eatFixedHexDigits = function(state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i = 0; i < length; ++i) {
      var ch = state.current();
      if (!isHexDigit(ch)) {
        state.pos = start;
        return false
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return true
  };


  var Token = function Token(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations)
      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
    if (p.options.ranges)
      { this.range = [p.start, p.end]; }
  };


  var pp$9 = Parser.prototype;


  pp$9.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
      { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
    if (this.options.onToken)
      { this.options.onToken(new Token(this)); }

    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };

  pp$9.getToken = function() {
    this.next();
    return new Token(this)
  };

  if (typeof Symbol !== "undefined")
    { pp$9[Symbol.iterator] = function() {
      var this$1 = this;

      return {
        next: function () {
          var token = this$1.getToken();
          return {
            done: token.type === types.eof,
            value: token
          }
        }
      }
    }; }


  pp$9.curContext = function() {
    return this.context[this.context.length - 1]
  };


  pp$9.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

    this.start = this.pos;
    if (this.options.locations) { this.startLoc = this.curPosition(); }
    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

    if (curContext.override) { return curContext.override(this) }
    else { this.readToken(this.fullCharCodeAtPos()); }
  };

  pp$9.readToken = function(code) {
    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 )
      { return this.readWord() }

    return this.getTokenFromCode(code)
  };

  pp$9.fullCharCodeAtPos = function() {
    var code = this.input.charCodeAt(this.pos);
    if (code <= 0xd7ff || code >= 0xe000) { return code }
    var next = this.input.charCodeAt(this.pos + 1);
    return (code << 10) + next - 0x35fdc00
  };

  pp$9.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
    this.pos = end + 2;
    if (this.options.locations) {
      lineBreakG.lastIndex = start;
      var match;
      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
        ++this.curLine;
        this.lineStart = match.index + match[0].length;
      }
    }
    if (this.options.onComment)
      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  pp$9.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch)) {
      ch = this.input.charCodeAt(++this.pos);
    }
    if (this.options.onComment)
      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                             startLoc, this.curPosition()); }
  };


  pp$9.skipSpace = function() {
    loop: while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
      case 32: case 160: 
        ++this.pos;
        break
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10: case 8232: case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break
      case 47: 
        switch (this.input.charCodeAt(this.pos + 1)) {
        case 42: 
          this.skipBlockComment();
          break
        case 47:
          this.skipLineComment(2);
          break
        default:
          break loop
        }
        break
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop
        }
      }
    }
  };


  pp$9.finishToken = function(type, val) {
    this.end = this.pos;
    if (this.options.locations) { this.endLoc = this.curPosition(); }
    var prevType = this.type;
    this.type = type;
    this.value = val;

    this.updateContext(prevType);
  };


  pp$9.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) { return this.readNumber(true) }
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { 
      this.pos += 3;
      return this.finishToken(types.ellipsis)
    } else {
      ++this.pos;
      return this.finishToken(types.dot)
    }
  };

  pp$9.readToken_slash = function() { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.slash, 1)
  };

  pp$9.readToken_mult_modulo_exp = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code === 42 ? types.star : types.modulo;

    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
      ++size;
      tokentype = types.starstar;
      next = this.input.charCodeAt(this.pos + 2);
    }

    if (next === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(tokentype, size)
  };

  pp$9.readToken_pipe_amp = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
  };

  pp$9.readToken_caret = function() { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.bitwiseXOR, 1)
  };

  pp$9.readToken_plus_min = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken()
      }
      return this.finishOp(types.incDec, 2)
    }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.plusMin, 1)
  };

  pp$9.readToken_lt_gt = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
      return this.finishOp(types.bitShift, size)
    }
    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
        this.input.charCodeAt(this.pos + 3) === 45) {
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken()
    }
    if (next === 61) { size = 2; }
    return this.finishOp(types.relational, size)
  };

  pp$9.readToken_eq_excl = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { 
      this.pos += 2;
      return this.finishToken(types.arrow)
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
  };

  pp$9.getTokenFromCode = function(code) {
    switch (code) {
    case 46: 
      return this.readToken_dot()

    case 40: ++this.pos; return this.finishToken(types.parenL)
    case 41: ++this.pos; return this.finishToken(types.parenR)
    case 59: ++this.pos; return this.finishToken(types.semi)
    case 44: ++this.pos; return this.finishToken(types.comma)
    case 91: ++this.pos; return this.finishToken(types.bracketL)
    case 93: ++this.pos; return this.finishToken(types.bracketR)
    case 123: ++this.pos; return this.finishToken(types.braceL)
    case 125: ++this.pos; return this.finishToken(types.braceR)
    case 58: ++this.pos; return this.finishToken(types.colon)
    case 63: ++this.pos; return this.finishToken(types.question)

    case 96: 
      if (this.options.ecmaVersion < 6) { break }
      ++this.pos;
      return this.finishToken(types.backQuote)

    case 48: 
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) { return this.readRadixNumber(16) } 
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) { return this.readRadixNumber(8) } 
        if (next === 98 || next === 66) { return this.readRadixNumber(2) } 
      }

    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: 
      return this.readNumber(false)

    case 34: case 39: 
      return this.readString(code)


    case 47: 
      return this.readToken_slash()

    case 37: case 42: 
      return this.readToken_mult_modulo_exp(code)

    case 124: case 38: 
      return this.readToken_pipe_amp(code)

    case 94: 
      return this.readToken_caret()

    case 43: case 45: 
      return this.readToken_plus_min(code)

    case 60: case 62: 
      return this.readToken_lt_gt(code)

    case 61: case 33: 
      return this.readToken_eq_excl(code)

    case 126: 
      return this.finishOp(types.prefix, 1)
    }

    this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
  };

  pp$9.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str)
  };

  pp$9.readRegexp = function() {
    var escaped, inClass, start = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
      if (!escaped) {
        if (ch === "[") { inClass = true; }
        else if (ch === "]" && inClass) { inClass = false; }
        else if (ch === "/" && !inClass) { break }
        escaped = ch === "\\";
      } else { escaped = false; }
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) { this.unexpected(flagsStart); }

    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);

    var value = null;
    try {
      value = new RegExp(pattern, flags);
    } catch (e) {
    }

    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
  };


  pp$9.readInt = function(radix, len) {
    var start = this.pos, total = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = this.input.charCodeAt(this.pos), val = (void 0);
      if (code >= 97) { val = code - 97 + 10; } 
      else if (code >= 65) { val = code - 65 + 10; } 
      else if (code >= 48 && code <= 57) { val = code - 48; } 
      else { val = Infinity; }
      if (val >= radix) { break }
      ++this.pos;
      total = total * radix + val;
    }
    if (this.pos === start || len != null && this.pos - start !== len) { return null }

    return total
  };

  pp$9.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2; 
    var val = this.readInt(radix);
    if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
      ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val)
  };


  pp$9.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) { this.raise(start, "Invalid number"); }
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
      var str$1 = this.input.slice(start, this.pos);
      var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
      ++this.pos;
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types.num, val$1)
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
    if (next === 46 && !octal) { 
      ++this.pos;
      this.readInt(10);
      next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) { 
      next = this.input.charCodeAt(++this.pos);
      if (next === 43 || next === 45) { ++this.pos; } 
      if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

    var str = this.input.slice(start, this.pos);
    var val = octal ? parseInt(str, 8) : parseFloat(str);
    return this.finishToken(types.num, val)
  };


  pp$9.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code;

    if (ch === 123) { 
      if (this.options.ecmaVersion < 6) { this.unexpected(); }
      var codePos = ++this.pos;
      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
    } else {
      code = this.readHexChar(4);
    }
    return code
  };

  function codePointToString$1(code) {
    if (code <= 0xFFFF) { return String.fromCharCode(code) }
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
  }

  pp$9.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) { break }
      if (ch === 92) { 
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else {
        if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types.string, out)
  };


  var INVALID_TEMPLATE_ESCAPE_ERROR = {};

  pp$9.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
        this.readInvalidTemplateToken();
      } else {
        throw err
      }
    }

    this.inTemplateElement = false;
  };

  pp$9.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
      throw INVALID_TEMPLATE_ESCAPE_ERROR
    } else {
      this.raise(position, message);
    }
  };

  pp$9.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { 
        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
          if (ch === 36) {
            this.pos += 2;
            return this.finishToken(types.dollarBraceL)
          } else {
            ++this.pos;
            return this.finishToken(types.backQuote)
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types.template, out)
      }
      if (ch === 92) { 
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
        case 10:
          out += "\n";
          break
        default:
          out += String.fromCharCode(ch);
          break
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
  };

  pp$9.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++) {
      switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break

      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break
        }

      case "`":
        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

      }
    }
    this.raise(this.start, "Unterminated template");
  };


  pp$9.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch) {
    case 110: return "\n" 
    case 114: return "\r" 
    case 120: return String.fromCharCode(this.readHexChar(2)) 
    case 117: return codePointToString$1(this.readCodePoint()) 
    case 116: return "\t" 
    case 98: return "\b" 
    case 118: return "\u000b" 
    case 102: return "\f" 
    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } 
    case 10: 
      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
      return ""
    case 56:
    case 57:
      if (inTemplate) {
        var codePos = this.pos - 1;

        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );

        return null
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate
              ? "Octal literal in template string"
              : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal)
      }
      if (isNewLine(ch)) {
        return ""
      }
      return String.fromCharCode(ch)
    }
  };


  pp$9.readHexChar = function(len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
    return n
  };


  pp$9.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral)) {
        this.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) { 
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117) 
          { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
          { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
        word += codePointToString$1(esc);
        chunkStart = this.pos;
      } else {
        break
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos)
  };


  pp$9.readWord = function() {
    var word = this.readWord1();
    var type = types.name;
    if (this.keywords.test(word)) {
      type = keywords$1[word];
    }
    return this.finishToken(type, word)
  };


  var version = "7.1.0";

  Parser.acorn = {
    Parser: Parser,
    version: version,
    defaultOptions: defaultOptions,
    Position: Position,
    SourceLocation: SourceLocation,
    getLineInfo: getLineInfo,
    Node: Node,
    TokenType: TokenType,
    tokTypes: types,
    keywordTypes: keywords$1,
    TokContext: TokContext,
    tokContexts: types$1,
    isIdentifierChar: isIdentifierChar,
    isIdentifierStart: isIdentifierStart,
    Token: Token,
    isNewLine: isNewLine,
    lineBreak: lineBreak,
    lineBreakG: lineBreakG,
    nonASCIIwhitespace: nonASCIIwhitespace
  };


  function parse(input, options) {
    return Parser.parse(input, options)
  }


  function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options)
  }


  function tokenizer(input, options) {
    return Parser.tokenizer(input, options)
  }

  exports.Node = Node;
  exports.Parser = Parser;
  exports.Position = Position;
  exports.SourceLocation = SourceLocation;
  exports.TokContext = TokContext;
  exports.Token = Token;
  exports.TokenType = TokenType;
  exports.defaultOptions = defaultOptions;
  exports.getLineInfo = getLineInfo;
  exports.isIdentifierChar = isIdentifierChar;
  exports.isIdentifierStart = isIdentifierStart;
  exports.isNewLine = isNewLine;
  exports.keywordTypes = keywords$1;
  exports.lineBreak = lineBreak;
  exports.lineBreakG = lineBreakG;
  exports.nonASCIIwhitespace = nonASCIIwhitespace;
  exports.parse = parse;
  exports.parseExpressionAt = parseExpressionAt;
  exports.tokContexts = types$1;
  exports.tokTypes = types;
  exports.tokenizer = tokenizer;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
function glWiretap(gl, options = {}) {
  const {
    contextName = 'gl',
    throwGetError,
    useTrackablePrimitives,
    readPixelsFile,
    recording = [],
    variables = {},
    onReadPixels,
    onUnrecognizedArgumentLookup,
  } = options;
  const proxy = new Proxy(gl, { get: listen });
  const contextVariables = [];
  const entityNames = {};
  let imageCount = 0;
  let indent = '';
  let readPixelsVariableName;
  return proxy;
  function listen(obj, property) {
    switch (property) {
      case 'addComment': return addComment;
      case 'checkThrowError': return checkThrowError;
      case 'getReadPixelsVariableName': return readPixelsVariableName;
      case 'insertVariable': return insertVariable;
      case 'reset': return reset;
      case 'setIndent': return setIndent;
      case 'toString': return toString;
      case 'getContextVariableName': return getContextVariableName;
    }
    if (typeof gl[property] === 'function') {
      return function() { 
        switch (property) {
          case 'getError':
            if (throwGetError) {
              recording.push(`${indent}if (${contextName}.getError() !== ${contextName}.NONE) throw new Error('error');`);
            } else {
              recording.push(`${indent}${contextName}.getError();`); 
            }
            return gl.getError();
          case 'getExtension': {
            const variableName = `${contextName}Variables${contextVariables.length}`;
            recording.push(`${indent}const ${variableName} = ${contextName}.getExtension('${arguments[0]}');`);
            const extension = gl.getExtension(arguments[0]);
            if (extension && typeof extension === 'object') {
              const tappedExtension = glExtensionWiretap(extension, {
                getEntity,
                useTrackablePrimitives,
                recording,
                contextName: variableName,
                contextVariables,
                variables,
                indent,
                onUnrecognizedArgumentLookup,
              });
              contextVariables.push(tappedExtension);
              return tappedExtension;
            } else {
              contextVariables.push(null);
            }
            return extension;
          }
          case 'readPixels':
            const i = contextVariables.indexOf(arguments[6]);
            let targetVariableName;
            if (i === -1) {
              const variableName = getVariableName(arguments[6]);
              if (variableName) {
                targetVariableName = variableName;
                recording.push(`${indent}${variableName}`);
              } else {
                targetVariableName = `${contextName}Variable${contextVariables.length}`;
                contextVariables.push(arguments[6]);
                recording.push(`${indent}const ${targetVariableName} = new ${arguments[6].constructor.name}(${arguments[6].length});`);
              }
            } else {
              targetVariableName = `${contextName}Variable${i}`;
            }
            readPixelsVariableName = targetVariableName;
            const argumentAsStrings = [
              arguments[0],
              arguments[1],
              arguments[2],
              arguments[3],
              getEntity(arguments[4]),
              getEntity(arguments[5]),
              targetVariableName
            ];
            recording.push(`${indent}${contextName}.readPixels(${argumentAsStrings.join(', ')});`);
            if (readPixelsFile) {
              writePPM(arguments[2], arguments[3]);
            }
            if (onReadPixels) {
              onReadPixels(targetVariableName, argumentAsStrings);
            }
            return gl.readPixels.apply(gl, arguments);
          case 'drawBuffers':
            recording.push(`${indent}${contextName}.drawBuffers([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup } )}]);`);
            return gl.drawBuffers(arguments[0]);
        }
        let result = gl[property].apply(gl, arguments);
        switch (typeof result) {
          case 'undefined':
            recording.push(`${indent}${methodCallToString(property, arguments)};`);
            return;
          case 'number':
          case 'boolean':
            if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result = trackablePrimitive(result));
              break;
            }
          default:
            if (result === null) {
              recording.push(`${methodCallToString(property, arguments)};`);
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
            }

            contextVariables.push(result);
        }
        return result;
      }
    }
    entityNames[gl[property]] = property;
    return gl[property];
  }
  function toString() {
    return recording.join('\n');
  }
  function reset() {
    while (recording.length > 0) {
      recording.pop();
    }
  }
  function insertVariable(name, value) {
    variables[name] = value;
  }
  function getEntity(value) {
    const name = entityNames[value];
    if (name) {
      return contextName + '.' + name;
    }
    return value;
  }
  function setIndent(spaces) {
    indent = ' '.repeat(spaces);
  }
  function addVariable(value, source) {
    const variableName = `${contextName}Variable${contextVariables.length}`;
    recording.push(`${indent}const ${variableName} = ${source};`);
    contextVariables.push(value);
    return variableName;
  }
  function writePPM(width, height) {
    const sourceVariable = `${contextName}Variable${contextVariables.length}`;
    const imageVariable = `imageDatum${imageCount}`;
    recording.push(`${indent}let ${imageVariable} = ["P3\\n# ${readPixelsFile}.ppm\\n", ${width}, ' ', ${height}, "\\n255\\n"].join("");`);
    recording.push(`${indent}for (let i = 0; i < ${imageVariable}.length; i += 4) {`);
    recording.push(`${indent}  ${imageVariable} += ${sourceVariable}[i] + ' ' + ${sourceVariable}[i + 1] + ' ' + ${sourceVariable}[i + 2] + ' ';`);
    recording.push(`${indent}}`);
    recording.push(`${indent}if (typeof require !== "undefined") {`);
    recording.push(`${indent}  require('fs').writeFileSync('./${readPixelsFile}.ppm', ${imageVariable});`);
    recording.push(`${indent}}`);
    imageCount++;
  }
  function addComment(value) {
    recording.push(`${indent}// ${value}`);
  }
  function checkThrowError() {
    recording.push(`${indent}(() => {
${indent}const error = ${contextName}.getError();
${indent}if (error !== ${contextName}.NONE) {
${indent}  const names = Object.getOwnPropertyNames(gl);
${indent}  for (let i = 0; i < names.length; i++) {
${indent}    const name = names[i];
${indent}    if (${contextName}[name] === error) {
${indent}      throw new Error('${contextName} threw ' + name);
${indent}    }
${indent}  }
${indent}}
${indent}})();`);
  }
  function methodCallToString(method, args) {
    return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
  }

  function getVariableName(value) {
    if (variables) {
      for (const name in variables) {
        if (variables[name] === value) {
          return name;
        }
      }
    }
    return null;
  }

  function getContextVariableName(value) {
    const i = contextVariables.indexOf(value);
    if (i !== -1) {
      return `${contextName}Variable${i}`;
    }
    return null;
  }
}

function glExtensionWiretap(extension, options) {
  const proxy = new Proxy(extension, { get: listen });
  const extensionEntityNames = {};
  const {
    contextName,
    contextVariables,
    getEntity,
    useTrackablePrimitives,
    recording,
    variables,
    indent,
    onUnrecognizedArgumentLookup,
  } = options;
  return proxy;
  function listen(obj, property) {
    if (typeof obj[property] === 'function') {
      return function() {
        switch (property) {
          case 'drawBuffersWEBGL':
            recording.push(`${indent}${contextName}.drawBuffersWEBGL([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })}]);`);
            return extension.drawBuffersWEBGL(arguments[0]);
        }
        let result = extension[property].apply(extension, arguments);
        switch (typeof result) {
          case 'undefined':
            recording.push(`${indent}${methodCallToString(property, arguments)};`);
            return;
          case 'number':
          case 'boolean':
            if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result = trackablePrimitive(result));
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result);
            }
            break;
          default:
            if (result === null) {
              recording.push(`${methodCallToString(property, arguments)};`);
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
            }
            contextVariables.push(result);
        }
        return result;
      };
    }
    extensionEntityNames[extension[property]] = property;
    return extension[property];
  }

  function getExtensionEntity(value) {
    if (extensionEntityNames.hasOwnProperty(value)) {
      return `${contextName}.${extensionEntityNames[value]}`;
    }
    return getEntity(value);
  }

  function methodCallToString(method, args) {
    return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
  }

  function addVariable(value, source) {
    const variableName = `${contextName}Variable${contextVariables.length}`;
    contextVariables.push(value);
    recording.push(`${indent}const ${variableName} = ${source};`);
    return variableName;
  }
}

function argumentsToString(args, options) {
  const { variables, onUnrecognizedArgumentLookup } = options;
  return (Array.from(args).map((arg) => {
    const variableName = getVariableName(arg);
    if (variableName) {
      return variableName;
    }
    return argumentToString(arg, options);
  }).join(', '));

  function getVariableName(value) {
    if (variables) {
      for (const name in variables) {
        if (!variables.hasOwnProperty(name)) continue;
        if (variables[name] === value) {
          return name;
        }
      }
    }
    if (onUnrecognizedArgumentLookup) {
      return onUnrecognizedArgumentLookup(value);
    }
    return null;
  }
}

function argumentToString(arg, options) {
  const { contextName, contextVariables, getEntity, addVariable, onUnrecognizedArgumentLookup } = options;
  if (typeof arg === 'undefined') {
    return 'undefined';
  }
  if (arg === null) {
    return 'null';
  }
  const i = contextVariables.indexOf(arg);
  if (i > -1) {
    return `${contextName}Variable${i}`;
  }
  switch (arg.constructor.name) {
    case 'String':
      const hasLines = /\n/.test(arg);
      const hasSingleQuotes = /'/.test(arg);
      const hasDoubleQuotes = /"/.test(arg);
      if (hasLines) {
        return '`' + arg + '`';
      } else if (hasSingleQuotes && !hasDoubleQuotes) {
        return '"' + arg + '"';
      } else if (!hasSingleQuotes && hasDoubleQuotes) {
        return "'" + arg + "'";
      } else {
        return '\'' + arg + '\'';
      }
    case 'Number': return getEntity(arg);
    case 'Boolean': return getEntity(arg);
    case 'Array':
      return addVariable(arg, `new ${arg.constructor.name}([${Array.from(arg).join(',')}])`);
    case 'Float32Array':
    case 'Uint8Array':
    case 'Uint16Array':
    case 'Int32Array':
      return addVariable(arg, `new ${arg.constructor.name}(${JSON.stringify(Array.from(arg))})`);
    default:
      if (onUnrecognizedArgumentLookup) {
        const instantiationString = onUnrecognizedArgumentLookup(arg);
        if (instantiationString) {
          return instantiationString;
        }
      }
      throw new Error(`unrecognized argument type ${arg.constructor.name}`);
  }
}

function trackablePrimitive(value) {
  return new value.constructor(value);
}

if (typeof module !== 'undefined') {
  module.exports = { glWiretap, glExtensionWiretap };
}

if (typeof window !== 'undefined') {
  glWiretap.glExtensionWiretap = glExtensionWiretap;
  window.glWiretap = glWiretap;
}

},{}],4:[function(require,module,exports){
function setupArguments(args) {
  const newArguments = new Array(args.length);
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.toArray) {
      newArguments[i] = arg.toArray();
    } else {
      newArguments[i] = arg;
    }
  }
  return newArguments;
}

function mock1D() {
  const args = setupArguments(arguments);
  const row = new Float32Array(this.output.x);
  for (let x = 0; x < this.output.x; x++) {
    this.thread.x = x;
    this.thread.y = 0;
    this.thread.z = 0;
    row[x] = this._fn.apply(this, args);
  }
  return row;
}

function mock2D() {
  const args = setupArguments(arguments);
  const matrix = new Array(this.output.y);
  for (let y = 0; y < this.output.y; y++) {
    const row = new Float32Array(this.output.x);
    for (let x = 0; x < this.output.x; x++) {
      this.thread.x = x;
      this.thread.y = y;
      this.thread.z = 0;
      row[x] = this._fn.apply(this, args);
    }
    matrix[y] = row;
  }
  return matrix;
}

function mock2DGraphical() {
  const args = setupArguments(arguments);
  for (let y = 0; y < this.output.y; y++) {
    for (let x = 0; x < this.output.x; x++) {
      this.thread.x = x;
      this.thread.y = y;
      this.thread.z = 0;
      this._fn.apply(this, args);
    }
  }
}

function mock3D() {
  const args = setupArguments(arguments);
  const cube = new Array(this.output.z);
  for (let z = 0; z < this.output.z; z++) {
    const matrix = new Array(this.output.y);
    for (let y = 0; y < this.output.y; y++) {
      const row = new Float32Array(this.output.x);
      for (let x = 0; x < this.output.x; x++) {
        this.thread.x = x;
        this.thread.y = y;
        this.thread.z = z;
        row[x] = this._fn.apply(this, args);
      }
      matrix[y] = row;
    }
    cube[z] = matrix;
  }
  return cube;
}

function apiDecorate(kernel) {
  kernel.setOutput = (output) => {
    kernel.output = setupOutput(output);
    if (kernel.graphical) {
      setupGraphical(kernel);
    }
  };
  kernel.toJSON = () => {
    throw new Error('Not usable with gpuMock');
  };
  kernel.setConstants = (flag) => {
    kernel.constants = flag;
    return kernel;
  };
  kernel.setGraphical = (flag) => {
    kernel.graphical = flag;
    return kernel;
  };
  kernel.setCanvas = (flag) => {
    kernel.canvas = flag;
    return kernel;
  };
  kernel.setContext = (flag) => {
    kernel.context = flag;
    return kernel;
  };
  kernel.destroy = () => {};
  kernel.validateSettings = () => {};
  if (kernel.graphical && kernel.output) {
    setupGraphical(kernel);
  }
  kernel.exec = function() {
    return new Promise((resolve, reject) => {
      try {
        resolve(kernel.apply(kernel, arguments));
      } catch(e) {
        reject(e);
      }
    });
  };
  kernel.getPixels = (flip) => {
    const {x, y} = kernel.output;
    return flip ? flipPixels(kernel._imageData.data, x, y) : kernel._imageData.data.slice(0);
  };
  kernel.color = function(r, g, b, a) {
    if (typeof a === 'undefined') {
      a = 1;
    }

    r = Math.floor(r * 255);
    g = Math.floor(g * 255);
    b = Math.floor(b * 255);
    a = Math.floor(a * 255);

    const width = kernel.output.x;
    const height = kernel.output.y;

    const x = kernel.thread.x;
    const y = height - kernel.thread.y - 1;

    const index = x + y * width;

    kernel._colorData[index * 4 + 0] = r;
    kernel._colorData[index * 4 + 1] = g;
    kernel._colorData[index * 4 + 2] = b;
    kernel._colorData[index * 4 + 3] = a;
  };

  const mockMethod = () => kernel;
  const methods = [
    'setWarnVarUsage',
    'setArgumentTypes',
    'setTactic',
    'setOptimizeFloatMemory',
    'setDebug',
    'setLoopMaxIterations',
    'setConstantTypes',
    'setFunctions',
    'setNativeFunctions',
    'setInjectedNative',
    'setPipeline',
    'setPrecision',
    'setOutputToTexture',
    'setImmutable',
    'setStrictIntegers',
    'setDynamicOutput',
    'setHardcodeConstants',
    'setDynamicArguments',
    'setUseLegacyEncoder',
    'setWarnVarUsage',
    'addSubKernel',
  ];
  for (let i = 0; i < methods.length; i++) {
    kernel[methods[i]] = mockMethod;
  }
  return kernel;
}

function setupGraphical(kernel) {
  const {x, y} = kernel.output;
  if (kernel.context && kernel.context.createImageData) {
    const data = new Uint8ClampedArray(x * y * 4);
    kernel._imageData = kernel.context.createImageData(x, y);
    kernel._colorData = data;
  } else {
    const data = new Uint8ClampedArray(x * y * 4);
    kernel._imageData = { data };
    kernel._colorData = data;
  }
}

function setupOutput(output) {
  let result = null;
  if (output.length) {
    if (output.length === 3) {
      const [x,y,z] = output;
      result = { x, y, z };
    } else if (output.length === 2) {
      const [x,y] = output;
      result = { x, y };
    } else {
      const [x] = output;
      result = { x };
    }
  } else {
    result = output;
  }
  return result;
}

function gpuMock(fn, settings = {}) {
  const output = settings.output ? setupOutput(settings.output) : null;
  function kernel() {
    if (kernel.output.z) {
      return mock3D.apply(kernel, arguments);
    } else if (kernel.output.y) {
      if (kernel.graphical) {
        return mock2DGraphical.apply(kernel, arguments);
      }
      return mock2D.apply(kernel, arguments);
    } else {
      return mock1D.apply(kernel, arguments);
    }
  }
  kernel._fn = fn;
  kernel.constants = settings.constants || null;
  kernel.context = settings.context || null;
  kernel.canvas = settings.canvas || null;
  kernel.graphical = settings.graphical || false;
  kernel._imageData = null;
  kernel._colorData = null;
  kernel.output = output;
  kernel.thread = {
    x: 0,
    y: 0,
    z: 0
  };
  return apiDecorate(kernel);
}

function flipPixels(pixels, width, height) {
  const halfHeight = height / 2 | 0; 
  const bytesPerRow = width * 4;
  const temp = new Uint8ClampedArray(width * 4);
  const result = pixels.slice(0);
  for (let y = 0; y < halfHeight; ++y) {
    const topOffset = y * bytesPerRow;
    const bottomOffset = (height - y - 1) * bytesPerRow;

    temp.set(result.subarray(topOffset, topOffset + bytesPerRow));

    result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);

    result.set(temp, bottomOffset);
  }
  return result;
}

module.exports = {
  gpuMock
};

},{}],5:[function(require,module,exports){
const { utils } = require('./utils');

function alias(name, source) {
  const fnString = source.toString();
  return new Function(`return function ${ name } (${ utils.getArgumentNamesFromString(fnString).join(', ') }) {
  ${ utils.getFunctionBodyFromString(fnString) }
}`)();
}

module.exports = {
  alias
};
},{"./utils":114}],6:[function(require,module,exports){
const { FunctionNode } = require('../function-node');

class CPUFunctionNode extends FunctionNode {
  astFunction(ast, retArr) {

    if (!this.isRootKernel) {
      retArr.push('function');
      retArr.push(' ');
      retArr.push(this.name);
      retArr.push('(');

      for (let i = 0; i < this.argumentNames.length; ++i) {
        const argumentName = this.argumentNames[i];

        if (i > 0) {
          retArr.push(', ');
        }
        retArr.push('user_');
        retArr.push(argumentName);
      }

      retArr.push(') {\n');
    }

    for (let i = 0; i < ast.body.body.length; ++i) {
      this.astGeneric(ast.body.body[i], retArr);
      retArr.push('\n');
    }

    if (!this.isRootKernel) {
      retArr.push('}\n');
    }
    return retArr;
  }

  astReturnStatement(ast, retArr) {
    const type = this.returnType || this.getType(ast.argument);

    if (!this.returnType) {
      this.returnType = type;
    }

    if (this.isRootKernel) {
      retArr.push(this.leadingReturnStatement);
      this.astGeneric(ast.argument, retArr);
      retArr.push(';\n');
      retArr.push(this.followingReturnStatement);
      retArr.push('continue;\n');
    } else if (this.isSubKernel) {
      retArr.push(`subKernelResult_${ this.name } = `);
      this.astGeneric(ast.argument, retArr);
      retArr.push(';');
      retArr.push(`return subKernelResult_${ this.name };`);
    } else {
      retArr.push('return ');
      this.astGeneric(ast.argument, retArr);
      retArr.push(';');
    }
    return retArr;
  }

  astLiteral(ast, retArr) {

    if (isNaN(ast.value)) {
      throw this.astErrorOutput(
        'Non-numeric literal not supported : ' + ast.value,
        ast
      );
    }

    retArr.push(ast.value);

    return retArr;
  }

  astBinaryExpression(ast, retArr) {
    retArr.push('(');
    this.astGeneric(ast.left, retArr);
    retArr.push(ast.operator);
    this.astGeneric(ast.right, retArr);
    retArr.push(')');
    return retArr;
  }

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput(
        'IdentifierExpression - not an Identifier',
        idtNode
      );
    }

    switch (idtNode.name) {
      case 'Infinity':
        retArr.push('Infinity');
        break;
      default:
        if (this.constants && this.constants.hasOwnProperty(idtNode.name)) {
          retArr.push('constants_' + idtNode.name);
        } else {
          retArr.push('user_' + idtNode.name);
        }
    }

    return retArr;
  }

  astForStatement(forNode, retArr) {
    if (forNode.type !== 'ForStatement') {
      throw this.astErrorOutput('Invalid for statement', forNode);
    }

    const initArr = [];
    const testArr = [];
    const updateArr = [];
    const bodyArr = [];
    let isSafe = null;

    if (forNode.init) {
      this.pushState('in-for-loop-init');
      this.astGeneric(forNode.init, initArr);
      for (let i = 0; i < initArr.length; i++) {
        if (initArr[i].includes && initArr[i].includes(',')) {
          isSafe = false;
        }
      }
      this.popState('in-for-loop-init');
    } else {
      isSafe = false;
    }

    if (forNode.test) {
      this.astGeneric(forNode.test, testArr);
    } else {
      isSafe = false;
    }

    if (forNode.update) {
      this.astGeneric(forNode.update, updateArr);
    } else {
      isSafe = false;
    }

    if (forNode.body) {
      this.pushState('loop-body');
      this.astGeneric(forNode.body, bodyArr);
      this.popState('loop-body');
    }

    if (isSafe === null) {
      isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
    }

    if (isSafe) {
      retArr.push(`for (${initArr.join('')};${testArr.join('')};${updateArr.join('')}){\n`);
      retArr.push(bodyArr.join(''));
      retArr.push('}\n');
    } else {
      const iVariableName = this.getInternalVariableName('safeI');
      if (initArr.length > 0) {
        retArr.push(initArr.join(''), ';\n');
      }
      retArr.push(`for (let ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
      if (testArr.length > 0) {
        retArr.push(`if (!${testArr.join('')}) break;\n`);
      }
      retArr.push(bodyArr.join(''));
      retArr.push(`\n${updateArr.join('')};`);
      retArr.push('}\n');
    }
    return retArr;
  }

  astWhileStatement(whileNode, retArr) {
    if (whileNode.type !== 'WhileStatement') {
      throw this.astErrorOutput(
        'Invalid while statement',
        whileNode
      );
    }

    retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
    retArr.push('if (');
    this.astGeneric(whileNode.test, retArr);
    retArr.push(') {\n');
    this.astGeneric(whileNode.body, retArr);
    retArr.push('} else {\n');
    retArr.push('break;\n');
    retArr.push('}\n');
    retArr.push('}\n');

    return retArr;
  }

  astDoWhileStatement(doWhileNode, retArr) {
    if (doWhileNode.type !== 'DoWhileStatement') {
      throw this.astErrorOutput(
        'Invalid while statement',
        doWhileNode
      );
    }

    retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
    this.astGeneric(doWhileNode.body, retArr);
    retArr.push('if (!');
    this.astGeneric(doWhileNode.test, retArr);
    retArr.push(') {\n');
    retArr.push('break;\n');
    retArr.push('}\n');
    retArr.push('}\n');

    return retArr;

  }

  astAssignmentExpression(assNode, retArr) {
    const declaration = this.getDeclaration(assNode.left);
    if (declaration && !declaration.assignable) {
      throw this.astErrorOutput(`Variable ${assNode.left.name} is not assignable here`, assNode);
    }
    this.astGeneric(assNode.left, retArr);
    retArr.push(assNode.operator);
    this.astGeneric(assNode.right, retArr);
    return retArr;
  }

  astBlockStatement(bNode, retArr) {
    if (this.isState('loop-body')) {
      this.pushState('block-body'); 
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      this.popState('block-body');
    } else {
      retArr.push('{\n');
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      retArr.push('}\n');
    }
    return retArr;
  }

  astVariableDeclaration(varDecNode, retArr) {
    retArr.push(`${varDecNode.kind} `);
    const { declarations } = varDecNode;
    for (let i = 0; i < declarations.length; i++) {
      if (i > 0) {
        retArr.push(',');
      }
      const declaration = declarations[i];
      const info = this.getDeclaration(declaration.id);
      if (!info.valueType) {
        info.valueType = this.getType(declaration.init);
      }
      this.astGeneric(declaration, retArr);
    }
    if (!this.isState('in-for-loop-init')) {
      retArr.push(';');
    }
    return retArr;
  }

  astIfStatement(ifNode, retArr) {
    retArr.push('if (');
    this.astGeneric(ifNode.test, retArr);
    retArr.push(')');
    if (ifNode.consequent.type === 'BlockStatement') {
      this.astGeneric(ifNode.consequent, retArr);
    } else {
      retArr.push(' {\n');
      this.astGeneric(ifNode.consequent, retArr);
      retArr.push('\n}\n');
    }

    if (ifNode.alternate) {
      retArr.push('else ');
      if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {
        this.astGeneric(ifNode.alternate, retArr);
      } else {
        retArr.push(' {\n');
        this.astGeneric(ifNode.alternate, retArr);
        retArr.push('\n}\n');
      }
    }
    return retArr;

  }

  astSwitchStatement(ast, retArr) {
    const { discriminant, cases } = ast;
    retArr.push('switch (');
    this.astGeneric(discriminant, retArr);
    retArr.push(') {\n');
    for (let i = 0; i < cases.length; i++) {
      if (cases[i].test === null) {
        retArr.push('default:\n');
        this.astGeneric(cases[i].consequent, retArr);
        if (cases[i].consequent && cases[i].consequent.length > 0) {
          retArr.push('break;\n');
        }
        continue;
      }
      retArr.push('case ');
      this.astGeneric(cases[i].test, retArr);
      retArr.push(':\n');
      if (cases[i].consequent && cases[i].consequent.length > 0) {
        this.astGeneric(cases[i].consequent, retArr);
        retArr.push('break;\n');
      }
    }
    retArr.push('\n}');
  }

  astThisExpression(tNode, retArr) {
    retArr.push('_this');
    return retArr;
  }

  astMemberExpression(mNode, retArr) {
    const {
      signature,
      type,
      property,
      xProperty,
      yProperty,
      zProperty,
      name,
      origin
    } = this.getMemberExpressionDetails(mNode);
    switch (signature) {
      case 'this.thread.value':
        retArr.push(`_this.thread.${ name }`);
        return retArr;
      case 'this.output.value':
        switch (name) {
          case 'x':
            retArr.push('outputX');
            break;
          case 'y':
            retArr.push('outputY');
            break;
          case 'z':
            retArr.push('outputZ');
            break;
          default:
            throw this.astErrorOutput('Unexpected expression', mNode);
        }
        return retArr;
      case 'value':
        throw this.astErrorOutput('Unexpected expression', mNode);
      case 'value[]':
      case 'value[][]':
      case 'value[][][]':
      case 'value.value':
        if (origin === 'Math') {
          retArr.push(Math[name]);
          return retArr;
        }
        switch (property) {
          case 'r':
            retArr.push(`user_${ name }[0]`);
            return retArr;
          case 'g':
            retArr.push(`user_${ name }[1]`);
            return retArr;
          case 'b':
            retArr.push(`user_${ name }[2]`);
            return retArr;
          case 'a':
            retArr.push(`user_${ name }[3]`);
            return retArr;
        }
        break;
      case 'value.value[]': 
        if (this.removeIstanbulCoverage) {
          return retArr;
        }
        retArr.push(`${mNode.object.object.name}.${mNode.object.property.name}[${mNode.property.value}]`);
        return retArr;
      case 'value.value[][]': 
        if (this.removeIstanbulCoverage) {
          return retArr;
        }
        retArr.push(`${mNode.object.object.object.name}.${mNode.object.object.property.name}[${mNode.object.property.value}][${mNode.property.value}]`);
        return retArr;
      case 'this.constants.value':
      case 'this.constants.value[]':
      case 'this.constants.value[][]':
      case 'this.constants.value[][][]':
        break;
      case 'fn()[]':
        this.astGeneric(mNode.object, retArr);
        retArr.push('[');
        this.astGeneric(mNode.property, retArr);
        retArr.push(']');
        return retArr;
      default:
        throw this.astErrorOutput('Unexpected expression', mNode);
    }

    if (!mNode.computed) {
      switch (type) {
        case 'Number':
        case 'Integer':
        case 'Float':
        case 'Boolean':
          retArr.push(`${origin}_${name}`);
          return retArr;
      }
    }

    const markupName = `${origin}_${name}`;

    switch (type) {
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'HTMLImageArray':
      case 'ArrayTexture(1)':
      case 'ArrayTexture(2)':
      case 'ArrayTexture(3)':
      case 'ArrayTexture(4)':
      case 'HTMLImage':
      default:
        let size;
        let isInput;
        if (origin === 'constants') {
          const constant = this.constants[name];
          isInput = this.constantTypes[name] === 'Input';
          size = isInput ? constant.size : null;
        } else {
          isInput = this.isInput(name);
          size = isInput ? this.argumentSizes[this.argumentNames.indexOf(name)] : null;
        }
        retArr.push(`${ markupName }`);
        if (zProperty && yProperty) {
          if (isInput) {
            retArr.push('[(');
            this.astGeneric(zProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? '(outputY * outputX)' : size[1] * size[0] })+(`);
            this.astGeneric(yProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          } else {
            retArr.push('[');
            this.astGeneric(zProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(yProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          }
        } else if (yProperty) {
          if (isInput) {
            retArr.push('[(');
            this.astGeneric(yProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          } else {
            retArr.push('[');
            this.astGeneric(yProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          }
        } else if (typeof xProperty !== 'undefined') {
          retArr.push('[');
          this.astGeneric(xProperty, retArr);
          retArr.push(']');
        }
    }
    return retArr;
  }

  astCallExpression(ast, retArr) {
    if (ast.type !== 'CallExpression') {
      throw this.astErrorOutput('Unknown CallExpression', ast);
    }
    let functionName = this.astMemberExpressionUnroll(ast.callee);

    if (this.calledFunctions.indexOf(functionName) < 0) {
      this.calledFunctions.push(functionName);
    }

    const isMathFunction = this.isAstMathFunction(ast);

    if (this.onFunctionCall) {
      this.onFunctionCall(this.name, functionName, ast.arguments);
    }

    retArr.push(functionName);

    retArr.push('(');
    const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
    for (let i = 0; i < ast.arguments.length; ++i) {
      const argument = ast.arguments[i];

      let argumentType = this.getType(argument);
      if (!targetTypes[i]) {
        this.triggerImplyArgumentType(functionName, i, argumentType, this);
      }

      if (i > 0) {
        retArr.push(', ');
      }
      this.astGeneric(argument, retArr);
    }
    retArr.push(')');

    return retArr;
  }

  astArrayExpression(arrNode, retArr) {
    const arrLen = arrNode.elements.length;

    retArr.push('new Float32Array([');
    for (let i = 0; i < arrLen; ++i) {
      if (i > 0) {
        retArr.push(', ');
      }
      const subNode = arrNode.elements[i];
      this.astGeneric(subNode, retArr)
    }
    retArr.push('])');

    return retArr;
  }

  astDebuggerStatement(arrNode, retArr) {
    retArr.push('debugger;');
    return retArr;
  }
}

module.exports = {
  CPUFunctionNode
};
},{"../function-node":10}],7:[function(require,module,exports){
const { utils } = require('../../utils');

function constantsToString(constants, types) {
  const results = [];
  for (const name in types) {
    if (!types.hasOwnProperty(name)) continue;
    const type = types[name];
    const constant = constants[name];
    switch (type) {
      case 'Number':
      case 'Integer':
      case 'Float':
      case 'Boolean':
        results.push(`${name}:${constant}`);
        break;
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
        results.push(`${name}:new ${constant.constructor.name}(${JSON.stringify(Array.from(constant))})`);
        break;
    }
  }
  return `{ ${ results.join() } }`;
}

function cpuKernelString(cpuKernel, name) {
  const header = [];
  const thisProperties = [];
  const beforeReturn = [];

  const useFunctionKeyword = !/^function/.test(cpuKernel.color.toString());

  header.push(
    '  const { context, canvas, constants: incomingConstants } = settings;',
    `  const output = new Int32Array(${JSON.stringify(Array.from(cpuKernel.output))});`,
    `  const _constantTypes = ${JSON.stringify(cpuKernel.constantTypes)};`,
    `  const _constants = ${constantsToString(cpuKernel.constants, cpuKernel.constantTypes)};`,
  );

  thisProperties.push(
    '    constants: _constants,',
    '    context,',
    '    output,',
    '    thread: {x: 0, y: 0, z: 0},',
  );

  if (cpuKernel.graphical) {
    header.push(`  const _imageData = context.createImageData(${cpuKernel.output[0]}, ${cpuKernel.output[1]});`);
    header.push(`  const _colorData = new Uint8ClampedArray(${cpuKernel.output[0]} * ${cpuKernel.output[1]} * 4);`);

    const colorFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.color.toString(), {
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case '_colorData':
            return '_colorData';
          case '_imageData':
            return '_imageData';
          case 'output':
            return 'output';
          case 'thread':
            return 'this.thread';
        }
        return JSON.stringify(cpuKernel[propertyName]);
      },
      findDependency: (object, name) => {
        return null;
      }
    });

    const getPixelsFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.getPixels.toString(), {
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case '_colorData':
            return '_colorData';
          case '_imageData':
            return '_imageData';
          case 'output':
            return 'output';
          case 'thread':
            return 'this.thread';
        }
        return JSON.stringify(cpuKernel[propertyName]);
      },
      findDependency: () => {
        return null;
      }
    });

    thisProperties.push(
      '    _imageData,',
      '    _colorData,',
      `    color: ${colorFn},`,
    );

    beforeReturn.push(
      `  kernel.getPixels = ${getPixelsFn};`
    );
  }

  const constantTypes = [];
  const constantKeys = Object.keys(cpuKernel.constantTypes);
  for (let i = 0; i < constantKeys.length; i++) {
    constantTypes.push(cpuKernel.constantTypes[constantKeys]);
  }
  if (cpuKernel.argumentTypes.indexOf('HTMLImageArray') !== -1 || constantTypes.indexOf('HTMLImageArray') !== -1) {
    const flattenedImageTo3DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._imageTo3DArray.toString(), {
      doNotDefine: ['canvas'],
      findDependency: (object, name) => {
        if (object === 'this') {
          return (useFunctionKeyword ? 'function ' : '') + cpuKernel[name].toString();
        }
        return null;
      },
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case 'canvas':
            return;
          case 'context':
            return 'context';
        }
      }
    });
    beforeReturn.push(flattenedImageTo3DArray);
    thisProperties.push(`    _mediaTo2DArray,`);
    thisProperties.push(`    _imageTo3DArray,`);
  } else if (cpuKernel.argumentTypes.indexOf('HTMLImage') !== -1 || constantTypes.indexOf('HTMLImage') !== -1) {
    const flattenedImageTo2DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._mediaTo2DArray.toString(), {
      findDependency: (object, name) => {
        return null;
      },
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case 'canvas':
            return 'settings.canvas';
          case 'context':
            return 'settings.context';
        }
        throw new Error('unhandled thisLookup');
      }
    });
    beforeReturn.push(flattenedImageTo2DArray);
    thisProperties.push(`    _mediaTo2DArray,`);
  }

  return `function(settings) {
${ header.join('\n') }
  for (const p in _constantTypes) {
    if (!_constantTypes.hasOwnProperty(p)) continue;
    const type = _constantTypes[p];
    switch (type) {
      case 'Number':
      case 'Integer':
      case 'Float':
      case 'Boolean':
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
        if (incomingConstants.hasOwnProperty(p)) {
          console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');
        }
        continue;
    }
    if (!incomingConstants.hasOwnProperty(p)) {
      throw new Error('constant ' + p + ' not found');
    }
    _constants[p] = incomingConstants[p];
  }
  const kernel = (function() {
${cpuKernel._kernelString}
  })
    .apply({ ${thisProperties.join('\n')} });
  ${ beforeReturn.join('\n') }
  return kernel;
}`;
}

module.exports = {
  cpuKernelString
};
},{"../../utils":114}],8:[function(require,module,exports){
const { Kernel } = require('../kernel');
const { FunctionBuilder } = require('../function-builder');
const { CPUFunctionNode } = require('./function-node');
const { utils } = require('../../utils');
const { cpuKernelString } = require('./kernel-string');

class CPUKernel extends Kernel {
  static getFeatures() {
    return this.features;
  }
  static get features() {
    return Object.freeze({
      kernelMap: true,
      isIntegerDivisionAccurate: true
    });
  }
  static get isSupported() {
    return true;
  }
  static isContextMatch(context) {
    return false;
  }
  static get mode() {
    return 'cpu';
  }

  static nativeFunctionArguments() {
    return null;
  }

  static nativeFunctionReturnType() {
    throw new Error(`Looking up native function return type not supported on ${this.name}`);
  }

  static combineKernels(combinedKernel) {
    return combinedKernel;
  }

  static getSignature(kernel, argumentTypes) {
    return 'cpu' + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');
  }

  constructor(source, settings) {
    super(source, settings);
    this.mergeSettings(source.settings || settings);

    this._imageData = null;
    this._colorData = null;
    this._kernelString = null;
    this._prependedString = [];
    this.thread = {
      x: 0,
      y: 0,
      z: 0
    };
    this.translatedSources = null;
  }

  initCanvas() {
    if (typeof document !== 'undefined') {
      return document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      return new OffscreenCanvas(0, 0);
    }
  }

  initContext() {
    if (!this.canvas) return null;
    return this.canvas.getContext('2d');
  }

  initPlugins(settings) {
    return [];
  }

  validateSettings(args) {
    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      if (argType === 'Array') {
        this.output = utils.getDimensions(argType);
      } else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {
        this.output = args[0].output;
      } else {
        throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }
    }

    this.checkOutput();
  }

  translateSource() {
    this.leadingReturnStatement = this.output.length > 1 ? 'resultX[x] = ' : 'result[x] = ';
    if (this.subKernels) {
      const followingReturnStatement = [];
      for (let i = 0; i < this.subKernels.length; i++) {
        const {
          name
        } = this.subKernels[i];
        followingReturnStatement.push(this.output.length > 1 ? `resultX_${ name }[x] = subKernelResult_${ name };\n` : `result_${ name }[x] = subKernelResult_${ name };\n`);
      }
      this.followingReturnStatement = followingReturnStatement.join('');
    }
    const functionBuilder = FunctionBuilder.fromKernel(this, CPUFunctionNode);
    this.translatedSources = functionBuilder.getPrototypes('kernel');
    if (!this.graphical && !this.returnType) {
      this.returnType = functionBuilder.getKernelResultType();
    }
  }

  build() {
    if (this.built) return;
    this.setupConstants();
    this.setupArguments(arguments);
    this.validateSettings(arguments);
    this.translateSource();

    if (this.graphical) {
      const {
        canvas,
        output
      } = this;
      if (!canvas) {
        throw new Error('no canvas available for using graphical output');
      }
      const width = output[0];
      const height = output[1] || 1;
      canvas.width = width;
      canvas.height = height;
      this._imageData = this.context.createImageData(width, height);
      this._colorData = new Uint8ClampedArray(width * height * 4);
    }

    const kernelString = this.getKernelString();
    this.kernelString = kernelString;

    if (this.debug) {
      console.log('Function output:');
      console.log(kernelString);
    }

    try {
      this.run = new Function([], kernelString).bind(this)();
    } catch (e) {
      console.error('An error occurred compiling the javascript: ', e);
    }
    this.buildSignature(arguments);
    this.built = true;
  }

  color(r, g, b, a) {
    if (typeof a === 'undefined') {
      a = 1;
    }

    r = Math.floor(r * 255);
    g = Math.floor(g * 255);
    b = Math.floor(b * 255);
    a = Math.floor(a * 255);

    const width = this.output[0];
    const height = this.output[1];

    const x = this.thread.x;
    const y = height - this.thread.y - 1;

    const index = x + y * width;

    this._colorData[index * 4 + 0] = r;
    this._colorData[index * 4 + 1] = g;
    this._colorData[index * 4 + 2] = b;
    this._colorData[index * 4 + 3] = a;
  }

  getKernelString() {
    if (this._kernelString !== null) return this._kernelString;

    let kernelThreadString = null;
    let {
      translatedSources
    } = this;
    if (translatedSources.length > 1) {
      translatedSources = translatedSources.filter(fn => {
        if (/^function/.test(fn)) return fn;
        kernelThreadString = fn;
        return false;
      });
    } else {
      kernelThreadString = translatedSources.shift();
    }
    return this._kernelString = `  const LOOP_MAX = ${ this._getLoopMaxString() };
  ${ this.injectedNative || '' }
  const _this = this;
  ${ this._resultKernelHeader() }
  ${ this._processConstants() }
  return (${ this.argumentNames.map(argumentName => 'user_' + argumentName).join(', ') }) => {
    ${ this._prependedString.join('') }
    ${ this._earlyThrows() }
    ${ this._processArguments() }
    ${ this.graphical ? this._graphicalKernelBody(kernelThreadString) : this._resultKernelBody(kernelThreadString) }
    ${ translatedSources.length > 0 ? translatedSources.join('\n') : '' }
  };`;
  }

  toString() {
    return cpuKernelString(this);
  }

  _getLoopMaxString() {
    return (
      this.loopMaxIterations ?
      ` ${ parseInt(this.loopMaxIterations) };` :
      ' 1000;'
    );
  }

  _processConstants() {
    if (!this.constants) return '';

    const result = [];
    for (let p in this.constants) {
      const type = this.constantTypes[p];
      switch (type) {
        case 'HTMLCanvas':
        case 'HTMLImage':
        case 'HTMLVideo':
          result.push(`    const constants_${p} = this._mediaTo2DArray(this.constants.${p});\n`);
          break;
        case 'HTMLImageArray':
          result.push(`    const constants_${p} = this._imageTo3DArray(this.constants.${p});\n`);
          break;
        case 'Input':
          result.push(`    const constants_${p} = this.constants.${p}.value;\n`);
          break;
        default:
          result.push(`    const constants_${p} = this.constants.${p};\n`);
      }
    }
    return result.join('');
  }

  _earlyThrows() {
    if (this.graphical) return '';
    if (this.immutable) return '';
    if (!this.pipeline) return '';
    const arrayArguments = [];
    for (let i = 0; i < this.argumentTypes.length; i++) {
      if (this.argumentTypes[i] === 'Array') {
        arrayArguments.push(this.argumentNames[i]);
      }
    }
    if (arrayArguments.length === 0) return '';
    const checks = [];
    for (let i = 0; i < arrayArguments.length; i++) {
      const argumentName = arrayArguments[i];
      const checkSubKernels = this._mapSubKernels(subKernel => `user_${argumentName} === result_${subKernel.name}`).join(' || ');
      checks.push(`user_${argumentName} === result${checkSubKernels ? ` || ${checkSubKernels}` : ''}`);
    }
    return `if (${checks.join(' || ')}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`;
  }

  _processArguments() {
    const result = [];
    for (let i = 0; i < this.argumentTypes.length; i++) {
      const variableName = `user_${this.argumentNames[i]}`;
      switch (this.argumentTypes[i]) {
        case 'HTMLCanvas':
        case 'HTMLImage':
        case 'HTMLVideo':
          result.push(`    ${variableName} = this._mediaTo2DArray(${variableName});\n`);
          break;
        case 'HTMLImageArray':
          result.push(`    ${variableName} = this._imageTo3DArray(${variableName});\n`);
          break;
        case 'Input':
          result.push(`    ${variableName} = ${variableName}.value;\n`);
          break;
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
          result.push(`
    if (${variableName}.toArray) {
      if (!_this.textureCache) {
        _this.textureCache = [];
        _this.arrayCache = [];
      }
      const textureIndex = _this.textureCache.indexOf(${variableName});
      if (textureIndex !== -1) {
        ${variableName} = _this.arrayCache[textureIndex];
      } else {
        _this.textureCache.push(${variableName});
        ${variableName} = ${variableName}.toArray();
        _this.arrayCache.push(${variableName});
      }
    }`);
          break;
      }
    }
    return result.join('');
  }

  _mediaTo2DArray(media) {
    const canvas = this.canvas;
    const width = media.width > 0 ? media.width : media.videoWidth;
    const height = media.height > 0 ? media.height : media.videoHeight;
    if (canvas.width < width) {
      canvas.width = width;
    }
    if (canvas.height < height) {
      canvas.height = height;
    }
    const ctx = this.context;
    ctx.drawImage(media, 0, 0, width, height);
    const pixelsData = ctx.getImageData(0, 0, width, height).data;
    const imageArray = new Array(height);
    let index = 0;
    for (let y = height - 1; y >= 0; y--) {
      const row = imageArray[y] = new Array(width);
      for (let x = 0; x < width; x++) {
        const pixel = new Float32Array(4);
        pixel[0] = pixelsData[index++] / 255; 
        pixel[1] = pixelsData[index++] / 255; 
        pixel[2] = pixelsData[index++] / 255; 
        pixel[3] = pixelsData[index++] / 255; 
        row[x] = pixel;
      }
    }
    return imageArray;
  }

  getPixels(flip) {
    const [width, height] = this.output;
    return flip ? utils.flipPixels(this._imageData.data, width, height) : this._imageData.data.slice(0);
  }

  _imageTo3DArray(images) {
    const imagesArray = new Array(images.length);
    for (let i = 0; i < images.length; i++) {
      imagesArray[i] = this._mediaTo2DArray(images[i]);
    }
    return imagesArray;
  }

  _resultKernelHeader() {
    if (this.graphical) return '';
    if (this.immutable) return '';
    if (!this.pipeline) return '';
    switch (this.output.length) {
      case 1:
        return this._mutableKernel1DResults();
      case 2:
        return this._mutableKernel2DResults();
      case 3:
        return this._mutableKernel3DResults();
    }
  }

  _resultKernelBody(kernelString) {
    switch (this.output.length) {
      case 1:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel1DLoop(kernelString) : this._resultImmutableKernel1DLoop(kernelString)) + this._kernelOutput();
      case 2:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel2DLoop(kernelString) : this._resultImmutableKernel2DLoop(kernelString)) + this._kernelOutput();
      case 3:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel3DLoop(kernelString) : this._resultImmutableKernel3DLoop(kernelString)) + this._kernelOutput();
      default:
        throw new Error('unsupported size kernel');
    }
  }

  _graphicalKernelBody(kernelThreadString) {
    switch (this.output.length) {
      case 2:
        return this._graphicalKernel2DLoop(kernelThreadString) + this._graphicalOutput();
      default:
        throw new Error('unsupported size kernel');
    }
  }

  _graphicalOutput() {
    return `
    this._imageData.data.set(this._colorData);
    this.context.putImageData(this._imageData, 0, 0);
    return;`
  }

  _getKernelResultTypeConstructorString() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return 'Float32Array';
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
        return 'Array';
      default:
        if (this.graphical) {
          return 'Float32Array';
        }
        throw new Error(`unhandled returnType ${ this.returnType }`);
    }
  }

  _resultImmutableKernel1DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const result = new ${constructorString}(outputX);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${ kernelString }
    }`;
  }

  _mutableKernel1DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const result = new ${constructorString}(outputX);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }`;
  }

  _resultMutableKernel1DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${ kernelString }
    }`;
  }

  _resultImmutableKernel2DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y] = new ${constructorString}(outputX);
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _mutableKernel2DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let y = 0; y < outputY; y++) {
      const resultX = result[y] = new ${constructorString}(outputX);
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
    }`;
  }

  _resultMutableKernel2DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y];
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _graphicalKernel2DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _resultImmutableKernel3DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z] = new Array(outputY);
      ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\n`).join('      ') }
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y] = new ${constructorString}(outputX);
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('        ') }
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }
    }`;
  }

  _mutableKernel3DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let z = 0; z < outputZ; z++) {
      const resultY = result[z] = new Array(outputY);
      ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\n`).join('      ') }
      for (let y = 0; y < outputY; y++) {
        const resultX = resultY[y] = new ${constructorString}(outputX);
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('        ') }
      }
    }`;
  }

  _resultMutableKernel3DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z];
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y];
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }
    }`;
  }

  _kernelOutput() {
    if (!this.subKernels) {
      return '\n    return result;';
    }
    return `\n    return {
      result: result,
      ${ this.subKernels.map(subKernel => `${ subKernel.property }: result_${ subKernel.name }`).join(',\n      ') }
    };`;
  }

  _mapSubKernels(fn) {
    return this.subKernels === null ? [''] :
      this.subKernels.map(fn);
  }

  destroy(removeCanvasReference) {
    if (removeCanvasReference) {
      delete this.canvas;
    }
  }

  static destroyContext(context) {}

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, CPUFunctionNode).toJSON();
    return json;
  }

  setOutput(output) {
    super.setOutput(output);
    const [width, height] = this.output;
    if (this.graphical) {
      this._imageData = this.context.createImageData(width, height);
      this._colorData = new Uint8ClampedArray(width * height * 4);
    }
  }

  prependString(value) {
    if (this._kernelString) throw new Error('Kernel already built');
    this._prependedString.push(value);
  }

  hasPrependString(value) {
    return this._prependedString.indexOf(value) > -1;
  }
}

module.exports = {
  CPUKernel
};
},{"../../utils":114,"../function-builder":9,"../kernel":36,"./function-node":6,"./kernel-string":7}],9:[function(require,module,exports){
class FunctionBuilder {
  static fromKernel(kernel, FunctionNode, extraNodeOptions) {
    const {
      kernelArguments,
      kernelConstants,
      argumentNames,
      argumentSizes,
      argumentBitRatios,
      constants,
      constantBitRatios,
      debug,
      loopMaxIterations,
      nativeFunctions,
      output,
      optimizeFloatMemory,
      precision,
      plugins,
      source,
      subKernels,
      functions,
      leadingReturnStatement,
      followingReturnStatement,
      dynamicArguments,
      dynamicOutput,
      onIstanbulCoverageVariable,
      removeIstanbulCoverage,
    } = kernel;

    const argumentTypes = new Array(kernelArguments.length);
    const constantTypes = {};

    for (let i = 0; i < kernelArguments.length; i++) {
      argumentTypes[i] = kernelArguments[i].type;
    }

    for (let i = 0; i < kernelConstants.length; i++) {
      const kernelConstant = kernelConstants[i];
      constantTypes[kernelConstant.name] = kernelConstant.type;
    }

    const needsArgumentType = (functionName, index) => {
      return functionBuilder.needsArgumentType(functionName, index);
    };

    const assignArgumentType = (functionName, index, type) => {
      functionBuilder.assignArgumentType(functionName, index, type);
    };

    const lookupReturnType = (functionName, ast, requestingNode) => {
      return functionBuilder.lookupReturnType(functionName, ast, requestingNode);
    };

    const lookupFunctionArgumentTypes = (functionName) => {
      return functionBuilder.lookupFunctionArgumentTypes(functionName);
    };

    const lookupFunctionArgumentName = (functionName, argumentIndex) => {
      return functionBuilder.lookupFunctionArgumentName(functionName, argumentIndex);
    };

    const lookupFunctionArgumentBitRatio = (functionName, argumentName) => {
      return functionBuilder.lookupFunctionArgumentBitRatio(functionName, argumentName);
    };

    const triggerImplyArgumentType = (functionName, i, argumentType, requestingNode) => {
      functionBuilder.assignArgumentType(functionName, i, argumentType, requestingNode);
    };

    const triggerImplyArgumentBitRatio = (functionName, argumentName, calleeFunctionName, argumentIndex) => {
      functionBuilder.assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex);
    };

    const onFunctionCall = (functionName, calleeFunctionName, args) => {
      functionBuilder.trackFunctionCall(functionName, calleeFunctionName, args);
    };

    const onNestedFunction = (ast, returnType) => {
      const argumentNames = [];
      for (let i = 0; i < ast.params.length; i++) {
        argumentNames.push(ast.params[i].name);
      }
      const nestedFunction = new FunctionNode(null, Object.assign({}, nodeOptions, {
        returnType: null,
        ast,
        name: ast.id.name,
        argumentNames,
        lookupReturnType,
        lookupFunctionArgumentTypes,
        lookupFunctionArgumentName,
        lookupFunctionArgumentBitRatio,
        needsArgumentType,
        assignArgumentType,
        triggerImplyArgumentType,
        triggerImplyArgumentBitRatio,
        onFunctionCall,
      }));
      nestedFunction.traceFunctionAST(ast);
      functionBuilder.addFunctionNode(nestedFunction);
    };

    const nodeOptions = Object.assign({
      isRootKernel: false,
      onNestedFunction,
      lookupReturnType,
      lookupFunctionArgumentTypes,
      lookupFunctionArgumentName,
      lookupFunctionArgumentBitRatio,
      needsArgumentType,
      assignArgumentType,
      triggerImplyArgumentType,
      triggerImplyArgumentBitRatio,
      onFunctionCall,
      onIstanbulCoverageVariable: onIstanbulCoverageVariable ? (name) => onIstanbulCoverageVariable(name, kernel) : null,
      removeIstanbulCoverage,
      optimizeFloatMemory,
      precision,
      constants,
      constantTypes,
      constantBitRatios,
      debug,
      loopMaxIterations,
      output,
      plugins,
      dynamicArguments,
      dynamicOutput,
    }, extraNodeOptions || {});

    const rootNodeOptions = Object.assign({}, nodeOptions, {
      isRootKernel: true,
      name: 'kernel',
      argumentNames,
      argumentTypes,
      argumentSizes,
      argumentBitRatios,
      leadingReturnStatement,
      followingReturnStatement,
    });

    if (typeof source === 'object' && source.functionNodes) {
      return new FunctionBuilder().fromJSON(source.functionNodes, FunctionNode);
    }

    const rootNode = new FunctionNode(source, rootNodeOptions);

    let functionNodes = null;
    if (functions) {
      functionNodes = functions.map((fn) => new FunctionNode(fn.source, {
        returnType: fn.returnType,
        argumentTypes: fn.argumentTypes,
        output,
        plugins,
        constants,
        constantTypes,
        constantBitRatios,
        optimizeFloatMemory,
        precision,
        lookupReturnType,
        lookupFunctionArgumentTypes,
        lookupFunctionArgumentName,
        lookupFunctionArgumentBitRatio,
        needsArgumentType,
        assignArgumentType,
        triggerImplyArgumentType,
        triggerImplyArgumentBitRatio,
        onFunctionCall,
        onNestedFunction,
        onIstanbulCoverageVariable: onIstanbulCoverageVariable ? (name) => onIstanbulCoverageVariable(name, kernel) : null,
        removeIstanbulCoverage,
      }));
    }

    let subKernelNodes = null;
    if (subKernels) {
      subKernelNodes = subKernels.map((subKernel) => {
        const { name, source } = subKernel;
        return new FunctionNode(source, Object.assign({}, nodeOptions, {
          name,
          isSubKernel: true,
          isRootKernel: false,
        }));
      });
    }

    const functionBuilder = new FunctionBuilder({
      kernel,
      rootNode,
      functionNodes,
      nativeFunctions,
      subKernelNodes
    });

    return functionBuilder;
  }

  constructor(settings) {
    settings = settings || {};
    this.kernel = settings.kernel;
    this.rootNode = settings.rootNode;
    this.functionNodes = settings.functionNodes || [];
    this.subKernelNodes = settings.subKernelNodes || [];
    this.nativeFunctions = settings.nativeFunctions || [];
    this.functionMap = {};
    this.nativeFunctionNames = [];
    this.lookupChain = [];
    this.functionNodeDependencies = {};
    this.functionCalls = {};

    if (this.rootNode) {
      this.functionMap['kernel'] = this.rootNode;
    }

    if (this.functionNodes) {
      for (let i = 0; i < this.functionNodes.length; i++) {
        this.functionMap[this.functionNodes[i].name] = this.functionNodes[i];
      }
    }

    if (this.subKernelNodes) {
      for (let i = 0; i < this.subKernelNodes.length; i++) {
        this.functionMap[this.subKernelNodes[i].name] = this.subKernelNodes[i];
      }
    }

    if (this.nativeFunctions) {
      for (let i = 0; i < this.nativeFunctions.length; i++) {
        const nativeFunction = this.nativeFunctions[i];
        this.nativeFunctionNames.push(nativeFunction.name);
      }
    }
  }

  addFunctionNode(functionNode) {
    if (!functionNode.name) throw new Error('functionNode.name needs set');
    this.functionMap[functionNode.name] = functionNode;
    if (functionNode.isRootKernel) {
      this.rootNode = functionNode;
    }
  }

  traceFunctionCalls(functionName, retList) {
    functionName = functionName || 'kernel';
    retList = retList || [];

    if (this.nativeFunctionNames.indexOf(functionName) > -1) {
      if (retList.indexOf(functionName) === -1) {
        retList.push(functionName);
      }
      return retList;
    }

    const functionNode = this.functionMap[functionName];
    if (functionNode) {
      const functionIndex = retList.indexOf(functionName);
      if (functionIndex === -1) {
        retList.push(functionName);
        functionNode.toString(); 
        for (let i = 0; i < functionNode.calledFunctions.length; ++i) {
          this.traceFunctionCalls(functionNode.calledFunctions[i], retList);
        }
      } else {
        const dependantFunctionName = retList.splice(functionIndex, 1)[0];
        retList.push(dependantFunctionName);
      }
    }

    return retList;
  }

  getPrototypeString(functionName) {
    return this.getPrototypes(functionName).join('\n');
  }

  getPrototypes(functionName) {
    if (this.rootNode) {
      this.rootNode.toString();
    }
    if (functionName) {
      return this.getPrototypesFromFunctionNames(this.traceFunctionCalls(functionName, []).reverse());
    }
    return this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));
  }

  getStringFromFunctionNames(functionList) {
    const ret = [];
    for (let i = 0; i < functionList.length; ++i) {
      const node = this.functionMap[functionList[i]];
      if (node) {
        ret.push(this.functionMap[functionList[i]].toString());
      }
    }
    return ret.join('\n');
  }

  getPrototypesFromFunctionNames(functionList) {
    const ret = [];
    for (let i = 0; i < functionList.length; ++i) {
      const functionName = functionList[i];
      const functionIndex = this.nativeFunctionNames.indexOf(functionName);
      if (functionIndex > -1) {
        ret.push(this.nativeFunctions[functionIndex].source);
        continue;
      }
      const node = this.functionMap[functionName];
      if (node) {
        ret.push(node.toString());
      }
    }
    return ret;
  }

  toJSON() {
    return this.traceFunctionCalls(this.rootNode.name).reverse().map(name => {
      const nativeIndex = this.nativeFunctions.indexOf(name);
      if (nativeIndex > -1) {
        return {
          name,
          source: this.nativeFunctions[nativeIndex].source
        };
      } else if (this.functionMap[name]) {
        return this.functionMap[name].toJSON();
      } else {
        throw new Error(`function ${ name } not found`);
      }
    });
  }

  fromJSON(jsonFunctionNodes, FunctionNode) {
    this.functionMap = {};
    for (let i = 0; i < jsonFunctionNodes.length; i++) {
      const jsonFunctionNode = jsonFunctionNodes[i];
      this.functionMap[jsonFunctionNode.settings.name] = new FunctionNode(jsonFunctionNode.ast, jsonFunctionNode.settings);
    }
    return this;
  }

  getString(functionName) {
    if (functionName) {
      return this.getStringFromFunctionNames(this.traceFunctionCalls(functionName).reverse());
    }
    return this.getStringFromFunctionNames(Object.keys(this.functionMap));
  }

  lookupReturnType(functionName, ast, requestingNode) {
    if (ast.type !== 'CallExpression') {
      throw new Error(`expected ast type of "CallExpression", but is ${ ast.type }`);
    }
    if (this._isNativeFunction(functionName)) {
      return this._lookupNativeFunctionReturnType(functionName);
    } else if (this._isFunction(functionName)) {
      const node = this._getFunction(functionName);
      if (node.returnType) {
        return node.returnType;
      } else {
        for (let i = 0; i < this.lookupChain.length; i++) {
          if (this.lookupChain[i].ast === ast) {
            if (node.argumentTypes.length === 0 && ast.arguments.length > 0) {
              const args = ast.arguments;
              for (let j = 0; j < args.length; j++) {
                this.lookupChain.push({
                  name: requestingNode.name,
                  ast: args[i],
                  requestingNode
                });
                node.argumentTypes[j] = requestingNode.getType(args[j]);
                this.lookupChain.pop();
              }
              return node.returnType = node.getType(node.getJsAST());
            }

            throw new Error('circlical logic detected!');
          }
        }
        this.lookupChain.push({
          name: requestingNode.name,
          ast,
          requestingNode
        });
        const type = node.getType(node.getJsAST());
        this.lookupChain.pop();
        return node.returnType = type;
      }
    }

    return null;
  }

  _getFunction(functionName) {
    if (!this._isFunction(functionName)) {
      new Error(`Function ${functionName} not found`);
    }
    return this.functionMap[functionName];
  }

  _isFunction(functionName) {
    return Boolean(this.functionMap[functionName]);
  }

  _getNativeFunction(functionName) {
    for (let i = 0; i < this.nativeFunctions.length; i++) {
      if (this.nativeFunctions[i].name === functionName) return this.nativeFunctions[i];
    }
    return null;
  }

  _isNativeFunction(functionName) {
    return Boolean(this._getNativeFunction(functionName));
  }

  _lookupNativeFunctionReturnType(functionName) {
    let nativeFunction = this._getNativeFunction(functionName);
    if (nativeFunction) {
      return nativeFunction.returnType;
    }
    throw new Error(`Native function ${ functionName } not found`);
  }

  lookupFunctionArgumentTypes(functionName) {
    if (this._isNativeFunction(functionName)) {
      return this._getNativeFunction(functionName).argumentTypes;
    } else if (this._isFunction(functionName)) {
      return this._getFunction(functionName).argumentTypes;
    }
    return null;
  }

  lookupFunctionArgumentName(functionName, argumentIndex) {
    return this._getFunction(functionName).argumentNames[argumentIndex];
  }

  lookupFunctionArgumentBitRatio(functionName, argumentName) {
    if (!this._isFunction(functionName)) {
      throw new Error('function not found');
    }
    if (this.rootNode.name === functionName) {
      const i = this.rootNode.argumentNames.indexOf(argumentName);
      if (i !== -1) {
        return this.rootNode.argumentBitRatios[i];
      }
    }
    const node = this._getFunction(functionName);
    const i = node.argumentNames.indexOf(argumentName);
    if (i === -1) {
      throw new Error('argument not found');
    }
    const bitRatio = node.argumentBitRatios[i];
    if (typeof bitRatio !== 'number') {
      throw new Error('argument bit ratio not found');
    }
    return bitRatio;
  }

  needsArgumentType(functionName, i) {
    if (!this._isFunction(functionName)) return false;
    const fnNode = this._getFunction(functionName);
    return !fnNode.argumentTypes[i];
  }

  assignArgumentType(functionName, i, argumentType, requestingNode) {
    if (!this._isFunction(functionName)) return;
    const fnNode = this._getFunction(functionName);
    if (!fnNode.argumentTypes[i]) {
      fnNode.argumentTypes[i] = argumentType;
    }
  }

  assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex) {
    const node = this._getFunction(functionName);
    if (this._isNativeFunction(calleeFunctionName)) return null;
    const calleeNode = this._getFunction(calleeFunctionName);
    const i = node.argumentNames.indexOf(argumentName);
    if (i === -1) {
      throw new Error(`Argument ${argumentName} not found in arguments from function ${functionName}`);
    }
    const bitRatio = node.argumentBitRatios[i];
    if (typeof bitRatio !== 'number') {
      throw new Error(`Bit ratio for argument ${argumentName} not found in function ${functionName}`);
    }
    if (!calleeNode.argumentBitRatios) {
      calleeNode.argumentBitRatios = new Array(calleeNode.argumentNames.length);
    }
    const calleeBitRatio = calleeNode.argumentBitRatios[i];
    if (typeof calleeBitRatio === 'number') {
      if (calleeBitRatio !== bitRatio) {
        throw new Error(`Incompatible bit ratio found at function ${functionName} at argument ${argumentName}`);
      }
      return calleeBitRatio;
    }
    calleeNode.argumentBitRatios[i] = bitRatio;
    return bitRatio;
  }

  trackFunctionCall(functionName, calleeFunctionName, args) {
    if (!this.functionNodeDependencies[functionName]) {
      this.functionNodeDependencies[functionName] = new Set();
      this.functionCalls[functionName] = [];
    }
    this.functionNodeDependencies[functionName].add(calleeFunctionName);
    this.functionCalls[functionName].push(args);
  }

  getKernelResultType() {
    return this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast);
  }

  getSubKernelResultType(index) {
    const subKernelNode = this.subKernelNodes[index];
    let called = false;
    for (let functionCallIndex = 0; functionCallIndex < this.rootNode.functionCalls.length; functionCallIndex++) {
      const functionCall = this.rootNode.functionCalls[functionCallIndex];
      if (functionCall.ast.callee.name === subKernelNode.name) {
        called = true;
      }
    }
    if (!called) {
      throw new Error(`SubKernel ${ subKernelNode.name } never called by kernel`);
    }
    return subKernelNode.returnType || subKernelNode.getType(subKernelNode.getJsAST());
  }

  getReturnTypes() {
    const result = {
      [this.rootNode.name]: this.rootNode.getType(this.rootNode.ast),
    };
    const list = this.traceFunctionCalls(this.rootNode.name);
    for (let i = 0; i < list.length; i++) {
      const functionName = list[i];
      const functionNode = this.functionMap[functionName];
      result[functionName] = functionNode.getType(functionNode.ast);
    }
    return result;
  }
}

module.exports = {
  FunctionBuilder
};
},{}],10:[function(require,module,exports){
const acorn = require('acorn');
const { utils } = require('../utils');
const { FunctionTracer } = require('./function-tracer');

class FunctionNode {
  constructor(source, settings) {
    if (!source && !settings.ast) {
      throw new Error('source parameter is missing');
    }
    settings = settings || {};
    this.source = source;
    this.ast = null;
    this.name = typeof source === 'string' ? settings.isRootKernel ?
      'kernel' :
      (settings.name || utils.getFunctionNameFromString(source)) : null;
    this.calledFunctions = [];
    this.constants = {};
    this.constantTypes = {};
    this.constantBitRatios = {};
    this.isRootKernel = false;
    this.isSubKernel = false;
    this.debug = null;
    this.functions = null;
    this.identifiers = null;
    this.contexts = null;
    this.functionCalls = null;
    this.states = [];
    this.needsArgumentType = null;
    this.assignArgumentType = null;
    this.lookupReturnType = null;
    this.lookupFunctionArgumentTypes = null;
    this.lookupFunctionArgumentBitRatio = null;
    this.triggerImplyArgumentType = null;
    this.triggerImplyArgumentBitRatio = null;
    this.onNestedFunction = null;
    this.onFunctionCall = null;
    this.optimizeFloatMemory = null;
    this.precision = null;
    this.loopMaxIterations = null;
    this.argumentNames = (typeof this.source === 'string' ? utils.getArgumentNamesFromString(this.source) : null);
    this.argumentTypes = [];
    this.argumentSizes = [];
    this.argumentBitRatios = null;
    this.returnType = null;
    this.output = [];
    this.plugins = null;
    this.leadingReturnStatement = null;
    this.followingReturnStatement = null;
    this.dynamicOutput = null;
    this.dynamicArguments = null;
    this.strictTypingChecking = false;
    this.fixIntegerDivisionAccuracy = null;
    this.onIstanbulCoverageVariable = null;
    this.removeIstanbulCoverage = false;

    if (settings) {
      for (const p in settings) {
        if (!settings.hasOwnProperty(p)) continue;
        if (!this.hasOwnProperty(p)) continue;
        this[p] = settings[p];
      }
    }

    this.literalTypes = {};

    this.validate();
    this._string = null;
    this._internalVariableNames = {};
  }

  validate() {
    if (typeof this.source !== 'string' && !this.ast) {
      throw new Error('this.source not a string');
    }

    if (!this.ast && !utils.isFunctionString(this.source)) {
      throw new Error('this.source not a function string');
    }

    if (!this.name) {
      throw new Error('this.name could not be set');
    }

    if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length) {
      throw new Error(`argumentTypes count of ${ this.argumentTypes.length } exceeds ${ this.argumentNames.length }`);
    }

    if (this.output.length < 1) {
      throw new Error('this.output is not big enough');
    }
  }

  isIdentifierConstant(name) {
    if (!this.constants) return false;
    return this.constants.hasOwnProperty(name);
  }

  isInput(argumentName) {
    return this.argumentTypes[this.argumentNames.indexOf(argumentName)] === 'Input';
  }

  pushState(state) {
    this.states.push(state);
  }

  popState(state) {
    if (this.state !== state) {
      throw new Error(`Cannot popState ${ state } when in ${ this.state }`);
    }
    this.states.pop();
  }

  isState(state) {
    return this.state === state;
  }

  get state() {
    return this.states[this.states.length - 1];
  }

  astMemberExpressionUnroll(ast) {
    if (ast.type === 'Identifier') {
      return ast.name;
    } else if (ast.type === 'ThisExpression') {
      return 'this';
    }

    if (ast.type === 'MemberExpression') {
      if (ast.object && ast.property) {
        if (ast.object.hasOwnProperty('name') && ast.object.name[0] === '_') {
          return this.astMemberExpressionUnroll(ast.property);
        }

        return (
          this.astMemberExpressionUnroll(ast.object) +
          '.' +
          this.astMemberExpressionUnroll(ast.property)
        );
      }
    }

    if (ast.hasOwnProperty('expressions')) {
      const firstExpression = ast.expressions[0];
      if (firstExpression.type === 'Literal' && firstExpression.value === 0 && ast.expressions.length === 2) {
        return this.astMemberExpressionUnroll(ast.expressions[1]);
      }
    }

    throw this.astErrorOutput('Unknown astMemberExpressionUnroll', ast);
  }

  getJsAST(inParser) {
    if (this.ast) {
      return this.ast;
    }
    if (typeof this.source === 'object') {
      this.traceFunctionAST(this.source);
      return this.ast = this.source;
    }

    inParser = inParser || acorn;
    if (inParser === null) {
      throw new Error('Missing JS to AST parser');
    }

    const ast = Object.freeze(inParser.parse(`const parser_${ this.name } = ${ this.source };`, {
      locations: true
    }));
    const functionAST = ast.body[0].declarations[0].init;
    this.traceFunctionAST(functionAST);

    if (!ast) {
      throw new Error('Failed to parse JS code');
    }

    return this.ast = functionAST;
  }

  traceFunctionAST(ast) {
    const { contexts, declarations, functions, identifiers, functionCalls } = new FunctionTracer(ast);
    this.contexts = contexts;
    this.identifiers = identifiers;
    this.functionCalls = functionCalls;
    this.functions = functions;
    for (let i = 0; i < declarations.length; i++) {
      const declaration = declarations[i];
      const { ast, inForLoopInit, inForLoopTest } = declaration;
      const { init } = ast;
      const dependencies = this.getDependencies(init);
      let valueType = null;

      if (inForLoopInit && inForLoopTest) {
        valueType = 'Integer';
      } else {
        if (init) {
          const realType = this.getType(init);
          switch (realType) {
            case 'Integer':
            case 'Float':
            case 'Number':
              if (init.type === 'MemberExpression') {
                valueType = realType;
              } else {
                valueType = 'Number';
              }
              break;
            case 'LiteralInteger':
              valueType = 'Number';
              break;
            default:
              valueType = realType;
          }
        }
      }
      declaration.valueType = valueType;
      declaration.dependencies = dependencies;
      declaration.isSafe = this.isSafeDependencies(dependencies);
    }

    for (let i = 0; i < functions.length; i++) {
      this.onNestedFunction(functions[i]);
    }
  }

  getDeclaration(ast) {
    for (let i = 0; i < this.identifiers.length; i++) {
      const identifier = this.identifiers[i];
      if (ast === identifier.ast) {
        return identifier.declaration;
      }
    }
    return null;
  }

  getVariableType(ast) {
    if (ast.type !== 'Identifier') {
      throw new Error(`ast of ${ast.type} not "Identifier"`);
    }
    let type = null;
    const argumentIndex = this.argumentNames.indexOf(ast.name);
    if (argumentIndex === -1) {
      const declaration = this.getDeclaration(ast);
      if (declaration) {
        return declaration.valueType;
      }
    } else {
      const argumentType = this.argumentTypes[argumentIndex];
      if (argumentType) {
        type = argumentType;
      }
    }
    if (!type && this.strictTypingChecking) {
      throw new Error(`Declaration of ${name} not found`);
    }
    return type;
  }

  getLookupType(type) {
    if (!typeLookupMap.hasOwnProperty(type)) {
      throw new Error(`unknown typeLookupMap ${ type }`);
    }
    return typeLookupMap[type];
  }

  getConstantType(constantName) {
    if (this.constantTypes[constantName]) {
      const type = this.constantTypes[constantName];
      if (type === 'Float') {
        return 'Number';
      } else {
        return type;
      }
    }
    throw new Error(`Type for constant "${ constantName }" not declared`);
  }

  toString() {
    if (this._string) return this._string;
    return this._string = this.astGeneric(this.getJsAST(), []).join('').trim();
  }

  toJSON() {
    const settings = {
      source: this.source,
      name: this.name,
      constants: this.constants,
      constantTypes: this.constantTypes,
      isRootKernel: this.isRootKernel,
      isSubKernel: this.isSubKernel,
      debug: this.debug,
      output: this.output,
      loopMaxIterations: this.loopMaxIterations,
      argumentNames: this.argumentNames,
      argumentTypes: this.argumentTypes,
      argumentSizes: this.argumentSizes,
      returnType: this.returnType,
      leadingReturnStatement: this.leadingReturnStatement,
      followingReturnStatement: this.followingReturnStatement,
    };

    return {
      ast: this.ast,
      settings
    };
  }

  getType(ast) {
    if (Array.isArray(ast)) {
      return this.getType(ast[ast.length - 1]);
    }
    switch (ast.type) {
      case 'BlockStatement':
        return this.getType(ast.body);
      case 'ArrayExpression':
        return `Array(${ ast.elements.length })`;
      case 'Literal':
        const literalKey = this.astKey(ast);
        if (this.literalTypes[literalKey]) {
          return this.literalTypes[literalKey];
        }
        if (Number.isInteger(ast.value)) {
          return 'LiteralInteger';
        } else if (ast.value === true || ast.value === false) {
          return 'Boolean';
        } else {
          return 'Number';
        }
        case 'AssignmentExpression':
          return this.getType(ast.left);
        case 'CallExpression':
          if (this.isAstMathFunction(ast)) {
            return 'Number';
          }
          if (!ast.callee || !ast.callee.name) {
            if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[ast.callee.expressions.length - 1].property.name) {
              const functionName = ast.callee.expressions[ast.callee.expressions.length - 1].property.name;
              this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
              return this.lookupReturnType(functionName, ast, this);
            }
            if (this.getVariableSignature(ast.callee, true) === 'this.color') {
              return null;
            }
            throw this.astErrorOutput('Unknown call expression', ast);
          }
          if (ast.callee && ast.callee.name) {
            const functionName = ast.callee.name;
            this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
            return this.lookupReturnType(functionName, ast, this);
          }
          throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
        case 'LogicalExpression':
          return 'Boolean';
        case 'BinaryExpression':
          switch (ast.operator) {
            case '%':
            case '/':
              if (this.fixIntegerDivisionAccuracy) {
                return 'Number';
              } else {
                break;
              }
              case '>':
              case '<':
                return 'Boolean';
              case '&':
              case '|':
              case '^':
              case '<<':
              case '>>':
              case '>>>':
                return 'Integer';
          }
          const type = this.getType(ast.left);
          if (this.isState('skip-literal-correction')) return type;
          if (type === 'LiteralInteger') {
            const rightType = this.getType(ast.right);
            if (rightType === 'LiteralInteger') {
              if (ast.left.value % 1 === 0) {
                return 'Integer';
              } else {
                return 'Float';
              }
            }
            return rightType;
          }
          return typeLookupMap[type] || type;
        case 'UpdateExpression':
          return this.getType(ast.argument);
        case 'UnaryExpression':
          if (ast.operator === '~') {
            return 'Integer';
          }
          return this.getType(ast.argument);
        case 'VariableDeclaration': {
          const declarations = ast.declarations;
          let lastType;
          for (let i = 0; i < declarations.length; i++) {
            const declaration = declarations[i];
            lastType = this.getType(declaration);
          }
          if (!lastType) {
            throw this.astErrorOutput(`Unable to find type for declaration`, ast);
          }
          return lastType;
        }
        case 'VariableDeclarator':
          const declaration = this.getDeclaration(ast.id);
          if (!declaration) {
            throw this.astErrorOutput(`Unable to find declarator`, ast);
          }

          if (!declaration.valueType) {
            throw this.astErrorOutput(`Unable to find declarator valueType`, ast);
          }

          return declaration.valueType;
        case 'Identifier':
          if (ast.name === 'Infinity') {
            return 'Number';
          }
          if (this.isAstVariable(ast)) {
            const signature = this.getVariableSignature(ast);
            if (signature === 'value') {
              return this.getCheckVariableType(ast);
            }
          }
          const origin = this.findIdentifierOrigin(ast);
          if (origin && origin.init) {
            return this.getType(origin.init);
          }
          return null;
        case 'ReturnStatement':
          return this.getType(ast.argument);
        case 'MemberExpression':
          if (this.isAstMathFunction(ast)) {
            switch (ast.property.name) {
              case 'ceil':
                return 'Integer';
              case 'floor':
                return 'Integer';
              case 'round':
                return 'Integer';
            }
            return 'Number';
          }
          if (this.isAstVariable(ast)) {
            const variableSignature = this.getVariableSignature(ast);
            switch (variableSignature) {
              case 'value[]':
                return this.getLookupType(this.getCheckVariableType(ast.object));
              case 'value[][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object));
              case 'value[][][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object.object));
              case 'value[][][][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object.object.object));
              case 'value.thread.value':
              case 'this.thread.value':
                return 'Integer';
              case 'this.output.value':
                return this.dynamicOutput ? 'Integer' : 'LiteralInteger';
              case 'this.constants.value':
                return this.getConstantType(ast.property.name);
              case 'this.constants.value[]':
                return this.getLookupType(this.getConstantType(ast.object.property.name));
              case 'this.constants.value[][]':
                return this.getLookupType(this.getConstantType(ast.object.object.property.name));
              case 'this.constants.value[][][]':
                return this.getLookupType(this.getConstantType(ast.object.object.object.property.name));
              case 'this.constants.value[][][][]':
                return this.getLookupType(this.getConstantType(ast.object.object.object.object.property.name));
              case 'fn()[]':
              case 'fn()[][]':
              case 'fn()[][][]':
                return this.getLookupType(this.getType(ast.object));
              case 'value.value':
                if (this.isAstMathVariable(ast)) {
                  return 'Number';
                }
                switch (ast.property.name) {
                  case 'r':
                  case 'g':
                  case 'b':
                  case 'a':
                    return this.getLookupType(this.getCheckVariableType(ast.object));
                }
                case '[][]':
                  return 'Number';
            }
            throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
          }
          throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
        case 'ConditionalExpression':
          return this.getType(ast.consequent);
        case 'FunctionDeclaration':
        case 'FunctionExpression':
          const lastReturn = this.findLastReturn(ast.body);
          if (lastReturn) {
            return this.getType(lastReturn);
          }
          return null;
        case 'IfStatement':
          return this.getType(ast.consequent);
        case 'SequenceExpression':
          return this.getType(ast.expressions[ast.expressions.length - 1]);
        default:
          throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
    }
  }

  getCheckVariableType(ast) {
    const type = this.getVariableType(ast);
    if (!type) {
      throw this.astErrorOutput(`${ast.type} is not defined`, ast);
    }
    return type;
  }

  inferArgumentTypesIfNeeded(functionName, args) {
    for (let i = 0; i < args.length; i++) {
      if (!this.needsArgumentType(functionName, i)) continue;
      const type = this.getType(args[i]);
      if (!type) {
        throw this.astErrorOutput(`Unable to infer argument ${i}`, args[i]);
      }
      this.assignArgumentType(functionName, i, type);
    }
  }

  isAstMathVariable(ast) {
    const mathProperties = [
      'E',
      'PI',
      'SQRT2',
      'SQRT1_2',
      'LN2',
      'LN10',
      'LOG2E',
      'LOG10E',
    ];
    return ast.type === 'MemberExpression' &&
      ast.object && ast.object.type === 'Identifier' &&
      ast.object.name === 'Math' &&
      ast.property &&
      ast.property.type === 'Identifier' &&
      mathProperties.indexOf(ast.property.name) > -1;
  }

  isAstMathFunction(ast) {
    const mathFunctions = [
      'abs',
      'acos',
      'acosh',
      'asin',
      'asinh',
      'atan',
      'atan2',
      'atanh',
      'cbrt',
      'ceil',
      'clz32',
      'cos',
      'cosh',
      'expm1',
      'exp',
      'floor',
      'fround',
      'imul',
      'log',
      'log2',
      'log10',
      'log1p',
      'max',
      'min',
      'pow',
      'random',
      'round',
      'sign',
      'sin',
      'sinh',
      'sqrt',
      'tan',
      'tanh',
      'trunc',
    ];
    return ast.type === 'CallExpression' &&
      ast.callee &&
      ast.callee.type === 'MemberExpression' &&
      ast.callee.object &&
      ast.callee.object.type === 'Identifier' &&
      ast.callee.object.name === 'Math' &&
      ast.callee.property &&
      ast.callee.property.type === 'Identifier' &&
      mathFunctions.indexOf(ast.callee.property.name) > -1;
  }

  isAstVariable(ast) {
    return ast.type === 'Identifier' || ast.type === 'MemberExpression';
  }

  isSafe(ast) {
    return this.isSafeDependencies(this.getDependencies(ast));
  }

  isSafeDependencies(dependencies) {
    return dependencies && dependencies.every ? dependencies.every(dependency => dependency.isSafe) : true;
  }

  getDependencies(ast, dependencies, isNotSafe) {
    if (!dependencies) {
      dependencies = [];
    }
    if (!ast) return null;
    if (Array.isArray(ast)) {
      for (let i = 0; i < ast.length; i++) {
        this.getDependencies(ast[i], dependencies, isNotSafe);
      }
      return dependencies;
    }
    switch (ast.type) {
      case 'AssignmentExpression':
        this.getDependencies(ast.left, dependencies, isNotSafe);
        this.getDependencies(ast.right, dependencies, isNotSafe);
        return dependencies;
      case 'ConditionalExpression':
        this.getDependencies(ast.test, dependencies, isNotSafe);
        this.getDependencies(ast.alternate, dependencies, isNotSafe);
        this.getDependencies(ast.consequent, dependencies, isNotSafe);
        return dependencies;
      case 'Literal':
        dependencies.push({
          origin: 'literal',
          value: ast.value,
          isSafe: isNotSafe === true ? false : ast.value > -Infinity && ast.value < Infinity && !isNaN(ast.value)
        });
        break;
      case 'VariableDeclarator':
        return this.getDependencies(ast.init, dependencies, isNotSafe);
      case 'Identifier':
        const declaration = this.getDeclaration(ast);
        if (declaration) {
          dependencies.push({
            name: ast.name,
            origin: 'declaration',
            isSafe: isNotSafe ? false : this.isSafeDependencies(declaration.dependencies),
          });
        } else if (this.argumentNames.indexOf(ast.name) > -1) {
          dependencies.push({
            name: ast.name,
            origin: 'argument',
            isSafe: false,
          });
        } else if (this.strictTypingChecking) {
          throw new Error(`Cannot find identifier origin "${ast.name}"`);
        }
        break;
      case 'FunctionDeclaration':
        return this.getDependencies(ast.body.body[ast.body.body.length - 1], dependencies, isNotSafe);
      case 'ReturnStatement':
        return this.getDependencies(ast.argument, dependencies);
      case 'BinaryExpression':
      case 'LogicalExpression':
        isNotSafe = (ast.operator === '/' || ast.operator === '*');
        this.getDependencies(ast.left, dependencies, isNotSafe);
        this.getDependencies(ast.right, dependencies, isNotSafe);
        return dependencies;
      case 'UnaryExpression':
      case 'UpdateExpression':
        return this.getDependencies(ast.argument, dependencies, isNotSafe);
      case 'VariableDeclaration':
        return this.getDependencies(ast.declarations, dependencies, isNotSafe);
      case 'ArrayExpression':
        dependencies.push({
          origin: 'declaration',
          isSafe: true,
        });
        return dependencies;
      case 'CallExpression':
        dependencies.push({
          origin: 'function',
          isSafe: true,
        });
        return dependencies;
      case 'MemberExpression':
        const details = this.getMemberExpressionDetails(ast);
        switch (details.signature) {
          case 'value[]':
            this.getDependencies(ast.object, dependencies, isNotSafe);
            break;
          case 'value[][]':
            this.getDependencies(ast.object.object, dependencies, isNotSafe);
            break;
          case 'value[][][]':
            this.getDependencies(ast.object.object.object, dependencies, isNotSafe);
            break;
          case 'this.output.value':
            if (this.dynamicOutput) {
              dependencies.push({
                name: details.name,
                origin: 'output',
                isSafe: false,
              });
            }
            break;
        }
        if (details) {
          if (details.property) {
            this.getDependencies(details.property, dependencies, isNotSafe);
          }
          if (details.xProperty) {
            this.getDependencies(details.xProperty, dependencies, isNotSafe);
          }
          if (details.yProperty) {
            this.getDependencies(details.yProperty, dependencies, isNotSafe);
          }
          if (details.zProperty) {
            this.getDependencies(details.zProperty, dependencies, isNotSafe);
          }
          return dependencies;
        }
        case 'SequenceExpression':
          return this.getDependencies(ast.expressions, dependencies, isNotSafe);
        default:
          throw this.astErrorOutput(`Unhandled type ${ ast.type } in getDependencies`, ast);
    }
    return dependencies;
  }

  getVariableSignature(ast, returnRawValue) {
    if (!this.isAstVariable(ast)) {
      throw new Error(`ast of type "${ ast.type }" is not a variable signature`);
    }
    if (ast.type === 'Identifier') {
      return 'value';
    }
    const signature = [];
    while (true) {
      if (!ast) break;
      if (ast.computed) {
        signature.push('[]');
      } else if (ast.type === 'ThisExpression') {
        signature.unshift('this');
      } else if (ast.property && ast.property.name) {
        if (
          ast.property.name === 'x' ||
          ast.property.name === 'y' ||
          ast.property.name === 'z'
        ) {
          signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');
        } else if (
          ast.property.name === 'constants' ||
          ast.property.name === 'thread' ||
          ast.property.name === 'output'
        ) {
          signature.unshift('.' + ast.property.name);
        } else {
          signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');
        }
      } else if (ast.name) {
        signature.unshift(returnRawValue ? ast.name : 'value');
      } else if (ast.callee && ast.callee.name) {
        signature.unshift(returnRawValue ? ast.callee.name + '()' : 'fn()');
      } else if (ast.elements) {
        signature.unshift('[]');
      } else {
        signature.unshift('unknown');
      }
      ast = ast.object;
    }

    const signatureString = signature.join('');
    if (returnRawValue) {
      return signatureString;
    }

    const allowedExpressions = [
      'value',
      'value[]',
      'value[][]',
      'value[][][]',
      'value[][][][]',
      'value.value',
      'value.value[]', 
      'value.value[][]', 
      'value.thread.value',
      'this.thread.value',
      'this.output.value',
      'this.constants.value',
      'this.constants.value[]',
      'this.constants.value[][]',
      'this.constants.value[][][]',
      'this.constants.value[][][][]',
      'fn()[]',
      'fn()[][]',
      'fn()[][][]',
      '[][]',
    ];
    if (allowedExpressions.indexOf(signatureString) > -1) {
      return signatureString;
    }
    return null;
  }

  build() {
    return this.toString().length > 0;
  }

  astGeneric(ast, retArr) {
    if (ast === null) {
      throw this.astErrorOutput('NULL ast', ast);
    } else {
      if (Array.isArray(ast)) {
        for (let i = 0; i < ast.length; i++) {
          this.astGeneric(ast[i], retArr);
        }
        return retArr;
      }

      switch (ast.type) {
        case 'FunctionDeclaration':
          return this.astFunctionDeclaration(ast, retArr);
        case 'FunctionExpression':
          return this.astFunctionExpression(ast, retArr);
        case 'ReturnStatement':
          return this.astReturnStatement(ast, retArr);
        case 'Literal':
          return this.astLiteral(ast, retArr);
        case 'BinaryExpression':
          return this.astBinaryExpression(ast, retArr);
        case 'Identifier':
          return this.astIdentifierExpression(ast, retArr);
        case 'AssignmentExpression':
          return this.astAssignmentExpression(ast, retArr);
        case 'ExpressionStatement':
          return this.astExpressionStatement(ast, retArr);
        case 'EmptyStatement':
          return this.astEmptyStatement(ast, retArr);
        case 'BlockStatement':
          return this.astBlockStatement(ast, retArr);
        case 'IfStatement':
          return this.astIfStatement(ast, retArr);
        case 'SwitchStatement':
          return this.astSwitchStatement(ast, retArr);
        case 'BreakStatement':
          return this.astBreakStatement(ast, retArr);
        case 'ContinueStatement':
          return this.astContinueStatement(ast, retArr);
        case 'ForStatement':
          return this.astForStatement(ast, retArr);
        case 'WhileStatement':
          return this.astWhileStatement(ast, retArr);
        case 'DoWhileStatement':
          return this.astDoWhileStatement(ast, retArr);
        case 'VariableDeclaration':
          return this.astVariableDeclaration(ast, retArr);
        case 'VariableDeclarator':
          return this.astVariableDeclarator(ast, retArr);
        case 'ThisExpression':
          return this.astThisExpression(ast, retArr);
        case 'SequenceExpression':
          return this.astSequenceExpression(ast, retArr);
        case 'UnaryExpression':
          return this.astUnaryExpression(ast, retArr);
        case 'UpdateExpression':
          return this.astUpdateExpression(ast, retArr);
        case 'LogicalExpression':
          return this.astLogicalExpression(ast, retArr);
        case 'MemberExpression':
          return this.astMemberExpression(ast, retArr);
        case 'CallExpression':
          return this.astCallExpression(ast, retArr);
        case 'ArrayExpression':
          return this.astArrayExpression(ast, retArr);
        case 'DebuggerStatement':
          return this.astDebuggerStatement(ast, retArr);
        case 'ConditionalExpression':
          return this.astConditionalExpression(ast, retArr);
      }

      throw this.astErrorOutput('Unknown ast type : ' + ast.type, ast);
    }
  }
  astErrorOutput(error, ast) {
    if (typeof this.source !== 'string') {
      return new Error(error);
    }

    const debugString = utils.getAstString(this.source, ast);
    const leadingSource = this.source.substr(ast.start);
    const splitLines = leadingSource.split(/\n/);
    const lineBefore = splitLines.length > 0 ? splitLines[splitLines.length - 1] : 0;
    return new Error(`${error} on line ${ splitLines.length }, position ${ lineBefore.length }:\n ${ debugString }`);
  }

  astDebuggerStatement(arrNode, retArr) {
    return retArr;
  }

  astConditionalExpression(ast, retArr) {
    if (ast.type !== 'ConditionalExpression') {
      throw this.astErrorOutput('Not a conditional expression', ast);
    }
    retArr.push('(');
    this.astGeneric(ast.test, retArr);
    retArr.push('?');
    this.astGeneric(ast.consequent, retArr);
    retArr.push(':');
    this.astGeneric(ast.alternate, retArr);
    retArr.push(')');
    return retArr;
  }

  astFunction(ast, retArr) {
    throw new Error(`"astFunction" not defined on ${ this.constructor.name }`);
  }

  astFunctionDeclaration(ast, retArr) {
    if (this.isChildFunction(ast)) {
      return retArr;
    }
    return this.astFunction(ast, retArr);
  }
  astFunctionExpression(ast, retArr) {
    if (this.isChildFunction(ast)) {
      return retArr;
    }
    return this.astFunction(ast, retArr);
  }
  isChildFunction(ast) {
    for (let i = 0; i < this.functions.length; i++) {
      if (this.functions[i] === ast) {
        return true;
      }
    }
    return false;
  }
  astReturnStatement(ast, retArr) {
    return retArr;
  }
  astLiteral(ast, retArr) {
    this.literalTypes[this.astKey(ast)] = 'Number';
    return retArr;
  }
  astBinaryExpression(ast, retArr) {
    return retArr;
  }
  astIdentifierExpression(ast, retArr) {
    return retArr;
  }
  astAssignmentExpression(ast, retArr) {
    return retArr;
  }
  astExpressionStatement(esNode, retArr) {
    this.astGeneric(esNode.expression, retArr);
    retArr.push(';');
    return retArr;
  }
  astEmptyStatement(eNode, retArr) {
    return retArr;
  }
  astBlockStatement(ast, retArr) {
    return retArr;
  }
  astIfStatement(ast, retArr) {
    return retArr;
  }
  astSwitchStatement(ast, retArr) {
    return retArr;
  }
  astBreakStatement(brNode, retArr) {
    retArr.push('break;');
    return retArr;
  }
  astContinueStatement(crNode, retArr) {
    retArr.push('continue;\n');
    return retArr;
  }
  astForStatement(ast, retArr) {
    return retArr;
  }
  astWhileStatement(ast, retArr) {
    return retArr;
  }
  astDoWhileStatement(ast, retArr) {
    return retArr;
  }
  astVariableDeclarator(iVarDecNode, retArr) {
    this.astGeneric(iVarDecNode.id, retArr);
    if (iVarDecNode.init !== null) {
      retArr.push('=');
      this.astGeneric(iVarDecNode.init, retArr);
    }
    return retArr;
  }
  astThisExpression(ast, retArr) {
    return retArr;
  }
  isIstanbulAST(ast) {
    const variableSignature = this.getVariableSignature(ast);
    return variableSignature === 'value.value[]' || variableSignature === 'value.value[][]';
  }
  astSequenceExpression(sNode, retArr) {
    const { expressions } = sNode;
    const sequenceResult = [];
    for (let i = 0; i < expressions.length; i++) {
      const expression = expressions[i];
      if (this.removeIstanbulCoverage) {
        if (expression.type === 'UpdateExpression' && this.isIstanbulAST(expression.argument)) {
          continue;
        }
      }
      const expressionResult = [];
      this.astGeneric(expression, expressionResult);
      sequenceResult.push(expressionResult.join(''));
    }
    if (sequenceResult.length > 1) {
      retArr.push('(', sequenceResult.join(','), ')');
    } else {
      retArr.push(sequenceResult[0]);
    }
    return retArr;
  }
  astUnaryExpression(uNode, retArr) {
    const unaryResult = this.checkAndUpconvertBitwiseUnary(uNode, retArr);
    if (unaryResult) {
      return retArr;
    }

    if (uNode.prefix) {
      retArr.push(uNode.operator);
      this.astGeneric(uNode.argument, retArr);
    } else {
      this.astGeneric(uNode.argument, retArr);
      retArr.push(uNode.operator);
    }

    return retArr;
  }

  checkAndUpconvertBitwiseUnary(uNode, retArr) {}

  astUpdateExpression(uNode, retArr) {
    if (this.removeIstanbulCoverage) {
      const signature = this.getVariableSignature(uNode.argument);
      if (this.isIstanbulAST(uNode.argument)) {
        return retArr;
      }
    }
    if (uNode.prefix) {
      retArr.push(uNode.operator);
      this.astGeneric(uNode.argument, retArr);
    } else {
      this.astGeneric(uNode.argument, retArr);
      retArr.push(uNode.operator);
    }

    return retArr;
  }
  astLogicalExpression(logNode, retArr) {
    retArr.push('(');
    this.astGeneric(logNode.left, retArr);
    retArr.push(logNode.operator);
    this.astGeneric(logNode.right, retArr);
    retArr.push(')');
    return retArr;
  }
  astMemberExpression(ast, retArr) {
    return retArr;
  }
  astCallExpression(ast, retArr) {
    return retArr;
  }
  astArrayExpression(ast, retArr) {
    return retArr;
  }

  getMemberExpressionDetails(ast) {
    if (ast.type !== 'MemberExpression') {
      throw this.astErrorOutput(`Expression ${ ast.type } not a MemberExpression`, ast);
    }
    let name = null;
    let type = null;
    const variableSignature = this.getVariableSignature(ast);
    switch (variableSignature) {
      case 'value':
        return null;
      case 'value.thread.value':
      case 'this.thread.value':
      case 'this.output.value':
        return {
          signature: variableSignature,
            type: 'Integer',
            name: ast.property.name
        };
      case 'value[]':
        if (typeof ast.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object),
            xProperty: ast.property
        };
      case 'value[][]':
        if (typeof ast.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object),
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value[][][]':
        if (typeof ast.object.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object.object),
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value[][][][]':
        if (typeof ast.object.object.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object.object.object),
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value.value':
        if (typeof ast.property.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        if (this.isAstMathVariable(ast)) {
          name = ast.property.name;
          return {
            name,
            origin: 'Math',
            type: 'Number',
            signature: variableSignature,
          };
        }
        switch (ast.property.name) {
          case 'r':
          case 'g':
          case 'b':
          case 'a':
            name = ast.object.name;
            return {
              name,
              property: ast.property.name,
                origin: 'user',
                signature: variableSignature,
                type: 'Number'
            };
          default:
            throw this.astErrorOutput('Unexpected expression', ast);
        }
        case 'this.constants.value':
          if (typeof ast.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
              signature: variableSignature,
          };
        case 'this.constants.value[]':
          if (typeof ast.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
              signature: variableSignature,
              xProperty: ast.property,
          };
        case 'this.constants.value[][]': {
          if (typeof ast.object.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
            signature: variableSignature,
            yProperty: ast.object.property,
            xProperty: ast.property,
          };
        }
        case 'this.constants.value[][][]': {
          if (typeof ast.object.object.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.object.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
            signature: variableSignature,
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
          };
        }
        case 'fn()[]':
        case '[][]':
          return {
            signature: variableSignature,
              property: ast.property,
          };
        case 'value.value[]': 
          if (this.removeIstanbulCoverage) {
            return { signature: variableSignature };
          }
          if (this.onIstanbulCoverageVariable) {
            this.onIstanbulCoverageVariable(ast.object.object.name);
            return {
              signature: variableSignature
            };
          }
          case 'value.value[][]': 
            if (this.removeIstanbulCoverage) {
              return { signature: variableSignature };
            }
            if (this.onIstanbulCoverageVariable) {
              this.onIstanbulCoverageVariable(ast.object.object.object.name);
              return {
                signature: variableSignature
              };
            }
            default:
              throw this.astErrorOutput('Unexpected expression', ast);
    }
  }

  findIdentifierOrigin(astToFind) {
    const stack = [this.ast];

    while (stack.length > 0) {
      const atNode = stack[0];
      if (atNode.type === 'VariableDeclarator' && atNode.id && atNode.id.name && atNode.id.name === astToFind.name) {
        return atNode;
      }
      stack.shift();
      if (atNode.argument) {
        stack.push(atNode.argument);
      } else if (atNode.body) {
        stack.push(atNode.body);
      } else if (atNode.declarations) {
        stack.push(atNode.declarations);
      } else if (Array.isArray(atNode)) {
        for (let i = 0; i < atNode.length; i++) {
          stack.push(atNode[i]);
        }
      }
    }
    return null;
  }

  findLastReturn(ast) {
    const stack = [ast || this.ast];

    while (stack.length > 0) {
      const atNode = stack.pop();
      if (atNode.type === 'ReturnStatement') {
        return atNode;
      }
      if (atNode.type === 'FunctionDeclaration') {
        continue;
      }
      if (atNode.argument) {
        stack.push(atNode.argument);
      } else if (atNode.body) {
        stack.push(atNode.body);
      } else if (atNode.declarations) {
        stack.push(atNode.declarations);
      } else if (Array.isArray(atNode)) {
        for (let i = 0; i < atNode.length; i++) {
          stack.push(atNode[i]);
        }
      } else if (atNode.consequent) {
        stack.push(atNode.consequent);
      } else if (atNode.cases) {
        stack.push(atNode.cases);
      }
    }
    return null;
  }

  getInternalVariableName(name) {
    if (!this._internalVariableNames.hasOwnProperty(name)) {
      this._internalVariableNames[name] = 0;
    }
    this._internalVariableNames[name]++;
    if (this._internalVariableNames[name] === 1) {
      return name;
    }
    return name + this._internalVariableNames[name];
  }

  astKey(ast, separator = ',') {
    if (!ast.start || !ast.end) throw new Error('AST start and end needed');
    return `${ast.start}${separator}${ast.end}`;
  }
}

const typeLookupMap = {
  'Number': 'Number',
  'Float': 'Float',
  'Integer': 'Integer',
  'Array': 'Number',
  'Array(2)': 'Number',
  'Array(3)': 'Number',
  'Array(4)': 'Number',
  'Array2D': 'Number',
  'Array3D': 'Number',
  'Input': 'Number',
  'HTMLCanvas': 'Array(4)',
  'HTMLImage': 'Array(4)',
  'HTMLVideo': 'Array(4)',
  'HTMLImageArray': 'Array(4)',
  'NumberTexture': 'Number',
  'MemoryOptimizedNumberTexture': 'Number',
  'Array1D(2)': 'Array(2)',
  'Array1D(3)': 'Array(3)',
  'Array1D(4)': 'Array(4)',
  'Array2D(2)': 'Array(2)',
  'Array2D(3)': 'Array(3)',
  'Array2D(4)': 'Array(4)',
  'Array3D(2)': 'Array(2)',
  'Array3D(3)': 'Array(3)',
  'Array3D(4)': 'Array(4)',
  'ArrayTexture(1)': 'Number',
  'ArrayTexture(2)': 'Array(2)',
  'ArrayTexture(3)': 'Array(3)',
  'ArrayTexture(4)': 'Array(4)',
};

module.exports = {
  FunctionNode
};
},{"../utils":114,"./function-tracer":11,"acorn":1}],11:[function(require,module,exports){
const { utils } = require('../utils');

function last(array) {
  return array.length > 0 ? array[array.length - 1] : null;
}

const states = {
  trackIdentifiers: 'trackIdentifiers',
  memberExpression: 'memberExpression',
  inForLoopInit: 'inForLoopInit'
};

class FunctionTracer {
  constructor(ast) {
    this.runningContexts = [];
    this.functionContexts = [];
    this.contexts = [];
    this.functionCalls = [];
    this.declarations = [];
    this.identifiers = [];
    this.functions = [];
    this.returnStatements = [];
    this.trackedIdentifiers = null;
    this.states = [];
    this.newFunctionContext();
    this.scan(ast);
  }

  isState(state) {
    return this.states[this.states.length - 1] === state;
  }

  hasState(state) {
    return this.states.indexOf(state) > -1;
  }

  pushState(state) {
    this.states.push(state);
  }

  popState(state) {
    if (this.isState(state)) {
      this.states.pop();
    } else {
      throw new Error(`Cannot pop the non-active state "${state}"`);
    }
  }

  get currentFunctionContext() {
    return last(this.functionContexts);
  }

  get currentContext() {
    return last(this.runningContexts);
  }

  newFunctionContext() {
    const newContext = { '@contextType': 'function' };
    this.contexts.push(newContext);
    this.functionContexts.push(newContext);
  }

  newContext(run) {
    const newContext = Object.assign({ '@contextType': 'const/let' }, this.currentContext);
    this.contexts.push(newContext);
    this.runningContexts.push(newContext);
    run();
    const { currentFunctionContext } = this;
    for (const p in currentFunctionContext) {
      if (!currentFunctionContext.hasOwnProperty(p) || newContext.hasOwnProperty(p)) continue;
      newContext[p] = currentFunctionContext[p];
    }
    this.runningContexts.pop();
    return newContext;
  }

  useFunctionContext(run) {
    const functionContext = last(this.functionContexts);
    this.runningContexts.push(functionContext);
    run();
    this.runningContexts.pop();
  }

  getIdentifiers(run) {
    const trackedIdentifiers = this.trackedIdentifiers = [];
    this.pushState(states.trackIdentifiers);
    run();
    this.trackedIdentifiers = null;
    this.popState(states.trackIdentifiers);
    return trackedIdentifiers;
  }

  getDeclaration(name) {
    const { currentContext, currentFunctionContext, runningContexts } = this;
    const declaration = currentContext[name] || currentFunctionContext[name] || null;

    if (
      !declaration &&
      currentContext === currentFunctionContext &&
      runningContexts.length > 0
    ) {
      const previousRunningContext = runningContexts[runningContexts.length - 2];
      if (previousRunningContext[name]) {
        return previousRunningContext[name];
      }
    }

    return declaration;
  }

  scan(ast) {
    if (!ast) return;
    if (Array.isArray(ast)) {
      for (let i = 0; i < ast.length; i++) {
        this.scan(ast[i]);
      }
      return;
    }
    switch (ast.type) {
      case 'Program':
        this.useFunctionContext(() => {
          this.scan(ast.body);
        });
        break;
      case 'BlockStatement':
        this.newContext(() => {
          this.scan(ast.body);
        });
        break;
      case 'AssignmentExpression':
      case 'LogicalExpression':
        this.scan(ast.left);
        this.scan(ast.right);
        break;
      case 'BinaryExpression':
        this.scan(ast.left);
        this.scan(ast.right);
        break;
      case 'UpdateExpression':
        if (ast.operator === '++') {
          const declaration = this.getDeclaration(ast.argument.name);
          if (declaration) {
            declaration.suggestedType = 'Integer';
          }
        }
        this.scan(ast.argument);
        break;
      case 'UnaryExpression':
        this.scan(ast.argument);
        break;
      case 'VariableDeclaration':
        if (ast.kind === 'var') {
          this.useFunctionContext(() => {
            ast.declarations = utils.normalizeDeclarations(ast);
            this.scan(ast.declarations);
          });
        } else {
          ast.declarations = utils.normalizeDeclarations(ast);
          this.scan(ast.declarations);
        }
        break;
      case 'VariableDeclarator': {
        const { currentContext } = this;
        const inForLoopInit = this.hasState(states.inForLoopInit);
        const declaration = {
          ast: ast,
          context: currentContext,
          name: ast.id.name,
          origin: 'declaration',
          inForLoopInit,
          inForLoopTest: null,
          assignable: currentContext === this.currentFunctionContext || (!inForLoopInit && !currentContext.hasOwnProperty(ast.id.name)),
          suggestedType: null,
          valueType: null,
          dependencies: null,
          isSafe: null,
        };
        if (!currentContext[ast.id.name]) {
          currentContext[ast.id.name] = declaration;
        }
        this.declarations.push(declaration);
        this.scan(ast.id);
        this.scan(ast.init);
        break;
      }
      case 'FunctionExpression':
      case 'FunctionDeclaration':
        if (this.runningContexts.length === 0) {
          this.scan(ast.body);
        } else {
          this.functions.push(ast);
        }
        break;
      case 'IfStatement':
        this.scan(ast.test);
        this.scan(ast.consequent);
        if (ast.alternate) this.scan(ast.alternate);
        break;
      case 'ForStatement': {
        let testIdentifiers;
        const context = this.newContext(() => {
          this.pushState(states.inForLoopInit);
          this.scan(ast.init);
          this.popState(states.inForLoopInit);

          testIdentifiers = this.getIdentifiers(() => {
            this.scan(ast.test);
          });

          this.scan(ast.update);
          this.newContext(() => {
            this.scan(ast.body);
          });
        });

        if (testIdentifiers) {
          for (const p in context) {
            if (p === '@contextType') continue;
            if (testIdentifiers.indexOf(p) > -1) {
              context[p].inForLoopTest = true;
            }
          }
        }
        break;
      }
      case 'DoWhileStatement':
      case 'WhileStatement':
        this.newContext(() => {
          this.scan(ast.body);
          this.scan(ast.test);
        });
        break;
      case 'Identifier': {
        if (this.isState(states.trackIdentifiers)) {
          this.trackedIdentifiers.push(ast.name);
        }
        this.identifiers.push({
          context: this.currentContext,
          declaration: this.getDeclaration(ast.name),
          ast,
        });
        break;
      }
      case 'ReturnStatement':
        this.returnStatements.push(ast);
        this.scan(ast.argument);
        break;
      case 'MemberExpression':
        this.pushState(states.memberExpression);
        this.scan(ast.object);
        this.scan(ast.property);
        this.popState(states.memberExpression);
        break;
      case 'ExpressionStatement':
        this.scan(ast.expression);
        break;
      case 'SequenceExpression':
        this.scan(ast.expressions);
        break;
      case 'CallExpression':
        this.functionCalls.push({
          context: this.currentContext,
          ast,
        });
        this.scan(ast.arguments);
        break;
      case 'ArrayExpression':
        this.scan(ast.elements);
        break;
      case 'ConditionalExpression':
        this.scan(ast.test);
        this.scan(ast.alternate);
        this.scan(ast.consequent);
        break;
      case 'SwitchStatement':
        this.scan(ast.discriminant);
        this.scan(ast.cases);
        break;
      case 'SwitchCase':
        this.scan(ast.test);
        this.scan(ast.consequent);
        break;

      case 'ThisExpression':
      case 'Literal':
      case 'DebuggerStatement':
      case 'EmptyStatement':
      case 'BreakStatement':
      case 'ContinueStatement':
        break;
      default:
        throw new Error(`unhandled type "${ast.type}"`);
    }
  }
}

module.exports = {
  FunctionTracer,
};
},{"../utils":114}],12:[function(require,module,exports){
const { glWiretap } = require('gl-wiretap');
const { utils } = require('../../utils');

function toStringWithoutUtils(fn) {
  return fn.toString()
    .replace('=>', '')
    .replace(/^function /, '')
    .replace(/utils[.]/g, '/*utils.*/');
}

function glKernelString(Kernel, args, originKernel, setupContextString, destroyContextString) {
  if (!originKernel.built) {
    originKernel.build.apply(originKernel, args);
  }
  args = args ? Array.from(args).map(arg => {
    switch (typeof arg) {
      case 'boolean':
        return new Boolean(arg);
      case 'number':
        return new Number(arg);
      default:
        return arg;
    }
  }) : null;
  const uploadedValues = [];
  const postResult = [];
  const context = glWiretap(originKernel.context, {
    useTrackablePrimitives: true,
    onReadPixels: (targetName) => {
      if (kernel.subKernels) {
        if (!subKernelsResultVariableSetup) {
          postResult.push(`    const result = { result: ${getRenderString(targetName, kernel)} };`);
          subKernelsResultVariableSetup = true;
        } else {
          const property = kernel.subKernels[subKernelsResultIndex++].property;
          postResult.push(`    result${isNaN(property) ? '.' + property : `[${property}]`} = ${getRenderString(targetName, kernel)};`);
        }
        if (subKernelsResultIndex === kernel.subKernels.length) {
          postResult.push('    return result;');
        }
        return;
      }
      if (targetName) {
        postResult.push(`    return ${getRenderString(targetName, kernel)};`);
      } else {
        postResult.push(`    return null;`);
      }
    },
    onUnrecognizedArgumentLookup: (argument) => {
      const argumentName = findKernelValue(argument, kernel.kernelArguments, [], context, uploadedValues);
      if (argumentName) {
        return argumentName;
      }
      const constantName = findKernelValue(argument, kernel.kernelConstants, constants ? Object.keys(constants).map(key => constants[key]) : [], context, uploadedValues);
      if (constantName) {
        return constantName;
      }
      return null;
    }
  });
  let subKernelsResultVariableSetup = false;
  let subKernelsResultIndex = 0;
  const {
    source,
    canvas,
    output,
    pipeline,
    graphical,
    loopMaxIterations,
    constants,
    optimizeFloatMemory,
    precision,
    fixIntegerDivisionAccuracy,
    functions,
    nativeFunctions,
    subKernels,
    immutable,
    argumentTypes,
    constantTypes,
    kernelArguments,
    kernelConstants,
    tactic,
  } = originKernel;
  const kernel = new Kernel(source, {
    canvas,
    context,
    checkContext: false,
    output,
    pipeline,
    graphical,
    loopMaxIterations,
    constants,
    optimizeFloatMemory,
    precision,
    fixIntegerDivisionAccuracy,
    functions,
    nativeFunctions,
    subKernels,
    immutable,
    argumentTypes,
    constantTypes,
    tactic,
  });
  let result = [];
  context.setIndent(2);
  kernel.build.apply(kernel, args);
  result.push(context.toString());
  context.reset();

  kernel.kernelArguments.forEach((kernelArgument, i) => {
    switch (kernelArgument.type) {
      case 'Integer':
      case 'Boolean':
      case 'Number':
      case 'Float':
      case 'Array':
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'HTMLCanvas':
      case 'HTMLImage':
      case 'HTMLVideo':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);
        break;
      case 'HTMLImageArray':
        for (let imageIndex = 0; imageIndex < args[i].length; imageIndex++) {
          const arg = args[i];
          context.insertVariable(`uploadValue_${kernelArgument.name}[${imageIndex}]`, arg[imageIndex]);
        }
        break;
      case 'Input':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);
        break;
      case 'MemoryOptimizedNumberTexture':
      case 'NumberTexture':
      case 'Array1D(2)':
      case 'Array1D(3)':
      case 'Array1D(4)':
      case 'Array2D(2)':
      case 'Array2D(3)':
      case 'Array2D(4)':
      case 'Array3D(2)':
      case 'Array3D(3)':
      case 'Array3D(4)':
      case 'ArrayTexture(1)':
      case 'ArrayTexture(2)':
      case 'ArrayTexture(3)':
      case 'ArrayTexture(4)':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, args[i].texture);
        break;
      default:
        throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${kernelArgument.type}`);
    }
  });
  result.push('/** start of injected functions **/');
  result.push(`function ${toStringWithoutUtils(utils.flattenTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten2dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten3dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten4dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.isArray)}`);
  if (kernel.renderOutput !== kernel.renderTexture && kernel.formatValues) {
    result.push(
      `  const renderOutput = function ${toStringWithoutUtils(kernel.formatValues)};`
    );
  }
  result.push('/** end of injected functions **/');
  result.push(`  const innerKernel = function (${kernel.kernelArguments.map(kernelArgument => kernelArgument.varName).join(', ')}) {`);
  context.setIndent(4);
  kernel.run.apply(kernel, args);
  if (kernel.renderKernels) {
    kernel.renderKernels();
  } else if (kernel.renderOutput) {
    kernel.renderOutput();
  }
  result.push('    /** start setup uploads for kernel values **/');
  kernel.kernelArguments.forEach(kernelArgument => {
    result.push('    ' + kernelArgument.getStringValueHandler().split('\n').join('\n    '));
  });
  result.push('    /** end setup uploads for kernel values **/');
  result.push(context.toString());
  if (kernel.renderOutput === kernel.renderTexture) {
    context.reset();
    if (kernel.renderKernels) {
      const results = kernel.renderKernels();
      const textureName = context.getContextVariableName(kernel.texture.texture);
      result.push(`    return {
      result: {
        texture: ${ textureName },
        type: '${ results.result.type }',
        toArray: ${ getToArrayString(results.result, textureName) }
      },`);
      const { subKernels, mappedTextures } = kernel;
      for (let i = 0; i < subKernels.length; i++) {
        const texture = mappedTextures[i];
        const subKernel = subKernels[i];
        const subKernelResult = results[subKernel.property];
        const subKernelTextureName = context.getContextVariableName(texture.texture);
        result.push(`
      ${subKernel.property}: {
        texture: ${ subKernelTextureName },
        type: '${ subKernelResult.type }',
        toArray: ${ getToArrayString(subKernelResult, subKernelTextureName) }
      },`);
      }
      result.push(`    };`);
    } else {
      const rendered = kernel.renderOutput();
      const textureName = context.getContextVariableName(kernel.texture.texture);
      result.push(`    return {
        texture: ${ textureName },
        type: '${ rendered.type }',
        toArray: ${ getToArrayString(rendered, textureName) }
      };`);
    }
  }
  result.push(`    ${destroyContextString ? '\n' + destroyContextString + '    ': ''}`);
  result.push(postResult.join('\n'));
  result.push('  };');
  if (kernel.graphical) {
    result.push(getGetPixelsString(kernel));
    result.push(`  innerKernel.getPixels = getPixels;`);
  }
  result.push('  return innerKernel;');

  let constantsUpload = [];
  kernelConstants.forEach((kernelConstant) => {
    constantsUpload.push(`${  kernelConstant.getStringValueHandler()}`);
  });
  return `function kernel(settings) {
  const { context, constants } = settings;
  ${constantsUpload.join('')}
  ${setupContextString ? setupContextString : ''}
${result.join('\n')}
}`;
}

function getRenderString(targetName, kernel) {
  const readBackValue = kernel.precision === 'single' ? targetName : `new Float32Array(${targetName}.buffer)`;
  if (kernel.output[2]) {
    return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]}, ${kernel.output[2]})`;
  }
  if (kernel.output[1]) {
    return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]})`;
  }

  return `renderOutput(${readBackValue}, ${kernel.output[0]})`;
}

function getGetPixelsString(kernel) {
  const getPixels = kernel.getPixels.toString();
  const useFunctionKeyword = !/^function/.test(getPixels);
  return utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ getPixels }`, {
    findDependency: (object, name) => {
      if (object === 'utils') {
        return `const ${name} = ${utils[name].toString()};`;
      }
      return null;
    },
    thisLookup: (property) => {
      if (property === 'context') {
        return null;
      }
      if (kernel.hasOwnProperty(property)) {
        return JSON.stringify(kernel[property]);
      }
      throw new Error(`unhandled thisLookup ${ property }`);
    }
  });
}

function getToArrayString(kernelResult, textureName) {
  const toArray = kernelResult.toArray.toString();
  const useFunctionKeyword = !/^function/.test(toArray);
  const flattenedFunctions = utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ toArray }`, {
    findDependency: (object, name) => {
      if (object === 'utils') {
        return `const ${name} = ${utils[name].toString()};`;
      } else if (object === 'this') {
        return `${useFunctionKeyword ? 'function ' : ''}${kernelResult[name].toString()}`;
      } else {
        throw new Error('unhandled fromObject');
      }
    },
    thisLookup: (property, isDeclaration) => {
      if (property === 'texture') {
        return textureName;
      }
      if (property === 'context') {
        if (isDeclaration) return null;
        return 'gl';
      }
      if (property === '_framebuffer') {
        return '_framebuffer';
      }
      if (kernelResult.hasOwnProperty(property)) {
        return JSON.stringify(kernelResult[property]);
      }
      throw new Error(`unhandled thisLookup ${ property }`);
    }
  });
  return `() => {
  let _framebuffer;
  ${flattenedFunctions}
  return toArray();
  }`;
}

function findKernelValue(argument, kernelValues, values, context, uploadedValues) {
  if (argument === null) return null;
  if (kernelValues === null) return null;
  switch (typeof argument) {
    case 'boolean':
    case 'number':
      return null;
  }
  if (
    typeof HTMLImageElement !== 'undefined' &&
    argument instanceof HTMLImageElement
  ) {
    for (let i = 0; i < kernelValues.length; i++) {
      const kernelValue = kernelValues[i];
      if (kernelValue.type !== 'HTMLImageArray' && kernelValue) continue;
      if (kernelValue.uploadValue !== argument) continue;
      const variableIndex = values[i].indexOf(argument);
      if (variableIndex === -1) continue;
      const variableName = `uploadValue_${kernelValue.name}[${variableIndex}]`;
      context.insertVariable(variableName, argument);
      return variableName;
    }
  }

  for (let i = 0; i < kernelValues.length; i++) {
    const kernelValue = kernelValues[i];
    if (argument !== kernelValue.uploadValue) continue;
    const variable = `uploadValue_${kernelValue.name}`;
    context.insertVariable(variable, kernelValue);
    return variable;
  }
  return null;
}

module.exports = {
  glKernelString
};
},{"../../utils":114,"gl-wiretap":3}],13:[function(require,module,exports){
const { Kernel } = require('../kernel');
const { utils } = require('../../utils');
const { GLTextureArray2Float } = require('./texture/array-2-float');
const { GLTextureArray2Float2D } = require('./texture/array-2-float-2d');
const { GLTextureArray2Float3D } = require('./texture/array-2-float-3d');
const { GLTextureArray3Float } = require('./texture/array-3-float');
const { GLTextureArray3Float2D } = require('./texture/array-3-float-2d');
const { GLTextureArray3Float3D } = require('./texture/array-3-float-3d');
const { GLTextureArray4Float } = require('./texture/array-4-float');
const { GLTextureArray4Float2D } = require('./texture/array-4-float-2d');
const { GLTextureArray4Float3D } = require('./texture/array-4-float-3d');
const { GLTextureFloat } = require('./texture/float');
const { GLTextureFloat2D } = require('./texture/float-2d');
const { GLTextureFloat3D } = require('./texture/float-3d');
const { GLTextureMemoryOptimized } = require('./texture/memory-optimized');
const { GLTextureMemoryOptimized2D } = require('./texture/memory-optimized-2d');
const { GLTextureMemoryOptimized3D } = require('./texture/memory-optimized-3d');
const { GLTextureUnsigned } = require('./texture/unsigned');
const { GLTextureUnsigned2D } = require('./texture/unsigned-2d');
const { GLTextureUnsigned3D } = require('./texture/unsigned-3d');
const { GLTextureGraphical } = require('./texture/graphical');

class GLKernel extends Kernel {
  static get mode() {
    return 'gpu';
  }

  static getIsFloatRead() {
    const kernelString = `function kernelFunction() {
      return 1;
    }`;
    const kernel = new this(kernelString, {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [1],
      precision: 'single',
      returnType: 'Number',
      tactic: 'speed',
    });
    kernel.build();
    kernel.run();
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return result[0] === 1;
  }

  static getIsIntegerDivisionAccurate() {
    function kernelFunction(v1, v2) {
      return v1[this.thread.x] / v2[this.thread.x];
    }
    const kernel = new this(kernelFunction.toString(), {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [2],
      returnType: 'Number',
      precision: 'unsigned',
      tactic: 'speed',
    });
    const args = [
      [6, 6030401],
      [3, 3991]
    ];
    kernel.build.apply(kernel, args);
    kernel.run.apply(kernel, args);
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return result[0] === 2 && result[1] === 1511;
  }

  static getIsSpeedTacticSupported() {
    function kernelFunction(value) {
      return value[this.thread.x];
    }
    const kernel = new this(kernelFunction.toString(), {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [4],
      returnType: 'Number',
      precision: 'unsigned',
      tactic: 'speed',
    });
    const args = [
      [0, 1, 2, 3]
    ];
    kernel.build.apply(kernel, args);
    kernel.run.apply(kernel, args);
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return Math.round(result[0]) === 0 && Math.round(result[1]) === 1 && Math.round(result[2]) === 2 && Math.round(result[3]) === 3;
  }

  static get testCanvas() {
    throw new Error(`"testCanvas" not defined on ${ this.name }`);
  }

  static get testContext() {
    throw new Error(`"testContext" not defined on ${ this.name }`);
  }

  static getFeatures() {
    const gl = this.testContext;
    const isDrawBuffers = this.getIsDrawBuffers();
    return Object.freeze({
      isFloatRead: this.getIsFloatRead(),
      isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
      isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
      isTextureFloat: this.getIsTextureFloat(),
      isDrawBuffers,
      kernelMap: isDrawBuffers,
      channelCount: this.getChannelCount(),
      maxTextureSize: this.getMaxTextureSize(),
      lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),
      lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),
      mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),
      mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),
      highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),
      highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
    });
  }

  static setupFeatureChecks() {
    throw new Error(`"setupFeatureChecks" not defined on ${ this.name }`);
  }

  static getSignature(kernel, argumentTypes) {
    return kernel.getVariablePrecisionString() + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');
  }

  setFixIntegerDivisionAccuracy(fix) {
    this.fixIntegerDivisionAccuracy = fix;
    return this;
  }

  setPrecision(flag) {
    this.precision = flag;
    return this;
  }

  setFloatTextures(flag) {
    utils.warnDeprecated('method', 'setFloatTextures', 'setOptimizeFloatMemory');
    this.floatTextures = flag;
    return this;
  }

  static nativeFunctionArguments(source) {
    const argumentTypes = [];
    const argumentNames = [];
    const states = [];
    const isStartingVariableName = /^[a-zA-Z_]/;
    const isVariableChar = /[a-zA-Z_0-9]/;
    let i = 0;
    let argumentName = null;
    let argumentType = null;
    while (i < source.length) {
      const char = source[i];
      const nextChar = source[i + 1];
      const state = states.length > 0 ? states[states.length - 1] : null;

      if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '*') {
        states.push('MULTI_LINE_COMMENT');
        i += 2;
        continue;
      } else if (state === 'MULTI_LINE_COMMENT' && char === '*' && nextChar === '/') {
        states.pop();
        i += 2;
        continue;
      }

      else if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '/') {
        states.push('COMMENT');
        i += 2;
        continue;
      } else if (state === 'COMMENT' && char === '\n') {
        states.pop();
        i++;
        continue;
      }

      else if (state === null && char === '(') {
        states.push('FUNCTION_ARGUMENTS');
        i++;
        continue;
      } else if (state === 'FUNCTION_ARGUMENTS') {
        if (char === ')') {
          states.pop();
          break;
        }
        if (char === 'f' && nextChar === 'l' && source[i + 2] === 'o' && source[i + 3] === 'a' && source[i + 4] === 't' && source[i + 5] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'float';
          argumentName = '';
          i += 6;
          continue;
        } else if (char === 'i' && nextChar === 'n' && source[i + 2] === 't' && source[i + 3] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'int';
          argumentName = '';
          i += 4;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '2' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec2';
          argumentName = '';
          i += 5;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '3' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec3';
          argumentName = '';
          i += 5;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '4' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec4';
          argumentName = '';
          i += 5;
          continue;
        }
      }

      else if (state === 'DECLARE_VARIABLE') {
        if (argumentName === '') {
          if (char === ' ') {
            i++;
            continue;
          }
          if (!isStartingVariableName.test(char)) {
            throw new Error('variable name is not expected string');
          }
        }
        argumentName += char;
        if (!isVariableChar.test(nextChar)) {
          states.pop();
          argumentNames.push(argumentName);
          argumentTypes.push(typeMap[argumentType]);
        }
      }

      i++;
    }
    if (states.length > 0) {
      throw new Error('GLSL function was not parsable');
    }
    return {
      argumentNames,
      argumentTypes,
    };
  }

  static nativeFunctionReturnType(source) {
    return typeMap[source.match(/int|float|vec[2-4]/)[0]];
  }

  static combineKernels(combinedKernel, lastKernel) {
    combinedKernel.apply(null, arguments);
    const {
      texSize,
      context,
      threadDim
    } = lastKernel.texSize;
    let result;
    if (lastKernel.precision === 'single') {
      const w = texSize[0];
      const h = Math.ceil(texSize[1] / 4);
      result = new Float32Array(w * h * 4 * 4);
      context.readPixels(0, 0, w, h * 4, context.RGBA, context.FLOAT, result);
    } else {
      const bytes = new Uint8Array(texSize[0] * texSize[1] * 4);
      context.readPixels(0, 0, texSize[0], texSize[1], context.RGBA, context.UNSIGNED_BYTE, bytes);
      result = new Float32Array(bytes.buffer);
    }

    result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);

    if (lastKernel.output.length === 1) {
      return result;
    } else if (lastKernel.output.length === 2) {
      return utils.splitArray(result, lastKernel.output[0]);
    } else if (lastKernel.output.length === 3) {
      const cube = utils.splitArray(result, lastKernel.output[0] * lastKernel.output[1]);
      return cube.map(function(x) {
        return utils.splitArray(x, lastKernel.output[0]);
      });
    }
  }

  constructor(source, settings) {
    super(source, settings);
    this.transferValues = null;
    this.formatValues = null;
    this.TextureConstructor = null;
    this.renderOutput = null;
    this.renderRawOutput = null;
    this.texSize = null;
    this.translatedSource = null;
    this.compiledFragmentShader = null;
    this.compiledVertexShader = null;
    this.switchingKernels = null;
    this._textureSwitched = null;
    this._mappedTextureSwitched = null;
  }

  checkTextureSize() {
    const { features } = this.constructor;
    if (this.texSize[0] > features.maxTextureSize || this.texSize[1] > features.maxTextureSize) {
      throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${features.maxTextureSize},${features.maxTextureSize}]`);
    }
  }

  translateSource() {
    throw new Error(`"translateSource" not defined on ${this.constructor.name}`);
  }

  pickRenderStrategy(args) {
    if (this.graphical) {
      this.renderRawOutput = this.readPackedPixelsToUint8Array;
      this.transferValues = (pixels) => pixels;
      this.TextureConstructor = GLTextureGraphical;
      return null;
    }
    if (this.precision === 'unsigned') {
      this.renderRawOutput = this.readPackedPixelsToUint8Array;
      this.transferValues = this.readPackedPixelsToFloat32Array;
      if (this.pipeline) {
        this.renderOutput = this.renderTexture;
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToTextures;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer':
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureUnsigned3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureUnsigned2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureUnsigned;
              return null;
            }
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              return this.requestFallback(args);
        }
      } else {
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToArrays;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer':
            this.renderOutput = this.renderValues;
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureUnsigned3D;
              this.formatValues = utils.erect3DPackedFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureUnsigned2D;
              this.formatValues = utils.erect2DPackedFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureUnsigned;
              this.formatValues = utils.erectPackedFloat;
              return null;
            }
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              return this.requestFallback(args);
        }
      }
    } else if (this.precision === 'single') {
      this.renderRawOutput = this.readFloatPixelsToFloat32Array;
      this.transferValues = this.readFloatPixelsToFloat32Array;
      if (this.pipeline) {
        this.renderOutput = this.renderTexture;
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToTextures;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.optimizeFloatMemory) {
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureMemoryOptimized3D;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureMemoryOptimized2D;
                return null;
              } else {
                this.TextureConstructor = GLTextureMemoryOptimized;
                return null;
              }
            } else {
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureFloat3D;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureFloat2D;
                return null;
              } else {
                this.TextureConstructor = GLTextureFloat;
                return null;
              }
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              return null;
            }
          }
        }
      }
      this.renderOutput = this.renderValues;
      if (this.subKernels !== null) {
        this.renderKernels = this.renderKernelsToArrays;
      }
      if (this.optimizeFloatMemory) {
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureMemoryOptimized3D;
              this.formatValues = utils.erectMemoryOptimized3DFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureMemoryOptimized2D;
              this.formatValues = utils.erectMemoryOptimized2DFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureMemoryOptimized;
              this.formatValues = utils.erectMemoryOptimizedFloat;
              return null;
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              this.formatValues = utils.erect3DArray2;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              this.formatValues = utils.erect2DArray2;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              this.formatValues = utils.erectArray2;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              this.formatValues = utils.erect3DArray3;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              this.formatValues = utils.erect2DArray3;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              this.formatValues = utils.erectArray3;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              this.formatValues = utils.erect3DArray4;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              this.formatValues = utils.erect2DArray4;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              this.formatValues = utils.erectArray4;
              return null;
            }
          }
        }
      } else {
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureFloat3D;
              this.formatValues = utils.erect3DFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureFloat2D;
              this.formatValues = utils.erect2DFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureFloat;
              this.formatValues = utils.erectFloat;
              return null;
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              this.formatValues = utils.erect3DArray2;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              this.formatValues = utils.erect2DArray2;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              this.formatValues = utils.erectArray2;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              this.formatValues = utils.erect3DArray3;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              this.formatValues = utils.erect2DArray3;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              this.formatValues = utils.erectArray3;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              this.formatValues = utils.erect3DArray4;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              this.formatValues = utils.erect2DArray4;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              this.formatValues = utils.erectArray4;
              return null;
            }
          }
        }
      }
    } else {
      throw new Error(`unhandled precision of "${this.precision}"`);
    }

    throw new Error(`unhandled return type "${this.returnType}"`);
  }

  getKernelString() {
    throw new Error(`abstract method call`);
  }

  getMainResultTexture() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Float':
      case 'Integer':
      case 'Number':
        return this.getMainResultNumberTexture();
      case 'Array(2)':
        return this.getMainResultArray2Texture();
      case 'Array(3)':
        return this.getMainResultArray3Texture();
      case 'Array(4)':
        return this.getMainResultArray4Texture();
      default:
        throw new Error(`unhandled returnType type ${ this.returnType }`);
    }
  }

  getMainResultKernelNumberTexture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelNumberTexture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray2Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray2Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray3Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray3Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray4Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray4Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultGraphical() {
    throw new Error(`abstract method call`);
  }
  getMainResultMemoryOptimizedFloats() {
    throw new Error(`abstract method call`);
  }
  getMainResultPackedPixels() {
    throw new Error(`abstract method call`);
  }

  getMainResultString() {
    if (this.graphical) {
      return this.getMainResultGraphical();
    } else if (this.precision === 'single') {
      if (this.optimizeFloatMemory) {
        return this.getMainResultMemoryOptimizedFloats();
      }
      return this.getMainResultTexture();
    } else {
      return this.getMainResultPackedPixels();
    }
  }

  getMainResultNumberTexture() {
    return utils.linesToString(this.getMainResultKernelNumberTexture()) +
      utils.linesToString(this.getMainResultSubKernelNumberTexture());
  }

  getMainResultArray2Texture() {
    return utils.linesToString(this.getMainResultKernelArray2Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray2Texture());
  }

  getMainResultArray3Texture() {
    return utils.linesToString(this.getMainResultKernelArray3Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray3Texture());
  }

  getMainResultArray4Texture() {
    return utils.linesToString(this.getMainResultKernelArray4Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray4Texture());
  }

  getFloatTacticDeclaration() {
    const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);
    return `precision ${variablePrecision} float;\n`;
  }

  getIntTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic, true)} int;\n`;
  }

  getSampler2DTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2D;\n`;
  }

  getSampler2DArrayTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2DArray;\n`;
  }

  renderTexture() {
    return this.immutable ? this.texture.clone() : this.texture;
  }
  readPackedPixelsToUint8Array() {
    if (this.precision !== 'unsigned') throw new Error('Requires this.precision to be "unsigned"');
    const {
      texSize,
      context: gl
    } = this;
    const result = new Uint8Array(texSize[0] * texSize[1] * 4);
    gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
    return result;
  }

  readPackedPixelsToFloat32Array() {
    return new Float32Array(this.readPackedPixelsToUint8Array().buffer);
  }

  readFloatPixelsToFloat32Array() {
    if (this.precision !== 'single') throw new Error('Requires this.precision to be "single"');
    const {
      texSize,
      context: gl
    } = this;
    const w = texSize[0];
    const h = texSize[1];
    const result = new Float32Array(w * h * 4);
    gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);
    return result;
  }

  getPixels(flip) {
    const {
      context: gl,
      output
    } = this;
    const [width, height] = output;
    const pixels = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    return new Uint8ClampedArray((flip ? pixels : utils.flipPixels(pixels, width, height)).buffer);
  }

  renderKernelsToArrays() {
    const result = {
      result: this.renderOutput(),
    };
    for (let i = 0; i < this.subKernels.length; i++) {
      result[this.subKernels[i].property] = this.mappedTextures[i].toArray();
    }
    return result;
  }

  renderKernelsToTextures() {
    const result = {
      result: this.renderOutput(),
    };
    if (this.immutable) {
      for (let i = 0; i < this.subKernels.length; i++) {
        result[this.subKernels[i].property] = this.mappedTextures[i].clone();
      }
    } else {
      for (let i = 0; i < this.subKernels.length; i++) {
        result[this.subKernels[i].property] = this.mappedTextures[i];
      }
    }
    return result;
  }

  resetSwitchingKernels() {
    const existingValue = this.switchingKernels;
    this.switchingKernels = null;
    return existingValue;
  }

  setOutput(output) {
    const newOutput = this.toKernelOutput(output);
    if (this.program) {
      if (!this.dynamicOutput) {
        throw new Error('Resizing a kernel with dynamicOutput: false is not possible');
      }
      const newThreadDim = [newOutput[0], newOutput[1] || 1, newOutput[2] || 1];
      const newTexSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, newThreadDim);
      const oldTexSize = this.texSize;
      if (oldTexSize) {
        const oldPrecision = this.getVariablePrecisionString(oldTexSize, this.tactic);
        const newPrecision = this.getVariablePrecisionString(newTexSize, this.tactic);
        if (oldPrecision !== newPrecision) {
          if (this.debug) {
            console.warn('Precision requirement changed, asking GPU instance to recompile');
          }
          this.switchKernels({
            type: 'outputPrecisionMismatch',
            precision: newPrecision,
            needed: output
          });
          return;
        }
      }
      this.output = newOutput;
      this.threadDim = newThreadDim;
      this.texSize = newTexSize;
      const { context: gl } = this;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      this.updateMaxTexSize();
      this.framebuffer.width = this.texSize[0];
      this.framebuffer.height = this.texSize[1];
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      this.canvas.width = this.maxTexSize[0];
      this.canvas.height = this.maxTexSize[1];
      if (this.texture) {
        this.texture.delete();
      }
      this.texture = null;
      this._setupOutputTexture();
      if (this.mappedTextures && this.mappedTextures.length > 0) {
        for (let i = 0; i < this.mappedTextures.length; i++) {
          this.mappedTextures[i].delete();
        }
        this.mappedTextures = null;
        this._setupSubOutputTextures();
      }
    } else {
      this.output = newOutput;
    }
    return this;
  }
  renderValues() {
    return this.formatValues(
      this.transferValues(),
      this.output[0],
      this.output[1],
      this.output[2]
    );
  }
  switchKernels(reason) {
    if (this.switchingKernels) {
      this.switchingKernels.push(reason);
    } else {
      this.switchingKernels = [reason];
    }
  }
  getVariablePrecisionString(textureSize = this.texSize, tactic = this.tactic, isInt = false) {
    if (!tactic) {
      if (!this.constructor.features.isSpeedTacticSupported) return 'highp';
      const low = this.constructor.features[isInt ? 'lowIntPrecision' : 'lowFloatPrecision'];
      const medium = this.constructor.features[isInt ? 'mediumIntPrecision' : 'mediumFloatPrecision'];
      const high = this.constructor.features[isInt ? 'highIntPrecision' : 'highFloatPrecision'];
      const requiredSize = Math.log2(textureSize[0] * textureSize[1]);
      if (requiredSize <= low.rangeMax) {
        return 'lowp';
      } else if (requiredSize <= medium.rangeMax) {
        return 'mediump';
      } else if (requiredSize <= high.rangeMax) {
        return 'highp';
      } else {
        throw new Error(`The required size exceeds that of the ability of your system`);
      }
    }
    switch (tactic) {
      case 'speed':
        return 'lowp';
      case 'balanced':
        return 'mediump';
      case 'precision':
        return 'highp';
      default:
        throw new Error(`Unknown tactic "${tactic}" use "speed", "balanced", "precision", or empty for auto`);
    }
  }

  updateTextureArgumentRefs(kernelValue, arg) {
    if (!this.immutable) return;
    if (this.texture.texture === arg.texture) {
      const { prevArg } = kernelValue;
      if (prevArg) {
        if (prevArg.texture._refs === 1) {
          this.texture.delete();
          this.texture = prevArg.clone();
          this._textureSwitched = true;
        }
        prevArg.delete();
      }
      kernelValue.prevArg = arg.clone();
    } else if (this.mappedTextures && this.mappedTextures.length > 0) {
      const { mappedTextures } = this;
      for (let i = 0; i < mappedTextures.length; i++) {
        const mappedTexture = mappedTextures[i];
        if (mappedTexture.texture === arg.texture) {
          const { prevArg } = kernelValue;
          if (prevArg) {
            if (prevArg.texture._refs === 1) {
              mappedTexture.delete();
              mappedTextures[i] = prevArg.clone();
              this._mappedTextureSwitched[i] = true;
            }
            prevArg.delete();
          }
          kernelValue.prevArg = arg.clone();
          return;
        }
      }
    }
  }

  onActivate(previousKernel) {
    this._textureSwitched = true;
    this.texture = previousKernel.texture;
    if (this.mappedTextures) {
      for (let i = 0; i < this.mappedTextures.length; i++) {
        this._mappedTextureSwitched[i] = true;
      }
      this.mappedTextures = previousKernel.mappedTextures;
    }
  }

  initCanvas() {}
}

const typeMap = {
  int: 'Integer',
  float: 'Number',
  vec2: 'Array(2)',
  vec3: 'Array(3)',
  vec4: 'Array(4)',
};

module.exports = {
  GLKernel
};
},{"../../utils":114,"../kernel":36,"./texture/array-2-float":16,"./texture/array-2-float-2d":14,"./texture/array-2-float-3d":15,"./texture/array-3-float":19,"./texture/array-3-float-2d":17,"./texture/array-3-float-3d":18,"./texture/array-4-float":22,"./texture/array-4-float-2d":20,"./texture/array-4-float-3d":21,"./texture/float":25,"./texture/float-2d":23,"./texture/float-3d":24,"./texture/graphical":26,"./texture/memory-optimized":30,"./texture/memory-optimized-2d":28,"./texture/memory-optimized-3d":29,"./texture/unsigned":33,"./texture/unsigned-2d":31,"./texture/unsigned-3d":32}],14:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erect2DArray2(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray2Float2D
};
},{"../../../utils":114,"./float":25}],15:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erect3DArray2(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray2Float3D
};
},{"../../../utils":114,"./float":25}],16:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erectArray2(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray2Float
};
},{"../../../utils":114,"./float":25}],17:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erect2DArray3(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray3Float2D
};
},{"../../../utils":114,"./float":25}],18:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erect3DArray3(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray3Float3D
};
},{"../../../utils":114,"./float":25}],19:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erectArray3(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureArray3Float
};
},{"../../../utils":114,"./float":25}],20:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erect2DArray4(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray4Float2D
};
},{"../../../utils":114,"./float":25}],21:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erect3DArray4(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray4Float3D
};
},{"../../../utils":114,"./float":25}],22:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erectArray4(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureArray4Float
};
},{"../../../utils":114,"./float":25}],23:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureFloat2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  toArray() {
    return utils.erect2DFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureFloat2D
};
},{"../../../utils":114,"./float":25}],24:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureFloat3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  toArray() {
    return utils.erect3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureFloat3D
};
},{"../../../utils":114,"./float":25}],25:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTexture } = require('./index');

class GLTextureFloat extends GLTexture {
  get textureType() {
    return this.context.FLOAT;
  }
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  renderRawOutput() {
    const gl = this.context;
    const size = this.size;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      this.texture,
      0
    );
    const result = new Float32Array(size[0] * size[1] * 4);
    gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.FLOAT, result);
    return result;
  }
  renderValues() {
    if (this._deleted) return null;
    return this.renderRawOutput();
  }
  toArray() {
    return utils.erectFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureFloat
};
},{"../../../utils":114,"./index":27}],26:[function(require,module,exports){
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureGraphical extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return this.renderValues();
  }
}

module.exports = {
  GLTextureGraphical
};
},{"./unsigned":33}],27:[function(require,module,exports){
const { Texture } = require('../../../texture');

class GLTexture extends Texture {
  get textureType() {
    throw new Error(`"textureType" not implemented on ${ this.name }`);
  }

  clone() {
    return new this.constructor(this);
  }

  beforeMutate() {
    if (this.texture._refs > 1) {
      this.newTexture();
      return true;
    }
    return false;
  }

  cloneTexture() {
    this.texture._refs--;
    const { context: gl, size, texture, kernel } = this;
    if (kernel.debug) {
      console.warn('cloning internal texture');
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    selectTexture(gl, texture);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const target = gl.createTexture();
    selectTexture(gl, target);
    gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, size[0], size[1]);
    target._refs = 1;
    this.texture = target;
  }

  newTexture() {
    this.texture._refs--;
    const gl = this.context;
    const size = this.size;
    const kernel = this.kernel;
    if (kernel.debug) {
      console.warn('new internal texture');
    }
    const target = gl.createTexture();
    selectTexture(gl, target);
    gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    target._refs = 1;
    this.texture = target;
  }

  clear() {
    if (this.texture._refs) {
      this.texture._refs--;
      const gl = this.context;
      const target = this.texture = gl.createTexture();
      selectTexture(gl, target);
      const size = this.size;
      target._refs = 1;
      gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    }
    const { context: gl, texture } = this;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    gl.bindTexture(gl.TEXTURE_2D, texture);
    selectTexture(gl, texture);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  }

  delete() {
    if (this._deleted) return;
    this._deleted = true;
    if (this.texture._refs) {
      this.texture._refs--;
      if (this.texture._refs) return;
    }
    this.context.deleteTexture(this.texture);
    if (this.texture._refs === 0 && this._framebuffer) {
      this.context.deleteFramebuffer(this._framebuffer);
      this._framebuffer = null;
    }
  }

  framebuffer() {
    if (!this._framebuffer) {
      this._framebuffer = this.context.createFramebuffer();
    }
    this._framebuffer.width = this.size[0];
    this._framebuffer.height = this.size[1];
    return this._framebuffer;
  }
}

function selectTexture(gl, texture) {
  gl.activeTexture(gl.TEXTURE15);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
}

module.exports = { GLTexture };
},{"../../../texture":113}],28:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimized2DFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureMemoryOptimized2D
};
},{"../../../utils":114,"./float":25}],29:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimized3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureMemoryOptimized3D
};
},{"../../../utils":114,"./float":25}],30:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimizedFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureMemoryOptimized
};
},{"../../../utils":114,"./float":25}],31:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureUnsigned2D extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  toArray() {
    return utils.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureUnsigned2D
};
},{"../../../utils":114,"./unsigned":33}],32:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureUnsigned3D extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  toArray() {
    return utils.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureUnsigned3D
};
},{"../../../utils":114,"./unsigned":33}],33:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTexture } = require('./index');

class GLTextureUnsigned extends GLTexture {
  get textureType() {
    return this.context.UNSIGNED_BYTE;
  }
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  renderRawOutput() {
    const { context: gl } = this;
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      this.texture,
      0
    );
    const result = new Uint8Array(this.size[0] * this.size[1] * 4);
    gl.readPixels(0, 0, this.size[0], this.size[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
    return result;
  }
  renderValues() {
    if (this._deleted) return null;
    return new Float32Array(this.renderRawOutput().buffer);
  }
  toArray() {
    return utils.erectPackedFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureUnsigned
};
},{"../../../utils":114,"./index":27}],34:[function(require,module,exports){
const getContext = require('gl');
const { WebGLKernel } = require('../web-gl/kernel');
const { glKernelString } = require('../gl/kernel-string');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;
let features = null;

class HeadlessGLKernel extends WebGLKernel {
  static get isSupported() {
    if (isSupported !== null) return isSupported;
    this.setupFeatureChecks();
    isSupported = testContext !== null;
    return isSupported;
  }

  static setupFeatureChecks() {
    testCanvas = null;
    testExtensions = null;
    if (typeof getContext !== 'function') return;
    try { 
      testContext = getContext(2, 2, {
        preserveDrawingBuffer: true
      });
      if (!testContext || !testContext.getExtension) return;
      testExtensions = {
        STACKGL_resize_drawingbuffer: testContext.getExtension('STACKGL_resize_drawingbuffer'),
        STACKGL_destroy_context: testContext.getExtension('STACKGL_destroy_context'),
        OES_texture_float: testContext.getExtension('OES_texture_float'),
        OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
        OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
        WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
        WEBGL_color_buffer_float: testContext.getExtension('WEBGL_color_buffer_float'),
      };
      features = this.getFeatures();
    } catch (e) {
      console.warn(e);
    }
  }

  static isContextMatch(context) {
    try {
      return context.getParameter(context.RENDERER) === 'ANGLE';
    } catch (e) {
      return false;
    }
  }

  static getIsTextureFloat() {
    return Boolean(testExtensions.OES_texture_float);
  }

  static getIsDrawBuffers() {
    return Boolean(testExtensions.WEBGL_draw_buffers);
  }

  static getChannelCount() {
    return testExtensions.WEBGL_draw_buffers ?
      testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :
      1;
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  initCanvas() {
    return {};
  }

  initContext() {
    return getContext(2, 2, {
      preserveDrawingBuffer: true
    });
  }

  initExtensions() {
    this.extensions = {
      STACKGL_resize_drawingbuffer: this.context.getExtension('STACKGL_resize_drawingbuffer'),
      STACKGL_destroy_context: this.context.getExtension('STACKGL_destroy_context'),
      OES_texture_float: this.context.getExtension('OES_texture_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
    };
  }

  build() {
    super.build.apply(this, arguments);
    if (!this.fallbackRequested) {
      this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
    }
  }

  destroyExtensions() {
    this.extensions.STACKGL_resize_drawingbuffer = null;
    this.extensions.STACKGL_destroy_context = null;
    this.extensions.OES_texture_float = null;
    this.extensions.OES_texture_float_linear = null;
    this.extensions.OES_element_index_uint = null;
    this.extensions.WEBGL_draw_buffers = null;
  }

  static destroyContext(context) {
    const extension = context.getExtension('STACKGL_destroy_context');
    if (extension && extension.destroy) {
      extension.destroy();
    }
  }

  toString() {
    const setupContextString = `const gl = context || require('gl')(1, 1);\n`;
    const destroyContextString = `    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }\n`;
    return glKernelString(this.constructor, arguments, this, setupContextString, destroyContextString);
  }

  setOutput(output) {
    super.setOutput(output);
    if (this.graphical && this.extensions.STACKGL_resize_drawingbuffer) {
      this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
    }
    return this;
  }
}

module.exports = {
  HeadlessGLKernel
};
},{"../gl/kernel-string":12,"../web-gl/kernel":70,"gl":2}],35:[function(require,module,exports){
class KernelValue {
  constructor(value, settings) {
    const {
      name,
      kernel,
      context,
      checkContext,
      onRequestContextHandle,
      onUpdateValueMismatch,
      origin,
      strictIntegers,
      type,
      tactic,
    } = settings;
    if (!name) {
      throw new Error('name not set');
    }
    if (!type) {
      throw new Error('type not set');
    }
    if (!origin) {
      throw new Error('origin not set');
    }
    if (origin !== 'user' && origin !== 'constants') {
      throw new Error(`origin must be "user" or "constants" value is "${ origin }"`);
    }
    if (!onRequestContextHandle) {
      throw new Error('onRequestContextHandle is not set');
    }
    this.name = name;
    this.origin = origin;
    this.tactic = tactic;
    this.varName = origin === 'constants' ? `constants.${name}` : name;
    this.kernel = kernel;
    this.strictIntegers = strictIntegers;
    this.type = value.type || type;
    this.size = value.size || null;
    this.index = null;
    this.context = context;
    this.checkContext = checkContext !== null && checkContext !== undefined ? checkContext : true;
    this.contextHandle = null;
    this.onRequestContextHandle = onRequestContextHandle;
    this.onUpdateValueMismatch = onUpdateValueMismatch;
    this.forceUploadEachRun = null;
  }

  get id() {
    return `${this.origin}_${name}`;
  }

  getSource() {
    throw new Error(`"getSource" not defined on ${ this.constructor.name }`);
  }

  updateValue(value) {
    throw new Error(`"updateValue" not defined on ${ this.constructor.name }`);
  }
}

module.exports = {
  KernelValue
};
},{}],36:[function(require,module,exports){
const { utils } = require('../utils');
const { Input } = require('../input');

class Kernel {
  static get isSupported() {
    throw new Error(`"isSupported" not implemented on ${ this.name }`);
  }

  static isContextMatch(context) {
    throw new Error(`"isContextMatch" not implemented on ${ this.name }`);
  }

  static getFeatures() {
    throw new Error(`"getFeatures" not implemented on ${ this.name }`);
  }

  static destroyContext(context) {
    throw new Error(`"destroyContext" called on ${ this.name }`);
  }

  static nativeFunctionArguments() {
    throw new Error(`"nativeFunctionArguments" called on ${ this.name }`);
  }

  static nativeFunctionReturnType() {
    throw new Error(`"nativeFunctionReturnType" called on ${ this.name }`);
  }

  static combineKernels() {
    throw new Error(`"combineKernels" called on ${ this.name }`);
  }

  constructor(source, settings) {
    if (typeof source !== 'object') {
      if (typeof source !== 'string') {
        throw new Error('source not a string');
      }
      if (!utils.isFunctionString(source)) {
        throw new Error('source not a function string');
      }
    }
    this.useLegacyEncoder = false;
    this.fallbackRequested = false;
    this.onRequestFallback = null;

    this.argumentNames = typeof source === 'string' ? utils.getArgumentNamesFromString(source) : null;
    this.argumentTypes = null;
    this.argumentSizes = null;
    this.argumentBitRatios = null;
    this.kernelArguments = null;
    this.kernelConstants = null;
    this.forceUploadKernelConstants = null;


    this.source = source;

    this.output = null;

    this.debug = false;

    this.graphical = false;

    this.loopMaxIterations = 0;

    this.constants = null;

    this.constantTypes = null;

    this.constantBitRatios = null;

    this.dynamicArguments = false;

    this.dynamicOutput = false;

    this.canvas = null;

    this.context = null;

    this.checkContext = null;

    this.gpu = null;

    this.functions = null;

    this.nativeFunctions = null;

    this.injectedNative = null;

    this.subKernels = null;

    this.validate = true;

    this.immutable = false;

    this.pipeline = false;

    this.precision = null;

    this.tactic = null;

    this.plugins = null;

    this.returnType = null;
    this.leadingReturnStatement = null;
    this.followingReturnStatement = null;
    this.optimizeFloatMemory = null;
    this.strictIntegers = false;
    this.fixIntegerDivisionAccuracy = null;
    this.onIstanbulCoverageVariable = null;
    this.removeIstanbulCoverage = false;
    this.built = false;
    this.signature = null;
  }

  mergeSettings(settings) {
    for (let p in settings) {
      if (!settings.hasOwnProperty(p) || !this.hasOwnProperty(p)) continue;
      switch (p) {
        case 'output':
          if (!Array.isArray(settings.output)) {
            this.setOutput(settings.output); 
            continue;
          }
          break;
        case 'functions':
          this.functions = [];
          for (let i = 0; i < settings.functions.length; i++) {
            this.addFunction(settings.functions[i]);
          }
          continue;
        case 'graphical':
          if (settings[p] && !settings.hasOwnProperty('precision')) {
            this.precision = 'unsigned';
          }
          this[p] = settings[p];
          continue;
        case 'removeIstanbulCoverage':
          if (settings[p] !== null) {
            this[p] = settings[p];
          }
          continue;
        case 'nativeFunctions':
          if (!settings.nativeFunctions) continue;
          this.nativeFunctions = [];
          for (let i = 0; i < settings.nativeFunctions.length; i++) {
            const s = settings.nativeFunctions[i];
            const { name, source } = s;
            this.addNativeFunction(name, source, s);
          }
          continue;
      }
      this[p] = settings[p];
    }

    if (!this.canvas) this.canvas = this.initCanvas();
    if (!this.context) this.context = this.initContext();
    if (!this.plugins) this.plugins = this.initPlugins(settings);
  }
  build() {
    throw new Error(`"build" not defined on ${ this.constructor.name }`);
  }

  run() {
    throw new Error(`"run" not defined on ${ this.constructor.name }`)
  }

  initCanvas() {
    throw new Error(`"initCanvas" not defined on ${ this.constructor.name }`);
  }

  initContext() {
    throw new Error(`"initContext" not defined on ${ this.constructor.name }`);
  }

  initPlugins(settings) {
    throw new Error(`"initPlugins" not defined on ${ this.constructor.name }`);
  }

  addFunction(source, settings = {}) {
    if (source.name && source.source && source.argumentTypes && 'returnType' in source) {
      this.functions.push(source);
    } else if ('settings' in source && 'source' in source) {
      this.functions.push(this.functionToIGPUFunction(source.source, source.settings));
    } else if (typeof source === 'string' || typeof source === 'function') {
      this.functions.push(this.functionToIGPUFunction(source, settings));
    } else {
      throw new Error(`function not properly defined`);
    }
    return this;
  }

  addNativeFunction(name, source, settings = {}) {
    const { argumentTypes, argumentNames } = settings.argumentTypes ?
      splitArgumentTypes(settings.argumentTypes) :
      this.constructor.nativeFunctionArguments(source) || {};
    this.nativeFunctions.push({
      name,
      source,
      settings,
      argumentTypes,
      argumentNames,
      returnType: settings.returnType || this.constructor.nativeFunctionReturnType(source)
    });
    return this;
  }

  setupArguments(args) {
    this.kernelArguments = [];
    if (!this.argumentTypes) {
      if (!this.argumentTypes) {
        this.argumentTypes = [];
        for (let i = 0; i < args.length; i++) {
          const argType = utils.getVariableType(args[i], this.strictIntegers);
          const type = argType === 'Integer' ? 'Number' : argType;
          this.argumentTypes.push(type);
          this.kernelArguments.push({
            type
          });
        }
      }
    } else {
      for (let i = 0; i < this.argumentTypes.length; i++) {
        this.kernelArguments.push({
          type: this.argumentTypes[i]
        });
      }
    }

    this.argumentSizes = new Array(args.length);
    this.argumentBitRatios = new Int32Array(args.length);

    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      this.argumentSizes[i] = arg.constructor === Input ? arg.size : null;
      this.argumentBitRatios[i] = this.getBitRatio(arg);
    }

    if (this.argumentNames.length !== args.length) {
      throw new Error(`arguments are miss-aligned`);
    }
  }

  setupConstants() {
    this.kernelConstants = [];
    let needsConstantTypes = this.constantTypes === null;
    if (needsConstantTypes) {
      this.constantTypes = {};
    }
    this.constantBitRatios = {};
    if (this.constants) {
      for (let name in this.constants) {
        if (needsConstantTypes) {
          const type = utils.getVariableType(this.constants[name], this.strictIntegers);
          this.constantTypes[name] = type;
          this.kernelConstants.push({
            name,
            type
          });
        } else {
          this.kernelConstants.push({
            name,
            type: this.constantTypes[name]
          });
        }
        this.constantBitRatios[name] = this.getBitRatio(this.constants[name]);
      }
    }
  }

  setOptimizeFloatMemory(flag) {
    this.optimizeFloatMemory = flag;
    return this;
  }

  toKernelOutput(output) {
    if (output.hasOwnProperty('x')) {
      if (output.hasOwnProperty('y')) {
        if (output.hasOwnProperty('z')) {
          return [output.x, output.y, output.z];
        } else {
          return [output.x, output.y];
        }
      } else {
        return [output.x];
      }
    } else {
      return output;
    }
  }

  setOutput(output) {
    this.output = this.toKernelOutput(output);
    return this;
  }

  setDebug(flag) {
    this.debug = flag;
    return this;
  }

  setGraphical(flag) {
    this.graphical = flag;
    this.precision = 'unsigned';
    return this;
  }

  setLoopMaxIterations(max) {
    this.loopMaxIterations = max;
    return this;
  }

  setConstants(constants) {
    this.constants = constants;
    return this;
  }

  setConstantTypes(constantTypes) {
    this.constantTypes = constantTypes;
    return this;
  }

  setFunctions(functions) {
    for (let i = 0; i < functions.length; i++) {
      this.addFunction(functions[i]);
    }
    return this;
  }

  setNativeFunctions(nativeFunctions) {
    for (let i = 0; i < nativeFunctions.length; i++) {
      const settings = nativeFunctions[i];
      const { name, source } = settings;
      this.addNativeFunction(name, source, settings);
    }
    return this;
  }

  setInjectedNative(injectedNative) {
    this.injectedNative = injectedNative;
    return this;
  }

  setPipeline(flag) {
    this.pipeline = flag;
    return this;
  }

  setPrecision(flag) {
    this.precision = flag;
    return this;
  }

  setDimensions(flag) {
    utils.warnDeprecated('method', 'setDimensions', 'setOutput');
    this.output = flag;
    return this;
  }

  setOutputToTexture(flag) {
    utils.warnDeprecated('method', 'setOutputToTexture', 'setPipeline');
    this.pipeline = flag;
    return this;
  }

  setImmutable(flag) {
    this.immutable = flag;
    return this;
  }

  setCanvas(canvas) {
    this.canvas = canvas;
    return this;
  }

  setStrictIntegers(flag) {
    this.strictIntegers = flag;
    return this;
  }

  setDynamicOutput(flag) {
    this.dynamicOutput = flag;
    return this;
  }

  setHardcodeConstants(flag) {
    utils.warnDeprecated('method', 'setHardcodeConstants');
    this.setDynamicOutput(flag);
    this.setDynamicArguments(flag);
    return this;
  }

  setDynamicArguments(flag) {
    this.dynamicArguments = flag;
    return this;
  }

  setUseLegacyEncoder(flag) {
    this.useLegacyEncoder = flag;
    return this;
  }

  setWarnVarUsage(flag) {
    utils.warnDeprecated('method', 'setWarnVarUsage');
    return this;
  }

  getCanvas() {
    utils.warnDeprecated('method', 'getCanvas');
    return this.canvas;
  }

  getWebGl() {
    utils.warnDeprecated('method', 'getWebGl');
    return this.context;
  }

  setContext(context) {
    this.context = context;
    return this;
  }

  setArgumentTypes(argumentTypes) {
    if (Array.isArray(argumentTypes)) {
      this.argumentTypes = argumentTypes;
    } else {
      this.argumentTypes = [];
      for (const p in argumentTypes) {
        if (!argumentTypes.hasOwnProperty(p)) continue;
        const argumentIndex = this.argumentNames.indexOf(p);
        if (argumentIndex === -1) throw new Error(`unable to find argument ${ p }`);
        this.argumentTypes[argumentIndex] = argumentTypes[p];
      }
    }
    return this;
  }

  setTactic(tactic) {
    this.tactic = tactic;
    return this;
  }

  requestFallback(args) {
    if (!this.onRequestFallback) {
      throw new Error(`"onRequestFallback" not defined on ${ this.constructor.name }`);
    }
    this.fallbackRequested = true;
    return this.onRequestFallback(args);
  }

  validateSettings() {
    throw new Error(`"validateSettings" not defined on ${ this.constructor.name }`);
  }

  addSubKernel(subKernel) {
    if (this.subKernels === null) {
      this.subKernels = [];
    }
    if (!subKernel.source) throw new Error('subKernel missing "source" property');
    if (!subKernel.property && isNaN(subKernel.property)) throw new Error('subKernel missing "property" property');
    if (!subKernel.name) throw new Error('subKernel missing "name" property');
    this.subKernels.push(subKernel);
    return this;
  }

  destroy(removeCanvasReferences) {
    throw new Error(`"destroy" called on ${ this.constructor.name }`);
  }

  getBitRatio(value) {
    if (this.precision === 'single') {
      return 4;
    } else if (Array.isArray(value[0])) {
      return this.getBitRatio(value[0]);
    } else if (value.constructor === Input) {
      return this.getBitRatio(value.value);
    }
    switch (value.constructor) {
      case Uint8ClampedArray:
      case Uint8Array:
      case Int8Array:
        return 1;
      case Uint16Array:
      case Int16Array:
        return 2;
      case Float32Array:
      case Int32Array:
      default:
        return 4;
    }
  }

  getPixels(flip) {
    throw new Error(`"getPixels" called on ${ this.constructor.name }`);
  }

  checkOutput() {
    if (!this.output || !utils.isArray(this.output)) throw new Error('kernel.output not an array');
    if (this.output.length < 1) throw new Error('kernel.output is empty, needs at least 1 value');
    for (let i = 0; i < this.output.length; i++) {
      if (isNaN(this.output[i]) || this.output[i] < 1) {
        throw new Error(`${ this.constructor.name }.output[${ i }] incorrectly defined as \`${ this.output[i] }\`, needs to be numeric, and greater than 0`);
      }
    }
  }

  prependString(value) {
    throw new Error(`"prependString" called on ${ this.constructor.name }`);
  }

  hasPrependString(value) {
    throw new Error(`"hasPrependString" called on ${ this.constructor.name }`);
  }

  toJSON() {
    return {
      settings: {
        output: this.output,
        pipeline: this.pipeline,
        argumentNames: this.argumentNames,
        argumentsTypes: this.argumentTypes,
        constants: this.constants,
        pluginNames: this.plugins ? this.plugins.map(plugin => plugin.name) : null,
        returnType: this.returnType,
      }
    };
  }

  buildSignature(args) {
    const Constructor = this.constructor;
    this.signature = Constructor.getSignature(this, Constructor.getArgumentTypes(this, args));
  }

  static getArgumentTypes(kernel, args) {
    const argumentTypes = new Array(args.length);
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      const type = kernel.argumentTypes[i];
      if (arg.type) {
        argumentTypes[i] = arg.type;
      } else {
        switch (type) {
          case 'Number':
          case 'Integer':
          case 'Float':
          case 'ArrayTexture(1)':
            argumentTypes[i] = utils.getVariableType(arg);
            break;
          default:
            argumentTypes[i] = type;
        }
      }
    }
    return argumentTypes;
  }

  static getSignature(kernel, argumentTypes) {
    throw new Error(`"getSignature" not implemented on ${ this.name }`);
  }

  functionToIGPUFunction(source, settings = {}) {
    if (typeof source !== 'string' && typeof source !== 'function') throw new Error('source not a string or function');
    const sourceString = typeof source === 'string' ? source : source.toString();
    let argumentTypes = [];

    if (Array.isArray(settings.argumentTypes)) {
      argumentTypes = settings.argumentTypes;
    } else if (typeof settings.argumentTypes === 'object') {
      argumentTypes = utils.getArgumentNamesFromString(sourceString)
        .map(name => settings.argumentTypes[name]) || [];
    } else {
      argumentTypes = settings.argumentTypes || [];
    }

    return {
      name: utils.getFunctionNameFromString(sourceString) || null,
      source: sourceString,
      argumentTypes,
      returnType: settings.returnType || null,
    };
  }

  onActivate(previousKernel) {}
}

function splitArgumentTypes(argumentTypesObject) {
  const argumentNames = Object.keys(argumentTypesObject);
  const argumentTypes = [];
  for (let i = 0; i < argumentNames.length; i++) {
    const argumentName = argumentNames[i];
    argumentTypes.push(argumentTypesObject[argumentName]);
  }
  return { argumentTypes, argumentNames };
}

module.exports = {
  Kernel
};
},{"../input":110,"../utils":114}],37:[function(require,module,exports){
const fragmentShader = `__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

varying vec2 vTexCoord;

float acosh(float x) {
  return log(x + sqrt(x * x - 1.0));
}

float sinh(float x) {
  return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;
}

float asinh(float x) {
  return log(x + sqrt(x * x + 1.0));
}

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float atanh(float x) {
  x = (x + 1.0) / (x - 1.0);
  if (x < 0.0) {
    return 0.5 * log(-x);
  }
  return 0.5 * log(x);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float cosh(float x) {
  return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; 
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float tanh(float x) {
  float e = exp(2.0 * x);
  return (e - 1.0) / (e + 1.0);
}

float trunc(float x) {
  if (x >= 0.0) {
    return floor(x); 
  } else {
    return ceil(x);
  }
}

vec4 _round(vec4 x) {
  return floor(x + 0.5);
}

float _round(float x) {
  return floor(x + 0.5);
}

const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x / y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(_round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;
  if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;
  return 0.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  if (channel == 0) return texel.r * 255.0;
  if (channel == 1) return texel.g * 255.0;
  if (channel == 2) return texel.b * 255.0;
  if (channel == 3) return texel.a * 255.0;
  return 0.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return texel.r;
  if (channel == 1) return texel.g;
  if (channel == 2) return texel.b;
  if (channel == 3) return texel.a;
  return 0.0;
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture2D(tex, st / vec2(texSize));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
  
  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

void color(sampler2D image) {
  actualColor = texture2D(image, vTexCoord);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;

module.exports = {
  fragmentShader
};
},{}],38:[function(require,module,exports){
const { utils } = require('../../utils');
const { FunctionNode } = require('../function-node');

class WebGLFunctionNode extends FunctionNode {
  constructor(source, settings) {
    super(source, settings);
    if (settings && settings.hasOwnProperty('fixIntegerDivisionAccuracy')) {
      this.fixIntegerDivisionAccuracy = settings.fixIntegerDivisionAccuracy;
    }
  }

  astConditionalExpression(ast, retArr) {
    if (ast.type !== 'ConditionalExpression') {
      throw this.astErrorOutput('Not a conditional expression', ast);
    }
    const consequentType = this.getType(ast.consequent);
    const alternateType = this.getType(ast.alternate);
    if (consequentType === null && alternateType === null) {
      retArr.push('if (');
      this.astGeneric(ast.test, retArr);
      retArr.push(') {');
      this.astGeneric(ast.consequent, retArr);
      retArr.push(';');
      retArr.push('} else {');
      this.astGeneric(ast.alternate, retArr);
      retArr.push(';');
      retArr.push('}');
      return retArr;
    }
    retArr.push('(');
    this.astGeneric(ast.test, retArr);
    retArr.push('?');
    this.astGeneric(ast.consequent, retArr);
    retArr.push(':');
    this.astGeneric(ast.alternate, retArr);
    retArr.push(')');
    return retArr;
  }

  astFunction(ast, retArr) {
    if (this.isRootKernel) {
      retArr.push('void');
    } else {
      if (!this.returnType) {
        const lastReturn = this.findLastReturn();
        if (lastReturn) {
          this.returnType = this.getType(ast.body);
          if (this.returnType === 'LiteralInteger') {
            this.returnType = 'Number';
          }
        }
      }

      const { returnType } = this;
      if (!returnType) {
        retArr.push('void');
      } else {
        const type = typeMap[returnType];
        if (!type) {
          throw new Error(`unknown type ${returnType}`);
        }
        retArr.push(type);
      }
    }
    retArr.push(' ');
    retArr.push(this.name);
    retArr.push('(');

    if (!this.isRootKernel) {
      for (let i = 0; i < this.argumentNames.length; ++i) {
        const argumentName = this.argumentNames[i];

        if (i > 0) {
          retArr.push(', ');
        }
        let argumentType = this.argumentTypes[this.argumentNames.indexOf(argumentName)];
        if (!argumentType) {
          throw this.astErrorOutput(`Unknown argument ${argumentName} type`, ast);
        }
        if (argumentType === 'LiteralInteger') {
          this.argumentTypes[i] = argumentType = 'Number';
        }
        const type = typeMap[argumentType];
        if (!type) {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        const name = utils.sanitizeName(argumentName);
        if (type === 'sampler2D' || type === 'sampler2DArray') {
          retArr.push(`${type} user_${name},ivec2 user_${name}Size,ivec3 user_${name}Dim`);
        } else {
          retArr.push(`${type} user_${name}`);
        }
      }
    }

    retArr.push(') {\n');

    for (let i = 0; i < ast.body.body.length; ++i) {
      this.astGeneric(ast.body.body[i], retArr);
      retArr.push('\n');
    }

    retArr.push('}\n');
    return retArr;
  }

  astReturnStatement(ast, retArr) {
    if (!ast.argument) throw this.astErrorOutput('Unexpected return statement', ast);
    this.pushState('skip-literal-correction');
    const type = this.getType(ast.argument);
    this.popState('skip-literal-correction');

    const result = [];

    if (!this.returnType) {
      if (type === 'LiteralInteger' || type === 'Integer') {
        this.returnType = 'Number';
      } else {
        this.returnType = type;
      }
    }

    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Float':
        switch (type) {
          case 'Integer':
            result.push('float(');
            this.astGeneric(ast.argument, result);
            result.push(')');
            break;
          case 'LiteralInteger':
            this.castLiteralToFloat(ast.argument, result);

            if (this.getType(ast) === 'Integer') {
              result.unshift('float(');
              result.push(')');
            }
            break;
          default:
            this.astGeneric(ast.argument, result);
        }
        break;
      case 'Integer':
        switch (type) {
          case 'Float':
          case 'Number':
            this.castValueToInteger(ast.argument, result);
            break;
          case 'LiteralInteger':
            this.castLiteralToInteger(ast.argument, result);
            break;
          default:
            this.astGeneric(ast.argument, result);
        }
        break;
      case 'Array(4)':
      case 'Array(3)':
      case 'Array(2)':
      case 'Input':
        this.astGeneric(ast.argument, result);
        break;
      default:
        throw this.astErrorOutput(`unhandled return type ${this.returnType}`, ast);
    }

    if (this.isRootKernel) {
      retArr.push(`kernelResult = ${ result.join('') };`);
      retArr.push('return;');
    } else if (this.isSubKernel) {
      retArr.push(`subKernelResult_${ this.name } = ${ result.join('') };`);
      retArr.push(`return subKernelResult_${ this.name };`);
    } else {
      retArr.push(`return ${ result.join('') };`);
    }
    return retArr;
  }

  astLiteral(ast, retArr) {
    if (isNaN(ast.value)) {
      throw this.astErrorOutput(
        'Non-numeric literal not supported : ' + ast.value,
        ast
      );
    }

    const key = this.astKey(ast);
    if (Number.isInteger(ast.value)) {
      if (this.isState('casting-to-integer') || this.isState('building-integer')) {
        this.literalTypes[key] = 'Integer';
        retArr.push(`${ast.value}`);
      } else if (this.isState('casting-to-float') || this.isState('building-float')) {
        this.literalTypes[key] = 'Number';
        retArr.push(`${ast.value}.0`);
      } else {
        this.literalTypes[key] = 'Number';
        retArr.push(`${ast.value}.0`);
      }
    } else if (this.isState('casting-to-integer') || this.isState('building-integer')) {
      this.literalTypes[key] = 'Integer';
      retArr.push(Math.round(ast.value));
    } else {
      this.literalTypes[key] = 'Number';
      retArr.push(`${ast.value}`);
    }
    return retArr;
  }

  astBinaryExpression(ast, retArr) {
    if (this.checkAndUpconvertOperator(ast, retArr)) {
      return retArr;
    }

    if (this.fixIntegerDivisionAccuracy && ast.operator === '/') {
      retArr.push('divWithIntCheck(');
      this.pushState('building-float');
      switch (this.getType(ast.left)) {
        case 'Integer':
          this.castValueToFloat(ast.left, retArr);
          break;
        case 'LiteralInteger':
          this.castLiteralToFloat(ast.left, retArr);
          break;
        default:
          this.astGeneric(ast.left, retArr);
      }
      retArr.push(', ');
      switch (this.getType(ast.right)) {
        case 'Integer':
          this.castValueToFloat(ast.right, retArr);
          break;
        case 'LiteralInteger':
          this.castLiteralToFloat(ast.right, retArr);
          break;
        default:
          this.astGeneric(ast.right, retArr);
      }
      this.popState('building-float');
      retArr.push(')');
      return retArr;
    }

    retArr.push('(');
    const leftType = this.getType(ast.left) || 'Number';
    const rightType = this.getType(ast.right) || 'Number';
    if (!leftType || !rightType) {
      throw this.astErrorOutput(`Unhandled binary expression`, ast);
    }
    const key = leftType + ' & ' + rightType;
    switch (key) {
      case 'Integer & Integer':
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-integer');
        break;
      case 'Number & Float':
      case 'Float & Number':
      case 'Float & Float':
      case 'Number & Number':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'LiteralInteger & LiteralInteger':
        if (this.isState('casting-to-integer') || this.isState('building-integer')) {
          this.pushState('building-integer');
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.astGeneric(ast.right, retArr);
          this.popState('building-integer');
        } else {
          this.pushState('building-float');
          this.castLiteralToFloat(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.castLiteralToFloat(ast.right, retArr);
          this.popState('building-float');
        }
        break;

      case 'Integer & Float':
      case 'Integer & Number':
        if (ast.operator === '>' || ast.operator === '<' && ast.right.type === 'Literal') {
          if (!Number.isInteger(ast.right.value)) {
            this.pushState('building-float');
            this.castValueToFloat(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.astGeneric(ast.right, retArr);
            this.popState('building-float');
            break;
          }
        }
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.pushState('casting-to-integer');
        if (ast.right.type === 'Literal') {
          const literalResult = [];
          this.astGeneric(ast.right, literalResult);
          const literalType = this.getType(ast.right);
          if (literalType === 'Integer') {
            retArr.push(literalResult.join(''));
          } else {
            throw this.astErrorOutput(`Unhandled binary expression with literal`, ast);
          }
        } else {
          retArr.push('int(');
          this.astGeneric(ast.right, retArr);
          retArr.push(')');
        }
        this.popState('casting-to-integer');
        this.popState('building-integer');
        break;
      case 'Integer & LiteralInteger':
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castLiteralToInteger(ast.right, retArr);
        this.popState('building-integer');
        break;

      case 'Number & Integer':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castValueToFloat(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'Float & LiteralInteger':
      case 'Number & LiteralInteger':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castLiteralToFloat(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'LiteralInteger & Float':
      case 'LiteralInteger & Number':
        if (this.isState('casting-to-integer')) {
          this.pushState('building-integer');
          this.castLiteralToInteger(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.castValueToInteger(ast.right, retArr);
          this.popState('building-integer');
        } else {
          this.pushState('building-float');
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.pushState('casting-to-float');
          this.astGeneric(ast.right, retArr);
          this.popState('casting-to-float');
          this.popState('building-float');
        }
        break;
      case 'LiteralInteger & Integer':
        this.pushState('building-integer');
        this.castLiteralToInteger(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-integer');
        break;

      case 'Boolean & Boolean':
        this.pushState('building-boolean');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-boolean');
        break;

      case 'Float & Integer':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castValueToFloat(ast.right, retArr);
        this.popState('building-float');
        break;

      default:
        throw this.astErrorOutput(`Unhandled binary expression between ${key}`, ast);
    }
    retArr.push(')');

    return retArr;
  }

  checkAndUpconvertOperator(ast, retArr) {
    const bitwiseResult = this.checkAndUpconvertBitwiseOperators(ast, retArr);
    if (bitwiseResult) {
      return bitwiseResult;
    }
    const upconvertableOperators = {
      '%': this.fixIntegerDivisionAccuracy ? 'integerCorrectionModulo' : 'modulo',
      '**': 'pow',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    switch (this.getType(ast.left)) {
      case 'Integer':
        this.castValueToFloat(ast.left, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToFloat(ast.left, retArr);
        break;
      default:
        this.astGeneric(ast.left, retArr);
    }
    retArr.push(',');
    switch (this.getType(ast.right)) {
      case 'Integer':
        this.castValueToFloat(ast.right, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToFloat(ast.right, retArr);
        break;
      default:
        this.astGeneric(ast.right, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  checkAndUpconvertBitwiseOperators(ast, retArr) {
    const upconvertableOperators = {
      '&': 'bitwiseAnd',
      '|': 'bitwiseOr',
      '^': 'bitwiseXOR',
      '<<': 'bitwiseZeroFillLeftShift',
      '>>': 'bitwiseSignedRightShift',
      '>>>': 'bitwiseZeroFillRightShift',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    const leftType = this.getType(ast.left);
    switch (leftType) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.left, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.left, retArr);
        break;
      default:
        this.astGeneric(ast.left, retArr);
    }
    retArr.push(',');
    const rightType = this.getType(ast.right);
    switch (rightType) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.right, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.right, retArr);
        break;
      default:
        this.astGeneric(ast.right, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  checkAndUpconvertBitwiseUnary(ast, retArr) {
    const upconvertableOperators = {
      '~': 'bitwiseNot',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    switch (this.getType(ast.argument)) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.argument, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.argument, retArr);
        break;
      default:
        this.astGeneric(ast.argument, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  castLiteralToInteger(ast, retArr) {
    this.pushState('casting-to-integer');
    this.astGeneric(ast, retArr);
    this.popState('casting-to-integer');
    return retArr;
  }

  castLiteralToFloat(ast, retArr) {
    this.pushState('casting-to-float');
    this.astGeneric(ast, retArr);
    this.popState('casting-to-float');
    return retArr;
  }

  castValueToInteger(ast, retArr) {
    this.pushState('casting-to-integer');
    retArr.push('int(');
    this.astGeneric(ast, retArr);
    retArr.push(')');
    this.popState('casting-to-integer');
    return retArr;
  }

  castValueToFloat(ast, retArr) {
    this.pushState('casting-to-float');
    retArr.push('float(');
    this.astGeneric(ast, retArr);
    retArr.push(')');
    this.popState('casting-to-float');
    return retArr;
  }

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);
    }

    const type = this.getType(idtNode);

    const name = utils.sanitizeName(idtNode.name);
    if (idtNode.name === 'Infinity') {
      retArr.push('3.402823466e+38');
    } else if (type === 'Boolean') {
      if (this.argumentNames.indexOf(name) > -1) {
        retArr.push(`bool(user_${name})`);
      } else {
        retArr.push(`user_${name}`);
      }
    } else {
      retArr.push(`user_${name}`);
    }

    return retArr;
  }

  astForStatement(forNode, retArr) {
    if (forNode.type !== 'ForStatement') {
      throw this.astErrorOutput('Invalid for statement', forNode);
    }

    const initArr = [];
    const testArr = [];
    const updateArr = [];
    const bodyArr = [];
    let isSafe = null;

    if (forNode.init) {
      const { declarations } = forNode.init;
      if (declarations.length > 1) {
        isSafe = false;
      }
      this.astGeneric(forNode.init, initArr);
      for (let i = 0; i < declarations.length; i++) {
        if (declarations[i].init && declarations[i].init.type !== 'Literal') {
          isSafe = false;
        }
      }
    } else {
      isSafe = false;
    }

    if (forNode.test) {
      this.astGeneric(forNode.test, testArr);
    } else {
      isSafe = false;
    }

    if (forNode.update) {
      this.astGeneric(forNode.update, updateArr);
    } else {
      isSafe = false;
    }

    if (forNode.body) {
      this.pushState('loop-body');
      this.astGeneric(forNode.body, bodyArr);
      this.popState('loop-body');
    }

    if (isSafe === null) {
      isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
    }

    if (isSafe) {
      const initString = initArr.join('');
      const initNeedsSemiColon = initString[initString.length - 1] !== ';';
      retArr.push(`for (${initString}${initNeedsSemiColon ? ';' : ''}${testArr.join('')};${updateArr.join('')}){\n`);
      retArr.push(bodyArr.join(''));
      retArr.push('}\n');
    } else {
      const iVariableName = this.getInternalVariableName('safeI');
      if (initArr.length > 0) {
        retArr.push(initArr.join(''), '\n');
      }
      retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
      if (testArr.length > 0) {
        retArr.push(`if (!${testArr.join('')}) break;\n`);
      }
      retArr.push(bodyArr.join(''));
      retArr.push(`\n${updateArr.join('')};`);
      retArr.push('}\n');
    }
    return retArr;
  }

  astWhileStatement(whileNode, retArr) {
    if (whileNode.type !== 'WhileStatement') {
      throw this.astErrorOutput('Invalid while statement', whileNode);
    }

    const iVariableName = this.getInternalVariableName('safeI');
    retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
    retArr.push('if (!');
    this.astGeneric(whileNode.test, retArr);
    retArr.push(') break;\n');
    this.astGeneric(whileNode.body, retArr);
    retArr.push('}\n');

    return retArr;
  }

  astDoWhileStatement(doWhileNode, retArr) {
    if (doWhileNode.type !== 'DoWhileStatement') {
      throw this.astErrorOutput('Invalid while statement', doWhileNode);
    }

    const iVariableName = this.getInternalVariableName('safeI');
    retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
    this.astGeneric(doWhileNode.body, retArr);
    retArr.push('if (!');
    this.astGeneric(doWhileNode.test, retArr);
    retArr.push(') break;\n');
    retArr.push('}\n');

    return retArr;
  }


  astAssignmentExpression(assNode, retArr) {
    if (assNode.operator === '%=') {
      this.astGeneric(assNode.left, retArr);
      retArr.push('=');
      retArr.push('mod(');
      this.astGeneric(assNode.left, retArr);
      retArr.push(',');
      this.astGeneric(assNode.right, retArr);
      retArr.push(')');
    } else if (assNode.operator === '**=') {
      this.astGeneric(assNode.left, retArr);
      retArr.push('=');
      retArr.push('pow(');
      this.astGeneric(assNode.left, retArr);
      retArr.push(',');
      this.astGeneric(assNode.right, retArr);
      retArr.push(')');
    } else {
      const leftType = this.getType(assNode.left);
      const rightType = this.getType(assNode.right);
      this.astGeneric(assNode.left, retArr);
      retArr.push(assNode.operator);
      if (leftType !== 'Integer' && rightType === 'Integer') {
        retArr.push('float(');
        this.astGeneric(assNode.right, retArr);
        retArr.push(')');
      } else {
        this.astGeneric(assNode.right, retArr);
      }
      return retArr;
    }
  }

  astBlockStatement(bNode, retArr) {
    if (this.isState('loop-body')) {
      this.pushState('block-body'); 
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      this.popState('block-body');
    } else {
      retArr.push('{\n');
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      retArr.push('}\n');
    }
    return retArr;
  }

  astVariableDeclaration(varDecNode, retArr) {
    const declarations = varDecNode.declarations;
    if (!declarations || !declarations[0] || !declarations[0].init) {
      throw this.astErrorOutput('Unexpected expression', varDecNode);
    }
    const result = [];
    let lastType = null;
    const declarationSets = [];
    let declarationSet = [];
    for (let i = 0; i < declarations.length; i++) {
      const declaration = declarations[i];
      const init = declaration.init;
      const info = this.getDeclaration(declaration.id);
      const actualType = this.getType(declaration.init);
      let type = actualType;
      if (type === 'LiteralInteger') {
        if (info.suggestedType === 'Integer') {
          type = 'Integer';
        } else {
          type = 'Number';
        }
      }
      const markupType = typeMap[type];
      if (!markupType) {
        throw this.astErrorOutput(`Markup type ${ markupType } not handled`, varDecNode);
      }
      const declarationResult = [];
      if (actualType === 'Integer' && type === 'Integer') {
        info.valueType = 'Number';
        if (i === 0 || lastType === null) {
          declarationResult.push('float ');
        } else if (type !== lastType) {
          throw new Error('Unhandled declaration');
        }
        lastType = type;
        declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);
        declarationResult.push('float(');
        this.astGeneric(init, declarationResult);
        declarationResult.push(')');
      } else {
        info.valueType = type;
        if (i === 0 || lastType === null) {
          declarationResult.push(`${markupType} `);
        } else if (type !== lastType) {
          declarationSets.push(declarationSet.join(','));
          declarationSet = [];
          declarationResult.push(`${markupType} `);
        }
        lastType = type;
        declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);
        if (actualType === 'Number' && type === 'Integer') {
          if (init.left && init.left.type === 'Literal') {
            this.astGeneric(init, declarationResult);
          } else {
            declarationResult.push('int(');
            this.astGeneric(init, declarationResult);
            declarationResult.push(')');
          }
        } else if (actualType === 'LiteralInteger' && type === 'Integer') {
          this.castLiteralToInteger(init, declarationResult);
        } else {
          this.astGeneric(init, declarationResult);
        }
      }
      declarationSet.push(declarationResult.join(''));
    }

    if (declarationSet.length > 0) {
      declarationSets.push(declarationSet.join(','));
    }

    result.push(declarationSets.join(';'));

    retArr.push(result.join(''));
    retArr.push(';');
    return retArr;
  }

  astIfStatement(ifNode, retArr) {
    retArr.push('if (');
    this.astGeneric(ifNode.test, retArr);
    retArr.push(')');
    if (ifNode.consequent.type === 'BlockStatement') {
      this.astGeneric(ifNode.consequent, retArr);
    } else {
      retArr.push(' {\n');
      this.astGeneric(ifNode.consequent, retArr);
      retArr.push('\n}\n');
    }

    if (ifNode.alternate) {
      retArr.push('else ');
      if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {
        this.astGeneric(ifNode.alternate, retArr);
      } else {
        retArr.push(' {\n');
        this.astGeneric(ifNode.alternate, retArr);
        retArr.push('\n}\n');
      }
    }
    return retArr;
  }

  astSwitchStatement(ast, retArr) {
    if (ast.type !== 'SwitchStatement') {
      throw this.astErrorOutput('Invalid switch statement', ast);
    }
    const { discriminant, cases } = ast;
    const type = this.getType(discriminant);
    const varName = `switchDiscriminant${this.astKey(ast, '_')}`;
    switch (type) {
      case 'Float':
      case 'Number':
        retArr.push(`float ${varName} = `);
        this.astGeneric(discriminant, retArr);
        retArr.push(';\n');
        break;
      case 'Integer':
        retArr.push(`int ${varName} = `);
        this.astGeneric(discriminant, retArr);
        retArr.push(';\n');
        break;
    }
    if (cases.length === 1 && !cases[0].test) {
      this.astGeneric(cases[0].consequent, retArr);
      return retArr;
    }

    let fallingThrough = false;
    let defaultResult = [];
    let movingDefaultToEnd = false;
    let pastFirstIf = false;
    for (let i = 0; i < cases.length; i++) {
      if (!cases[i].test) {
        if (cases.length > i + 1) {
          movingDefaultToEnd = true;
          this.astGeneric(cases[i].consequent, defaultResult);
          continue;
        } else {
          retArr.push(' else {\n');
        }
      } else {
        if (i === 0 || !pastFirstIf) {
          pastFirstIf = true;
          retArr.push(`if (${varName} == `);
        } else {
          if (fallingThrough) {
            retArr.push(`${varName} == `);
            fallingThrough = false;
          } else {
            retArr.push(` else if (${varName} == `);
          }
        }
        if (type === 'Integer') {
          const testType = this.getType(cases[i].test);
          switch (testType) {
            case 'Number':
            case 'Float':
              this.castValueToInteger(cases[i].test, retArr);
              break;
            case 'LiteralInteger':
              this.castLiteralToInteger(cases[i].test, retArr);
              break;
          }
        } else if (type === 'Float') {
          const testType = this.getType(cases[i].test);
          switch (testType) {
            case 'LiteralInteger':
              this.castLiteralToFloat(cases[i].test, retArr);
              break;
            case 'Integer':
              this.castValueToFloat(cases[i].test, retArr);
              break;
          }
        } else {
          throw new Error('unhanlded');
        }
        if (!cases[i].consequent || cases[i].consequent.length === 0) {
          fallingThrough = true;
          retArr.push(' || ');
          continue;
        }
        retArr.push(`) {\n`);
      }
      this.astGeneric(cases[i].consequent, retArr);
      retArr.push('\n}');
    }
    if (movingDefaultToEnd) {
      retArr.push(' else {');
      retArr.push(defaultResult.join(''));
      retArr.push('}');
    }
    return retArr;
  }

  astThisExpression(tNode, retArr) {
    retArr.push('this');
    return retArr;
  }

  astMemberExpression(mNode, retArr) {
    const {
      property,
      name,
      signature,
      origin,
      type,
      xProperty,
      yProperty,
      zProperty
    } = this.getMemberExpressionDetails(mNode);
    switch (signature) {
      case 'value.thread.value':
      case 'this.thread.value':
        if (name !== 'x' && name !== 'y' && name !== 'z') {
          throw this.astErrorOutput('Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`', mNode);
        }
        retArr.push(`threadId.${name}`);
        return retArr;
      case 'this.output.value':
        if (this.dynamicOutput) {
          switch (name) {
            case 'x':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.x)');
              } else {
                retArr.push('uOutputDim.x');
              }
              break;
            case 'y':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.y)');
              } else {
                retArr.push('uOutputDim.y');
              }
              break;
            case 'z':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.z)');
              } else {
                retArr.push('uOutputDim.z');
              }
              break;
            default:
              throw this.astErrorOutput('Unexpected expression', mNode);
          }
        } else {
          switch (name) {
            case 'x':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[0]);
              } else {
                retArr.push(this.output[0], '.0');
              }
              break;
            case 'y':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[1]);
              } else {
                retArr.push(this.output[1], '.0');
              }
              break;
            case 'z':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[2]);
              } else {
                retArr.push(this.output[2], '.0');
              }
              break;
            default:
              throw this.astErrorOutput('Unexpected expression', mNode);
          }
        }
        return retArr;
      case 'value':
        throw this.astErrorOutput('Unexpected expression', mNode);
      case 'value[]':
      case 'value[][]':
      case 'value[][][]':
      case 'value[][][][]':
      case 'value.value':
        if (origin === 'Math') {
          retArr.push(Math[name]);
          return retArr;
        }
        const cleanName = utils.sanitizeName(name);
        switch (property) {
          case 'r':
            retArr.push(`user_${ cleanName }.r`);
            return retArr;
          case 'g':
            retArr.push(`user_${ cleanName }.g`);
            return retArr;
          case 'b':
            retArr.push(`user_${ cleanName }.b`);
            return retArr;
          case 'a':
            retArr.push(`user_${ cleanName }.a`);
            return retArr;
        }
        break;
      case 'this.constants.value':
        if (typeof xProperty === 'undefined') {
          switch (type) {
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              retArr.push(`constants_${ utils.sanitizeName(name) }`);
              return retArr;
          }
        }
        case 'this.constants.value[]':
        case 'this.constants.value[][]':
        case 'this.constants.value[][][]':
        case 'this.constants.value[][][][]':
          break;
        case 'fn()[]':
          this.astCallExpression(mNode.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(property));
          retArr.push(']');
          return retArr;
        case '[][]':
          this.astArrayExpression(mNode.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(property));
          retArr.push(']');
          return retArr;
        case 'value.value[]':
        case 'value.value[][]':
          if (this.removeIstanbulCoverage) {
            return retArr;
          }
          default:
            throw this.astErrorOutput('Unexpected expression', mNode);
    }

    if (mNode.computed === false) {
      switch (type) {
        case 'Number':
        case 'Integer':
        case 'Float':
        case 'Boolean':
          retArr.push(`${origin}_${utils.sanitizeName(name)}`);
          return retArr;
      }
    }

    const markupName = `${origin}_${utils.sanitizeName(name)}`;

    switch (type) {
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
        this.astGeneric(mNode.object, retArr);
        retArr.push('[');
        retArr.push(this.memberExpressionPropertyMarkup(xProperty));
        retArr.push(']');
        break;
      case 'HTMLImageArray':
        retArr.push(`getImage3D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(1)':
        retArr.push(`getFloatFromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(2)':
      case 'Array2D(2)':
      case 'Array3D(2)':
        retArr.push(`getMemoryOptimizedVec2(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(2)':
        retArr.push(`getVec2FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(3)':
      case 'Array2D(3)':
      case 'Array3D(3)':
        retArr.push(`getMemoryOptimizedVec3(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(3)':
        retArr.push(`getVec3FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(4)':
      case 'Array2D(4)':
      case 'Array3D(4)':
        retArr.push(`getMemoryOptimizedVec4(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(4)':
      case 'HTMLCanvas':
      case 'HTMLImage':
      case 'HTMLVideo':
        retArr.push(`getVec4FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'NumberTexture':
      case 'Array':
      case 'Array2D':
      case 'Array3D':
      case 'Array4D':
      case 'Input':
      case 'Number':
      case 'Float':
      case 'Integer':
        if (this.precision === 'single') {
          retArr.push(`getMemoryOptimized32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
        } else {
          const bitRatio = (origin === 'user' ?
            this.lookupFunctionArgumentBitRatio(this.name, name) :
            this.constantBitRatios[name]
          );
          switch (bitRatio) {
            case 1:
              retArr.push(`get8(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            case 2:
              retArr.push(`get16(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            case 4:
            case 0:
              retArr.push(`get32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            default:
              throw new Error(`unhandled bit ratio of ${bitRatio}`);
          }
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
        }
        break;
      case 'MemoryOptimizedNumberTexture':
        retArr.push(`getMemoryOptimized32(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      default:
        throw new Error(`unhandled member expression "${ type }"`);
    }
    return retArr;
  }

  astCallExpression(ast, retArr) {
    if (!ast.callee) {
      throw this.astErrorOutput('Unknown CallExpression', ast);
    }

    let functionName = null;
    const isMathFunction = this.isAstMathFunction(ast);

    if (isMathFunction || (ast.callee.object && ast.callee.object.type === 'ThisExpression')) {
      functionName = ast.callee.property.name;
    }
    else if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[0].type === 'Literal' && !isNaN(ast.callee.expressions[0].raw)) {
      functionName = ast.callee.expressions[1].property.name;
    } else {
      functionName = ast.callee.name;
    }

    if (!functionName) {
      throw this.astErrorOutput(`Unhandled function, couldn't find name`, ast);
    }

    switch (functionName) {
      case 'pow':
        functionName = '_pow';
        break;
      case 'round':
        functionName = '_round';
        break;
    }

    if (this.calledFunctions.indexOf(functionName) < 0) {
      this.calledFunctions.push(functionName);
    }

    if (functionName === 'random' && this.plugins && this.plugins.length > 0) {
      for (let i = 0; i < this.plugins.length; i++) {
        const plugin = this.plugins[i];
        if (plugin.functionMatch === 'Math.random()' && plugin.functionReplace) {
          retArr.push(plugin.functionReplace);
          return retArr;
        }
      }
    }

    if (this.onFunctionCall) {
      this.onFunctionCall(this.name, functionName, ast.arguments);
    }

    retArr.push(functionName);

    retArr.push('(');

    if (isMathFunction) {
      for (let i = 0; i < ast.arguments.length; ++i) {
        const argument = ast.arguments[i];
        const argumentType = this.getType(argument);
        if (i > 0) {
          retArr.push(', ');
        }

        switch (argumentType) {
          case 'Integer':
            this.castValueToFloat(argument, retArr);
            break;
          default:
            this.astGeneric(argument, retArr);
            break;
        }
      }
    } else {
      const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
      for (let i = 0; i < ast.arguments.length; ++i) {
        const argument = ast.arguments[i];
        let targetType = targetTypes[i];
        if (i > 0) {
          retArr.push(', ');
        }
        const argumentType = this.getType(argument);
        if (!targetType) {
          this.triggerImplyArgumentType(functionName, i, argumentType, this);
          targetType = argumentType;
        }
        switch (argumentType) {
          case 'Boolean':
            this.astGeneric(argument, retArr);
            continue;
          case 'Number':
          case 'Float':
            if (targetType === 'Integer') {
              retArr.push('int(');
              this.astGeneric(argument, retArr);
              retArr.push(')');
              continue;
            } else if (targetType === 'Number' || targetType === 'Float') {
              this.astGeneric(argument, retArr);
              continue;
            } else if (targetType === 'LiteralInteger') {
              this.castLiteralToFloat(argument, retArr);
              continue;
            }
            break;
          case 'Integer':
            if (targetType === 'Number' || targetType === 'Float') {
              retArr.push('float(');
              this.astGeneric(argument, retArr);
              retArr.push(')');
              continue;
            } else if (targetType === 'Integer') {
              this.astGeneric(argument, retArr);
              continue;
            }
            break;
          case 'LiteralInteger':
            if (targetType === 'Integer') {
              this.castLiteralToInteger(argument, retArr);
              continue;
            } else if (targetType === 'Number' || targetType === 'Float') {
              this.castLiteralToFloat(argument, retArr);
              continue;
            } else if (targetType === 'LiteralInteger') {
              this.astGeneric(argument, retArr);
              continue;
            }
            break;
          case 'Array(2)':
          case 'Array(3)':
          case 'Array(4)':
            if (targetType === argumentType) {
              if (argument.type === 'Identifier') {
                retArr.push(`user_${utils.sanitizeName(argument.name)}`);
              } else if (argument.type === 'ArrayExpression' || argument.type === 'MemberExpression' || argument.type === 'CallExpression') {
                this.astGeneric(argument, retArr);
              } else {
                throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);
              }
              continue;
            }
            break;
          case 'HTMLCanvas':
          case 'HTMLImage':
          case 'HTMLImageArray':
          case 'HTMLVideo':
          case 'ArrayTexture(1)':
          case 'ArrayTexture(2)':
          case 'ArrayTexture(3)':
          case 'ArrayTexture(4)':
          case 'Array':
          case 'Input':
            if (targetType === argumentType) {
              if (argument.type !== 'Identifier') throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);
              this.triggerImplyArgumentBitRatio(this.name, argument.name, functionName, i);
              const name = utils.sanitizeName(argument.name);
              retArr.push(`user_${name},user_${name}Size,user_${name}Dim`);
              continue;
            }
            break;
        }
        throw this.astErrorOutput(`Unhandled argument combination of ${ argumentType } and ${ targetType } for argument named "${ argument.name }"`, ast);
      }
    }
    retArr.push(')');

    return retArr;
  }

  astArrayExpression(arrNode, retArr) {
    const arrLen = arrNode.elements.length;

    retArr.push('vec' + arrLen + '(');
    for (let i = 0; i < arrLen; ++i) {
      if (i > 0) {
        retArr.push(', ');
      }
      const subNode = arrNode.elements[i];
      this.astGeneric(subNode, retArr)
    }
    retArr.push(')');

    return retArr;
  }

  memberExpressionXYZ(x, y, z, retArr) {
    if (z) {
      retArr.push(this.memberExpressionPropertyMarkup(z), ', ');
    } else {
      retArr.push('0, ');
    }
    if (y) {
      retArr.push(this.memberExpressionPropertyMarkup(y), ', ');
    } else {
      retArr.push('0, ');
    }
    retArr.push(this.memberExpressionPropertyMarkup(x));
    return retArr;
  }

  memberExpressionPropertyMarkup(property) {
    if (!property) {
      throw new Error('Property not set');
    }
    const type = this.getType(property);
    const result = [];
    switch (type) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(property, result);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(property, result);
        break;
      default:
        this.astGeneric(property, result);
    }
    return result.join('');
  }
}

const typeMap = {
  'Array': 'sampler2D',
  'Array(2)': 'vec2',
  'Array(3)': 'vec3',
  'Array(4)': 'vec4',
  'Array2D': 'sampler2D',
  'Array3D': 'sampler2D',
  'Boolean': 'bool',
  'Float': 'float',
  'Input': 'sampler2D',
  'Integer': 'int',
  'Number': 'float',
  'LiteralInteger': 'float',
  'NumberTexture': 'sampler2D',
  'MemoryOptimizedNumberTexture': 'sampler2D',
  'ArrayTexture(1)': 'sampler2D',
  'ArrayTexture(2)': 'sampler2D',
  'ArrayTexture(3)': 'sampler2D',
  'ArrayTexture(4)': 'sampler2D',
  'HTMLVideo': 'sampler2D',
  'HTMLCanvas': 'sampler2D',
  'HTMLImage': 'sampler2D',
  'HTMLImageArray': 'sampler2DArray',
};

const operatorMap = {
  '===': '==',
  '!==': '!='
};

module.exports = {
  WebGLFunctionNode
};
},{"../../utils":114,"../function-node":10}],39:[function(require,module,exports){
const { WebGLKernelValueBoolean } = require('./kernel-value/boolean');
const { WebGLKernelValueFloat } = require('./kernel-value/float');
const { WebGLKernelValueInteger } = require('./kernel-value/integer');

const { WebGLKernelValueHTMLImage } = require('./kernel-value/html-image');
const { WebGLKernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');

const { WebGLKernelValueHTMLVideo } = require('./kernel-value/html-video');
const { WebGLKernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');

const { WebGLKernelValueSingleInput } = require('./kernel-value/single-input');
const { WebGLKernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');

const { WebGLKernelValueUnsignedInput } = require('./kernel-value/unsigned-input');
const { WebGLKernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');

const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');
const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');

const { WebGLKernelValueNumberTexture } = require('./kernel-value/number-texture');
const { WebGLKernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');

const { WebGLKernelValueSingleArray } = require('./kernel-value/single-array');
const { WebGLKernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');

const { WebGLKernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');
const { WebGLKernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');

const { WebGLKernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');
const { WebGLKernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');

const { WebGLKernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');
const { WebGLKernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');

const { WebGLKernelValueSingleArray2 } = require('./kernel-value/single-array2');
const { WebGLKernelValueSingleArray3 } = require('./kernel-value/single-array3');
const { WebGLKernelValueSingleArray4 } = require('./kernel-value/single-array4');

const { WebGLKernelValueUnsignedArray } = require('./kernel-value/unsigned-array');
const { WebGLKernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');

const kernelValueMaps = {
  unsigned: {
    dynamic: {
      'Boolean': WebGLKernelValueBoolean,
      'Integer': WebGLKernelValueInteger,
      'Float': WebGLKernelValueFloat,
      'Array': WebGLKernelValueDynamicUnsignedArray,
      'Array(2)': false,
      'Array(3)': false,
      'Array(4)': false,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGLKernelValueDynamicUnsignedInput,
      'NumberTexture': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,
      'HTMLImage': WebGLKernelValueDynamicHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGLKernelValueBoolean,
      'Float': WebGLKernelValueFloat,
      'Integer': WebGLKernelValueInteger,
      'Array': WebGLKernelValueUnsignedArray,
      'Array(2)': false,
      'Array(3)': false,
      'Array(4)': false,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGLKernelValueUnsignedInput,
      'NumberTexture': WebGLKernelValueNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueHTMLImage,
      'HTMLImage': WebGLKernelValueHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueHTMLVideo,
    }
  },
  single: {
    dynamic: {
      'Boolean': WebGLKernelValueBoolean,
      'Integer': WebGLKernelValueInteger,
      'Float': WebGLKernelValueFloat,
      'Array': WebGLKernelValueDynamicSingleArray,
      'Array(2)': WebGLKernelValueSingleArray2,
      'Array(3)': WebGLKernelValueSingleArray3,
      'Array(4)': WebGLKernelValueSingleArray4,
      'Array1D(2)': WebGLKernelValueDynamicSingleArray1DI,
      'Array1D(3)': WebGLKernelValueDynamicSingleArray1DI,
      'Array1D(4)': WebGLKernelValueDynamicSingleArray1DI,
      'Array2D(2)': WebGLKernelValueDynamicSingleArray2DI,
      'Array2D(3)': WebGLKernelValueDynamicSingleArray2DI,
      'Array2D(4)': WebGLKernelValueDynamicSingleArray2DI,
      'Array3D(2)': WebGLKernelValueDynamicSingleArray3DI,
      'Array3D(3)': WebGLKernelValueDynamicSingleArray3DI,
      'Array3D(4)': WebGLKernelValueDynamicSingleArray3DI,
      'Input': WebGLKernelValueDynamicSingleInput,
      'NumberTexture': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,
      'HTMLImage': WebGLKernelValueDynamicHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGLKernelValueBoolean,
      'Float': WebGLKernelValueFloat,
      'Integer': WebGLKernelValueInteger,
      'Array': WebGLKernelValueSingleArray,
      'Array(2)': WebGLKernelValueSingleArray2,
      'Array(3)': WebGLKernelValueSingleArray3,
      'Array(4)': WebGLKernelValueSingleArray4,
      'Array1D(2)': WebGLKernelValueSingleArray1DI,
      'Array1D(3)': WebGLKernelValueSingleArray1DI,
      'Array1D(4)': WebGLKernelValueSingleArray1DI,
      'Array2D(2)': WebGLKernelValueSingleArray2DI,
      'Array2D(3)': WebGLKernelValueSingleArray2DI,
      'Array2D(4)': WebGLKernelValueSingleArray2DI,
      'Array3D(2)': WebGLKernelValueSingleArray3DI,
      'Array3D(3)': WebGLKernelValueSingleArray3DI,
      'Array3D(4)': WebGLKernelValueSingleArray3DI,
      'Input': WebGLKernelValueSingleInput,
      'NumberTexture': WebGLKernelValueNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueHTMLImage,
      'HTMLImage': WebGLKernelValueHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueHTMLVideo,
    }
  },
};

function lookupKernelValueType(type, dynamic, precision, value) {
  if (!type) {
    throw new Error('type missing');
  }
  if (!dynamic) {
    throw new Error('dynamic missing');
  }
  if (!precision) {
    throw new Error('precision missing');
  }
  if (value.type) {
    type = value.type;
  }
  const types = kernelValueMaps[precision][dynamic];
  if (types[type] === false) {
    return null;
  } else if (types[type] === undefined) {
    throw new Error(`Could not find a KernelValue for ${ type }`);
  }
  return types[type];
}

module.exports = {
  lookupKernelValueType,
  kernelValueMaps,
};
},{"./kernel-value/boolean":41,"./kernel-value/dynamic-html-image":42,"./kernel-value/dynamic-html-video":43,"./kernel-value/dynamic-memory-optimized-number-texture":44,"./kernel-value/dynamic-number-texture":45,"./kernel-value/dynamic-single-array":46,"./kernel-value/dynamic-single-array1d-i":47,"./kernel-value/dynamic-single-array2d-i":48,"./kernel-value/dynamic-single-array3d-i":49,"./kernel-value/dynamic-single-input":50,"./kernel-value/dynamic-unsigned-array":51,"./kernel-value/dynamic-unsigned-input":52,"./kernel-value/float":53,"./kernel-value/html-image":54,"./kernel-value/html-video":55,"./kernel-value/integer":57,"./kernel-value/memory-optimized-number-texture":58,"./kernel-value/number-texture":59,"./kernel-value/single-array":60,"./kernel-value/single-array1d-i":61,"./kernel-value/single-array2":62,"./kernel-value/single-array2d-i":63,"./kernel-value/single-array3":64,"./kernel-value/single-array3d-i":65,"./kernel-value/single-array4":66,"./kernel-value/single-input":67,"./kernel-value/unsigned-array":68,"./kernel-value/unsigned-input":69}],40:[function(require,module,exports){
const { WebGLKernelValue } = require('./index');
const { Input } = require('../../../input');

class WebGLKernelArray extends WebGLKernelValue {
  checkSize(width, height) {
    if (!this.kernel.validate) return;
    const { maxTextureSize } = this.kernel.constructor.features;
    if (width > maxTextureSize || height > maxTextureSize) {
      if (width > height) {
        throw new Error(`Argument texture width of ${width} larger than maximum size of ${maxTextureSize} for your GPU`);
      } else if (width < height) {
        throw new Error(`Argument texture height of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);
      } else {
        throw new Error(`Argument texture height and width of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);
      }
    }
  }

  setup() {
    this.requestTexture();
    this.setupTexture();
    this.defineTexture();
  }

  requestTexture() {
    this.texture = this.onRequestTexture();
  }

  defineTexture() {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  }

  setupTexture() {
    this.contextHandle = this.onRequestContextHandle();
    this.index = this.onRequestIndex();
    this.dimensionsId = this.id + 'Dim';
    this.sizeId = this.id + 'Size';
  }

  getBitRatio(value) {
    if (Array.isArray(value[0])) {
      return this.getBitRatio(value[0]);
    } else if (value.constructor === Input) {
      return this.getBitRatio(value.value);
    }
    switch (value.constructor) {
      case Uint8ClampedArray:
      case Uint8Array:
      case Int8Array:
        return 1;
      case Uint16Array:
      case Int16Array:
        return 2;
      case Float32Array:
      case Int32Array:
      default:
        return 4;
    }
  }

  destroy() {
    if (this.prevArg) {
      this.prevArg.delete();
    }
    this.context.deleteTexture(this.texture);
  }
}

module.exports = {
  WebGLKernelArray
};
},{"../../../input":110,"./index":56}],41:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueBoolean extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const bool ${this.id} = ${value};\n`;
    }
    return `uniform bool ${this.id};\n`;
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueBoolean
};
},{"../../../utils":114,"./index":56}],42:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueHTMLImage } = require('./html-image');

class WebGLKernelValueDynamicHTMLImage extends WebGLKernelValueHTMLImage {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    const { width, height } = value;
    this.checkSize(width, height);
    this.dimensions = [width, height, 1];
    this.textureSize = [width, height];
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicHTMLImage
};
},{"../../../utils":114,"./html-image":54}],43:[function(require,module,exports){
const { WebGLKernelValueDynamicHTMLImage } = require('./dynamic-html-image');

class WebGLKernelValueDynamicHTMLVideo extends WebGLKernelValueDynamicHTMLImage {}

module.exports = {
  WebGLKernelValueDynamicHTMLVideo
};
},{"./dynamic-html-image":42}],44:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./memory-optimized-number-texture');

class WebGLKernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(inputTexture) {
    this.dimensions = inputTexture.dimensions;
    this.checkSize(inputTexture.size[0], inputTexture.size[1]);
    this.textureSize = inputTexture.size;
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(inputTexture);
  }
}

module.exports = {
  WebGLKernelValueDynamicMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"./memory-optimized-number-texture":58}],45:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueNumberTexture } = require('./number-texture');

class WebGLKernelValueDynamicNumberTexture extends WebGLKernelValueNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = value.dimensions;
    this.checkSize(value.size[0], value.size[1]);
    this.textureSize = value.size;
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicNumberTexture
};
},{"../../../utils":114,"./number-texture":59}],46:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray } = require('./single-array');

class WebGLKernelValueDynamicSingleArray extends WebGLKernelValueSingleArray {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray
};
},{"../../../utils":114,"./single-array":60}],47:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray1DI } = require('./single-array1d-i');

class WebGLKernelValueDynamicSingleArray1DI extends WebGLKernelValueSingleArray1DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray1DI
};
},{"../../../utils":114,"./single-array1d-i":61}],48:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray2DI } = require('./single-array2d-i');

class WebGLKernelValueDynamicSingleArray2DI extends WebGLKernelValueSingleArray2DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray2DI
};
},{"../../../utils":114,"./single-array2d-i":63}],49:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray3DI } = require('./single-array3d-i');

class WebGLKernelValueDynamicSingleArray3DI extends WebGLKernelValueSingleArray3DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray3DI
};
},{"../../../utils":114,"./single-array3d-i":65}],50:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleInput } = require('./single-input');

class WebGLKernelValueDynamicSingleInput extends WebGLKernelValueSingleInput {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleInput
};
},{"../../../utils":114,"./single-input":67}],51:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedArray } = require('./unsigned-array');

class WebGLKernelValueDynamicUnsignedArray extends WebGLKernelValueUnsignedArray {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    const Type = this.getTransferArrayType(value);
    this.preUploadValue = new Type(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicUnsignedArray
};
},{"../../../utils":114,"./unsigned-array":68}],52:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedInput } = require('./unsigned-input');

class WebGLKernelValueDynamicUnsignedInput extends WebGLKernelValueUnsignedInput {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    const Type = this.getTransferArrayType(value.value);
    this.preUploadValue = new Type(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicUnsignedInput
};
},{"../../../utils":114,"./unsigned-input":69}],53:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueFloat extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      if (Number.isInteger(value)) {
        return `const float ${this.id} = ${value}.0;\n`;
      }
      return `const float ${this.id} = ${value};\n`;
    }
    return `uniform float ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1f(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueFloat
};
},{"../../../utils":114,"./index":56}],54:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueHTMLImage extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const { width, height } = value;
    this.checkSize(width, height);
    this.dimensions = [width, height, 1];
    this.textureSize = [width, height];
    this.uploadValue = value;
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputImage) {
    if (inputImage.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputImage.constructor);
      return;
    }
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue = inputImage);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueHTMLImage
};
},{"../../../utils":114,"./array":40}],55:[function(require,module,exports){
const { WebGLKernelValueHTMLImage } = require('./html-image');

class WebGLKernelValueHTMLVideo extends WebGLKernelValueHTMLImage {}

module.exports = {
  WebGLKernelValueHTMLVideo
};
},{"./html-image":54}],56:[function(require,module,exports){
const { utils } = require('../../../utils');
const { KernelValue } = require('../../kernel-value');

class WebGLKernelValue extends KernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.dimensionsId = null;
    this.sizeId = null;
    this.initialValueConstructor = value.constructor;
    this.onRequestTexture = settings.onRequestTexture;
    this.onRequestIndex = settings.onRequestIndex;
    this.uploadValue = null;
    this.textureSize = null;
    this.bitRatio = null;
    this.prevArg = null;
  }

  get id() {
    return `${this.origin}_${utils.sanitizeName(this.name)}`;
  }

  setup() {}

  getTransferArrayType(value) {
    if (Array.isArray(value[0])) {
      return this.getTransferArrayType(value[0]);
    }
    switch (value.constructor) {
      case Array:
      case Int32Array:
      case Int16Array:
      case Int8Array:
        return Float32Array;
      case Uint8ClampedArray:
      case Uint8Array:
      case Uint16Array:
      case Uint32Array:
      case Float32Array:
      case Float64Array:
        return value.constructor;
    }
    console.warn('Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros');
    return value.constructor;
  }

  getStringValueHandler() {
    throw new Error(`"getStringValueHandler" not implemented on ${this.constructor.name}`);
  }

  getVariablePrecisionString() {
    return this.kernel.getVariablePrecisionString(this.textureSize || undefined, this.tactic || undefined);
  }

  destroy() {}
}

module.exports = {
  WebGLKernelValue
};
},{"../../../utils":114,"../../kernel-value":35}],57:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueInteger extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const int ${this.id} = ${ parseInt(value) };\n`;
    }
    return `uniform int ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueInteger
};
},{"../../../utils":114,"./index":56}],58:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

const sameError = `Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()`;

class WebGLKernelValueMemoryOptimizedNumberTexture extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const [width, height] = value.size;
    this.checkSize(width, height);
    this.dimensions = value.dimensions;
    this.textureSize = value.size;
    this.uploadValue = value.texture;
    this.forceUploadEachRun = true;
  }

  setup() {
    this.setupTexture();
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName}.texture;\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputTexture) {
    if (inputTexture.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputTexture.constructor);
      return;
    }
    if (this.checkContext && inputTexture.context !== this.context) {
      throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
    }

    const { kernel, context: gl } = this;
    if (kernel.pipeline) {
      if (kernel.immutable) {
        kernel.updateTextureArgumentRefs(this, inputTexture);
      } else {
        if (kernel.texture.texture === inputTexture.texture) {
          throw new Error(sameError);
        } else if (kernel.mappedTextures) {
          const { mappedTextures } = kernel;
          for (let i = 0; i < mappedTextures.length; i++) {
            if (mappedTextures[i].texture === inputTexture.texture) {
              throw new Error(sameError);
            }
          }
        }
      }
    }

    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueMemoryOptimizedNumberTexture,
  sameError
};
},{"../../../utils":114,"./array":40}],59:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');
const { sameError } = require('./memory-optimized-number-texture');

class WebGLKernelValueNumberTexture extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const [width, height] = value.size;
    this.checkSize(width, height);
    const { size: textureSize, dimensions } = value;
    this.bitRatio = this.getBitRatio(value);
    this.dimensions = dimensions;
    this.textureSize = textureSize;
    this.uploadValue = value.texture;
    this.forceUploadEachRun = true;
  }

  setup() {
    this.setupTexture();
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName}.texture;\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputTexture) {
    if (inputTexture.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputTexture.constructor);
      return;
    }
    if (this.checkContext && inputTexture.context !== this.context) {
      throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
    }

    const { kernel, context: gl } = this;
    if (kernel.pipeline) {
      if (kernel.immutable) {
        kernel.updateTextureArgumentRefs(this, inputTexture);
      } else {
        if (kernel.texture.texture === inputTexture.texture) {
          throw new Error(sameError);
        } else if (kernel.mappedTextures) {
          const { mappedTextures } = kernel;
          for (let i = 0; i < mappedTextures.length; i++) {
            if (mappedTextures[i].texture === inputTexture.texture) {
              throw new Error(sameError);
            }
          }
        }
      }
    }

    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueNumberTexture
};
},{"../../../utils":114,"./array":40,"./memory-optimized-number-texture":58}],60:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray
};
},{"../../../utils":114,"./array":40}],61:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray1DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], 1, 1]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten2dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray1DI
};
},{"../../../utils":114,"./array":40}],62:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueSingleArray2 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec2 ${this.id} = vec2(${value[0]},${value[1]});\n`;
    }
    return `uniform vec2 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform2fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueSingleArray2
};
},{"../../../utils":114,"./index":56}],63:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray2DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], 1]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten3dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray2DI
};
},{"../../../utils":114,"./array":40}],64:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueSingleArray3 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec3 ${this.id} = vec3(${value[0]},${value[1]},${value[2]});\n`;
    }
    return `uniform vec3 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform3fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueSingleArray3
};
},{"../../../utils":114,"./index":56}],65:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray3DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], valueDimensions[3]]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten4dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray3DI
};
},{"../../../utils":114,"./array":40}],66:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueSingleArray4 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec4 ${this.id} = vec4(${value[0]},${value[1]},${value[2]},${value[3]});\n`;
    }
    return `uniform vec4 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform4fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueSingleArray4
};
},{"../../../utils":114,"./index":56}],67:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleInput extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}.value, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    if (input.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(input.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(input.value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleInput
};
},{"../../../utils":114,"./array":40}],68:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueUnsignedArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = this.getBitRatio(value);
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.TranserArrayType = this.getTransferArrayType(value);
    this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
      `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
      `flattenTo(${this.varName}, preUploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.preUploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueUnsignedArray
};
},{"../../../utils":114,"./array":40}],69:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueUnsignedInput extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = this.getBitRatio(value);
    const [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.TranserArrayType = this.getTransferArrayType(value.value);
    this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
      `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
      `flattenTo(${this.varName}.value, preUploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    if (input.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(input.value, this.preUploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueUnsignedInput
};
},{"../../../utils":114,"./array":40}],70:[function(require,module,exports){
const { GLKernel } = require('../gl/kernel');
const { FunctionBuilder } = require('../function-builder');
const { WebGLFunctionNode } = require('./function-node');
const { utils } = require('../../utils');
const mrud = require('../../plugins/math-random-uniformly-distributed');
const { fragmentShader } = require('./fragment-shader');
const { vertexShader } = require('./vertex-shader');
const { glKernelString } = require('../gl/kernel-string');
const { lookupKernelValueType } = require('./kernel-value-maps');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;
let features = null;

const plugins = [mrud];
const canvases = [];
const maxTexSizes = {};


class WebGLKernel extends GLKernel {
  static get isSupported() {
    if (isSupported !== null) {
      return isSupported;
    }
    this.setupFeatureChecks();
    isSupported = this.isContextMatch(testContext);
    return isSupported;
  }

  static setupFeatureChecks() {
    if (typeof document !== 'undefined') {
      testCanvas = document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      testCanvas = new OffscreenCanvas(0, 0);
    }
    if (!testCanvas) return;
    testContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
    if (!testContext || !testContext.getExtension) return;
    testExtensions = {
      OES_texture_float: testContext.getExtension('OES_texture_float'),
      OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
    };
    features = this.getFeatures();
  }

  static isContextMatch(context) {
    if (typeof WebGLRenderingContext !== 'undefined') {
      return context instanceof WebGLRenderingContext;
    }
    return false;
  }

  static getIsTextureFloat() {
    return Boolean(testExtensions.OES_texture_float);
  }

  static getIsDrawBuffers() {
    return Boolean(testExtensions.WEBGL_draw_buffers);
  }

  static getChannelCount() {
    return testExtensions.WEBGL_draw_buffers ?
      testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :
      1;
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static lookupKernelValueType(type, dynamic, precision, value) {
    return lookupKernelValueType(type, dynamic, precision, value);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  static get fragmentShader() {
    return fragmentShader;
  }

  static get vertexShader() {
    return vertexShader;
  }

  constructor(source, settings) {
    super(source, settings);
    this.program = null;
    this.pipeline = settings.pipeline;
    this.endianness = utils.systemEndianness();
    this.extensions = {};
    this.argumentTextureCount = 0;
    this.constantTextureCount = 0;
    this.fragShader = null;
    this.vertShader = null;
    this.drawBuffersMap = null;

    this.maxTexSize = null;
    this.onRequestSwitchKernel = null;
    this.removeIstanbulCoverage = true;

    this.texture = null;
    this.mappedTextures = null;
    this.mergeSettings(source.settings || settings);

    this.threadDim = null;
    this.framebuffer = null;
    this.buffer = null;

    this.textureCache = [];
    this.programUniformLocationCache = {};
    this.uniform1fCache = {};
    this.uniform1iCache = {};
    this.uniform2fCache = {};
    this.uniform2fvCache = {};
    this.uniform2ivCache = {};
    this.uniform3fvCache = {};
    this.uniform3ivCache = {};
    this.uniform4fvCache = {};
    this.uniform4ivCache = {};
  }

  initCanvas() {
    if (typeof document !== 'undefined') {
      const canvas = document.createElement('canvas');
      canvas.width = 2;
      canvas.height = 2;
      return canvas;
    } else if (typeof OffscreenCanvas !== 'undefined') {
      return new OffscreenCanvas(0, 0);
    }
  }

  initContext() {
    const settings = {
      alpha: false,
      depth: false,
      antialias: false
    };
    return this.canvas.getContext('webgl', settings) || this.canvas.getContext('experimental-webgl', settings);
  }

  initPlugins(settings) {
    const pluginsToUse = [];
    const { source } = this;
    if (typeof source === 'string') {
      for (let i = 0; i < plugins.length; i++) {
        const plugin = plugins[i];
        if (source.match(plugin.functionMatch)) {
          pluginsToUse.push(plugin);
        }
      }
    } else if (typeof source === 'object') {
      if (settings.pluginNames) { 
        for (let i = 0; i < plugins.length; i++) {
          const plugin = plugins[i];
          const usePlugin = settings.pluginNames.some(pluginName => pluginName === plugin.name);
          if (usePlugin) {
            pluginsToUse.push(plugin);
          }
        }
      }
    }
    return pluginsToUse;
  }

  initExtensions() {
    this.extensions = {
      OES_texture_float: this.context.getExtension('OES_texture_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
      WEBGL_color_buffer_float: this.context.getExtension('WEBGL_color_buffer_float'),
    };
  }

  validateSettings(args) {
    if (!this.validate) {
      this.texSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, this.output);
      return;
    }

    const { features } = this.constructor;

    if (this.optimizeFloatMemory === true && !features.isTextureFloat) {
      throw new Error('Float textures are not supported');
    } else if (this.precision === 'single' && !features.isFloatRead) {
      throw new Error('Single precision not supported');
    } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
      this.precision = features.isFloatRead ? 'single' : 'unsigned';
    }

    if (this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers) {
      throw new Error('could not instantiate draw buffers extension');
    }

    if (this.fixIntegerDivisionAccuracy === null) {
      this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
    } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
      this.fixIntegerDivisionAccuracy = false;
    }

    this.checkOutput();

    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      switch (argType) {
        case 'Array':
          this.output = utils.getDimensions(argType);
          break;
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
          this.output = args[0].output;
          break;
        default:
          throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }

      if (this.precision === 'precision') {
        this.precision = 'unsigned';
        console.warn('Cannot use graphical mode and single precision at the same time');
      }

      this.texSize = utils.clone(this.output);
      return;
    } else if (this.precision === null && features.isTextureFloat) {
      this.precision = 'single';
    }

    this.texSize = utils.getKernelTextureSize({
      optimizeFloatMemory: this.optimizeFloatMemory,
      precision: this.precision,
    }, this.output);

    this.checkTextureSize();
  }

  updateMaxTexSize() {
    const { texSize, canvas } = this;
    if (this.maxTexSize === null) {
      let canvasIndex = canvases.indexOf(canvas);
      if (canvasIndex === -1) {
        canvasIndex = canvases.length;
        canvases.push(canvas);
        maxTexSizes[canvasIndex] = [texSize[0], texSize[1]];
      }
      this.maxTexSize = maxTexSizes[canvasIndex];
    }
    if (this.maxTexSize[0] < texSize[0]) {
      this.maxTexSize[0] = texSize[0];
    }
    if (this.maxTexSize[1] < texSize[1]) {
      this.maxTexSize[1] = texSize[1];
    }
  }

  setupArguments(args) {
    this.kernelArguments = [];
    this.argumentTextureCount = 0;
    const needsArgumentTypes = this.argumentTypes === null;
    if (needsArgumentTypes) {
      this.argumentTypes = [];
    }
    this.argumentSizes = [];
    this.argumentBitRatios = [];

    if (args.length < this.argumentNames.length) {
      throw new Error('not enough arguments for kernel');
    } else if (args.length > this.argumentNames.length) {
      throw new Error('too many arguments for kernel');
    }

    const { context: gl } = this;
    let textureIndexes = 0;

    const onRequestTexture = () => {
      return this.createTexture();
    };
    const onRequestIndex = () => {
      return textureIndexes++;
    };
    const onUpdateValueMismatch = (constructor) => {
      this.switchKernels({
        type: 'argumentMismatch',
        needed: constructor
      });
    };
    const onRequestContextHandle = () => {
      return gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount++;
    };

    for (let index = 0; index < args.length; index++) {
      const value = args[index];
      const name = this.argumentNames[index];
      let type;
      if (needsArgumentTypes) {
        type = utils.getVariableType(value, this.strictIntegers);
        this.argumentTypes.push(type);
      } else {
        type = this.argumentTypes[index];
      }
      const KernelValue = this.constructor.lookupKernelValueType(type, this.dynamicArguments ? 'dynamic' : 'static', this.precision, args[index]);
      if (KernelValue === null) {
        return this.requestFallback(args);
      }
      const kernelArgument = new KernelValue(value, {
        name,
        type,
        tactic: this.tactic,
        origin: 'user',
        context: gl,
        checkContext: this.checkContext,
        kernel: this,
        strictIntegers: this.strictIntegers,
        onRequestTexture,
        onRequestIndex,
        onUpdateValueMismatch,
        onRequestContextHandle,
      });
      this.kernelArguments.push(kernelArgument);
      kernelArgument.setup();
      this.argumentSizes.push(kernelArgument.textureSize);
      this.argumentBitRatios[index] = kernelArgument.bitRatio;
    }
  }

  createTexture() {
    const texture = this.context.createTexture();
    this.textureCache.push(texture);
    return texture;
  }

  setupConstants(args) {
    const { context: gl } = this;
    this.kernelConstants = [];
    this.forceUploadKernelConstants = [];
    let needsConstantTypes = this.constantTypes === null;
    if (needsConstantTypes) {
      this.constantTypes = {};
    }
    this.constantBitRatios = {};
    let textureIndexes = 0;
    for (const name in this.constants) {
      const value = this.constants[name];
      let type;
      if (needsConstantTypes) {
        type = utils.getVariableType(value, this.strictIntegers);
        this.constantTypes[name] = type;
      } else {
        type = this.constantTypes[name];
      }
      const KernelValue = this.constructor.lookupKernelValueType(type, 'static', this.precision, value);
      if (KernelValue === null) {
        return this.requestFallback(args);
      }
      const kernelValue = new KernelValue(value, {
        name,
        type,
        tactic: this.tactic,
        origin: 'constants',
        context: this.context,
        checkContext: this.checkContext,
        kernel: this,
        strictIntegers: this.strictIntegers,
        onRequestTexture: () => {
          return this.createTexture();
        },
        onRequestIndex: () => {
          return textureIndexes++;
        },
        onRequestContextHandle: () => {
          return gl.TEXTURE0 + this.constantTextureCount++;
        }
      });
      this.constantBitRatios[name] = kernelValue.bitRatio;
      this.kernelConstants.push(kernelValue);
      kernelValue.setup();
      if (kernelValue.forceUploadEachRun) {
        this.forceUploadKernelConstants.push(kernelValue);
      }
    }
  }

  build() {
    if (this.built) return;
    this.initExtensions();
    this.validateSettings(arguments);
    this.setupConstants(arguments);
    if (this.fallbackRequested) return;
    this.setupArguments(arguments);
    if (this.fallbackRequested) return;
    this.updateMaxTexSize();
    this.translateSource();
    const failureResult = this.pickRenderStrategy(arguments);
    if (failureResult) {
      return failureResult;
    }
    const { texSize, context: gl, canvas } = this;
    gl.enable(gl.SCISSOR_TEST);
    if (this.pipeline && this.precision === 'single') {
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      canvas.width = this.maxTexSize[0];
      canvas.height = this.maxTexSize[1];
    } else {
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      canvas.width = this.maxTexSize[0];
      canvas.height = this.maxTexSize[1];
    }
    const threadDim = this.threadDim = Array.from(this.output);
    while (threadDim.length < 3) {
      threadDim.push(1);
    }

    const compiledVertexShader = this.getVertexShader(arguments);
    const vertShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertShader, compiledVertexShader);
    gl.compileShader(vertShader);
    this.vertShader = vertShader;

    const compiledFragmentShader = this.getFragmentShader(arguments);
    const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragShader, compiledFragmentShader);
    gl.compileShader(fragShader);
    this.fragShader = fragShader;

    if (this.debug) {
      console.log('GLSL Shader Output:');
      console.log(compiledFragmentShader);
    }

    if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
      throw new Error('Error compiling vertex shader: ' + gl.getShaderInfoLog(vertShader));
    }
    if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
      throw new Error('Error compiling fragment shader: ' + gl.getShaderInfoLog(fragShader));
    }

    const program = this.program = gl.createProgram();
    gl.attachShader(program, vertShader);
    gl.attachShader(program, fragShader);
    gl.linkProgram(program);
    this.framebuffer = gl.createFramebuffer();
    this.framebuffer.width = texSize[0];
    this.framebuffer.height = texSize[1];

    const vertices = new Float32Array([-1, -1,
      1, -1, -1, 1,
      1, 1
    ]);
    const texCoords = new Float32Array([
      0, 0,
      1, 0,
      0, 1,
      1, 1
    ]);

    const texCoordOffset = vertices.byteLength;

    let buffer = this.buffer;
    if (!buffer) {
      buffer = this.buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices.byteLength + texCoords.byteLength, gl.STATIC_DRAW);
    } else {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    }

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
    gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);

    const aPosLoc = gl.getAttribLocation(this.program, 'aPos');
    gl.enableVertexAttribArray(aPosLoc);
    gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);
    const aTexCoordLoc = gl.getAttribLocation(this.program, 'aTexCoord');
    gl.enableVertexAttribArray(aTexCoordLoc);
    gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, false, 0, texCoordOffset);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);

    let i = 0;
    gl.useProgram(this.program);
    for (let p in this.constants) {
      this.kernelConstants[i++].updateValue(this.constants[p]);
    }

    this._setupOutputTexture();
    if (
      this.subKernels !== null &&
      this.subKernels.length > 0
    ) {
      this._mappedTextureSwitched = {};
      this._setupSubOutputTextures();
    }
    this.buildSignature(arguments);
    this.built = true;
  }

  translateSource() {
    const functionBuilder = FunctionBuilder.fromKernel(this, WebGLFunctionNode, {
      fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
    });
    this.translatedSource = functionBuilder.getPrototypeString('kernel');
    this.setupReturnTypes(functionBuilder);
  }

  setupReturnTypes(functionBuilder) {
    if (!this.graphical && !this.returnType) {
      this.returnType = functionBuilder.getKernelResultType();
    }

    if (this.subKernels && this.subKernels.length > 0) {
      for (let i = 0; i < this.subKernels.length; i++) {
        const subKernel = this.subKernels[i];
        if (!subKernel.returnType) {
          subKernel.returnType = functionBuilder.getSubKernelResultType(i);
        }
      }
    }
  }

  run() {
    const { kernelArguments, texSize, forceUploadKernelConstants, context: gl } = this;

    gl.useProgram(this.program);
    gl.scissor(0, 0, texSize[0], texSize[1]);
    if (this.dynamicOutput) {
      this.setUniform3iv('uOutputDim', new Int32Array(this.threadDim));
      this.setUniform2iv('uTexSize', texSize);
    }

    this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);

    for (let i = 0; i < forceUploadKernelConstants.length; i++) {
      const constant = forceUploadKernelConstants[i];
      constant.updateValue(this.constants[constant.name]);
      if (this.switchingKernels) return;
    }
    for (let i = 0; i < kernelArguments.length; i++) {
      kernelArguments[i].updateValue(arguments[i]);
      if (this.switchingKernels) return;
    }

    if (this.plugins) {
      for (let i = 0; i < this.plugins.length; i++) {
        const plugin = this.plugins[i];
        if (plugin.onBeforeRun) {
          plugin.onBeforeRun(this);
        }
      }
    }

    if (this.graphical) {
      if (this.pipeline) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        if (this.immutable) {
          this._replaceOutputTexture();
        }
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        return this.immutable ? this.texture.clone() : this.texture;
      }
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      return;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    if (this.immutable) {
      this._replaceOutputTexture();
    }

    if (this.subKernels !== null) {
      if (this.immutable) {
        this._replaceSubOutputTextures();
      }
      this.drawBuffers();
    }

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  drawBuffers() {
    this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);
  }

  getInternalFormat() {
    return this.context.RGBA;
  }
  getTextureFormat() {
    const { context: gl } = this;
    switch (this.getInternalFormat()) {
      case gl.RGBA:
        return gl.RGBA;
      default:
        throw new Error('Unknown internal format');
    }
  }

  _replaceOutputTexture() {
    if (this.texture.beforeMutate() || this._textureSwitched) {
      const gl = this.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      this._textureSwitched = false;
    }
  }

  _setupOutputTexture() {
    const gl = this.context;
    const texSize = this.texSize;
    if (this.texture) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      return;
    }
    const texture = this.createTexture();
    gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    const format = this.getInternalFormat();
    if (this.precision === 'single') {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    this.texture = new this.TextureConstructor({
      texture,
      size: texSize,
      dimensions: this.threadDim,
      output: this.output,
      context: this.context,
      internalFormat: this.getInternalFormat(),
      textureFormat: this.getTextureFormat(),
      kernel: this,
    });
  }

  _replaceSubOutputTextures() {
    const gl = this.context;
    for (let i = 0; i < this.mappedTextures.length; i++) {
      const mappedTexture = this.mappedTextures[i];
      if (mappedTexture.beforeMutate() || this._mappedTextureSwitched[i]) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, mappedTexture.texture, 0);
        this._mappedTextureSwitched[i] = false;
      }
    }
  }

  _setupSubOutputTextures() {
    const gl = this.context;
    if (this.mappedTextures) {
      for (let i = 0; i < this.subKernels.length; i++) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);
      }
      return;
    }
    const texSize = this.texSize;
    this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
    this.mappedTextures = [];
    for (let i = 0; i < this.subKernels.length; i++) {
      const texture = this.createTexture();
      this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
      gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      if (this.precision === 'single') {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);

      this.mappedTextures.push(new this.TextureConstructor({
        texture,
        size: texSize,
        dimensions: this.threadDim,
        output: this.output,
        context: this.context,
        internalFormat: this.getInternalFormat(),
        textureFormat: this.getTextureFormat(),
        kernel: this,
      }));
    }
  }

  setUniform1f(name, value) {
    if (this.uniform1fCache.hasOwnProperty(name)) {
      const cache = this.uniform1fCache[name];
      if (value === cache) {
        return;
      }
    }
    this.uniform1fCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform1f(loc, value);
  }

  setUniform1i(name, value) {
    if (this.uniform1iCache.hasOwnProperty(name)) {
      const cache = this.uniform1iCache[name];
      if (value === cache) {
        return;
      }
    }
    this.uniform1iCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform1i(loc, value);
  }

  setUniform2f(name, value1, value2) {
    if (this.uniform2fCache.hasOwnProperty(name)) {
      const cache = this.uniform2fCache[name];
      if (
        value1 === cache[0] &&
        value2 === cache[1]
      ) {
        return;
      }
    }
    this.uniform2fCache[name] = [value1, value2];
    const loc = this.getUniformLocation(name);
    this.context.uniform2f(loc, value1, value2);
  }

  setUniform2fv(name, value) {
    if (this.uniform2fvCache.hasOwnProperty(name)) {
      const cache = this.uniform2fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1]
      ) {
        return;
      }
    }
    this.uniform2fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform2fv(loc, value);
  }

  setUniform2iv(name, value) {
    if (this.uniform2ivCache.hasOwnProperty(name)) {
      const cache = this.uniform2ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1]
      ) {
        return;
      }
    }
    this.uniform2ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform2iv(loc, value);
  }

  setUniform3fv(name, value) {
    if (this.uniform3fvCache.hasOwnProperty(name)) {
      const cache = this.uniform3fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2]
      ) {
        return;
      }
    }
    this.uniform3fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform3fv(loc, value);
  }

  setUniform3iv(name, value) {
    if (this.uniform3ivCache.hasOwnProperty(name)) {
      const cache = this.uniform3ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2]
      ) {
        return;
      }
    }
    this.uniform3ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform3iv(loc, value);
  }

  setUniform4fv(name, value) {
    if (this.uniform4fvCache.hasOwnProperty(name)) {
      const cache = this.uniform4fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2] &&
        value[3] === cache[3]
      ) {
        return;
      }
    }
    this.uniform4fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform4fv(loc, value);
  }

  setUniform4iv(name, value) {
    if (this.uniform4ivCache.hasOwnProperty(name)) {
      const cache = this.uniform4ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2] &&
        value[3] === cache[3]
      ) {
        return;
      }
    }
    this.uniform4ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform4iv(loc, value);
  }

  getUniformLocation(name) {
    if (this.programUniformLocationCache.hasOwnProperty(name)) {
      return this.programUniformLocationCache[name];
    }
    return this.programUniformLocationCache[name] = this.context.getUniformLocation(this.program, name);
  }

  _getFragShaderArtifactMap(args) {
    return {
      HEADER: this._getHeaderString(),
      LOOP_MAX: this._getLoopMaxString(),
      PLUGINS: this._getPluginsString(),
      CONSTANTS: this._getConstantsString(),
      DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),
      ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),
      DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),
      INJECTED_NATIVE: this._getInjectedNative(),
      MAIN_CONSTANTS: this._getMainConstantsString(),
      MAIN_ARGUMENTS: this._getMainArgumentsString(args),
      KERNEL: this.getKernelString(),
      MAIN_RESULT: this.getMainResultString(),
      FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
      INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
      SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
      SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),
    };
  }

  _getVertShaderArtifactMap(args) {
    return {
      FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
      INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
      SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
      SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),
    };
  }

  _getHeaderString() {
    return (
      this.subKernels !== null ?
      '#extension GL_EXT_draw_buffers : require\n' :
      ''
    );
  }

  _getLoopMaxString() {
    return (
      this.loopMaxIterations ?
      ` ${parseInt(this.loopMaxIterations)};\n` :
      ' 1000;\n'
    );
  }

  _getPluginsString() {
    if (!this.plugins) return '\n';
    return this.plugins.map(plugin => plugin.source && this.source.match(plugin.functionMatch) ? plugin.source : '').join('\n');
  }

  _getConstantsString() {
    const result = [];
    const { threadDim, texSize } = this;
    if (this.dynamicOutput) {
      result.push(
        'uniform ivec3 uOutputDim',
        'uniform ivec2 uTexSize'
      );
    } else {
      result.push(
        `ivec3 uOutputDim = ivec3(${threadDim[0]}, ${threadDim[1]}, ${threadDim[2]})`,
        `ivec2 uTexSize = ivec2(${texSize[0]}, ${texSize[1]})`
      );
    }
    return utils.linesToString(result);
  }

  _getTextureCoordinate() {
    const subKernels = this.subKernels;
    if (subKernels === null || subKernels.length < 1) {
      return 'varying vec2 vTexCoord;\n';
    } else {
      return 'out vec2 vTexCoord;\n';
    }
  }

  _getDecode32EndiannessString() {
    return (
      this.endianness === 'LE' ?
      '' :
      '  texel.rgba = texel.abgr;\n'
    );
  }

  _getEncode32EndiannessString() {
    return (
      this.endianness === 'LE' ?
      '' :
      '  texel.rgba = texel.abgr;\n'
    );
  }

  _getDivideWithIntegerCheckString() {
    return this.fixIntegerDivisionAccuracy ?
      `float divWithIntCheck(float x, float y) {
  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {
    return float(int(x) / int(y));
  }
  return x / y;
}

float integerCorrectionModulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -(number - (divisor * floor(divWithIntCheck(number, divisor))));
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return number - (divisor * floor(divWithIntCheck(number, divisor)));
}` :
      '';
  }

  _getMainArgumentsString(args) {
    const results = [];
    const { argumentNames } = this;
    for (let i = 0; i < argumentNames.length; i++) {
      results.push(this.kernelArguments[i].getSource(args[i]));
    }
    return results.join('');
  }

  _getInjectedNative() {
    return this.injectedNative || '';
  }

  _getMainConstantsString() {
    const result = [];
    const { constants } = this;
    if (constants) {
      let i = 0;
      for (const name in constants) {
        if (!this.constants.hasOwnProperty(name)) continue;
        result.push(this.kernelConstants[i++].getSource(this.constants[name]));
      }
    }
    return result.join('');
  }

  getKernelResultDeclaration() {
    switch (this.returnType) {
      case 'Array(2)':
        return 'vec2 kernelResult';
      case 'Array(3)':
        return 'vec3 kernelResult';
      case 'Array(4)':
        return 'vec4 kernelResult';
      case 'LiteralInteger':
      case 'Float':
      case 'Number':
      case 'Integer':
        return 'float kernelResult';
      default:
        if (this.graphical) {
          return 'float kernelResult';
        } else {
          throw new Error(`unrecognized output type "${ this.returnType }"`);
        }
    }
  }
  getKernelString() {
    const result = [this.getKernelResultDeclaration()];
    const { subKernels } = this;
    if (subKernels !== null) {
      switch (this.returnType) {
        case 'Number':
        case 'Float':
        case 'Integer':
          for (let i = 0; i < subKernels.length; i++) {
            const subKernel = subKernels[i];
            result.push(
              subKernel.returnType === 'Integer' ?
              `int subKernelResult_${ subKernel.name } = 0` :
              `float subKernelResult_${ subKernel.name } = 0.0`
            );
          }
          break;
        case 'Array(2)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec2 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
        case 'Array(3)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec3 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
        case 'Array(4)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec4 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
      }
    }

    return utils.linesToString(result) + this.translatedSource;
  }

  getMainResultGraphical() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragColor = actualColor',
    ]);
  }

  getMainResultPackedPixels() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return this.getMainResultKernelPackedPixels() +
          this.getMainResultSubKernelPackedPixels();
      default:
        throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
    }
  }

  getMainResultKernelPackedPixels() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  gl_FragData[0] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`
    ]);
  }

  getMainResultSubKernelPackedPixels() {
    const result = [];
    if (!this.subKernels) return '';
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`
        );
      }
    }
    return utils.linesToString(result);
  }

  getMainResultMemoryOptimizedFloats() {
    const result = [
      '  index *= 4',
    ];

    switch (this.returnType) {
      case 'Number':
      case 'Integer':
      case 'Float':
        const channels = ['r', 'g', 'b', 'a'];
        for (let i = 0; i < channels.length; i++) {
          const channel = channels[i];
          this.getMainResultKernelMemoryOptimizedFloats(result, channel);
          this.getMainResultSubKernelMemoryOptimizedFloats(result, channel);
          if (i + 1 < channels.length) {
            result.push('  index += 1');
          }
        }
        break;
      default:
        throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`);
    }

    return utils.linesToString(result);
  }

  getMainResultKernelMemoryOptimizedFloats(result, channel) {
    result.push(
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  gl_FragData[0].${channel} = kernelResult`,
    );
  }

  getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}].${channel} = float(subKernelResult_${this.subKernels[i].name})`,
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}].${channel} = subKernelResult_${this.subKernels[i].name}`,
        );
      }
    }
  }

  getMainResultKernelNumberTexture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult',
    ];
  }

  getMainResultSubKernelNumberTexture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}][0] = float(subKernelResult_${subKernel.name})`,
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}][0] = subKernelResult_${subKernel.name}`,
        );
      }
    }
    return result;
  }

  getMainResultKernelArray2Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult[0]',
      '  gl_FragData[0][1] = kernelResult[1]',
    ];
  }

  getMainResultSubKernelArray2Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
        `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
      );
    }
    return result;
  }

  getMainResultKernelArray3Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult[0]',
      '  gl_FragData[0][1] = kernelResult[1]',
      '  gl_FragData[0][2] = kernelResult[2]',
    ];
  }

  getMainResultSubKernelArray3Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
        `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
        `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,
      );
    }
    return result;
  }

  getMainResultKernelArray4Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0] = kernelResult',
    ];
  }

  getMainResultSubKernelArray4Texture() {
    const result = [];
    if (!this.subKernels) return result;
    switch (this.returnType) {
      case 'Number':
      case 'Float':
      case 'Integer':
        for (let i = 0; i < this.subKernels.length; ++i) {
          const subKernel = this.subKernels[i];
          if (subKernel.returnType === 'Integer') {
            result.push(
              `  gl_FragData[${i + 1}] = float(subKernelResult_${this.subKernels[i].name})`,
            );
          } else {
            result.push(
              `  gl_FragData[${i + 1}] = subKernelResult_${this.subKernels[i].name}`,
            );
          }
        }
        break;
      case 'Array(2)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
          );
        }
        break;
      case 'Array(3)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
            `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,
          );
        }
        break;
      case 'Array(4)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
            `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,
            `  gl_FragData[${i + 1}][3] = subKernelResult_${this.subKernels[i].name}[3]`,
          );
        }
        break;
    }

    return result;
  }

  replaceArtifacts(src, map) {
    return src.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\n/g, (match, artifact) => {
      if (map.hasOwnProperty(artifact)) {
        return map[artifact];
      }
      throw `unhandled artifact ${artifact}`;
    });
  }

  getFragmentShader(args) {
    if (this.compiledFragmentShader !== null) {
      return this.compiledFragmentShader;
    }
    return this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(args));
  }

  getVertexShader(args) {
    if (this.compiledVertexShader !== null) {
      return this.compiledVertexShader;
    }
    return this.compiledVertexShader = this.replaceArtifacts(this.constructor.vertexShader, this._getVertShaderArtifactMap(args));
  }

  toString() {
    const setupContextString = utils.linesToString([
      `const gl = context`,
    ]);
    return glKernelString(this.constructor, arguments, this, setupContextString);
  }

  destroy(removeCanvasReferences) {
    if (!this.context) return;
    if (this.buffer) {
      this.context.deleteBuffer(this.buffer);
    }
    if (this.framebuffer) {
      this.context.deleteFramebuffer(this.framebuffer);
    }
    if (this.vertShader) {
      this.context.deleteShader(this.vertShader);
    }
    if (this.fragShader) {
      this.context.deleteShader(this.fragShader);
    }
    if (this.program) {
      this.context.deleteProgram(this.program);
    }
    if (this.texture) {
      this.texture.delete();
      const textureCacheIndex = this.textureCache.indexOf(this.texture.texture);
      if (textureCacheIndex > -1) {
        this.textureCache.splice(textureCacheIndex, 1);
      }
      this.texture = null;
    }
    if (this.mappedTextures && this.mappedTextures.length) {
      for (let i = 0; i < this.mappedTextures.length; i++) {
        const mappedTexture = this.mappedTextures[i];
        mappedTexture.delete();
        const textureCacheIndex = this.textureCache.indexOf(mappedTexture.texture);
        if (textureCacheIndex > -1) {
          this.textureCache.splice(textureCacheIndex, 1);
        }
      }
      this.mappedTextures = null;
    }
    if (this.kernelArguments) {
      for (let i = 0; i < this.kernelArguments.length; i++) {
        this.kernelArguments[i].destroy();
      }
    }
    if (this.kernelConstants) {
      for (let i = 0; i < this.kernelConstants.length; i++) {
        this.kernelConstants[i].destroy();
      }
    }
    while (this.textureCache.length > 0) {
      const texture = this.textureCache.pop();
      this.context.deleteTexture(texture);
    }
    if (removeCanvasReferences) {
      const idx = canvases.indexOf(this.canvas);
      if (idx >= 0) {
        canvases[idx] = null;
        maxTexSizes[idx] = null;
      }
    }
    this.destroyExtensions();
    delete this.context;
    delete this.canvas;
    if (!this.gpu) return;
    const i = this.gpu.kernels.indexOf(this);
    if (i === -1) return;
    this.gpu.kernels.splice(i, 1);
  }

  destroyExtensions() {
    this.extensions.OES_texture_float = null;
    this.extensions.OES_texture_float_linear = null;
    this.extensions.OES_element_index_uint = null;
    this.extensions.WEBGL_draw_buffers = null;
  }

  static destroyContext(context) {
    const extension = context.getExtension('WEBGL_lose_context');
    if (extension) {
      extension.loseContext();
    }
  }

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, WebGLFunctionNode).toJSON();
    json.settings.threadDim = this.threadDim;
    return json;
  }
}

module.exports = {
  WebGLKernel
};
},{"../../plugins/math-random-uniformly-distributed":112,"../../utils":114,"../function-builder":9,"../gl/kernel":13,"../gl/kernel-string":12,"./fragment-shader":37,"./function-node":38,"./kernel-value-maps":39,"./vertex-shader":71}],71:[function(require,module,exports){
const vertexShader = `__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

attribute vec2 aPos;
attribute vec2 aTexCoord;

varying vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;

module.exports = {
  vertexShader
};
},{}],72:[function(require,module,exports){
const fragmentShader = `#version 300 es
__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;
__SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

in vec2 vTexCoord;

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float _round(float x) {
  return floor(x + 0.5);
}


const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x/y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  return texel[channel] * 255.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  index = index / 4;
  vec4 texel = texture(tex, st / vec2(texSize));
  return texel[channel];
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, st / vec2(texSize));
}

vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, vec3(st / vec2(texSize), z));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));

  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;

module.exports = {
  fragmentShader
};
},{}],73:[function(require,module,exports){
const { utils } = require('../../utils');
const { WebGLFunctionNode } = require('../web-gl/function-node');

class WebGL2FunctionNode extends WebGLFunctionNode {

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput(
        'IdentifierExpression - not an Identifier',
        idtNode
      );
    }

    const type = this.getType(idtNode);

    const name = utils.sanitizeName(idtNode.name);
    if (idtNode.name === 'Infinity') {
      retArr.push('intBitsToFloat(2139095039)');
    } else if (type === 'Boolean') {
      if (this.argumentNames.indexOf(name) > -1) {
        retArr.push(`bool(user_${name})`);
      } else {
        retArr.push(`user_${name}`);
      }
    } else {
      retArr.push(`user_${name}`);
    }

    return retArr;
  }
}

module.exports = {
  WebGL2FunctionNode
};
},{"../../utils":114,"../web-gl/function-node":38}],74:[function(require,module,exports){
const { WebGL2KernelValueBoolean } = require('./kernel-value/boolean');
const { WebGL2KernelValueFloat } = require('./kernel-value/float');
const { WebGL2KernelValueInteger } = require('./kernel-value/integer');

const { WebGL2KernelValueHTMLImage } = require('./kernel-value/html-image');
const { WebGL2KernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');

const { WebGL2KernelValueHTMLImageArray } = require('./kernel-value/html-image-array');
const { WebGL2KernelValueDynamicHTMLImageArray } = require('./kernel-value/dynamic-html-image-array');

const { WebGL2KernelValueHTMLVideo } = require('./kernel-value/html-video');
const { WebGL2KernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');

const { WebGL2KernelValueSingleInput } = require('./kernel-value/single-input');
const { WebGL2KernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');

const { WebGL2KernelValueUnsignedInput } = require('./kernel-value/unsigned-input');
const { WebGL2KernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');

const { WebGL2KernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');
const { WebGL2KernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');

const { WebGL2KernelValueNumberTexture } = require('./kernel-value/number-texture');
const { WebGL2KernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');

const { WebGL2KernelValueSingleArray } = require('./kernel-value/single-array');
const { WebGL2KernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');

const { WebGL2KernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');
const { WebGL2KernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');

const { WebGL2KernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');
const { WebGL2KernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');

const { WebGL2KernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');
const { WebGL2KernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');

const { WebGL2KernelValueSingleArray2 } = require('./kernel-value/single-array2');
const { WebGL2KernelValueSingleArray3 } = require('./kernel-value/single-array3');
const { WebGL2KernelValueSingleArray4 } = require('./kernel-value/single-array4');

const { WebGL2KernelValueUnsignedArray } = require('./kernel-value/unsigned-array');
const { WebGL2KernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');

const kernelValueMaps = {
  unsigned: {
    dynamic: {
      'Boolean': WebGL2KernelValueBoolean,
      'Integer': WebGL2KernelValueInteger,
      'Float': WebGL2KernelValueFloat,
      'Array': WebGL2KernelValueDynamicUnsignedArray,
      'Array(2)': false,
      'Array(3)': false,
      'Array(4)': false,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGL2KernelValueDynamicUnsignedInput,
      'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGL2KernelValueBoolean,
      'Float': WebGL2KernelValueFloat,
      'Integer': WebGL2KernelValueInteger,
      'Array': WebGL2KernelValueUnsignedArray,
      'Array(2)': false,
      'Array(3)': false,
      'Array(4)': false,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGL2KernelValueUnsignedInput,
      'NumberTexture': WebGL2KernelValueNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueHTMLImage,
      'HTMLImage': WebGL2KernelValueHTMLImage,
      'HTMLImageArray': WebGL2KernelValueHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueHTMLVideo,
    }
  },
  single: {
    dynamic: {
      'Boolean': WebGL2KernelValueBoolean,
      'Integer': WebGL2KernelValueInteger,
      'Float': WebGL2KernelValueFloat,
      'Array': WebGL2KernelValueDynamicSingleArray,
      'Array(2)': WebGL2KernelValueSingleArray2,
      'Array(3)': WebGL2KernelValueSingleArray3,
      'Array(4)': WebGL2KernelValueSingleArray4,
      'Array1D(2)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array1D(3)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array1D(4)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array2D(2)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array2D(3)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array2D(4)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array3D(2)': WebGL2KernelValueDynamicSingleArray3DI,
      'Array3D(3)': WebGL2KernelValueDynamicSingleArray3DI,
      'Array3D(4)': WebGL2KernelValueDynamicSingleArray3DI,
      'Input': WebGL2KernelValueDynamicSingleInput,
      'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGL2KernelValueBoolean,
      'Float': WebGL2KernelValueFloat,
      'Integer': WebGL2KernelValueInteger,
      'Array': WebGL2KernelValueSingleArray,
      'Array(2)': WebGL2KernelValueSingleArray2,
      'Array(3)': WebGL2KernelValueSingleArray3,
      'Array(4)': WebGL2KernelValueSingleArray4,
      'Array1D(2)': WebGL2KernelValueSingleArray1DI,
      'Array1D(3)': WebGL2KernelValueSingleArray1DI,
      'Array1D(4)': WebGL2KernelValueSingleArray1DI,
      'Array2D(2)': WebGL2KernelValueSingleArray2DI,
      'Array2D(3)': WebGL2KernelValueSingleArray2DI,
      'Array2D(4)': WebGL2KernelValueSingleArray2DI,
      'Array3D(2)': WebGL2KernelValueSingleArray3DI,
      'Array3D(3)': WebGL2KernelValueSingleArray3DI,
      'Array3D(4)': WebGL2KernelValueSingleArray3DI,
      'Input': WebGL2KernelValueSingleInput,
      'NumberTexture': WebGL2KernelValueNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueHTMLImage,
      'HTMLImage': WebGL2KernelValueHTMLImage,
      'HTMLImageArray': WebGL2KernelValueHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueHTMLVideo,
    }
  },
};

function lookupKernelValueType(type, dynamic, precision, value) {
  if (!type) {
    throw new Error('type missing');
  }
  if (!dynamic) {
    throw new Error('dynamic missing');
  }
  if (!precision) {
    throw new Error('precision missing');
  }
  if (value.type) {
    type = value.type;
  }
  const types = kernelValueMaps[precision][dynamic];
  if (types[type] === false) {
    return null;
  } else if (types[type] === undefined) {
    throw new Error(`Could not find a KernelValue for ${ type }`);
  }
  return types[type];
}

module.exports = {
  kernelValueMaps,
  lookupKernelValueType
};
},{"./kernel-value/boolean":75,"./kernel-value/dynamic-html-image":77,"./kernel-value/dynamic-html-image-array":76,"./kernel-value/dynamic-html-video":78,"./kernel-value/dynamic-memory-optimized-number-texture":79,"./kernel-value/dynamic-number-texture":80,"./kernel-value/dynamic-single-array":81,"./kernel-value/dynamic-single-array1d-i":82,"./kernel-value/dynamic-single-array2d-i":83,"./kernel-value/dynamic-single-array3d-i":84,"./kernel-value/dynamic-single-input":85,"./kernel-value/dynamic-unsigned-array":86,"./kernel-value/dynamic-unsigned-input":87,"./kernel-value/float":88,"./kernel-value/html-image":90,"./kernel-value/html-image-array":89,"./kernel-value/html-video":91,"./kernel-value/integer":92,"./kernel-value/memory-optimized-number-texture":93,"./kernel-value/number-texture":94,"./kernel-value/single-array":95,"./kernel-value/single-array1d-i":96,"./kernel-value/single-array2":97,"./kernel-value/single-array2d-i":98,"./kernel-value/single-array3":99,"./kernel-value/single-array3d-i":100,"./kernel-value/single-array4":101,"./kernel-value/single-input":102,"./kernel-value/unsigned-array":103,"./kernel-value/unsigned-input":104}],75:[function(require,module,exports){
const { WebGLKernelValueBoolean } = require('../../web-gl/kernel-value/boolean');

class WebGL2KernelValueBoolean extends WebGLKernelValueBoolean {}

module.exports = {
  WebGL2KernelValueBoolean
};
},{"../../web-gl/kernel-value/boolean":41}],76:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueHTMLImageArray } = require('./html-image-array');

class WebGL2KernelValueDynamicHTMLImageArray extends WebGL2KernelValueHTMLImageArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2DArray ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(images) {
    const { width, height } = images[0];
    this.checkSize(width, height);
    this.dimensions = [width, height, images.length];
    this.textureSize = [width, height];
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(images);
  }
}

module.exports = {
  WebGL2KernelValueDynamicHTMLImageArray
};
},{"../../../utils":114,"./html-image-array":89}],77:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicHTMLImage } = require('../../web-gl/kernel-value/dynamic-html-image');

class WebGL2KernelValueDynamicHTMLImage extends WebGLKernelValueDynamicHTMLImage {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicHTMLImage
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-html-image":42}],78:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueDynamicHTMLImage } = require('./dynamic-html-image');

class WebGL2KernelValueDynamicHTMLVideo extends WebGL2KernelValueDynamicHTMLImage {}

module.exports = {
  WebGL2KernelValueDynamicHTMLVideo
};
},{"../../../utils":114,"./dynamic-html-image":77}],79:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/dynamic-memory-optimized-number-texture');

class WebGL2KernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueDynamicMemoryOptimizedNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture":44}],80:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicNumberTexture } = require('../../web-gl/kernel-value/dynamic-number-texture');

class WebGL2KernelValueDynamicNumberTexture extends WebGLKernelValueDynamicNumberTexture {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-number-texture":45}],81:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray } = require('../../web-gl2/kernel-value/single-array');

class WebGL2KernelValueDynamicSingleArray extends WebGL2KernelValueSingleArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array":95}],82:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray1DI } = require('../../web-gl2/kernel-value/single-array1d-i');

class WebGL2KernelValueDynamicSingleArray1DI extends WebGL2KernelValueSingleArray1DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray1DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array1d-i":96}],83:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray2DI } = require('../../web-gl2/kernel-value/single-array2d-i');

class WebGL2KernelValueDynamicSingleArray2DI extends WebGL2KernelValueSingleArray2DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray2DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array2d-i":98}],84:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray3DI } = require('../../web-gl2/kernel-value/single-array3d-i');

class WebGL2KernelValueDynamicSingleArray3DI extends WebGL2KernelValueSingleArray3DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray3DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array3d-i":100}],85:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleInput } = require('../../web-gl2/kernel-value/single-input');

class WebGL2KernelValueDynamicSingleInput extends WebGL2KernelValueSingleInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleInput
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-input":102}],86:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicUnsignedArray } = require('../../web-gl/kernel-value/dynamic-unsigned-array');

class WebGL2KernelValueDynamicUnsignedArray extends WebGLKernelValueDynamicUnsignedArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicUnsignedArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-array":51}],87:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicUnsignedInput } = require('../../web-gl/kernel-value/dynamic-unsigned-input');

class WebGL2KernelValueDynamicUnsignedInput extends WebGLKernelValueDynamicUnsignedInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicUnsignedInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-input":52}],88:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueFloat } = require('../../web-gl/kernel-value/float');

class WebGL2KernelValueFloat extends WebGLKernelValueFloat {}

module.exports = {
  WebGL2KernelValueFloat
};
},{"../../../utils":114,"../../web-gl/kernel-value/float":53}],89:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('../../web-gl/kernel-value/array');

class WebGL2KernelValueHTMLImageArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.checkSize(value[0].width, value[0].height);
    this.dimensions = [value[0].width, value[0].height, value.length];
    this.textureSize = [value[0].width, value[0].height];
  }
  defineTexture() {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2DArray ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(images) {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage3D(
      gl.TEXTURE_2D_ARRAY,
      0,
      gl.RGBA,
      images[0].width,
      images[0].height,
      images.length,
      0,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      null
    );
    for (let i = 0; i < images.length; i++) {
      const xOffset = 0;
      const yOffset = 0;
      const imageDepth = 1;
      gl.texSubImage3D(
        gl.TEXTURE_2D_ARRAY,
        0,
        xOffset,
        yOffset,
        i,
        images[i].width,
        images[i].height,
        imageDepth,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        this.uploadValue = images[i]
      );
    }
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueHTMLImageArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/array":40}],90:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueHTMLImage } = require('../../web-gl/kernel-value/html-image');

class WebGL2KernelValueHTMLImage extends WebGLKernelValueHTMLImage {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueHTMLImage
};
},{"../../../utils":114,"../../web-gl/kernel-value/html-image":54}],91:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueHTMLImage } = require('./html-image');

class WebGL2KernelValueHTMLVideo extends WebGL2KernelValueHTMLImage {}

module.exports = {
  WebGL2KernelValueHTMLVideo
};
},{"../../../utils":114,"./html-image":90}],92:[function(require,module,exports){
const { WebGLKernelValueInteger } = require('../../web-gl/kernel-value/integer');

class WebGL2KernelValueInteger extends WebGLKernelValueInteger {
  getSource(value) {
    const variablePrecision = this.getVariablePrecisionString();
    if (this.origin === 'constants') {
      return `const ${ variablePrecision } int ${this.id} = ${ parseInt(value) };\n`;
    }
    return `uniform ${ variablePrecision } int ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGL2KernelValueInteger
};
},{"../../web-gl/kernel-value/integer":57}],93:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/memory-optimized-number-texture');

class WebGL2KernelValueMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {
  getSource() {
    const { id, sizeId, textureSize, dimensionsId, dimensions } = this;
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform sampler2D ${id}`,
      `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,
      `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/memory-optimized-number-texture":58}],94:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueNumberTexture } = require('../../web-gl/kernel-value/number-texture');

class WebGL2KernelValueNumberTexture extends WebGLKernelValueNumberTexture {
  getSource() {
    const { id, sizeId, textureSize, dimensionsId, dimensions } = this;
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${id}`,
      `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,
      `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/number-texture":59}],95:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray } = require('../../web-gl/kernel-value/single-array');

class WebGL2KernelValueSingleArray extends WebGLKernelValueSingleArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array":60}],96:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray1DI } = require('../../web-gl/kernel-value/single-array1d-i');

class WebGL2KernelValueSingleArray1DI extends WebGLKernelValueSingleArray1DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray1DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array1d-i":61}],97:[function(require,module,exports){
const { WebGLKernelValueSingleArray2 } = require('../../web-gl/kernel-value/single-array2');

class WebGL2KernelValueSingleArray2 extends WebGLKernelValueSingleArray2 {}

module.exports = {
  WebGL2KernelValueSingleArray2
};
},{"../../web-gl/kernel-value/single-array2":62}],98:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray2DI } = require('../../web-gl/kernel-value/single-array2d-i');

class WebGL2KernelValueSingleArray2DI extends WebGLKernelValueSingleArray2DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray2DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array2d-i":63}],99:[function(require,module,exports){
const { WebGLKernelValueSingleArray3 } = require('../../web-gl/kernel-value/single-array3');

class WebGL2KernelValueSingleArray3 extends WebGLKernelValueSingleArray3 {}

module.exports = {
  WebGL2KernelValueSingleArray3
};
},{"../../web-gl/kernel-value/single-array3":64}],100:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray3DI } = require('../../web-gl/kernel-value/single-array3d-i');

class WebGL2KernelValueSingleArray3DI extends WebGLKernelValueSingleArray3DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray3DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array3d-i":65}],101:[function(require,module,exports){
const { WebGLKernelValueSingleArray4 } = require('../../web-gl/kernel-value/single-array4');

class WebGL2KernelValueSingleArray4 extends WebGLKernelValueSingleArray4 {}

module.exports = {
  WebGL2KernelValueSingleArray4
};
},{"../../web-gl/kernel-value/single-array4":66}],102:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleInput } = require('../../web-gl/kernel-value/single-input');

class WebGL2KernelValueSingleInput extends WebGLKernelValueSingleInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    const { context: gl } = this;
    utils.flattenTo(input.value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-input":67}],103:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedArray } = require('../../web-gl/kernel-value/unsigned-array');

class WebGL2KernelValueUnsignedArray extends WebGLKernelValueUnsignedArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueUnsignedArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-array":68}],104:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedInput } = require('../../web-gl/kernel-value/unsigned-input');

class WebGL2KernelValueUnsignedInput extends WebGLKernelValueUnsignedInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueUnsignedInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-input":69}],105:[function(require,module,exports){
const { WebGLKernel } = require('../web-gl/kernel');
const { WebGL2FunctionNode } = require('./function-node');
const { FunctionBuilder } = require('../function-builder');
const { utils } = require('../../utils');
const { fragmentShader } = require('./fragment-shader');
const { vertexShader } = require('./vertex-shader');
const { lookupKernelValueType } = require('./kernel-value-maps');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;

let features = null;

class WebGL2Kernel extends WebGLKernel {
  static get isSupported() {
    if (isSupported !== null) {
      return isSupported;
    }
    this.setupFeatureChecks();
    isSupported = this.isContextMatch(testContext);
    return isSupported;
  }

  static setupFeatureChecks() {
    if (typeof document !== 'undefined') {
      testCanvas = document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      testCanvas = new OffscreenCanvas(0, 0);
    }
    if (!testCanvas) return;
    testContext = testCanvas.getContext('webgl2');
    if (!testContext || !testContext.getExtension) return;
    testExtensions = {
      EXT_color_buffer_float: testContext.getExtension('EXT_color_buffer_float'),
      OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
    };
    features = this.getFeatures();
  }

  static isContextMatch(context) {
    if (typeof WebGL2RenderingContext !== 'undefined') {
      return context instanceof WebGL2RenderingContext;
    }
    return false;
  }

  static getFeatures() {
    const gl = this.testContext;
    return Object.freeze({
      isFloatRead: this.getIsFloatRead(),
      isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
      isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
      kernelMap: true,
      isTextureFloat: true,
      isDrawBuffers: true,
      channelCount: this.getChannelCount(),
      maxTextureSize: this.getMaxTextureSize(),
      lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),
      lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),
      mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),
      mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),
      highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),
      highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
    });
  }

  static getIsTextureFloat() {
    return true;
  }

  static getChannelCount() {
    return testContext.getParameter(testContext.MAX_DRAW_BUFFERS);
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static lookupKernelValueType(type, dynamic, precision, value) {
    return lookupKernelValueType(type, dynamic, precision, value);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  static get fragmentShader() {
    return fragmentShader;
  }
  static get vertexShader() {
    return vertexShader;
  }

  initContext() {
    const settings = {
      alpha: false,
      depth: false,
      antialias: false
    };
    return this.canvas.getContext('webgl2', settings);
  }

  initExtensions() {
    this.extensions = {
      EXT_color_buffer_float: this.context.getExtension('EXT_color_buffer_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
    };
  }

  validateSettings(args) {
    if (!this.validate) {
      this.texSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, this.output);
      return;
    }

    const { features } = this.constructor;
    if (this.precision === 'single' && !features.isFloatRead) {
      throw new Error('Float texture outputs are not supported');
    } else if (!this.graphical && this.precision === null) {
      this.precision = features.isFloatRead ? 'single' : 'unsigned';
    }

    if (this.fixIntegerDivisionAccuracy === null) {
      this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
    } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
      this.fixIntegerDivisionAccuracy = false;
    }

    this.checkOutput();

    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      switch (argType) {
        case 'Array':
          this.output = utils.getDimensions(argType);
          break;
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
          this.output = args[0].output;
          break;
        default:
          throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }

      if (this.precision === 'single') {
        console.warn('Cannot use graphical mode and single precision at the same time');
        this.precision = 'unsigned';
      }

      this.texSize = utils.clone(this.output);
      return;
    } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
      this.precision = 'single';
    }

    this.texSize = utils.getKernelTextureSize({
      optimizeFloatMemory: this.optimizeFloatMemory,
      precision: this.precision,
    }, this.output);

    this.checkTextureSize();
  }

  translateSource() {
    const functionBuilder = FunctionBuilder.fromKernel(this, WebGL2FunctionNode, {
      fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
    });
    this.translatedSource = functionBuilder.getPrototypeString('kernel');
    this.setupReturnTypes(functionBuilder);
  }

  drawBuffers() {
    this.context.drawBuffers(this.drawBuffersMap);
  }

  getTextureFormat() {
    const { context: gl } = this;
    switch (this.getInternalFormat()) {
      case gl.R32F:
        return gl.RED;
      case gl.RG32F:
        return gl.RG;
      case gl.RGBA32F:
        return gl.RGBA;
      case gl.RGBA:
        return gl.RGBA;
      default:
        throw new Error('Unknown internal format');
    }
  }
  getInternalFormat() {
    const { context: gl } = this;

    if (this.precision === 'single') {
      if (this.pipeline) {
        switch (this.returnType) {
          case 'Number':
          case 'Float':
          case 'Integer':
            if (this.optimizeFloatMemory) {
              return gl.RGBA32F;
            } else {
              return gl.R32F;
            }
            case 'Array(2)':
              return gl.RG32F;
            case 'Array(3)': 
            case 'Array(4)':
              return gl.RGBA32F;
            default:
              throw new Error('Unhandled return type');
        }
      }
      return gl.RGBA32F;
    }
    return gl.RGBA;
  }

  _setupOutputTexture() {
    const gl = this.context;
    if (this.texture) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      return;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    const texture = gl.createTexture();
    const texSize = this.texSize;
    gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    const format = this.getInternalFormat();
    if (this.precision === 'single') {
      gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    this.texture = new this.TextureConstructor({
      texture,
      size: texSize,
      dimensions: this.threadDim,
      output: this.output,
      context: this.context,
      internalFormat: this.getInternalFormat(),
      textureFormat: this.getTextureFormat(),
      kernel: this,
    });
  }

  _setupSubOutputTextures() {
    const gl = this.context;
    if (this.mappedTextures) {
      for (let i = 0; i < this.subKernels.length; i++) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);
      }
      return;
    }
    const texSize = this.texSize;
    this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
    this.mappedTextures = [];
    for (let i = 0; i < this.subKernels.length; i++) {
      const texture = this.createTexture();
      this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
      gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      const format = this.getInternalFormat();
      if (this.precision === 'single') {
        gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);

      this.mappedTextures.push(new this.TextureConstructor({
        texture,
        size: texSize,
        dimensions: this.threadDim,
        output: this.output,
        context: this.context,
        internalFormat: this.getInternalFormat(),
        textureFormat: this.getTextureFormat(),
        kernel: this,
      }));
    }
  }

  _getHeaderString() {
    return '';
  }

  _getTextureCoordinate() {
    const subKernels = this.subKernels;
    const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);
    if (subKernels === null || subKernels.length < 1) {
      return `in ${ variablePrecision } vec2 vTexCoord;\n`;
    } else {
      return `out ${ variablePrecision } vec2 vTexCoord;\n`;
    }
  }

  _getMainArgumentsString(args) {
    const result = [];
    const argumentNames = this.argumentNames;
    for (let i = 0; i < argumentNames.length; i++) {
      result.push(this.kernelArguments[i].getSource(args[i]));
    }
    return result.join('');
  }

  getKernelString() {
    const result = [this.getKernelResultDeclaration()];
    const subKernels = this.subKernels;
    if (subKernels !== null) {
      result.push(
        'layout(location = 0) out vec4 data0'
      );
      switch (this.returnType) {
        case 'Number':
        case 'Float':
        case 'Integer':
          for (let i = 0; i < subKernels.length; i++) {
            const subKernel = subKernels[i];
            result.push(
              subKernel.returnType === 'Integer' ?
              `int subKernelResult_${ subKernel.name } = 0` :
              `float subKernelResult_${ subKernel.name } = 0.0`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(2)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec2 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(3)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec3 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(4)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec4 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
      }
    } else {
      result.push(
        'out vec4 data0'
      );
    }

    return utils.linesToString(result) + this.translatedSource;
  }

  getMainResultGraphical() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0 = actualColor',
    ]);
  }

  getMainResultPackedPixels() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return this.getMainResultKernelPackedPixels() +
          this.getMainResultSubKernelPackedPixels();
      default:
        throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
    }
  }

  getMainResultKernelPackedPixels() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  data0 = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`
    ]);
  }

  getMainResultSubKernelPackedPixels() {
    const result = [];
    if (!this.subKernels) return '';
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`
        );
      } else {
        result.push(
          `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`
        );
      }
    }
    return utils.linesToString(result);
  }

  getMainResultKernelMemoryOptimizedFloats(result, channel) {
    result.push(
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  data0.${channel} = kernelResult`,
    );
  }

  getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1}.${channel} = float(subKernelResult_${subKernel.name})`,
        );
      } else {
        result.push(
          `  data${i + 1}.${channel} = subKernelResult_${subKernel.name}`,
        );
      }
    }
  }

  getMainResultKernelNumberTexture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult',
    ];
  }

  getMainResultSubKernelNumberTexture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1}[0] = float(subKernelResult_${subKernel.name})`,
        );
      } else {
        result.push(
          `  data${i + 1}[0] = subKernelResult_${subKernel.name}`,
        );
      }
    }
    return result;
  }

  getMainResultKernelArray2Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult[0]',
      '  data0[1] = kernelResult[1]',
    ];
  }

  getMainResultSubKernelArray2Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      result.push(
        `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,
        `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`,
      );
    }
    return result;
  }

  getMainResultKernelArray3Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult[0]',
      '  data0[1] = kernelResult[1]',
      '  data0[2] = kernelResult[2]',
    ];
  }

  getMainResultSubKernelArray3Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      result.push(
        `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,
        `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`,
        `  data${i + 1}[2] = subKernelResult_${subKernel.name}[2]`,
      );
    }
    return result;
  }

  getMainResultKernelArray4Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0 = kernelResult',
    ];
  }

  getMainResultSubKernelArray4Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  data${i + 1} = subKernelResult_${this.subKernels[i].name}`,
      );
    }
    return result;
  }

  destroyExtensions() {
    this.extensions.EXT_color_buffer_float = null;
    this.extensions.OES_texture_float_linear = null;
  }

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, WebGL2FunctionNode).toJSON();
    json.settings.threadDim = this.threadDim;
    return json;
  }
}

module.exports = {
  WebGL2Kernel
};
},{"../../utils":114,"../function-builder":9,"../web-gl/kernel":70,"./fragment-shader":72,"./function-node":73,"./kernel-value-maps":74,"./vertex-shader":106}],106:[function(require,module,exports){
const vertexShader = `#version 300 es
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

in vec2 aPos;
in vec2 aTexCoord;

out vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;

module.exports = {
  vertexShader
};
},{}],107:[function(require,module,exports){
const lib = require('./index');
const GPU = lib.GPU;
for (const p in lib) {
  if (!lib.hasOwnProperty(p)) continue;
  if (p === 'GPU') continue; 
  GPU[p] = lib[p];
}

if (typeof window !== 'undefined') {
  bindTo(window);
}
if (typeof self !== 'undefined') {
  bindTo(self);
}

function bindTo(target) {
  if (target.GPU) return;
  Object.defineProperty(target, 'GPU', {
    get() {
      return GPU;
    }
  });
}

module.exports = lib;
},{"./index":109}],108:[function(require,module,exports){
const { gpuMock } = require('gpu-mock.js');
const { utils } = require('./utils');
const { Kernel } = require('./backend/kernel');
const { CPUKernel } = require('./backend/cpu/kernel');
const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');
const { WebGL2Kernel } = require('./backend/web-gl2/kernel');
const { WebGLKernel } = require('./backend/web-gl/kernel');
const { kernelRunShortcut } = require('./kernel-run-shortcut');


const kernelOrder = [HeadlessGLKernel, WebGL2Kernel, WebGLKernel];

const kernelTypes = ['gpu', 'cpu'];

const internalKernels = {
  'headlessgl': HeadlessGLKernel,
  'webgl2': WebGL2Kernel,
  'webgl': WebGLKernel,
};

let validate = true;

class GPU {
  static disableValidation() {
    validate = false;
  }

  static enableValidation() {
    validate = true;
  }

  static get isGPUSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported);
  }

  static get isKernelMapSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.kernelMap);
  }

  static get isOffscreenCanvasSupported() {
    return (typeof Worker !== 'undefined' && typeof OffscreenCanvas !== 'undefined') || typeof importScripts !== 'undefined';
  }

  static get isWebGLSupported() {
    return WebGLKernel.isSupported;
  }

  static get isWebGL2Supported() {
    return WebGL2Kernel.isSupported;
  }

  static get isHeadlessGLSupported() {
    return HeadlessGLKernel.isSupported;
  }

  static get isCanvasSupported() {
    return typeof HTMLCanvasElement !== 'undefined';
  }

  static get isGPUHTMLImageArraySupported() {
    return WebGL2Kernel.isSupported;
  }

  static get isSinglePrecisionSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.isFloatRead && Kernel.features.isTextureFloat);
  }

  constructor(settings) {
    settings = settings || {};
    this.canvas = settings.canvas || null;
    this.context = settings.context || null;
    this.mode = settings.mode;
    this.Kernel = null;
    this.kernels = [];
    this.functions = [];
    this.nativeFunctions = [];
    this.injectedNative = null;
    this.onIstanbulCoverageVariable = settings.onIstanbulCoverageVariable || null;
    this.removeIstanbulCoverage = settings.hasOwnProperty('removeIstanbulCoverage') ? settings.removeIstanbulCoverage : null;
    if (this.mode === 'dev') return;
    this.chooseKernel();
    if (settings.functions) {
      for (let i = 0; i < settings.functions.length; i++) {
        this.addFunction(settings.functions[i]);
      }
    }

    if (settings.nativeFunctions) {
      for (const p in settings.nativeFunctions) {
        if (!settings.nativeFunctions.hasOwnProperty(p)) continue;
        const s = settings.nativeFunctions[p];
        const { name, source } = s;
        this.addNativeFunction(name, source, s);
      }
    }
  }

  chooseKernel() {
    if (this.Kernel) return;

    let Kernel = null;

    if (this.context) {
      for (let i = 0; i < kernelOrder.length; i++) {
        const ExternalKernel = kernelOrder[i];
        if (ExternalKernel.isContextMatch(this.context)) {
          if (!ExternalKernel.isSupported) {
            throw new Error(`Kernel type ${ExternalKernel.name} not supported`);
          }
          Kernel = ExternalKernel;
          break;
        }
      }
      if (Kernel === null) {
        throw new Error('unknown Context');
      }
    } else if (this.mode) {
      if (this.mode in internalKernels) {
        if (!validate || internalKernels[this.mode].isSupported) {
          Kernel = internalKernels[this.mode];
        }
      } else if (this.mode === 'gpu') {
        for (let i = 0; i < kernelOrder.length; i++) {
          if (kernelOrder[i].isSupported) {
            Kernel = kernelOrder[i];
            break;
          }
        }
      } else if (this.mode === 'cpu') {
        Kernel = CPUKernel;
      }
      if (!Kernel) {
        throw new Error(`A requested mode of "${this.mode}" and is not supported`);
      }
    } else {
      for (let i = 0; i < kernelOrder.length; i++) {
        if (kernelOrder[i].isSupported) {
          Kernel = kernelOrder[i];
          break;
        }
      }
      if (!Kernel) {
        Kernel = CPUKernel;
      }
    }

    if (!this.mode) {
      this.mode = Kernel.mode;
    }
    this.Kernel = Kernel;
  }

  createKernel(source, settings) {
    if (typeof source === 'undefined') {
      throw new Error('Missing source parameter');
    }
    if (typeof source !== 'object' && !utils.isFunction(source) && typeof source !== 'string') {
      throw new Error('source parameter not a function');
    }

    const kernels = this.kernels;
    if (this.mode === 'dev') {
      const devKernel = gpuMock(source, upgradeDeprecatedCreateKernelSettings(settings));
      kernels.push(devKernel);
      return devKernel;
    }

    source = typeof source === 'function' ? source.toString() : source;
    const switchableKernels = {};
    const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings) || {};
    if (settings && typeof settings.argumentTypes === 'object') {
      settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);
    }

    function onRequestFallback(args) {
      console.warn('Falling back to CPU');
      const fallbackKernel = new CPUKernel(source, {
        argumentTypes: kernelRun.argumentTypes,
        constantTypes: kernelRun.constantTypes,
        graphical: kernelRun.graphical,
        loopMaxIterations: kernelRun.loopMaxIterations,
        constants: kernelRun.constants,
        dynamicOutput: kernelRun.dynamicOutput,
        dynamicArgument: kernelRun.dynamicArguments,
        output: kernelRun.output,
        precision: kernelRun.precision,
        pipeline: kernelRun.pipeline,
        immutable: kernelRun.immutable,
        optimizeFloatMemory: kernelRun.optimizeFloatMemory,
        fixIntegerDivisionAccuracy: kernelRun.fixIntegerDivisionAccuracy,
        functions: kernelRun.functions,
        nativeFunctions: kernelRun.nativeFunctions,
        injectedNative: kernelRun.injectedNative,
        subKernels: kernelRun.subKernels,
        strictIntegers: kernelRun.strictIntegers,
        debug: kernelRun.debug,
      });
      fallbackKernel.build.apply(fallbackKernel, args);
      const result = fallbackKernel.run.apply(fallbackKernel, args);
      kernelRun.replaceKernel(fallbackKernel);
      return result;
    }

    function onRequestSwitchKernel(reasons, args, _kernel) {
      if (_kernel.debug) {
        console.warn('Switching kernels');
      }
      let newOutput = null;
      if (_kernel.signature && !switchableKernels[_kernel.signature]) {
        switchableKernels[_kernel.signature] = _kernel;
      }
      if (_kernel.dynamicOutput) {
        for (let i = reasons.length - 1; i >= 0; i--) {
          const reason = reasons[i];
          if (reason.type === 'outputPrecisionMismatch') {
            newOutput = reason.needed;
          }
        }
      }

      const Constructor = _kernel.constructor;
      const argumentTypes = Constructor.getArgumentTypes(_kernel, args);
      const signature = Constructor.getSignature(_kernel, argumentTypes);
      const existingKernel = switchableKernels[signature];
      if (existingKernel) {
        existingKernel.onActivate(_kernel);
        return existingKernel;
      }

      const newKernel = switchableKernels[signature] = new Constructor(source, {
        argumentTypes,
        constantTypes: _kernel.constantTypes,
        graphical: _kernel.graphical,
        loopMaxIterations: _kernel.loopMaxIterations,
        constants: _kernel.constants,
        dynamicOutput: _kernel.dynamicOutput,
        dynamicArgument: _kernel.dynamicArguments,
        context: _kernel.context,
        canvas: _kernel.canvas,
        output: newOutput || _kernel.output,
        precision: _kernel.precision,
        pipeline: _kernel.pipeline,
        immutable: _kernel.immutable,
        optimizeFloatMemory: _kernel.optimizeFloatMemory,
        fixIntegerDivisionAccuracy: _kernel.fixIntegerDivisionAccuracy,
        functions: _kernel.functions,
        nativeFunctions: _kernel.nativeFunctions,
        injectedNative: _kernel.injectedNative,
        subKernels: _kernel.subKernels,
        strictIntegers: _kernel.strictIntegers,
        debug: _kernel.debug,
        gpu: _kernel.gpu,
        validate,
        returnType: _kernel.returnType,
        onIstanbulCoverageVariable: _kernel.onIstanbulCoverageVariable,
        removeIstanbulCoverage: _kernel.removeIstanbulCoverage,
        tactic: _kernel.tactic,
        onRequestFallback,
        onRequestSwitchKernel,
        texture: _kernel.texture,
        mappedTextures: _kernel.mappedTextures,
        drawBuffersMap: _kernel.drawBuffersMap,
      });
      newKernel.build.apply(newKernel, args);
      kernelRun.replaceKernel(newKernel);
      kernels.push(newKernel);
      return newKernel;
    }
    const mergedSettings = Object.assign({
      context: this.context,
      canvas: this.canvas,
      functions: this.functions,
      nativeFunctions: this.nativeFunctions,
      injectedNative: this.injectedNative,
      onIstanbulCoverageVariable: this.onIstanbulCoverageVariable,
      removeIstanbulCoverage: this.removeIstanbulCoverage,
      gpu: this,
      validate,
      onRequestFallback,
      onRequestSwitchKernel
    }, settingsCopy);

    const kernel = new this.Kernel(source, mergedSettings);
    const kernelRun = kernelRunShortcut(kernel);

    if (!this.canvas) {
      this.canvas = kernel.canvas;
    }

    if (!this.context) {
      this.context = kernel.context;
    }

    kernels.push(kernel);

    return kernelRun;
  }

  createKernelMap() {
    let fn;
    let settings;
    const argument2Type = typeof arguments[arguments.length - 2];
    if (argument2Type === 'function' || argument2Type === 'string') {
      fn = arguments[arguments.length - 2];
      settings = arguments[arguments.length - 1];
    } else {
      fn = arguments[arguments.length - 1];
    }

    if (this.mode !== 'dev') {
      if (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) {
        if (this.mode && kernelTypes.indexOf(this.mode) < 0) {
          throw new Error(`kernelMap not supported on ${this.Kernel.name}`);
        }
      }
    }

    const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings);
    if (settings && typeof settings.argumentTypes === 'object') {
      settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);
    }

    if (Array.isArray(arguments[0])) {
      settingsCopy.subKernels = [];
      const functions = arguments[0];
      for (let i = 0; i < functions.length; i++) {
        const source = functions[i].toString();
        const name = utils.getFunctionNameFromString(source);
        settingsCopy.subKernels.push({
          name,
          source,
          property: i,
        });
      }
    } else {
      settingsCopy.subKernels = [];
      const functions = arguments[0];
      for (let p in functions) {
        if (!functions.hasOwnProperty(p)) continue;
        const source = functions[p].toString();
        const name = utils.getFunctionNameFromString(source);
        settingsCopy.subKernels.push({
          name: name || p,
          source,
          property: p,
        });
      }
    }
    return this.createKernel(fn, settingsCopy);
  }

  combineKernels() {
    const firstKernel = arguments[0];
    const combinedKernel = arguments[arguments.length - 1];
    if (firstKernel.kernel.constructor.mode === 'cpu') return combinedKernel;
    const canvas = arguments[0].canvas;
    const context = arguments[0].context;
    const max = arguments.length - 1;
    for (let i = 0; i < max; i++) {
      arguments[i]
        .setCanvas(canvas)
        .setContext(context)
        .setPipeline(true);
    }

    return function() {
      const texture = combinedKernel.apply(this, arguments);
      if (texture.toArray) {
        return texture.toArray();
      }
      return texture;
    };
  }

  setFunctions(functions) {
    this.functions = functions;
    return this;
  }

  setNativeFunctions(nativeFunctions) {
    this.nativeFunctions = nativeFunctions;
    return this;
  }

  addFunction(source, settings) {
    this.functions.push({ source, settings });
    return this;
  }

  addNativeFunction(name, source, settings) {
    if (this.kernels.length > 0) {
      throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');
    }
    this.nativeFunctions.push(Object.assign({ name, source }, settings));
    return this;
  }

  injectNative(source) {
    this.injectedNative = source;
    return this;
  }

  destroy() {
    return new Promise((resolve, reject) => {
      if (!this.kernels) {
        resolve();
      }
      setTimeout(() => {
        try {
          for (let i = 0; i < this.kernels.length; i++) {
            this.kernels[i].destroy(true); 
          }
          let firstKernel = this.kernels[0];
          if (firstKernel) {
            if (firstKernel.kernel) {
              firstKernel = firstKernel.kernel;
            }
            if (firstKernel.constructor.destroyContext) {
              firstKernel.constructor.destroyContext(this.context);
            }
          }
        } catch (e) {
          reject(e);
        }
        resolve();
      }, 0);
    });
  }
}


function upgradeDeprecatedCreateKernelSettings(settings) {
  if (!settings) {
    return {};
  }
  const upgradedSettings = Object.assign({}, settings);

  if (settings.hasOwnProperty('floatOutput')) {
    utils.warnDeprecated('setting', 'floatOutput', 'precision');
    upgradedSettings.precision = settings.floatOutput ? 'single' : 'unsigned';
  }
  if (settings.hasOwnProperty('outputToTexture')) {
    utils.warnDeprecated('setting', 'outputToTexture', 'pipeline');
    upgradedSettings.pipeline = Boolean(settings.outputToTexture);
  }
  if (settings.hasOwnProperty('outputImmutable')) {
    utils.warnDeprecated('setting', 'outputImmutable', 'immutable');
    upgradedSettings.immutable = Boolean(settings.outputImmutable);
  }
  if (settings.hasOwnProperty('floatTextures')) {
    utils.warnDeprecated('setting', 'floatTextures', 'optimizeFloatMemory');
    upgradedSettings.optimizeFloatMemory = Boolean(settings.floatTextures);
  }
  return upgradedSettings;
}

module.exports = {
  GPU,
  kernelOrder,
  kernelTypes
};
},{"./backend/cpu/kernel":8,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/kernel":70,"./backend/web-gl2/kernel":105,"./kernel-run-shortcut":111,"./utils":114,"gpu-mock.js":4}],109:[function(require,module,exports){
const { GPU } = require('./gpu');
const { alias } = require('./alias');
const { utils } = require('./utils');
const { Input, input } = require('./input');
const { Texture } = require('./texture');
const { FunctionBuilder } = require('./backend/function-builder');
const { FunctionNode } = require('./backend/function-node');
const { CPUFunctionNode } = require('./backend/cpu/function-node');
const { CPUKernel } = require('./backend/cpu/kernel');

const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');

const { WebGLFunctionNode } = require('./backend/web-gl/function-node');
const { WebGLKernel } = require('./backend/web-gl/kernel');
const { kernelValueMaps: webGLKernelValueMaps } = require('./backend/web-gl/kernel-value-maps');

const { WebGL2FunctionNode } = require('./backend/web-gl2/function-node');
const { WebGL2Kernel } = require('./backend/web-gl2/kernel');
const { kernelValueMaps: webGL2KernelValueMaps } = require('./backend/web-gl2/kernel-value-maps');

const { GLKernel } = require('./backend/gl/kernel');

const { Kernel } = require('./backend/kernel');

const { FunctionTracer } = require('./backend/function-tracer');

const mathRandom = require('./plugins/math-random-uniformly-distributed');

module.exports = {
  alias,
  CPUFunctionNode,
  CPUKernel,
  GPU,
  FunctionBuilder,
  FunctionNode,
  HeadlessGLKernel,
  Input,
  input,
  Texture,
  utils,

  WebGL2FunctionNode,
  WebGL2Kernel,
  webGL2KernelValueMaps,

  WebGLFunctionNode,
  WebGLKernel,
  webGLKernelValueMaps,

  GLKernel,
  Kernel,
  FunctionTracer,

  plugins: {
    mathRandom
  }
};
},{"./alias":5,"./backend/cpu/function-node":6,"./backend/cpu/kernel":8,"./backend/function-builder":9,"./backend/function-node":10,"./backend/function-tracer":11,"./backend/gl/kernel":13,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/function-node":38,"./backend/web-gl/kernel":70,"./backend/web-gl/kernel-value-maps":39,"./backend/web-gl2/function-node":73,"./backend/web-gl2/kernel":105,"./backend/web-gl2/kernel-value-maps":74,"./gpu":108,"./input":110,"./plugins/math-random-uniformly-distributed":112,"./texture":113,"./utils":114}],110:[function(require,module,exports){
class Input {
  constructor(value, size) {
    this.value = value;
    if (Array.isArray(size)) {
      this.size = size;
    } else {
      this.size = new Int32Array(3);
      if (size.z) {
        this.size = new Int32Array([size.x, size.y, size.z]);
      } else if (size.y) {
        this.size = new Int32Array([size.x, size.y]);
      } else {
        this.size = new Int32Array([size.x]);
      }
    }

    const [w, h, d] = this.size;
    if (d) {
      if (this.value.length !== (w * h * d)) {
        throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} * ${d} = ${(h * w * d)}`);
      }
    } else if (h) {
      if (this.value.length !== (w * h)) {
        throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} = ${(h * w)}`);
      }
    } else {
      if (this.value.length !== w) {
        throw new Error(`Input size ${this.value.length} does not match ${w}`);
      }
    }

  }

  toArray() {
    const { utils } = require('./utils');
    const [w, h, d] = this.size;
    if (d) {
      return utils.erectMemoryOptimized3DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h, d);
    } else if (h) {
      return utils.erectMemoryOptimized2DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h);
    } else {
      return this.value;
    }
  }
}

function input(value, size) {
  return new Input(value, size);
}

module.exports = {
  Input,
  input
};
},{"./utils":114}],111:[function(require,module,exports){
const { utils } = require('./utils');

function kernelRunShortcut(kernel) {
  let run = function() {
    kernel.build.apply(kernel, arguments);
    run = function() {
      let result = kernel.run.apply(kernel, arguments);
      if (kernel.switchingKernels) {
        const reasons = kernel.resetSwitchingKernels();
        const newKernel = kernel.onRequestSwitchKernel(reasons, arguments, kernel);
        shortcut.kernel = kernel = newKernel;
        result = newKernel.run.apply(newKernel, arguments);
      }
      if (kernel.renderKernels) {
        return kernel.renderKernels();
      } else if (kernel.renderOutput) {
        return kernel.renderOutput();
      } else {
        return result;
      }
    };
    return run.apply(kernel, arguments);
  };
  const shortcut = function() {
    return run.apply(kernel, arguments);
  };
  shortcut.exec = function() {
    return new Promise((accept, reject) => {
      try {
        accept(run.apply(this, arguments));
      } catch (e) {
        reject(e);
      }
    });
  };
  shortcut.replaceKernel = function(replacementKernel) {
    kernel = replacementKernel;
    bindKernelToShortcut(kernel, shortcut);
  };

  bindKernelToShortcut(kernel, shortcut);
  return shortcut;
}

function bindKernelToShortcut(kernel, shortcut) {
  if (shortcut.kernel) {
    shortcut.kernel = kernel;
    return;
  }
  const properties = utils.allPropertiesOf(kernel);
  for (let i = 0; i < properties.length; i++) {
    const property = properties[i];
    if (property[0] === '_' && property[1] === '_') continue;
    if (typeof kernel[property] === 'function') {
      if (property.substring(0, 3) === 'add' || property.substring(0, 3) === 'set') {
        shortcut[property] = function() {
          shortcut.kernel[property].apply(shortcut.kernel, arguments);
          return shortcut;
        };
      } else {
        shortcut[property] = function() {
          return shortcut.kernel[property].apply(shortcut.kernel, arguments);
        };
      }
    } else {
      shortcut.__defineGetter__(property, () => shortcut.kernel[property]);
      shortcut.__defineSetter__(property, (value) => {
        shortcut.kernel[property] = value;
      });
    }
  }
  shortcut.kernel = kernel;
}
module.exports = {
  kernelRunShortcut
};
},{"./utils":114}],112:[function(require,module,exports){
const source = `// https://www.shadertoy.com/view/4t2SDh
//note: uniformly distributed, normalized rand, [0,1]
highp float randomSeedShift = 1.0;
highp float slide = 1.0;
uniform highp float randomSeed1;
uniform highp float randomSeed2;

highp float nrand(highp vec2 n) {
  highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);
  randomSeedShift = result;
  if (randomSeedShift > 0.5) {
    slide += 0.00009; 
  } else {
    slide += 0.0009;
  }
  return result;
}`;

const name = 'math-random-uniformly-distributed';

const functionMatch = `Math.random()`;

const functionReplace = `nrand(vTexCoord)`;

const functionReturnType = 'Number';
const onBeforeRun = (kernel) => {
  kernel.setUniform1f('randomSeed1', Math.random());
  kernel.setUniform1f('randomSeed2', Math.random());
};

const plugin = {
  name,
  onBeforeRun,
  functionMatch,
  functionReplace,
  functionReturnType,
  source
};

module.exports = plugin;
},{}],113:[function(require,module,exports){
class Texture {
  constructor(settings) {
    const {
      texture,
      size,
      dimensions,
      output,
      context,
      type = 'NumberTexture',
      kernel,
      internalFormat,
      textureFormat
    } = settings;
    if (!output) throw new Error('settings property "output" required.');
    if (!context) throw new Error('settings property "context" required.');
    if (!texture) throw new Error('settings property "texture" required.');
    if (!kernel) throw new Error('settings property "kernel" required.');
    this.texture = texture;
    if (texture._refs) {
      texture._refs++;
    } else {
      texture._refs = 1;
    }
    this.size = size;
    this.dimensions = dimensions;
    this.output = output;
    this.context = context;
    this.kernel = kernel;
    this.type = type;
    this._deleted = false;
    this.internalFormat = internalFormat;
    this.textureFormat = textureFormat;
  }

  toArray() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  clone() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  delete() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  clear() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }
}

module.exports = {
  Texture
};
},{}],114:[function(require,module,exports){
const acorn = require('acorn');
const { Input } = require('./input');
const { Texture } = require('./texture');

const FUNCTION_NAME = /function ([^(]*)/;
const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
const ARGUMENT_NAMES = /([^\s,]+)/g;

const utils = {
  systemEndianness() {
    return _systemEndianness;
  },
  getSystemEndianness() {
    const b = new ArrayBuffer(4);
    const a = new Uint32Array(b);
    const c = new Uint8Array(b);
    a[0] = 0xdeadbeef;
    if (c[0] === 0xef) return 'LE';
    if (c[0] === 0xde) return 'BE';
    throw new Error('unknown endianness');
  },

  isFunction(funcObj) {
    return typeof(funcObj) === 'function';
  },

  isFunctionString(fn) {
    if (typeof fn === 'string') {
      return (fn
        .slice(0, 'function'.length)
        .toLowerCase() === 'function');
    }
    return false;
  },

  getFunctionNameFromString(funcStr) {
    const result = FUNCTION_NAME.exec(funcStr);
    if (!result || result.length === 0) return null;
    return result[1].trim();
  },

  getFunctionBodyFromString(funcStr) {
    return funcStr.substring(funcStr.indexOf('{') + 1, funcStr.lastIndexOf('}'));
  },

  getArgumentNamesFromString(fn) {
    const fnStr = fn.replace(STRIP_COMMENTS, '');
    let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
    if (result === null) {
      result = [];
    }
    return result;
  },

  clone(obj) {
    if (obj === null || typeof obj !== 'object' || obj.hasOwnProperty('isActiveClone')) return obj;

    const temp = obj.constructor(); 

    for (let key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        obj.isActiveClone = null;
        temp[key] = utils.clone(obj[key]);
        delete obj.isActiveClone;
      }
    }

    return temp;
  },

  isArray(array) {
    return !isNaN(array.length);
  },

  getVariableType(value, strictIntegers) {
    if (utils.isArray(value)) {
      if (value.length > 0 && value[0].nodeName === 'IMG') {
        return 'HTMLImageArray';
      }
      return 'Array';
    }

    switch (value.constructor) {
      case Boolean:
        return 'Boolean';
      case Number:
        if (strictIntegers && Number.isInteger(value)) {
          return 'Integer';
        }
        return 'Float';
      case Texture:
        return value.type;
      case Input:
        return 'Input';
    }
    switch (value.nodeName) {
      case 'IMG':
        return 'HTMLImage';
      case 'CANVAS':
        return 'HTMLImage';
      case 'VIDEO':
        return 'HTMLVideo';
    }
    if (value.hasOwnProperty('type')) {
      return value.type;
    }
    return 'Unknown';
  },

  getKernelTextureSize(settings, dimensions) {
    let [w, h, d] = dimensions;
    let texelCount = (w || 1) * (h || 1) * (d || 1);

    if (settings.optimizeFloatMemory && settings.precision === 'single') {
      w = texelCount = Math.ceil(texelCount / 4);
    }
    if (h > 1 && w * h === texelCount) {
      return new Int32Array([w, h]);
    }
    return utils.closestSquareDimensions(texelCount);
  },

  closestSquareDimensions(length) {
    const sqrt = Math.sqrt(length);
    let high = Math.ceil(sqrt);
    let low = Math.floor(sqrt);
    while (high * low < length) {
      high--;
      low = Math.ceil(length / high);
    }
    return new Int32Array([low, Math.ceil(length / low)]);
  },

  getMemoryOptimizedFloatTextureSize(dimensions, bitRatio) {
    const totalArea = utils.roundTo((dimensions[0] || 1) * (dimensions[1] || 1) * (dimensions[2] || 1) * (dimensions[3] || 1), 4);
    const texelCount = totalArea / bitRatio;
    return utils.closestSquareDimensions(texelCount);
  },

  getMemoryOptimizedPackedTextureSize(dimensions, bitRatio) {
    const [w, h, d] = dimensions;
    const totalArea = utils.roundTo((w || 1) * (h || 1) * (d || 1), 4);
    const texelCount = totalArea / (4 / bitRatio);
    return utils.closestSquareDimensions(texelCount);
  },

  roundTo(n, d) {
    return Math.floor((n + d - 1) / d) * d;
  },
  getDimensions(x, pad) {
    let ret;
    if (utils.isArray(x)) {
      const dim = [];
      let temp = x;
      while (utils.isArray(temp)) {
        dim.push(temp.length);
        temp = temp[0];
      }
      ret = dim.reverse();
    } else if (x instanceof Texture) {
      ret = x.output;
    } else if (x instanceof Input) {
      ret = x.size;
    } else {
      throw new Error(`Unknown dimensions of ${x}`);
    }

    if (pad) {
      ret = Array.from(ret);
      while (ret.length < 3) {
        ret.push(1);
      }
    }

    return new Int32Array(ret);
  },

  flatten2dArrayTo(array, target) {
    let offset = 0;
    for (let y = 0; y < array.length; y++) {
      target.set(array[y], offset);
      offset += array[y].length;
    }
  },

  flatten3dArrayTo(array, target) {
    let offset = 0;
    for (let z = 0; z < array.length; z++) {
      for (let y = 0; y < array[z].length; y++) {
        target.set(array[z][y], offset);
        offset += array[z][y].length;
      }
    }
  },

  flatten4dArrayTo(array, target) {
    let offset = 0;
    for (let l = 0; l < array.length; l++) {
      for (let z = 0; z < array[l].length; z++) {
        for (let y = 0; y < array[l][z].length; y++) {
          target.set(array[l][z][y], offset);
          offset += array[l][z][y].length;
        }
      }
    }
  },

  flattenTo(array, target) {
    if (utils.isArray(array[0])) {
      if (utils.isArray(array[0][0])) {
        if (utils.isArray(array[0][0][0])) {
          utils.flatten4dArrayTo(array, target);
        } else {
          utils.flatten3dArrayTo(array, target);
        }
      } else {
        utils.flatten2dArrayTo(array, target);
      }
    } else {
      target.set(array);
    }
  },

  splitArray(array, part) {
    const result = [];
    for (let i = 0; i < array.length; i += part) {
      result.push(new array.constructor(array.buffer, i * 4 + array.byteOffset, part));
    }
    return result;
  },

  getAstString(source, ast) {
    const lines = Array.isArray(source) ? source : source.split(/\r?\n/g);
    const start = ast.loc.start;
    const end = ast.loc.end;
    const result = [];
    if (start.line === end.line) {
      result.push(lines[start.line - 1].substring(start.column, end.column));
    } else {
      result.push(lines[start.line - 1].slice(start.column));
      for (let i = start.line; i < end.line; i++) {
        result.push(lines[i]);
      }
      result.push(lines[end.line - 1].slice(0, end.column));
    }
    return result.join('\n');
  },

  allPropertiesOf(obj) {
    const props = [];

    do {
      props.push.apply(props, Object.getOwnPropertyNames(obj));
    } while (obj = Object.getPrototypeOf(obj));

    return props;
  },

  linesToString(lines) {
    if (lines.length > 0) {
      return lines.join(';\n') + ';\n';
    } else {
      return '\n';
    }
  },
  warnDeprecated(type, oldName, newName) {
    if (newName) {
      console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been replaced with "${ newName }". Fixing, but please upgrade as it will soon be removed.`);
    } else {
      console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been removed. Fixing, but please upgrade as it will soon be removed.`);
    }
  },
  flipPixels: (pixels, width, height) => {
    const halfHeight = height / 2 | 0; 
    const bytesPerRow = width * 4;
    const temp = new Uint8ClampedArray(width * 4);
    const result = pixels.slice(0);
    for (let y = 0; y < halfHeight; ++y) {
      const topOffset = y * bytesPerRow;
      const bottomOffset = (height - y - 1) * bytesPerRow;

      temp.set(result.subarray(topOffset, topOffset + bytesPerRow));

      result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);

      result.set(temp, bottomOffset);
    }
    return result;
  },
  erectPackedFloat: (array, width) => {
    return array.subarray(0, width);
  },
  erect2DPackedFloat: (array, width, height) => {
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xStart = y * width;
      const xEnd = xStart + width;
      yResults[y] = array.subarray(xStart, xEnd);
    }
    return yResults;
  },
  erect3DPackedFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xStart = (z * height * width) + y * width;
        const xEnd = xStart + width;
        yResults[y] = array.subarray(xStart, xEnd);
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectMemoryOptimizedFloat: (array, width) => {
    return array.subarray(0, width);
  },
  erectMemoryOptimized2DFloat: (array, width, height) => {
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const offset = y * width;
      yResults[y] = array.subarray(offset, offset + width);
    }
    return yResults;
  },
  erectMemoryOptimized3DFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const offset = (z * height * width) + (y * width);
        yResults[y] = array.subarray(offset, offset + width);
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectFloat: (array, width) => {
    const xResults = new Float32Array(width);
    let i = 0;
    for (let x = 0; x < width; x++) {
      xResults[x] = array[i];
      i += 4;
    }
    return xResults;
  },
  erect2DFloat: (array, width, height) => {
    const yResults = new Array(height);
    let i = 0;
    for (let y = 0; y < height; y++) {
      const xResults = new Float32Array(width);
      for (let x = 0; x < width; x++) {
        xResults[x] = array[i];
        i += 4;
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    let i = 0;
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Float32Array(width);
        for (let x = 0; x < width; x++) {
          xResults[x] = array[i];
          i += 4;
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray2: (array, width) => {
    const xResults = new Array(width);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 2);
    }
    return xResults;
  },
  erect2DArray2: (array, width, height) => {
    const yResults = new Array(height);
    const XResultsMax = width * 4;
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * XResultsMax;
      let i = 0;
      for (let x = 0; x < XResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 2);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray2: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 2);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray3: (array, width) => {
    const xResults = new Array(width);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 3);
    }
    return xResults;
  },
  erect2DArray3: (array, width, height) => {
    const xResultsMax = width * 4;
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * xResultsMax;
      let i = 0;
      for (let x = 0; x < xResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 3);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray3: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 3);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray4: (array, width) => {
    const xResults = new Array(array);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 4);
    }
    return xResults;
  },
  erect2DArray4: (array, width, height) => {
    const xResultsMax = width * 4;
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * xResultsMax;
      let i = 0;
      for (let x = 0; x < xResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 4);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray4: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 4);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },

  flattenFunctionToString: (source, settings) => {
    const { findDependency, thisLookup, doNotDefine } = settings;
    let flattened = settings.flattened;
    if (!flattened) {
      flattened = settings.flattened = {};
    }
    const ast = acorn.parse(source);
    const functionDependencies = [];
    let indent = 0;

    function flatten(ast) {
      if (Array.isArray(ast)) {
        const results = [];
        for (let i = 0; i < ast.length; i++) {
          results.push(flatten(ast[i]));
        }
        return results.join('');
      }
      switch (ast.type) {
        case 'Program':
          return flatten(ast.body) + (ast.body[0].type === 'VariableDeclaration' ? ';' : '');
        case 'FunctionDeclaration':
          return `function ${ast.id.name}(${ast.params.map(flatten).join(', ')}) ${ flatten(ast.body) }`;
        case 'BlockStatement': {
          const result = [];
          indent += 2;
          for (let i = 0; i < ast.body.length; i++) {
            const flat = flatten(ast.body[i]);
            if (flat) {
              result.push(' '.repeat(indent) + flat, ';\n');
            }
          }
          indent -= 2;
          return `{\n${result.join('')}}`;
        }
        case 'VariableDeclaration':
          const declarations = utils.normalizeDeclarations(ast)
            .map(flatten)
            .filter(r => r !== null);
          if (declarations.length < 1) {
            return '';
          } else {
            return `${ast.kind} ${declarations.join(',')}`;
          }
          case 'VariableDeclarator':
            if (ast.init.object && ast.init.object.type === 'ThisExpression') {
              const lookup = thisLookup(ast.init.property.name, true);
              if (lookup) {
                return `${ast.id.name} = ${flatten(ast.init)}`;
              } else {
                return null;
              }
            } else {
              return `${ast.id.name} = ${flatten(ast.init)}`;
            }
            case 'CallExpression': {
              if (ast.callee.property.name === 'subarray') {
                return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              }
              if (ast.callee.object.name === 'gl' || ast.callee.object.name === 'context') {
                return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              }
              if (ast.callee.object.type === 'ThisExpression') {
                functionDependencies.push(findDependency('this', ast.callee.property.name));
                return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              } else if (ast.callee.object.name) {
                const foundSource = findDependency(ast.callee.object.name, ast.callee.property.name);
                if (foundSource === null) {
                  return `${ast.callee.object.name}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                } else {
                  functionDependencies.push(foundSource);
                  return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                }
              } else if (ast.callee.object.type === 'MemberExpression') {
                return `${flatten(ast.callee.object)}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              } else {
                throw new Error('unknown ast.callee');
              }
            }
            case 'ReturnStatement':
              return `return ${flatten(ast.argument)}`;
            case 'BinaryExpression':
              return `(${flatten(ast.left)}${ast.operator}${flatten(ast.right)})`;
            case 'UnaryExpression':
              if (ast.prefix) {
                return `${ast.operator} ${flatten(ast.argument)}`;
              } else {
                return `${flatten(ast.argument)} ${ast.operator}`;
              }
              case 'ExpressionStatement':
                return `${flatten(ast.expression)}`;
              case 'SequenceExpression':
                return `(${flatten(ast.expressions)})`;
              case 'ArrowFunctionExpression':
                return `(${ast.params.map(flatten).join(', ')}) => ${flatten(ast.body)}`;
              case 'Literal':
                return ast.raw;
              case 'Identifier':
                return ast.name;
              case 'MemberExpression':
                if (ast.object.type === 'ThisExpression') {
                  return thisLookup(ast.property.name);
                }
                if (ast.computed) {
                  return `${flatten(ast.object)}[${flatten(ast.property)}]`;
                }
                return flatten(ast.object) + '.' + flatten(ast.property);
              case 'ThisExpression':
                return 'this';
              case 'NewExpression':
                return `new ${flatten(ast.callee)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              case 'ForStatement':
                return `for (${flatten(ast.init)};${flatten(ast.test)};${flatten(ast.update)}) ${flatten(ast.body)}`;
              case 'AssignmentExpression':
                return `${flatten(ast.left)}${ast.operator}${flatten(ast.right)}`;
              case 'UpdateExpression':
                return `${flatten(ast.argument)}${ast.operator}`;
              case 'IfStatement':
                return `if (${flatten(ast.test)}) ${flatten(ast.consequent)}`;
              case 'ThrowStatement':
                return `throw ${flatten(ast.argument)}`;
              case 'ObjectPattern':
                return ast.properties.map(flatten).join(', ');
              case 'ArrayPattern':
                return ast.elements.map(flatten).join(', ');
              case 'DebuggerStatement':
                return 'debugger;';
              case 'ConditionalExpression':
                return `${flatten(ast.test)}?${flatten(ast.consequent)}:${flatten(ast.alternate)}`;
              case 'Property':
                if (ast.kind === 'init') {
                  return flatten(ast.key);
                }
      }
      throw new Error(`unhandled ast.type of ${ ast.type }`);
    }
    const result = flatten(ast);
    if (functionDependencies.length > 0) {
      const flattenedFunctionDependencies = [];
      for (let i = 0; i < functionDependencies.length; i++) {
        const functionDependency = functionDependencies[i];
        if (!flattened[functionDependency]) {
          flattened[functionDependency] = true;
        }
        flattenedFunctionDependencies.push(utils.flattenFunctionToString(functionDependency, settings) + '\n');
      }
      return flattenedFunctionDependencies.join('') + result;
    }
    return result;
  },

  normalizeDeclarations: (ast) => {
    if (ast.type !== 'VariableDeclaration') throw new Error('Ast is not of type "VariableDeclaration"');
    const normalizedDeclarations = [];
    for (let declarationIndex = 0; declarationIndex < ast.declarations.length; declarationIndex++) {
      const declaration = ast.declarations[declarationIndex];
      if (declaration.id && declaration.id.type === 'ObjectPattern' && declaration.id.properties) {
        const { properties } = declaration.id;
        for (let propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {
          const property = properties[propertyIndex];
          if (property.value.type === 'ObjectPattern' && property.value.properties) {
            for (let subPropertyIndex = 0; subPropertyIndex < property.value.properties.length; subPropertyIndex++) {
              const subProperty = property.value.properties[subPropertyIndex];
              if (subProperty.type === 'Property') {
                normalizedDeclarations.push({
                  type: 'VariableDeclarator',
                  id: {
                    type: 'Identifier',
                    name: subProperty.key.name
                  },
                  init: {
                    type: 'MemberExpression',
                    object: {
                      type: 'MemberExpression',
                      object: declaration.init,
                      property: {
                        type: 'Identifier',
                        name: property.key.name
                      },
                      computed: false
                    },
                    property: {
                      type: 'Identifier',
                      name: subProperty.key.name
                    },
                    computed: false
                  }
                });
              } else {
                throw new Error('unexpected state');
              }
            }
          } else if (property.value.type === 'Identifier') {
            normalizedDeclarations.push({
              type: 'VariableDeclarator',
              id: {
                type: 'Identifier',
                name: property.value && property.value.name ? property.value.name : property.key.name
              },
              init: {
                type: 'MemberExpression',
                object: declaration.init,
                property: {
                  type: 'Identifier',
                  name: property.key.name
                },
                computed: false
              }
            });
          } else {
            throw new Error('unexpected state');
          }
        }
      } else if (declaration.id && declaration.id.type === 'ArrayPattern' && declaration.id.elements) {
        const { elements } = declaration.id;
        for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {
          const element = elements[elementIndex];
          if (element.type === 'Identifier') {
            normalizedDeclarations.push({
              type: 'VariableDeclarator',
              id: {
                type: 'Identifier',
                name: element.name
              },
              init: {
                type: 'MemberExpression',
                object: declaration.init,
                property: {
                  type: 'Literal',
                  value: elementIndex,
                  raw: elementIndex.toString(),
                  start: element.start,
                  end: element.end
                },
                computed: true
              }
            });
          } else {
            throw new Error('unexpected state');
          }
        }
      } else {
        normalizedDeclarations.push(declaration);
      }
    }
    return normalizedDeclarations;
  },

  splitHTMLImageToRGB: (gpu, image) => {
    const rKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.r * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const gKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.g * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const bKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.b * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const aKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.a * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const result = [
      rKernel(image),
      gKernel(image),
      bKernel(image),
      aKernel(image),
    ];
    result.rKernel = rKernel;
    result.gKernel = gKernel;
    result.bKernel = bKernel;
    result.aKernel = aKernel;
    result.gpu = gpu;
    return result;
  },

  splitRGBAToCanvases: (gpu, rgba, width, height) => {
    const visualKernelR = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(pixel.r / 255, 0, 0, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelR(rgba);

    const visualKernelG = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(0, pixel.g / 255, 0, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelG(rgba);

    const visualKernelB = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(0, 0, pixel.b / 255, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelB(rgba);

    const visualKernelA = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(255, 255, 255, pixel.a / 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelA(rgba);
    return [
      visualKernelR.canvas,
      visualKernelG.canvas,
      visualKernelB.canvas,
      visualKernelA.canvas,
    ];
  },

  getMinifySafeName: (fn) => {
    try {
      const ast = acorn.parse(`const value = ${fn.toString()}`);
      const { init } = ast.body[0].declarations[0];
      return init.body.name || init.body.body[0].argument.name;
    } catch (e) {
      throw new Error('Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }');
    }
  },
  sanitizeName: function(name) {
    if (dollarSign.test(name)) {
      name = name.replace(dollarSign, 'S_S');
    }
    if (doubleUnderscore.test(name)) {
      name = name.replace(doubleUnderscore, 'U_U');
    } else if (singleUnderscore.test(name)) {
      name = name.replace(singleUnderscore, 'u_u');
    }
    return name;
  }
};

const dollarSign = /\$/;
const doubleUnderscore = /__/;
const singleUnderscore = /_/;

const _systemEndianness = utils.getSystemEndianness();

module.exports = {
  utils
};
},{"./input":110,"./texture":113,"acorn":1}]},{},[107])(107)
});


/***/ }),

/***/ "./src/compiler.worker.js":
/*!********************************!*\
  !*** ./src/compiler.worker.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {extract} = __webpack_require__(/*! ./image-target/tracking/extractor.js */ "./src/image-target/tracking/extractor.js");
const {Detector} = __webpack_require__(/*! ./image-target/detectorGPU/detector.js */ "./src/image-target/detectorGPU/detector.js");
const {build: hierarchicalClusteringBuild} = __webpack_require__(/*! ./image-target/matching/hierarchical-clustering.js */ "./src/image-target/matching/hierarchical-clustering.js");
const {buildImageList} = __webpack_require__(/*! ./image-target/image-list.js */ "./src/image-target/image-list.js");

onmessage = (msg) => {
  const {data} = msg;
  if (data.type === 'compile') {
    const {targetImages} = data;
    const list = [];
    for (let i = 0; i < targetImages.length; i++) {
      const targetImage = targetImages[i];
      const imageList = buildImageList(targetImage);
      console.log("compiling tracking...", i);
      const trackingData = _extractTrackingFeatures(imageList);
      console.log("compiling matching...", i);
      const matchingData = _extractMatchingFeatures(imageList);
      list.push({
        targetImage,
        imageList,
        trackingData,
        matchingData
      });
    }
    postMessage({
      type: 'compileDone',
      list,
    });
  }
};

const _extractMatchingFeatures = (imageList) => {
  const keyframes = [];
  for (let i = 0; i < imageList.length; i++) {
    const image = imageList[i];
    const detector = new Detector(image.width, image.height);
    const ps = detector.detectImageData(image.data);
    const pointsCluster = hierarchicalClusteringBuild({points: ps});
    keyframes.push({points: ps, pointsCluster, width: image.width, height: image.height, scale: image.dpi});
  }
  return keyframes;
}

const _extractTrackingFeatures = (imageList) => {
  const featureSets = [];
  for (let i = 0; i < imageList.length; i++) {
    const image = imageList[i];
    const coords = extract(image);

    const featureSet = {};
    featureSet.scale = i;
    featureSet.mindpi = (i === imageList.length-1)? imageList[i].dpi * 0.5: imageList[i+1].dpi;
    featureSet.maxdpi = (i === 0)? imageList[i].dpi * 2: (imageList[i].dpi * 0.8 + imageList[i-1].dpi * 0.2);
    featureSet.coords = [];
    for (let j = 0; j < coords.length; j++) {
      featureSet.coords.push({
        mx: coords[j].mx,
        my: coords[j].my,
      });
    }
    featureSets.push(featureSet);
  }
  return featureSets;
}


/***/ }),

/***/ "./src/image-target/detectorGPU/detector.js":
/*!**************************************************!*\
  !*** ./src/image-target/detectorGPU/detector.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {GPU} = __webpack_require__(/*! gpu.js */ "./node_modules/gpu.js/dist/gpu-browser.js");

const PYRAMID_NUM_SCALES_PER_OCTAVES = 3;
const PYRAMID_MIN_SIZE = 8;

const LAPLACIAN_SQR_THRESHOLD = 3 * 3;
const MAX_SUBPIXEL_DISTANCE_SQR = 3 * 3;
const EDGE_THRESHOLD = 4.0;
const EDGE_HESSIAN_THRESHOLD = ((EDGE_THRESHOLD+1) * (EDGE_THRESHOLD+1) / EDGE_THRESHOLD);

const NUM_BUCKETS_PER_DIMENSION = 10;
const MAX_FEATURES_PER_BUCKET = 5;
//const NUM_BUCKETS_PER_DIMENSION = 20;
//const MAX_FEATURES_PER_BUCKET = 1;
const NUM_BUCKETS = NUM_BUCKETS_PER_DIMENSION * NUM_BUCKETS_PER_DIMENSION;
// total max feature points = NUM_BUCKETS * MAX_FEATURES_PER_BUCKET

const ORIENTATION_NUM_BINS = 36;
const ORIENTATION_SMOOTHING_ITERATIONS = 5;

const ORIENTATION_GAUSSIAN_EXPANSION_FACTOR = 3.0;
const ORIENTATION_REGION_EXPANSION_FACTOR = 1.5;
const FREAK_EXPANSION_FACTOR = 7.0;

// 37 points = 6 rings x 6 points per ring + 1 center
const FREAK_RINGS = [
  // ring 5
  {
    sigma: 0.550000,
    points: [
      [-1.000000, 0.000000],
      [-0.500000, -0.866025],
      [0.500000, -0.866025],
      [1.000000, -0.000000],
      [0.500000, 0.866025],
      [-0.500000, 0.866025]
    ]
  },
  // ring 4
  {
    sigma: 0.475000,
    points: [
      [0.000000, 0.930969],
      [-0.806243, 0.465485],
      [-0.806243, -0.465485],
      [-0.000000, -0.930969],
      [0.806243, -0.465485],
      [0.806243, 0.465485]
    ]
  },
  // ring 3
  {
    sigma: 0.400000,
    points: [
      [0.847306, -0.000000],
      [0.423653, 0.733789],
      [-0.423653, 0.733789],
      [-0.847306, 0.000000],
      [-0.423653, -0.733789],
      [0.423653, -0.733789]
    ]
  },
  // ring 2
  {
    sigma: 0.325000,
    points: [
      [-0.000000, -0.741094],
      [0.641806, -0.370547],
      [0.641806, 0.370547],
      [0.000000, 0.741094],
      [-0.641806, 0.370547],
      [-0.641806, -0.370547]
    ]
  },
  // ring 1
  {
    sigma: 0.250000,
    points: [
      [-0.595502, 0.000000],
      [-0.297751, -0.515720],
      [0.297751, -0.515720],
      [0.595502, -0.000000],
      [0.297751, 0.515720],
      [-0.297751, 0.515720]
    ]
  },
  // ring 0
  {
    sigma: 0.175000,
    points: [
      [0.000000, 0.362783],
      [-0.314179, 0.181391],
      [-0.314179, -0.181391],
      [-0.000000, -0.362783],
      [0.314179, -0.181391],
      [0.314179, 0.181391]
    ]
  },
  // center
  {
    sigma: 0.100000,
    points: [
      [0, 0]
    ]
  }
];

const FREAKPOINTS = [];
for (let r = 0; r < FREAK_RINGS.length; r++) {
  const sigma = FREAK_RINGS[r].sigma;
  for (let i = 0; i < FREAK_RINGS[r].points.length; i++) {
    const point = FREAK_RINGS[r].points[i];
    FREAKPOINTS.push([sigma, point[0], point[1]]);
  }
}

const FREAK_CONPARISON_COUNT = (FREAKPOINTS.length-1) * (FREAKPOINTS.length) / 2; // 666

// gpu.js use 32-bit float number. it has 24 significant bit and 8 bit exponent (can confirmed?)
//   therefore, it can only put 24 bits of information with full accuracy
//   any better way to utilize all 32 bits?
const FREAK_24BIT_DESCRIPTOR_COUNT = Math.ceil(FREAK_CONPARISON_COUNT / 24); // ceil(666/24) = 28 numbers

class Detector {
  constructor(width, height) {
    this.width = width;
    this.height = height;

    let numOctaves = 0;
    while (width >= PYRAMID_MIN_SIZE && height >= PYRAMID_MIN_SIZE) {
      width /= 2;
      height /= 2;
      numOctaves++;
    }
    this.numOctaves = numOctaves;
    this.kernels = [];
    this.gpu = new GPU();
    this.inputKernel = null;
  }

  detect(input) {
    if (this.inputKernel === null) {
      this.inputKernel = this.gpu.createKernel(function(inputFrame) {
        const pixel = inputFrame[this.constants.height-1-Math.floor(this.thread.x / this.constants.width)][this.thread.x % this.constants.width];
        //return (pixel[0] + pixel[1] + pixel[2]) * 255 / 3;
        // https://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color/596241#596241
        return 255 * (0.2126 * pixel[0] + 0.7152 * pixel[1] + 0.0722 * pixel[2]);
      }, {
        constants: {width: this.width, height: this.height},
        output: [this.width * this.height],
        pipeline: true,
      })
    }
    const result = this.inputKernel(input);
    return this.detectImageData(result);
  }

  detectImageData(imagedata) {
    this.kernelIndex = 0; // reset kernelIndex

    const inputImage = {width: this.width, height: this.height, data: imagedata};

    const originalWidth = this.width;
    const originalHeight = this.height;
    const numOctaves = this.numOctaves;

    // Build gaussian pyramid images
    const pyramidImages = [];
    for (let i = 0; i < numOctaves; i++) {
      if (i === 0) {
        pyramidImages.push(this._applyFilter(inputImage));
      } else {
        // first image of each octave, downsample from previous
        pyramidImages.push(this._downsampleBilinear(pyramidImages[pyramidImages.length-1]));
      }

      // remaining images of octave, 4th order binomail from previous
      for (let j = 0; j < PYRAMID_NUM_SCALES_PER_OCTAVES - 1; j++) {
        pyramidImages.push(this._applyFilter(pyramidImages[pyramidImages.length-1]));
      }
    }

    // Build difference of gaussian pyramid
    const dogPyramidImages = [];
    for (let i = 0; i < numOctaves; i++) {
      for (let j = 0; j < PYRAMID_NUM_SCALES_PER_OCTAVES - 1; j++) {
        const image1 = pyramidImages[i * PYRAMID_NUM_SCALES_PER_OCTAVES + j];
        const image2 = pyramidImages[i * PYRAMID_NUM_SCALES_PER_OCTAVES + j + 1];
        dogPyramidImages.push(this._differenceImageBinomial(image1, image2));
      }
    }

    let prunedExtremas = this._initializePrune();

    // Find feature points (i.e. extremas in dog images)
    for (let k = 1; k < dogPyramidImages.length - 1; k++) {
      // Experimental result shows that no extrema is possible for odd number of k
      // I believe it has something to do with how the gaussian pyramid being constructed
      if (k % 2 === 1) continue;

      let image0 = dogPyramidImages[k-1];
      let image1 = dogPyramidImages[k];
      let image2 = dogPyramidImages[k+1];

      const octave = Math.floor(k / (PYRAMID_NUM_SCALES_PER_OCTAVES-1));
      const scale = k % (PYRAMID_NUM_SCALES_PER_OCTAVES-1);

      let hasUpsample = false;
      let hasPadOneWidth = false;
      let hasPadOneHeight = false;

      if ( Math.floor(image0.width/2) == image1.width) {
        image0 = this._downsampleBilinear(image0);
      }
      if ( Math.floor(image1.width/2) == image2.width) {
        hasUpsample = true;
        hasPadOneWidth = image1.width % 2 === 1;
        hasPadOneHeight = image1.height % 2 === 1;
        image2 = this._upsampleBilinear(image2, hasPadOneWidth, hasPadOneHeight);
      }

      // In upsample image, ignore the border
      // it's possible to further pad one more line (i.e. upsacale 2x2 -> 5x5), so ignore one more line
      let startI = hasUpsample? 2: 1;
      let startJ = startI;

      // should it be "image1.width -2" ? but this yield consistent result with artoolkit
      let endI = hasUpsample? image1.width - 3: image1.width - 1;
      let endJ = hasUpsample? image1.height - 3: image1.height - 1;
      if (hasPadOneWidth) endI -= 1;
      if (hasPadOneHeight) endJ -= 1;

      // find all extrema for image1
      const extremasResult = this._buildExtremas(image0, image1, image2, octave, scale, startI, startJ, endI, endJ);

      // combine this extrema with the existing
      prunedExtremas = this._applyPrune(k, prunedExtremas, extremasResult, image1.width, image1.height);
    }

    // compute the orientation angle of the extrema
    //  artoolkit picks mutiple angles (usually 1-3), but we pick one only for simplicity
    let extremaHistograms = this._initializeHistograms();
    for (let k = 1; k < dogPyramidImages.length - 1; k++) {
      const octave = Math.floor(k / (PYRAMID_NUM_SCALES_PER_OCTAVES-1));
      const scale = k % (PYRAMID_NUM_SCALES_PER_OCTAVES-1);
      const gaussianIndex = octave * PYRAMID_NUM_SCALES_PER_OCTAVES + scale;
      const gaussianImage = pyramidImages[gaussianIndex]
      const gradientResult = this._computeGradients(gaussianImage);

      extremaHistograms = this._computeOrientationHistograms(extremaHistograms, gradientResult, prunedExtremas, k, gaussianImage.width, gaussianImage.height);
    }
    extremaHistograms = this._smoothHistograms(extremaHistograms);
    const extremaAngles = this._computeExtremaAngles(extremaHistograms);

    // compute the FREAK descriptors for extremas
    const extremaFreaks = this._computeExtremaFreak(pyramidImages, numOctaves, prunedExtremas, extremaAngles);
    const freakDescriptors = this._computeFreakDescriptors(extremaFreaks);

    // combine all needed data and return to CPU together
    const combinedExtremas = this._combine(prunedExtremas, freakDescriptors);

    const combinedExtremasArr = combinedExtremas.toArray();

    const featurePoints = [];
    for (let i = 0; i < combinedExtremasArr.length; i++) {
      for (let j = 0; j < combinedExtremasArr[i].length; j++) {
        if (combinedExtremasArr[i][j][0] !== 0) {
          const ext = combinedExtremasArr[i][j];

          const descBit24 = ext.slice(3);
          // convert 24-bits encoded to 32-bits encoded. i.e. every 4 numbers to 3 numbers
          //  [24 + 8] [16 + 16] [8 + 24]
          // altogether 28 numbers, so perfectly convert to 21 numbers
          const descriptors = [];
          for (let k = 0; k < descBit24.length; k += 4) {
            const v1 = descBit24[k] * 256 + (descBit24[k+1] >> 16);
            const v2 = (descBit24[k+1] & 65535) * 65536 + (descBit24[k+2] >> 8);
            const v3 = (descBit24[k+2] & 255) * 16777216 + descBit24[k+3];
            descriptors.push(v1);
            descriptors.push(v2);
            descriptors.push(v3);
          }
          // there are 666 freak bits to encode, so the last descriptors only use 26 bits. (666 % 32)
          // for historically reason, it started from the 2nd least significant bits (but not necessary); so now we shift by (32-26-1) bits
          descriptors[descriptors.length-1] = (descriptors[descriptors.length-1] >>> 5);

          featurePoints.push({
            maxima: ext[0] > 0,
            x: ext[1],
            y: ext[2],
            descriptors: descriptors
          });
        }
      }
    }

    return featurePoints;
  }

  _initializePrune() {
    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        this.gpu.createKernel(function() {
          return 0;
        }, {
          output: [5, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS], // first dimension: [score, sigma, x, y, dogIndex]
          pipeline: true,
        })
      )
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel();
    return result;
  }

  // combine necessary information to return to cpu
  // first dimension: [score, x, y, freak1, freak2, ..., freak37]
  _combine(prunedExtremas, freakDescriptors) {
    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        this.gpu.createKernel(function(prunedExtremas, freakDescriptors) {
          if (this.thread.x === 0) {
            return prunedExtremas[this.thread.z][this.thread.y][0];
          } else if (this.thread.x <= 2) {
            return prunedExtremas[this.thread.z][this.thread.y][this.thread.x + 1];
          }
          return freakDescriptors[this.thread.z][this.thread.y][this.thread.x-3];
        }, {
          output: [3 + FREAK_24BIT_DESCRIPTOR_COUNT, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      )
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel(prunedExtremas, freakDescriptors);
    return result;
  }

  _initializeHistograms() {
    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        this.gpu.createKernel(function() {
          return 0;
        }, {
          output: [ORIENTATION_NUM_BINS, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      )
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel();
    return result;
  }

  _computeOrientationHistograms(extremaHistograms, gradientResult, prunedExtremas, dogIndex, width, height) {
    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        this.gpu.createKernel(function(extremaHistograms, gradientMags, gradientAngles, prunedExtremas) {
          const dogIndex = this.constants.dogIndex;
          const bucketPointIndex = this.thread.y;
          const bucketIndex = this.thread.z;

          const thisDogIndex = prunedExtremas[bucketIndex][bucketPointIndex][4];
          if (dogIndex !== thisDogIndex) {
            return extremaHistograms[this.thread.z][this.thread.y][this.thread.x];
          }

          const octave = this.constants.octave;
          const scale = this.constants.scale;
          const numBins = this.constants.numBins;
          const width = this.constants.width;
          const height = this.constants.height;
          const oneOver2PI = 0.159154943091895;
          const gaussianExpansionFactor = this.constants.gaussianExpansionFactor;
          const regionExpansionFactor = this.constants.regionExpansionFactor;

          const histogramIndex = this.thread.x;

          const originalSigma = prunedExtremas[bucketIndex][bucketPointIndex][1];
          const originalX = prunedExtremas[bucketIndex][bucketPointIndex][2];
          const originalY = prunedExtremas[bucketIndex][bucketPointIndex][3];

          // x, y, sigma in current octave
          const octaveFactor = 1.0 / Math.pow(2, octave);
          const x = Math.floor(originalX * octaveFactor + 0.5 * octaveFactor);
          const y = Math.floor(originalY * octaveFactor + 0.5 * octaveFactor);
          const sigma = originalSigma * octaveFactor;

          const gwSigma = Math.max(1.0, gaussianExpansionFactor * sigma);
          const gwScale = -1.0 / (2 * gwSigma * gwSigma);

          const radius = regionExpansionFactor * gwSigma;
          const radius2 = Math.ceil(radius * radius - 0.5);

          const x0 = Math.max(0, x - Math.floor(radius + 0.5));
          const x1 = Math.min(width-1, x + Math.floor(radius + 0.5));
          const y0 = Math.max(0, y - Math.floor(radius + 0.5));
          const y1 = Math.min(height-1, y + Math.floor(radius + 0.5));

          let sum = 0;

          for (let yp = y0; yp <= y1; yp++) {
            const dy = yp - y;
            const dy2 = dy * dy;
            for (let xp = x0; xp <= x1; xp++) {
              const dx = xp - x;
              const dx2 = dx * dx;
              const r2 = dx2 + dy2;

              if (r2 <= radius2) {
                const mag = gradientMags[yp * width + xp];
                const angle = gradientAngles[yp * width + xp];
                const _x = r2 * gwScale;

                /**
                 * fast Exp6
                 * 0.01% error at 1.030
                 * 0.10% error at 1.520
                 * 1.00% error at 2.330
                 * 5.00% error at 3.285
                 */
                const w = (720+_x*(720+_x*(360+_x*(120+_x*(30+_x*(6+_x))))))*0.0013888888;

                const fbin  = numBins * angle * oneOver2PI;
                const bin = Math.floor(fbin - 0.5);
                const w2 = fbin - bin - 0.5;
                const w1 = (1.0 - w2);
                const b1 = (bin + numBins) % numBins;
                const b2 = (bin + 1) % numBins;
                const magnitude = w * mag;

                if (b1 === this.thread.x) sum += w1 * magnitude;
                if (b2 === this.thread.x) sum += w2 * magnitude;
              }
            }
          }
          return sum;
        }, {
          constants: {
            dogIndex: dogIndex,
            octave: Math.floor(dogIndex / (PYRAMID_NUM_SCALES_PER_OCTAVES-1)),
            scale: dogIndex % (PYRAMID_NUM_SCALES_PER_OCTAVES-1),
            numBins: ORIENTATION_NUM_BINS,
            width: width,
            height: height,
            gaussianExpansionFactor: ORIENTATION_GAUSSIAN_EXPANSION_FACTOR,
            regionExpansionFactor: ORIENTATION_REGION_EXPANSION_FACTOR
          },
          output: [ORIENTATION_NUM_BINS, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      )
    }
    const kernel = this.kernels[this.kernelIndex++];
    const gradientMags = gradientResult.saveMag;
    const gradientAngles = gradientResult.result;
    const result = kernel(extremaHistograms, gradientMags, gradientAngles, prunedExtremas);
    return result;
  }

  _smoothHistograms(histograms) {
    if (this.kernelIndex === this.kernels.length) {
      const subkernels = [];
      for (let k = 0; k < ORIENTATION_SMOOTHING_ITERATIONS; k++) {
        subkernels.push(
          this.gpu.createKernel(function(histograms) {
            const numBins = this.constants.numBins;
            // The histogram is smoothed with a Gaussian, with sigma = 1
            return 0.274068619061197 * histograms[this.thread.z][this.thread.y][(this.thread.x - 1 + numBins) % numBins]
                 + 0.451862761877606 * histograms[this.thread.z][this.thread.y][this.thread.x]
                 + 0.274068619061197 * histograms[this.thread.z][this.thread.y][(this.thread.x + 1) % numBins];
          }, {
            constants: {numBins: ORIENTATION_NUM_BINS},
            output: [ORIENTATION_NUM_BINS, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
            pipeline: true,
          })
        );
      }
      this.kernels.push(subkernels);
    }
    const subkernels = this.kernels[this.kernelIndex++];
    for (let k = 0; k < ORIENTATION_SMOOTHING_ITERATIONS; k++) {
      histograms = subkernels[k](histograms);
    }
    return histograms;
  }

  _computeExtremaAngles(histograms) {
    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        this.gpu.createKernel(function(histograms) {
          const numBins = this.constants.numBins;

          let maxIndex = 0;
          for (let i = 1; i < numBins; i++) {
            if (histograms[this.thread.z][this.thread.y][i] > histograms[this.thread.z][this.thread.y][maxIndex]) {
              maxIndex = i;
            }
          }
          const prev = (maxIndex - 1 + numBins) % numBins;
          const next = (maxIndex + 1) % numBins;

          let fbin = maxIndex; // default if no quadratic fit
          /**
           * Fit a quatratic to 3 points. The system of equations is:
           *
           * y0 = A*x0^2 + B*x0 + C
           * y1 = A*x1^2 + B*x1 + C
           * y2 = A*x2^2 + B*x2 + C
           *
           * This system of equations is solved for A,B,C.
           */
          const p10 = maxIndex-1;
          const p11 = histograms[this.thread.z][this.thread.y][prev];
          const p20 = maxIndex;
          const p21 = histograms[this.thread.z][this.thread.y][maxIndex];
          const p30 = maxIndex+1;
          const p31 = histograms[this.thread.z][this.thread.y][next];

          const d1 = (p30-p20)*(p30-p10);
          const d2 = (p10-p20)*(p30-p10);
          const d3 = p10-p20;

          // If any of the denominators are zero then return FALSE.
          if (d1 != 0 && d2 != 0 && d3 != 0) {
            const a = p10*p10;
            const b = p20*p20;

            // Solve for the coefficients A,B,C
            const A = ((p31-p21)/d1)-((p11-p21)/d2);
            const B = ((p11-p21)+(A*(b-a)))/d3;
            const C = p11-(A*a)-(B*p10);
            fbin = -B / (2 * A);
          }

          let an =  2.0 * Math.PI * ((fbin + 0.5 + numBins) / numBins);
          while (an > 2.0 * Math.PI) { // modula
            an -= 2.0 * Math.PI;
          }
          return an;
        }, {
          constants: {numBins: ORIENTATION_NUM_BINS},
          output: [1, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      );
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel(histograms);
    return result;
  }

  _applyPrune(dogIndex, prunedExtremas, extremasResult, width, height) {
    const extremaScores = extremasResult.result;
    const extremaSigmas = extremasResult.saveSigma;
    const extremaXs = extremasResult.saveX;
    const extremaYs = extremasResult.saveY;

    if (this.kernelIndex === this.kernels.length) {
      const subkernels = [];

      subkernels.push( //dummy
        this.gpu.createKernel(function() {
          return -1;
        }, {
          output: [1, NUM_BUCKETS],
          pipeline: true,
        })
      );

      // compute the orders one by one, and store the index as:
      //  if maxIndex < 0: it means coming from the existing prunedExtremas. the position is (-maxIndex-1);
      //        e.g. -1 -> 0, -2 -> 1, -3 -> 2
      //  if maxIndex >= 0: it means coming from the new extremas. the position is the pixel index
      for (let i = 0; i < MAX_FEATURES_PER_BUCKET; i++) {
        subkernels.push(
          this.gpu.createKernel(function(orders, prunedExtremas, extremaScores) {
            const bucketPointIndex = this.thread.x;
            const bucketIndex = this.thread.y;
            const orderIndex = this.constants.orderIndex;
            if (bucketPointIndex < orderIndex) return orders[this.thread.y][this.thread.x];

            const width = this.constants.width;
            const height= this.constants.height;
            const numBucketsPerDimension = this.constants.numBucketsPerDimension;
            const dx = this.constants.bucketWidth;
            const dy = this.constants.bucketHeight;

            const bucketX = bucketIndex % numBucketsPerDimension;
            const bucketY = Math.floor(bucketIndex / numBucketsPerDimension);

            let currentPrunedMaxIndex = -1;
            for (let i = 0; i < orderIndex; i++) {
              if (orders[bucketIndex][i] < 0) currentPrunedMaxIndex -= 1;
            }
            let maxIndex = currentPrunedMaxIndex;
            let maxScore = Math.abs(prunedExtremas[bucketIndex][-1 * currentPrunedMaxIndex - 1][0]); // score at propertyIndex 0
            maxScore = Math.max(maxScore, 0.0001); // safeguard, but probably not needed

            let startX = Math.floor(bucketX * dx);
            let endX = Math.floor((bucketX + 1) * dx);
            let startY = Math.floor(bucketY * dy);
            let endY = Math.floor((bucketY + 1) * dy);

            for (let i = startX; i < endX; i++) {
              for (let j = startY; j < endY; j++) {
                const pointIndex = j * width + i;
                const pointScore = Math.abs(extremaScores[pointIndex]);
                if (pointScore > maxScore) {
                  let selected = false;
                  for (let k = 0; k < orderIndex; k++) {
                    if (orders[bucketIndex][k] === pointIndex) selected = true;
                  }
                  if (!selected) {
                    maxScore = pointScore;
                    maxIndex = pointIndex;
                  }
                }
              }
            }
            return maxIndex;
          }, {
            constants: {
              bucketWidth: width / NUM_BUCKETS_PER_DIMENSION,
              bucketHeight: height / NUM_BUCKETS_PER_DIMENSION,
              width: width,
              height: height,
              numBucketsPerDimension: NUM_BUCKETS_PER_DIMENSION,
              orderIndex: i
            },
            output: [i+1, NUM_BUCKETS],
            pipeline: true,
          })
        )
      }
      subkernels.push(
        this.gpu.createKernel(function(orders, prunedExtremas, extremaScores, extremaSigmas, extremaXs, extremaYs) {
          const dogIndex = this.constants.dogIndex;
          const propertyIndex = this.thread.x;
          const bucketPointIndex = this.thread.y;
          const bucketIndex = this.thread.z;
          const maxIndex = orders[bucketIndex][bucketPointIndex];
          if (maxIndex < 0) {
            return prunedExtremas[bucketIndex][-1 * maxIndex -1][propertyIndex];
          } else {
            if (propertyIndex === 0) return extremaScores[maxIndex];
            if (propertyIndex === 1) return extremaSigmas[maxIndex];
            if (propertyIndex === 2) return extremaXs[maxIndex];
            if (propertyIndex === 3) return extremaYs[maxIndex];
            if (propertyIndex === 4) return dogIndex;
          }
        }, {
          constants: {
            dogIndex: dogIndex,
          },
          output: [5, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS], // first dimension: [score, sigma, x, y, dogIndex]
          pipeline: true,
        })
      );
      this.kernels.push(subkernels);
    }

    const subkernels = this.kernels[this.kernelIndex++];
    let c = 0;
    let orders = subkernels[c++](); // dummy
    for (let i = 0; i < MAX_FEATURES_PER_BUCKET; i++) {
      orders = subkernels[c++](orders, prunedExtremas, extremaScores); // build max index one by one
    }
    // pack the result
    const result = subkernels[c++](orders, prunedExtremas, extremaScores, extremaSigmas, extremaXs, extremaYs);
    return result;
  }

  _computeGradients(image) {
    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        this.gpu.createKernelMap({
          saveMag: function(a) {return a}
        },
        function(data) {
          const width = this.constants.width;
          const height = this.constants.height;

          const i = this.thread.x % width;
          const j = Math.floor(this.thread.x / width);
          const prevJ = j > 0? j - 1: j;
          const nextJ = j < height - 1? j + 1: j;
          const prevI = i > 0? i - 1: i;
          const nextI = i < width - 1? i + 1: i;
          const dx = data[j * width + nextI] - data[j * width + prevI];
          const dy = data[nextJ * width + i] - data[prevJ * width + i];

          // seems like gpu atan2 doesn't handle dx === 0 well
          // angle = Math.atan2(dy, dx); can someone verify correctness?
          let angle = 0;
          if (dx === 0 && dy === 0) angle = 0;
          else if (dy === 0) {
            if (dx < 0) angle = Math.PI;
            else angle = 0;
          }
          else if (dx === 0) {
            if (dy < 0) angle = -Math.PI / 2;
            else angle = Math.PI / 2;
          }
          else {
            angle = Math.atan2(Math.abs(dy), Math.abs(dx));
            if (dx < 0 && dy > 0) angle = Math.PI - angle;
            else if (dx < 0 && dy < 0) angle = -(Math.PI - angle);
            else if (dx > 0 && dy < 0) angle = -angle;
          }
          angle += Math.PI;

          const mag = Math.sqrt(dx * dx + dy * dy);
          saveMag(mag);
          return angle;
        }, {
          constants: {width: image.width, height: image.height},
          output: [image.width * image.height],
          pipeline: true,
        })
      )
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel(image.data);
    return result;
  }

  _computeFreakDescriptors(freakResult) {
    if (this.kernelIndex === this.kernels.length) {
      const subkernels = [];
      subkernels.push(
        this.gpu.createKernel(function(freakResult) {
          const numFreakPoints = this.constants.numFreakPoints;
          const x = this.thread.x;

          // binary search first point index
          let l = 0;
          let r = numFreakPoints - 1;
          let startAt = 0;
          const maxloop = 7; // l=0, r=36. max num of loops = m = 18,9,5,3,2,1,
          for (let i = 0; i < maxloop; i++) {
            if (l !== r) {
              let m = Math.ceil((l + r) / 2);
              startAt = (numFreakPoints-m + numFreakPoints-1) * m / 2;
              if (x < startAt) {
                r = m - 1;
              } else {
                l = m;
              }
            }
          }
          startAt = (numFreakPoints-l + numFreakPoints-1) * l / 2;
          const p1 = l;
          const p2 = x - startAt + (p1+1);

          if (freakResult[this.thread.z][this.thread.y][p1] < freakResult[this.thread.z][this.thread.y][p2] + 0.0001) return 1;
          return 0;
        }, {
          constants: {
            numFreakPoints: FREAKPOINTS.length
          },
          output: [FREAK_CONPARISON_COUNT, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      )

      subkernels.push(
        this.gpu.createKernel(function(freakValues) {
          const comparisonCount = this.constants.comparisonCount;
          const x = this.thread.x;
          const start = 24 * x;
          const end = start + 24;
          let temp = 0;
          for (let i = start; i < end; i++) {
            if (i < comparisonCount && freakValues[this.thread.z][this.thread.y][i] === 1) {
              temp += 1;
            }
            temp = temp * 2;
          }
          temp /= 2;

          return temp;
        }, {
          constants: {
            comparisonCount: FREAK_CONPARISON_COUNT,
            numFreakPoints: FREAKPOINTS.length
          },
          output: [FREAK_24BIT_DESCRIPTOR_COUNT, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      );

      this.kernels.push(subkernels);
    }
    const subkernels = this.kernels[this.kernelIndex++];
    const result = subkernels[0](freakResult);
    const result2 = subkernels[1](result);
    return result2;
  }

  _computeExtremaFreak(pyramidImages, gaussianNumOctaves, prunedExtremas, prunedExtremasAngles) {
    if (this.kernelIndex === this.kernels.length) {
      const subkernels = [];

      subkernels.push(
        this.gpu.createKernelMap({
          saveXp: function(a) {return a},
          saveYp: function(a) {return a}
        },
        function(prunedExtremas, prunedExtremasAngles, freakPoints) {
          const gaussianNumOctaves = this.constants.gaussianNumOctaves;
          const gaussianNumScalesPerOctaves = this.constants.gaussianNumScalesPerOctaves;
          const expansionFactor = this.constants.expansionFactor;

          const bucketPointIndex = this.thread.y;
          const bucketIndex = this.thread.z;

          const mK = Math.pow(2, 1.0 / (gaussianNumScalesPerOctaves-1));
          const oneOverLogK = 1.0 / Math.log(mK);

          const inputX = prunedExtremas[bucketIndex][bucketPointIndex][2];
          const inputY = prunedExtremas[bucketIndex][bucketPointIndex][3];
          const inputSigma = prunedExtremas[bucketIndex][bucketPointIndex][1];
          const inputAngle = prunedExtremasAngles[bucketIndex][bucketPointIndex][0];

          const freakSigma = freakPoints[this.thread.x][0];
          const freakX = freakPoints[this.thread.x][1];
          const freakY = freakPoints[this.thread.x][2];

          // Ensure the scale of the similarity transform is at least "1".
          const transformScale = Math.max(1, inputSigma * expansionFactor);
          const c = transformScale * Math.cos(inputAngle);
          const s = transformScale * Math.sin(inputAngle);
          // similarity matrix
          // const S = [
          //  c, -s, x,
          //  s, c, y,
          //  0, 0, 1
          //]
          const S0 = c;
          const S1 = -s;
          const S2 = inputX;
          const S3 = s;
          const S4 = c;
          const S5 = inputY;

          const sigma = transformScale * freakSigma;
          let octave = Math.floor(Math.log2(sigma));
          const fscale = Math.log(sigma / Math.pow(2, octave)) * oneOverLogK;
          let scale = Math.round(fscale);

          // sgima of last scale = sigma of the first scale in next octave
          // prefer coarser octaves for efficiency
          if (scale === gaussianNumScalesPerOctaves - 1) {
            octave = octave + 1;
            scale = 0;
          }
          // clip octave and scale
          if (octave < 0) {
            octave = 0;
            scale = 0;
          }
          if (octave >= gaussianNumOctaves) {
            octave = gaussianNumOctaves - 1;
            scale = gaussianNumScalesPerOctaves - 1;
          }

          // for downsample point
          const imageIndex = octave * gaussianNumScalesPerOctaves + scale;
          const a = 1.0 / (Math.pow(2, octave));
          const b = 0.5 * a - 0.5;

          const x = S0 * freakX + S1 * freakY + S2;
          const y = S3 * freakX + S4 * freakY + S5;
          let xp = x * a + b; // x in octave
          let yp = y * a + b; // y in octave

          saveXp(xp);
          saveYp(yp);
          return imageIndex;
        }, {
          constants: {
            gaussianNumOctaves: gaussianNumOctaves,
            gaussianNumScalesPerOctaves: PYRAMID_NUM_SCALES_PER_OCTAVES,
            expansionFactor: FREAK_EXPANSION_FACTOR
          },
          output: [FREAKPOINTS.length, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      )

      subkernels.push(
        this.gpu.createKernel(function() {
          return 0;
        }, {
          output: [FREAKPOINTS.length, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      );

      for (let i = 0; i < pyramidImages.length; i++) {
        subkernels.push(
          this.gpu.createKernel(function(freakResult, imageData, xps, yps, imageIndexes) {
            const gaussianIndex = this.constants.gaussianIndex;
            const width = this.constants.width;
            const height = this.constants.height;

            if (imageIndexes[this.thread.z][this.thread.y][this.thread.x] !== gaussianIndex) {
              return freakResult[this.thread.z][this.thread.y][this.thread.x];
            }

            let xp = xps[this.thread.z][this.thread.y][this.thread.x];
            let yp = yps[this.thread.z][this.thread.y][this.thread.x];

            // bilinear interpolation
            xp = Math.max(0, Math.min(xp, width - 2));
            yp = Math.max(0, Math.min(yp, height - 2));

            const x0 = Math.floor(xp);
            const x1 = x0 + 1;
            const y0 = Math.floor(yp);
            const y1 = y0 + 1;
            const value = (x1-xp) * (y1-yp) * imageData[y0 * width + x0]
                        + (xp-x0) * (y1-yp) * imageData[y0 * width + x1]
                        + (x1-xp) * (yp-y0) * imageData[y1 * width + x0]
                        + (xp-x0) * (yp-y0) * imageData[y1 * width + x1];
            return value;
          }, {
            constants: {
              gaussianIndex: i,
              width: pyramidImages[i].width,
              height: pyramidImages[i].height
            },
            output: [FREAKPOINTS.length, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
            pipeline: true,
          })
        )
      }
      this.kernels.push(subkernels);
    }
    const subkernels = this.kernels[this.kernelIndex++];

    // compute the locations of all freak points
    const result = subkernels[0](prunedExtremas, prunedExtremasAngles, FREAKPOINTS);
    const imageIndexes = result.result;
    const xps = result.saveXp;
    const yps = result.saveYp;

    // compute the interpolated values of each freak coordinates (this values is used to build the freak descriptors)
    let freakResult = subkernels[1]();
    for (let i = 0; i < pyramidImages.length; i++) {
      freakResult = subkernels[i+2](freakResult, pyramidImages[i].data, xps, yps, imageIndexes);
    }
    return freakResult;
  }

  _buildExtremas(image0, image1, image2, octave, scale, startI, startJ, endI, endJ) {
    const originalWidth = this.width;
    const originalHeight = this.height;
    const dogNumScalesPerOctaves = PYRAMID_NUM_SCALES_PER_OCTAVES - 1;

    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        // return
        //  1. score: how strong is the extrema. (the larger the difference of gaussian value, the stronger)
        //      score can be positive (maxima) or negative (minima)
        //  2. x, y: the effective x, y coordinate in the original image
        //  3. sigma: the effective sigma in the original image (I'm not sure what sigma is. any educational reference?)
        this.gpu.createKernelMap({
          saveSigma: function(a) {return a;},
          saveX: function(a) {return a;},
          saveY: function(a) {return a;}
        },
        function(data0, data1, data2, startI, startJ, endI, endJ) {
          const LAPLACIAN_SQR_THRESHOLD = this.constants.LAPLACIAN_SQR_THRESHOLD;
          const MAX_SUBPIXEL_DISTANCE_SQR = this.constants.MAX_SUBPIXEL_DISTANCE_SQR;
          const EDGE_HESSIAN_THRESHOLD = this.constants.EDGE_HESSIAN_THRESHOLD;
          const originalWidth = this.constants.originalWidth;
          const originalHeight = this.constants.originalHeight;
          const width = this.constants.width;
          const height = this.constants.height;
          const octave = this.constants.octave;
          const scale = this.constants.scale;
          const dogNumScalesPerOctaves = this.constants.dogNumScalesPerOctaves;

          const pos = this.thread.x;
          const posI = pos % width;
          const posJ = Math.floor(pos / width);
          if (posI < startI || posI > endI || posJ < startJ || posJ > endJ) return 0;

          const v = data1[pos];
          if (v * v < LAPLACIAN_SQR_THRESHOLD) return 0;

          let isMax = true;
          for (let d = 0; d < 9; d++) {
            const i = d % 3;
            const j = Math.floor(d / 3);
            const pos2 = pos + (j-1) * width + (i-1);
            if (data1[pos] <= data0[pos2]) {isMax = false; break;};
            if (data1[pos] <= data2[pos2]) {isMax = false; break;};
            if (pos !== pos2 && data1[pos] <= data1[pos2]) {isMax = false; break;};
          }

          let isMin = false;
          if (!isMax) {
            isMin = true;
            for (let d = 0; d < 9; d++) {
              const i = d % 3;
              const j = Math.floor(d / 3);
              const pos2 = pos + (j-1) * width + (i-1);
              if (data1[pos] >= data0[pos2]) {isMin = false; break};
              if (data1[pos] >= data2[pos2]) {isMin = false; break};
              if (pos !== pos2 && data1[pos] >= data1[pos2]) {isMin = false; break};
            }
          }
          if (!isMax && !isMin) return 0;

          // Step 2: sub-pixel refinement (I'm not sure what that means. Any educational ref?)

          // Compute spatial derivatives
          const dx = 0.5 * (data1[pos + 1] - data1[pos - 1]);
          const dy = 0.5 * (data1[pos + width] - data1[pos - width]);
          const dxx = data1[pos + 1] + data1[pos - 1] - 2 * data1[pos];
          const dyy = data1[pos + width] + data1[pos - width] - 2 * data1[pos];
          const dxy = 0.25 * (data1[pos - width -1] + data1[pos + width + 1] - data1[pos - width +1] - data1[pos + width - 1]);

          // Compute scale derivates
          const ds = 0.5 * (data2[pos] - data0[pos]);
          const dss = data2[pos] + data0[pos] - 2 * data1[pos];
          const dxs = 0.25 * ((data0[pos-1] - data0[pos+1]) + (-data2[pos-1] + data2[pos+1]));
          const dys = 0.25 * ((data0[pos-width] - data0[pos+width]) + (-data2[pos-width] + data2[pos+width]));

          // Solve Hessian A * u = b;
          const A0 = dxx;
          const A1 = dxy;
          const A2 = dxs;
          const A3 = dxy;
          const A4 = dyy;
          const A5 = dys;
          const A6 = dxs;
          const A7 = dys;
          const A8 = dss;
          const b0 = -dx;
          const b1 = -dy;
          const b2 = -ds;

          const detA = A0 * A4 * A8
                    - A0 * A5 * A5
                    - A4 * A2 * A2
                    - A8 * A1 * A1
                    + 2 * A1 * A2 * A5;

          if ( Math.abs(detA) < 0.0000001) return 0; // determinant undefined. no solution

          // B = inverse of A
          const B0 = A4 * A8 - A5 * A7;
          const B1 = A2 * A7 - A1 * A8;
          const B2 = A1 * A5 - A2 * A4;
          const B3 = B1;
          const B4 = A0 * A8 - A2 * A6;
          const B5 = A2 * A3 - A0 * A5;
          const B6 = B2;
          const B7 = B5;
          const B8 = A0 * A4 - A1 * A3;

          const u0 = (B0 * b0 + B1 * b1 + B2 * b2) / detA;
          const u1 = (B3 * b0 + B4 * b1 + B5 * b2) / detA;
          const u2 = (B6 * b0 + B7 * b1 + B8 * b2) / detA;

          // If points move too much in the sub-pixel update, then the point probably unstable.
          if (u0 * u0 + u1 * u1 > MAX_SUBPIXEL_DISTANCE_SQR) return 0;

          // compute edge score
          const det = (dxx * dyy) - (dxy * dxy);
          if (det === 0) return 0;

          const edgeScore = (dxx + dyy) * (dxx + dyy) / det;
          if (Math.abs(edgeScore) >= EDGE_HESSIAN_THRESHOLD ) return 0;

          const score = v - (b0 * u0 + b1 * u1 + b2 * u2);
          if (score * score < LAPLACIAN_SQR_THRESHOLD) return 0;

          // original x = x*2^n + 2^(n-1) - 0.5
          // original y = y*2^n + 2^(n-1) - 0.5
          let originalX = posI * Math.pow(2, octave) + Math.pow(2, octave-1) - 0.5;
          let originalY = posJ * Math.pow(2, octave) + Math.pow(2, octave-1) - 0.5;
          originalX = originalX + u0 * Math.pow(2, octave);
          originalY = originalY + u1 * Math.pow(2, octave);
          if (originalX < 0 || originalX >= originalWidth || originalY < 0 || originalY >= originalHeight) return 0;

          const spScale = Math.min(Math.max(0, scale + u2), dogNumScalesPerOctaves);
          const mK = Math.pow(2, 1.0 / dogNumScalesPerOctaves);
          const newSigma = Math.pow(mK, spScale) * (1 << octave);

          saveSigma(newSigma);
          saveX(originalX);
          saveY(originalY);
          return score;
        }, {
          constants: {
            LAPLACIAN_SQR_THRESHOLD: LAPLACIAN_SQR_THRESHOLD,
            MAX_SUBPIXEL_DISTANCE_SQR: MAX_SUBPIXEL_DISTANCE_SQR,
            EDGE_HESSIAN_THRESHOLD: EDGE_HESSIAN_THRESHOLD,
            originalWidth: originalWidth,
            originalHeight: originalHeight,
            width: image1.width,
            height: image1.height,
            octave: octave,
            scale: scale,
            dogNumScalesPerOctaves: dogNumScalesPerOctaves,
          },
          output: [image1.width * image1.height],
          pipeline: true,
        })
      );
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel(image0.data, image1.data, image2.data, startI, startJ, endI, endJ);
    return result;
  }

  _downsampleBilinear(image) {
    const dstWidth = Math.floor(image.width / 2);
    const dstHeight = Math.floor(image.height / 2);

    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        this.gpu.createKernel(function(data) {
          const width = this.constants.width;
          const srcWidth = this.constants.srcWidth;
          const j = Math.floor(this.thread.x / width);
          const i = this.thread.x % width;
          const srcPos = j * 2 * srcWidth + i * 2;
          const v = (data[srcPos] + data[srcPos+1] + data[srcPos+srcWidth] + data[srcPos+srcWidth+1]) * 0.25;
          return v;
        }, {
          constants: {srcWidth: image.width, width: dstWidth},
          output: [dstWidth * dstHeight],
          pipeline: true,
        })
      );
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel(image.data);
    return {width: dstWidth, height: dstHeight, data: result};
  }

  _upsampleBilinear(image, padOneWidth, padOneHeight) {
    const dstWidth = image.width * 2 + (padOneWidth?1:0);
    const dstHeight = image.height * 2 + (padOneHeight?1:0);

    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        this.gpu.createKernel(function(data) {
          const width = this.constants.width;
          const height = this.constants.height;

          const srcWidth = Math.floor(width / 2);
          const srcHeight = Math.floor(height / 2);

          const j = Math.floor(this.thread.x / width);
          const i = this.thread.x % width;
          const si = 0.5 * i - 0.25;
          const sj = 0.5 * j - 0.25;
          const si0 = Math.max(0, Math.floor(si));
          const si1 = Math.min(Math.ceil(si), srcWidth-1);
          const sj0 = Math.max(0, Math.floor(sj));
          const sj1 = Math.min(Math.ceil(sj), srcHeight-1);
          const value = (si1 - si) * (sj1 - sj) * data[ sj0 * width + si0 ] +
                        (si1 - si) * (sj - sj0) * data[ sj1 * width + si0 ] +
                        (si - si0) * (sj1 - sj) * data[ sj0 * width + si1 ] +
                        (si - si0) * (sj - sj0) * data[ sj1 * width + si1 ];
          return value;
        }, {
          constants: {width: dstWidth, height: dstHeight},
          output: [dstWidth * dstHeight],
          pipeline: true,
        })
      );
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel(image.data);
    return {width: dstWidth, height: dstHeight, data: result};
  }

  // 4th order binomail filter
  _applyFilter(image) {
    if (this.kernelIndex === this.kernels.length) {
      const f1 = this.gpu.createKernel(function(data) {
        const width = this.constants.width;
        const j = Math.floor(this.thread.x / width);
        const i = this.thread.x % width;
        const joffset = j * width;
        const v = data[joffset + Math.max(i-2,0)] +
                  data[joffset + Math.max(i-1,0)] * 4 +
                  data[joffset + i] * 6 +
                  data[joffset + Math.min(i+1,width-1)] * 4 +
                  data[joffset + Math.min(i+2,width-1)];
        return v;
      }, {
        constants: {width: image.width},
        output: [image.width * image.height],
        pipeline: true
      });

      const f2 = this.gpu.createKernel(function(data) {
        const width = this.constants.width;
        const height = this.constants.height;
        const j = Math.floor(this.thread.x / width);
        const i = this.thread.x % width;
        const v = data[Math.max(j-2,0) * width + i] +
                  data[Math.max(j-1,0) * width + i] * 4 +
                  data[j * width + i] * 6 +
                  data[Math.min(j+1,height-1) * width + i] * 4 +
                  data[Math.min(j+2,height-1) * width + i];

        return v / 256; // altogether (1+4+6+4+1) * (1+4+6+4+1) numbers
      }, {
        constants: {width: image.width, height: image.height},
        output: [image.width * image.height],
        pipeline: true,
      });
      this.kernels.push({f1, f2});
    }
    const {f1, f2} = this.kernels[this.kernelIndex++];
    const result = f2(f1(image.data));
    return {width: image.width, height: image.height, data: result};
  }

  _differenceImageBinomial(image1, image2) {
    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        this.gpu.createKernel(function(data1, data2) {
          return data1[this.thread.x] - data2[this.thread.x];
        }, {
          output: [image1.width * image1.height],
          pipeline: true,
        })
      );
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel(image1.data, image2.data);
    return {width: image1.width, height: image1.height, data: result};
  }
}

module.exports = {
  Detector
};


/***/ }),

/***/ "./src/image-target/image-list.js":
/*!****************************************!*\
  !*** ./src/image-target/image-list.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {resize} = __webpack_require__(/*! ./utils/images.js */ "./src/image-target/utils/images.js");

const DEFAULT_DPI = 1;
const MIN_IMAGE_PIXEL_SIZE = 28;

// return list of {data, width, height, dpi}
const buildImageList = (inputImage) => {
  const dpi = DEFAULT_DPI;
  const minDpi = Math.floor(1.0 * MIN_IMAGE_PIXEL_SIZE / Math.min(inputImage.width, inputImage.height) * dpi * 1000) / 1000;
  const dpiList = [];

  let c = minDpi;
  while (true) {
    dpiList.push(c);
    c *= Math.pow(2.0, 1.0/3.0);
    c = Math.fround(c); // can remove this line in production. trying to reproduce the same result as artoolkit, which use float.
    if (c >= dpi * 0.95) {
      c = dpi;
      break;
    }
  }
  dpiList.push(c);
  dpiList.reverse();

  const imageList = []; // list of {data: [width x height], width, height}
  for (let i = 0; i < dpiList.length; i++) {
    const w = inputImage.width * dpiList[i] / dpi;
    const h = inputImage.height * dpiList[i] / dpi;
    imageList.push(Object.assign(resize({image: inputImage, ratio: dpiList[i]/dpi}), {dpi: dpiList[i]}));
  }

  return imageList;
}

module.exports = {
  buildImageList
}


/***/ }),

/***/ "./src/image-target/matching/hamming-distance.js":
/*!*******************************************************!*\
  !*** ./src/image-target/matching/hamming-distance.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Fast computation on number of bit sets
// Ref: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel
const compute = (options) => {
  const {v1, v2} = options;
  let d = 0;
  for (let i = 0; i < v1.length; i++) {
    let x = (v1[i] ^ v2[i]) >>> 0;
    d += bitCount(x);
  }
  return d;
}

const bitCount = (v) => {
  var c = v - ((v >> 1) & 0x55555555);
  c = ((c >> 2) & 0x33333333) + (c & 0x33333333);
  c = ((c >> 4) + c) & 0x0F0F0F0F;
  c = ((c >> 8) + c) & 0x00FF00FF;
  c = ((c >> 16) + c) & 0x0000FFFF;
  return c;
}

module.exports = {
  compute
};


/***/ }),

/***/ "./src/image-target/matching/hierarchical-clustering.js":
/*!**************************************************************!*\
  !*** ./src/image-target/matching/hierarchical-clustering.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {compute: hammingCompute} = __webpack_require__(/*! ./hamming-distance.js */ "./src/image-target/matching/hamming-distance.js");
const {createRandomizer} = __webpack_require__(/*! ../utils/randomizer.js */ "./src/image-target/utils/randomizer.js");

const MIN_FEATURE_PER_NODE = 16;
const NUM_ASSIGNMENT_HYPOTHESES =  128;
const NUM_CENTERS = 8;

// kmedoids clustering of points, with hamming distance of FREAK descriptor
//
// node = {
//   isLeaf: bool,
//   children: [], list of children node
//   pointIndexes: [], list of int, point indexes
//   centerPointIndex: int
// }
const build = ({points}) => {
  const pointIndexes = [];
  for (let i = 0; i < points.length; i++) {
    pointIndexes.push(i);
  }

  const randomizer = createRandomizer();

  const rootNode = _build({points: points, pointIndexes: pointIndexes, centerPointIndex: null, randomizer});
  return {rootNode};
}

// recursive build hierarchy clusters
const _build = (options) => {
  const {points, pointIndexes, centerPointIndex, randomizer} = options;

  let isLeaf = false;

  if (pointIndexes.length <= NUM_CENTERS || pointIndexes.length <= MIN_FEATURE_PER_NODE) {
    isLeaf = true;
  }

  const clusters = {};
  if (!isLeaf) {
    // compute clusters
    const assignment = _computeKMedoids({points, pointIndexes, randomizer});

    for (let i = 0; i < assignment.length; i++) {
      if (clusters[pointIndexes[assignment[i]]] === undefined) {
        clusters[pointIndexes[assignment[i]]] = [];
      }
      clusters[pointIndexes[assignment[i]]].push(pointIndexes[i]);
    }
  }
  if (Object.keys(clusters).length === 1) {
    isLeaf = true;
  }

  const node = {
    centerPointIndex: centerPointIndex
  }

  if (isLeaf) {
    node.leaf = true;
    node.pointIndexes = [];
    for (let i = 0; i < pointIndexes.length; i++) {
      node.pointIndexes.push(pointIndexes[i]);
    }
    return node;
  }

  // recursive build children
  node.leaf = false;
  node.children = [];

  Object.keys(clusters).forEach((centerIndex) => {
    node.children.push(_build({points: points, pointIndexes: clusters[centerIndex], centerPointIndex: centerIndex, randomizer}));
  });
  return node;
}

_computeKMedoids = (options) => {
  const {points, pointIndexes, randomizer} = options;

  const randomPointIndexes = [];
  for (let i = 0; i < pointIndexes.length; i++) {
    randomPointIndexes.push(i);
  }

  let bestSumD = Number.MAX_SAFE_INTEGER;
  let bestAssignmentIndex = -1;

  const assignments = [];
  for (let i = 0; i < NUM_ASSIGNMENT_HYPOTHESES; i++) {
    randomizer.arrayShuffle({arr: randomPointIndexes, sampleSize: NUM_CENTERS});

    let sumD = 0;
    const assignment = [];
    for (let j = 0; j < pointIndexes.length; j++) {
      let bestD = Number.MAX_SAFE_INTEGER;
      for (let k = 0; k < NUM_CENTERS; k++) {
        const centerIndex = pointIndexes[randomPointIndexes[k]];
        const d = hammingCompute({v1: points[pointIndexes[j]].descriptors, v2: points[centerIndex].descriptors});
        if (d < bestD) {
          assignment[j] = randomPointIndexes[k];
          bestD = d;
        }
      }
      sumD += bestD;
    }
    assignments.push(assignment);

    if (sumD < bestSumD) {
      bestSumD = sumD;
      bestAssignmentIndex = i;
    }
  }
  return assignments[bestAssignmentIndex];
}

module.exports = {
  build,
};



/***/ }),

/***/ "./src/image-target/tracking/extractor.js":
/*!************************************************!*\
  !*** ./src/image-target/tracking/extractor.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {Cumsum} = __webpack_require__(/*! ../utils/cumsum */ "./src/image-target/utils/cumsum.js");

const SEARCH_SIZE1 = 10;
const SEARCH_SIZE2 = 2;

const TEMPLATE_SIZE = 22 // DEFAULT
//const TEMPLATE_SIZE = 6;
const TEMPLATE_SD_THRESH = 5.0;
const MAX_SIM_THRESH = 0.95;

const MAX_THRESH = 0.9;
const MIN_THRESH = 0.55;
const SD_THRESH = 8.0;
const OCCUPANCY_SIZE = 24 * 2 / 3;

/*
 * Input image is in grey format. the imageData array size is width * height. value range from 0-255
 * pixel value at row r and c = imageData[r * width + c]
 *
 * @param {Uint8Array} options.imageData
 * @param {int} options.width image width
 * @param {int} options.height image height
 */
const extract = (image) => {
  const {data: imageData, width, height, dpi} = image;

  // Step 1 - filter out interesting points. Interesting points have strong pixel value changed across neighbours
  const isPixelSelected = [width * height];
  for (let i = 0; i < isPixelSelected.length; i++) isPixelSelected[i] = false;

  // Step 1.1 consider a pixel at position (x, y). compute:
  //   dx = ((data[x+1, y-1] - data[x-1, y-1]) + (data[x+1, y] - data[x-1, y]) + (data[x+1, y+1] - data[x-1, y-1])) / 256 / 3
  //   dy = ((data[x+1, y+1] - data[x+1, y-1]) + (data[x, y+1] - data[x, y-1]) + (data[x-1, y+1] - data[x-1, y-1])) / 256 / 3
  //   dValue =  sqrt(dx^2 + dy^2) / 2;
  const dValue = new Float32Array(imageData.length);
  for (let i = 0; i < width; i++) {
    dValue[i] = -1;
    dValue[width * (height-1) + i] = -1;
  }
  for (let j = 0; j < height; j++) {
    dValue[j*width] = -1;
    dValue[j*width + width-1] = -1;
  }

  for (let i = 1; i < width-1; i++) {
    for (let j = 1; j < height-1; j++) {
      let pos = i + width * j;

      let dx = 0.0;
      let dy = 0.0;
      for (let k = -1; k <= 1; k++) {
        dx += (imageData[pos + width*k + 1] - imageData[pos + width*k -1]);
        dy += (imageData[pos + width + k] - imageData[pos - width + k]);
      }
      dx /= (3 * 256);
      dy /= (3 * 256);
      dValue[pos] = Math.sqrt( (dx * dx + dy * dy) / 2);
    }
  }

  // Step 1.2 - select all pixel which is dValue largest than all its neighbour as "potential" candidate
  //  the number of selected points is still too many, so we use the value to further filter (e.g. largest the dValue, the better)
  const dValueHist = new Uint32Array(1000); // histogram of dvalue scaled to [0, 1000)
  for (let i = 0; i < 1000; i++) dValueHist[i] = 0;
  const neighbourOffsets = [-1, 1, -width, width];
  let allCount = 0;
  for (let i = 1; i < width-1; i++) {
    for (let j = 1; j < height-1; j++) {
      let pos = i + width * j;
      let isMax = true;
      for (let d = 0; d < neighbourOffsets.length; d++) {
        if (dValue[pos] <= dValue[pos + neighbourOffsets[d]]) {
          isMax = false;
          break;
        }
      }
      if (isMax) {
        let k = Math.floor(dValue[pos] * 1000);
        if (k > 999) k = 999; // k>999 should not happen if computaiton is correction
        if (k < 0) k = 0; // k<0 should not happen if computaiton is correction
        dValueHist[k] += 1;
        allCount += 1;
        isPixelSelected[pos] = true;
      }
    }
  }

  // reduce number of points according to dValue.
  // actually, the whole Step 1. might be better to just sort the dvalues and pick the top (0.02 * width * height) points
  const maxPoints = 0.02 * width * height;
  let k = 999;
  let filteredCount = 0;
  while (k >= 0) {
    filteredCount += dValueHist[k];
    if (filteredCount > maxPoints) break;
    k--;
  }

  //console.log("image size: ", width * height);
  //console.log("extracted featues: ", allCount);
  //console.log("filtered featues: ", filteredCount);

  for (let i = 0; i < isPixelSelected.length; i++) {
    if (isPixelSelected[i]) {
      if (dValue[i] * 1000 < k) isPixelSelected[i] = false;
    }
  }

  //console.log("selected count: ", isPixelSelected.reduce((a, b) => {return a + (b?1:0);}, 0));

  // Step 2
  // prebuild cumulative sum matrix for fast computation
  const imageDataSqr = [];
  for (let i = 0; i < imageData.length; i++) {
    imageDataSqr[i] = imageData[i] * imageData[i];
  }
  const imageDataCumsum = new Cumsum(imageData, width, height);
  const imageDataSqrCumsum = new Cumsum(imageDataSqr, width, height);

  // holds the max similariliy value computed within SEARCH area of each pixel
  //   idea: if there is high simliarity with another pixel in nearby area, then it's not a good feature point
  //         next step is to find pixel with low similarity
  const featureMap = new Float32Array(imageData.length);

  for (let i = 0; i < width; i++) {
    for (let j = 0; j < height; j++) {
      const pos = j * width + i;
      if (!isPixelSelected[pos]) {
        featureMap[pos] = 1.0;
        continue;
      }

      const vlen = _templateVar({image, cx: i, cy: j, sdThresh: TEMPLATE_SD_THRESH, imageDataCumsum, imageDataSqrCumsum});
      if (vlen === null) {
        featureMap[pos] = 1.0;
        continue;
      }

      let max = -1.0;
      for (let jj = -SEARCH_SIZE1; jj <= SEARCH_SIZE1; jj++) {
        for (let ii = -SEARCH_SIZE1; ii <= SEARCH_SIZE1; ii++) {
          if (ii * ii + jj * jj <= SEARCH_SIZE2 * SEARCH_SIZE2) continue;
          const sim = _getSimilarity({image, cx: i+ii, cy: j+jj, vlen: vlen, tx: i, ty: j, imageDataCumsum, imageDataSqrCumsum});

          if (sim === null) continue;

          if (sim > max) {
            max = sim;
            if (max > MAX_SIM_THRESH) break;
          }
        }
        if (max > MAX_SIM_THRESH) break;
      }
      featureMap[pos] = max;
    }
  }

  // Step 2.2 select feature
  const coords = _selectFeature({image, featureMap, templateSize: TEMPLATE_SIZE, searchSize: SEARCH_SIZE2, occSize: OCCUPANCY_SIZE, maxSimThresh: MAX_THRESH, minSimThresh: MIN_THRESH, sdThresh: SD_THRESH, imageDataCumsum, imageDataSqrCumsum});

  return coords;
}

const _selectFeature = (options) => {
  let {image, featureMap, templateSize, searchSize, occSize, maxSimThresh, minSimThresh, sdThresh, imageDataCumsum, imageDataSqrCumsum} = options;
  const {data: imageData, width, height, dpi} = image;

  //console.log("params: ", templateSize, templateSize, occSize, maxSimThresh, minSimThresh, sdThresh);

  //occSize *= 2;
  occSize = Math.floor(Math.min(image.width, image.height) / 10);

  const divSize = (templateSize * 2 + 1) * 3;
  const xDiv = Math.floor(width / divSize);
  const yDiv = Math.floor(height / divSize);

  let maxFeatureNum = Math.floor(width / occSize) * Math.floor(height / occSize) + xDiv * yDiv;
  //console.log("max feature num: ", maxFeatureNum);

  const coords = [];
  const image2 = new Float32Array(imageData.length);
  for (let i = 0; i < image2.length; i++) {
    image2[i] = featureMap[i];
  }

  let num = 0;
  while (num < maxFeatureNum) {
    let minSim = maxSimThresh;
    let cx = -1;
    let cy = -1;
    for (let j = 0; j < height; j++) {
      for (let i = 0; i < width; i++) {
        if (image2[j*width+i] < minSim) {
          minSim = image2[j*width+i];
          cx = i;
          cy = j;
        }
      }
    }
    if (cx === -1) break;

    const vlen = _templateVar({image, cx: cx, cy: cy, sdThresh: 0, imageDataCumsum, imageDataSqrCumsum});
    if (vlen === null) {
      image2[ cy * width + cx ] = 1.0;
      continue;
    }
    if (vlen / (templateSize * 2 + 1) < sdThresh) {
      image2[ cy * width + cx ] = 1.0;
      continue;
    }

    let min = 1.0;
    let max = -1.0;

    for (let j = -searchSize; j <= searchSize; j++) {
      for (let i = -searchSize; i <= searchSize; i++) {
        if (i*i + j*j > searchSize * searchSize) continue;
        if (i === 0 && j === 0) continue;

        const sim = _getSimilarity({image, vlen, cx: cx+i, cy: cy+j, tx: cx, ty:cy, imageDataCumsum, imageDataSqrCumsum});
        if (sim === null) continue;

        if (sim < min) {
          min = sim;
          if (min < minSimThresh && min < minSim) break;
        }
        if (sim > max) {
          max = sim;
          if (max > 0.99) break;
        }
      }
      if( (min < minSimThresh && min < minSim) || max > 0.99 ) break;
    }

    if( (min < minSimThresh && min < minSim) || max > 0.99 ) {
        image2[ cy * width + cx ] = 1.0;
        continue;
    }

    coords.push({
      //x: cx,
      //y: cy,
      //mx: 1.0 * cx / dpi * 25.4,
      //my: 1.0 * (height - cy) / dpi * 25.4,
      mx: 1.0 * cx / dpi,
      my: 1.0 * (height - cy) / dpi,
      //maxSim: minSim,
    })

    num += 1;
    //console.log(num, '(', cx, ',', cy, ')', minSim, 'min = ', min, 'max = ', max, 'sd = ', vlen/(templateSize*2+1));

    // no other feature points within occSize square
    for (let j = -occSize; j <= occSize; j++) {
      for (let i = -occSize; i <= occSize; i++) {
        if (cy + j < 0 || cy + j >= height || cx + i < 0 || cx + i >= width) continue;
        image2[ (cy+j)*width + (cx+i) ] = 1.0;
      }
    }
  }
  return coords;
}

// compute variances of the pixels, centered at (cx, cy)
const _templateVar = ({image, cx, cy, sdThresh, imageDataCumsum, imageDataSqrCumsum}) => {
  if (cx - TEMPLATE_SIZE < 0 || cx + TEMPLATE_SIZE >= image.width) return null;
  if (cy - TEMPLATE_SIZE < 0 || cy + TEMPLATE_SIZE >= image.height) return null;

  const templateWidth = 2 * TEMPLATE_SIZE + 1;
  const nPixels = templateWidth * templateWidth;

  let average = imageDataCumsum.query(cx - TEMPLATE_SIZE, cy - TEMPLATE_SIZE, cx + TEMPLATE_SIZE, cy+TEMPLATE_SIZE);
  average /= nPixels;

  //v = sum((pixel_i - avg)^2) for all pixel i within the template
  //  = sum(pixel_i^2) - sum(2 * avg * pixel_i) + sum(avg^avg)

  let vlen = imageDataSqrCumsum.query(cx - TEMPLATE_SIZE, cy - TEMPLATE_SIZE, cx + TEMPLATE_SIZE, cy+TEMPLATE_SIZE);
  vlen -= 2 * average * imageDataCumsum.query(cx - TEMPLATE_SIZE, cy - TEMPLATE_SIZE, cx + TEMPLATE_SIZE, cy+TEMPLATE_SIZE);
  vlen += nPixels * average * average;

  if (vlen / nPixels < sdThresh * sdThresh) return null;
  vlen = Math.sqrt(vlen);
  return vlen;
}

const _getSimilarity = (options) => {
  const {image, cx, cy, vlen, tx, ty, imageDataCumsum, imageDataSqrCumsum} = options;
  const {data: imageData, width, height} = image;
  const templateSize = TEMPLATE_SIZE;

  if (cx - templateSize < 0 || cx + templateSize >= width) return null;
  if (cy - templateSize < 0 || cy + templateSize >= height) return null;

  const templateWidth = 2 * templateSize + 1;

  let sx = imageDataCumsum.query(cx-templateSize, cy-templateSize, cx+templateSize, cy+templateSize);
  let sxx = imageDataSqrCumsum.query(cx-templateSize, cy-templateSize, cx+templateSize, cy+templateSize);
  let sxy = 0;

  // !! This loop is the performance bottleneck. Use moving pointers to optimize
  //
  //   for (let i = cx - templateSize, i2 = tx - templateSize; i <= cx + templateSize; i++, i2++) {
  //     for (let j = cy - templateSize, j2 = ty - templateSize; j <= cy + templateSize; j++, j2++) {
  //       sxy += imageData[j*width + i] * imageData[j2*width + i2];
  //     }
  //   }
  //
  let p1 = (cy-templateSize) * width + (cx-templateSize);
  let p2 = (ty-templateSize) * width + (tx-templateSize);
  let nextRowOffset = width - templateWidth;
  for (let j = 0; j < templateWidth; j++) {
    for (let i = 0; i < templateWidth; i++) {
      sxy += imageData[p1] * imageData[p2];
      p1 +=1;
      p2 +=1;
    }
    p1 += nextRowOffset;
    p2 += nextRowOffset;
  }

  let templateAverage = imageDataCumsum.query(tx-templateSize, ty-templateSize, tx+templateSize, ty+templateSize);
  templateAverage /= templateWidth * templateWidth;
  sxy -= templateAverage * sx;

  let vlen2 = sxx - sx*sx / (templateWidth * templateWidth);
  if (vlen2 == 0) return null;
  vlen2 = Math.sqrt(vlen2);

  // covariance between template and current pixel
  const sim = 1.0 * sxy / (vlen * vlen2);
  return sim;
}

module.exports = {
  extract
};


/***/ }),

/***/ "./src/image-target/utils/cumsum.js":
/*!******************************************!*\
  !*** ./src/image-target/utils/cumsum.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast 2D submatrix sum using cumulative sum algorithm
class Cumsum {
  constructor(data, width, height) {
    this.cumsum = [];
    for (let j = 0; j < height; j++) {
      this.cumsum.push([]);
      for (let i = 0; i < width; i++) {
        this.cumsum[j].push(0);
      }
    }

    this.cumsum[0][0] = data[0];
    for (let i = 1; i < width; i++) {
      this.cumsum[0][i] = this.cumsum[0][i-1] + data[i];
    }
    for (let j = 1; j < height; j++) {
      this.cumsum[j][0] = this.cumsum[j-1][0] + data[j*width];
    }

    for (let j = 1; j < height; j++) {
      for (let i = 1; i < width; i++) {
        this.cumsum[j][i] = data[j*width+i]
                               + this.cumsum[j-1][i]
                               + this.cumsum[j][i-1]
                               - this.cumsum[j-1][i-1];
      }
    }
  }

  query(x1, y1, x2, y2) {
    let ret = this.cumsum[y2][x2];
    if (y1 > 0) ret -= this.cumsum[y1-1][x2];
    if (x1 > 0) ret -= this.cumsum[y2][x1-1];
    if (x1 > 0 && y1 > 0) ret += this.cumsum[y1-1][x1-1];
    return ret;
  }
}

module.exports = {
  Cumsum
}


/***/ }),

/***/ "./src/image-target/utils/images.js":
/*!******************************************!*\
  !*** ./src/image-target/utils/images.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// simpler version of upsampling. better performance
const _upsampleBilinear = ({image, padOneWidth, padOneHeight}) => {
  const {width, height, data} = image;
  const dstWidth = image.width * 2 + (padOneWidth?1:0);
  const dstHeight = image.height * 2 + (padOneHeight?1:0);
  const temp = new Float32Array(dstWidth * dstHeight);

  for (let i = 0; i < width; i++) {
    for (let j = 0; j < height; j++) {
      const v = 0.25 * data[j * width + i];
      const ii = Math.floor(i/2);
      const jj = Math.floor(j/2);
      const pos = Math.floor(j/2) * dstWidth + Math.floor(i/2);
      temp[pos] += v;
      temp[pos+1] += v;
      temp[pos+dstWidth] += v;
      temp[pos+dstWidth+1] += v;
    }
  }
  return {data: temp, width: dstWidth, height: dstHeight};
}

// artoolkit version. slower. is it necessary?
const upsampleBilinear = ({image, padOneWidth, padOneHeight}) => {
  const {width, height, data} = image;

  const dstWidth = image.width * 2 + (padOneWidth?1:0);
  const dstHeight = image.height * 2 + (padOneHeight?1:0);

  const temp = new Float32Array(dstWidth * dstHeight);
  for (let i = 0; i < dstWidth; i++) {
    const si = 0.5 * i - 0.25;
    let si0 = Math.floor(si);
    let si1 = Math.ceil(si);
    if (si0 < 0) si0 = 0; // border
    if (si1 >= width) si1 = width - 1; // border

    for (let j = 0; j < dstHeight; j++) {
      const sj = 0.5 * j - 0.25;
      let sj0 = Math.floor(sj);
      let sj1 = Math.ceil(sj);
      if (sj0 < 0) sj0 = 0; // border
      if (sj1 >= height) sj1 = height - 1; //border

      const value = (si1 - si) * (sj1 - sj) * data[ sj0 * width + si0 ] +
                    (si1 - si) * (sj - sj0) * data[ sj1 * width + si0 ] +
                    (si - si0) * (sj1 - sj) * data[ sj0 * width + si1 ] +
                    (si - si0) * (sj - sj0) * data[ sj1 * width + si1 ];

      temp[j * dstWidth + i] = value;
    }
  }

  return {data: temp, width: dstWidth, height: dstHeight};
}

const downsampleBilinear = ({image}) => {
  const {data, width, height} = image;

  const dstWidth = Math.floor(width / 2);
  const dstHeight = Math.floor(height / 2);

  const temp = new Float32Array(dstWidth * dstHeight);
  const offsets = [0, 1, width, width+1];

  for (let j = 0; j < dstHeight; j++) {
    for (let i = 0; i < dstWidth; i++) {
      let srcPos = j*2 * width + i*2;
      let value = 0.0;
      for (let d = 0; d < offsets.length; d++) {
        value += data[srcPos+ offsets[d]];
      }
      value *= 0.25;
      temp[j*dstWidth+i] = value;
    }
  }
  return {data: temp, width: dstWidth, height: dstHeight};
}

const resize = ({image, ratio}) => {
  const width = Math.round(image.width * ratio);
  const height = Math.round(image.height * ratio);

  //const imageData = new Float32Array(width * height);
  const imageData = new Uint8Array(width * height);
  for (let i = 0; i < width; i++) {
    let si1 = Math.round(1.0 * i / ratio);
    let si2 = Math.round(1.0 * (i+1) / ratio) - 1;
    if (si2 >= image.width) si2 = image.width - 1;

    for (let j = 0; j < height; j++) {
      let sj1 = Math.round(1.0 * j / ratio);
      let sj2 = Math.round(1.0 * (j+1) / ratio) - 1;
      if (sj2 >= image.height) sj2 = image.height - 1;

      let sum = 0;
      let count = 0;
      for (let ii = si1; ii <= si2; ii++) {
        for (let jj = sj1; jj <= sj2; jj++) {
          sum += (1.0 * image.data[jj * image.width + ii]);
          count += 1;
        }
      }
      imageData[j * width + i] = Math.floor(sum / count);
    }
  }
  return {data: imageData, width: width, height: height};
}

module.exports = {
  downsampleBilinear,
  upsampleBilinear,
  resize,
}



/***/ }),

/***/ "./src/image-target/utils/randomizer.js":
/*!**********************************************!*\
  !*** ./src/image-target/utils/randomizer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

const mRandSeed = 1234;

const createRandomizer = () => {
  const randomizer = {
    seed: mRandSeed,

    arrayShuffle(options) {
      const {arr, sampleSize} = options;
      for (let i = 0; i < sampleSize; i++) {

        this.seed = (214013 * this.seed + 2531011) % (1 << 31);
        let k = (this.seed >> 16) & 0x7fff;
        k = k % arr.length;

        let tmp = arr[i];
        arr[i] = arr[k];
        arr[k] = tmp;
      }
    },

    nextInt(maxValue) {
      this.seed = (214013 * this.seed + 2531011) % (1 << 31);
      let k = (this.seed >> 16) & 0x7fff;
      k = k % maxValue;
      return k;
    }
  }
  return randomizer;
}

module.exports = {
  createRandomizer
}


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2dwdS1icm93c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21waWxlci53b3JrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ltYWdlLXRhcmdldC9kZXRlY3RvckdQVS9kZXRlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW1hZ2UtdGFyZ2V0L2ltYWdlLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ltYWdlLXRhcmdldC9tYXRjaGluZy9oYW1taW5nLWRpc3RhbmNlLmpzIiwid2VicGFjazovLy8uL3NyYy9pbWFnZS10YXJnZXQvbWF0Y2hpbmcvaGllcmFyY2hpY2FsLWNsdXN0ZXJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ltYWdlLXRhcmdldC90cmFja2luZy9leHRyYWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ltYWdlLXRhcmdldC91dGlscy9jdW1zdW0uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ltYWdlLXRhcmdldC91dGlscy9pbWFnZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ltYWdlLXRhcmdldC91dGlscy9yYW5kb21pemVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0NBQXNDO0FBQzdDO0FBQ0EsT0FBTyx1Q0FBdUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsT0FBTyxzQ0FBc0M7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFdBQVc7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCw0REFBNEQsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsV0FBVztBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTSxXQUFXLG9CQUFvQixhQUFhLG9CQUFvQixNQUFNLGNBQWM7QUFDbEg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9ELHdCQUF3QjtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7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c0I7QUFDN0IsT0FBTyxzQkFBc0I7QUFDN0IsT0FBTyxxQkFBcUI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxZQUFZO0FBQy9EOztBQUVBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsMkRBQTJELFlBQVk7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBLHVDQUF1QyxnQkFBZ0IsR0FBRyxnQkFBZ0IsdURBQXVELHdCQUF3QixHQUFHLHdCQUF3QjtBQUNwTDtBQUNBOztBQUVBO0FBQ0Esd0RBQXdELHNCQUFzQjtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsa0NBQWtDO0FBQ3JDO0FBQ0EsT0FBTyxjQUFjO0FBQ3JCLE9BQU8saUJBQWlCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFO0FBQzFFLHFEQUFxRCxzREFBc0QsRUFBRTtBQUM3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLHNEQUFzRDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtB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Q0wsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQyxPQUFPO0FBQ1A7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQyxPQUFPO0FBQ1A7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUUsSUFBSTtBQUM3RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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Q0FBaUM7QUFDeEMsT0FBTyx3Q0FBd0M7O0FBRS9DLE9BQU8sK0JBQStCO0FBQ3RDLE9BQU8sK0JBQStCO0FBQ3RDLE9BQU8sK0JBQStCOztBQUV0QyxPQUFPLGdDQUFnQztBQUN2QyxPQUFPLHVDQUF1Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdEQUF3RCxPQUFPO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG9FQUFvRTs7QUFFL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQix1Q0FBdUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYzs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsaUJBQWlCO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwrQ0FBK0MsOEJBQThCO0FBQzdFLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsbUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsK0NBQStDLEVBQUU7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxHQUFH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NUQsOENBQThDLGNBQWM7QUFDNUQsOERBQThELGNBQWM7QUFDNUU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQkFBc0IsdUNBQXVDO0FBQzdEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQkFBc0IsbUNBQW1DO0FBQ3pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QixPQUFPO0FBQ1Asb0JBQW9CLHlDQUF5QztBQUM3RDtBQUNBO0FBQ0EsT0FBTztBQUNQLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaHVDQSxPQUFPLE9BQU8sR0FBRyxtQkFBTyxDQUFDLDZEQUFtQjs7QUFFNUM7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEMsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0EseUNBQXlDLHlDQUF5QyxJQUFJLGdCQUFnQjtBQUN0Rzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZCQSxPQUFPLHdCQUF3QixHQUFHLG1CQUFPLENBQUMsOEVBQXVCO0FBQ2pFLE9BQU8saUJBQWlCLEdBQUcsbUJBQU8sQ0FBQyxzRUFBd0I7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCLCtFQUErRTtBQUMxRyxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBLFNBQVMsbURBQW1EOztBQUU1RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlDQUFpQzs7QUFFMUUsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLCtGQUErRjtBQUM5SCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLFNBQVMsaUNBQWlDOztBQUUxQztBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRCw2QkFBNkIsaURBQWlEOztBQUU5RTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQSxrQ0FBa0MsNkVBQTZFO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckhBLE9BQU8sT0FBTyxHQUFHLG1CQUFPLENBQUMsMkRBQWlCOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsSUFBSTtBQUNmLFdBQVcsSUFBSTtBQUNmO0FBQ0E7QUFDQSxTQUFTLG9DQUFvQzs7QUFFN0M7QUFDQTtBQUNBLGlCQUFpQiw0QkFBNEI7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGFBQWE7QUFDOUIsbUJBQW1CLGNBQWM7QUFDakM7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUIsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzRUFBc0Usb0JBQW9COztBQUUxRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixXQUFXO0FBQzVCLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHVGQUF1RjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQsb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBLHNDQUFzQyx5RkFBeUY7O0FBRS9IOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLGdOQUFnTjs7QUFFalA7QUFDQTs7QUFFQTtBQUNBLE9BQU8sZ0lBQWdJO0FBQ3ZJLFNBQVMsb0NBQW9DOztBQUU3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLHdFQUF3RTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLGlCQUFpQjtBQUM5QywrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7O0FBRUEsb0NBQW9DLG9GQUFvRjtBQUN4SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsY0FBYztBQUN4Qyw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qiw2REFBNkQ7QUFDcEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGlFQUFpRTtBQUMxRSxTQUFTLCtCQUErQjtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThELHdCQUF3QjtBQUN0RixnRUFBZ0Usd0JBQXdCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQyxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBOztBQUVBLG1CQUFtQixZQUFZO0FBQy9CLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN4Q0E7QUFDQSw0QkFBNEIsaUNBQWlDO0FBQzdELFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsV0FBVztBQUM1QixtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQsU0FBUyxvQkFBb0I7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsc0NBQXNDOztBQUV0QyxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBLDZCQUE2QixNQUFNO0FBQ25DLFNBQVMsb0JBQW9COztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGVBQWU7QUFDaEMsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqSEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IscUJBQXFCLGdCQUFnQjs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Indvcmtlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL35oaXVraW0vcHJvamVjdHMvV2ViQ2FyZHMvbWluZC1hci1qcy9kaXN0L1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9jb21waWxlci53b3JrZXIuanNcIik7XG4iLCIvKipcbiAqIGdwdS5qc1xuICogaHR0cDovL2dwdS5yb2Nrcy9cbiAqXG4gKiBHUFUgQWNjZWxlcmF0ZWQgSmF2YVNjcmlwdFxuICpcbiAqIEB2ZXJzaW9uIDIuOS40XG4gKiBAZGF0ZSBTYXQgTWF5IDAyIDIwMjAgMTE6NDY6NDkgR01ULTA0MDAgKEVhc3Rlcm4gRGF5bGlnaHQgVGltZSlcbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqIFRoZSBNSVQgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAyMCBncHUuanMgVGVhbVxuICovKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuR1BVID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuYWNvcm4gPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cblxuICB2YXIgcmVzZXJ2ZWRXb3JkcyA9IHtcbiAgICAzOiBcImFic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGVcIixcbiAgICA1OiBcImNsYXNzIGVudW0gZXh0ZW5kcyBzdXBlciBjb25zdCBleHBvcnQgaW1wb3J0XCIsXG4gICAgNjogXCJlbnVtXCIsXG4gICAgc3RyaWN0OiBcImltcGxlbWVudHMgaW50ZXJmYWNlIGxldCBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzdGF0aWMgeWllbGRcIixcbiAgICBzdHJpY3RCaW5kOiBcImV2YWwgYXJndW1lbnRzXCJcbiAgfTtcblxuXG4gIHZhciBlY21hNUFuZExlc3NLZXl3b3JkcyA9IFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCI7XG5cbiAgdmFyIGtleXdvcmRzID0ge1xuICAgIDU6IGVjbWE1QW5kTGVzc0tleXdvcmRzLFxuICAgIFwiNW1vZHVsZVwiOiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGV4cG9ydCBpbXBvcnRcIixcbiAgICA2OiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGNvbnN0IGNsYXNzIGV4dGVuZHMgZXhwb3J0IGltcG9ydCBzdXBlclwiXG4gIH07XG5cbiAgdmFyIGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IgPSAvXmluKHN0YW5jZW9mKT8kLztcblxuXG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzdmXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MmZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVkMC1cXHUwNWVhXFx1MDVlZi1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2YVxcdTA4YTAtXFx1MDhiNFxcdTA4YjYtXFx1MDhiZFxcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MDlmY1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBhZjlcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNWFcXHUwYzYwXFx1MGM2MVxcdTBjODBcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNTQtXFx1MGQ1NlxcdTBkNWYtXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODYtXFx1MGU4YVxcdTBlOGMtXFx1MGVhM1xcdTBlYTVcXHUwZWE3LVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNVxcdTEzZjgtXFx1MTNmZFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmOFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc4XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxZVxcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YjAtXFx1MTljOVxcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjODAtXFx1MWM4OFxcdTFjOTAtXFx1MWNiYVxcdTFjYmQtXFx1MWNiZlxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmM1xcdTFjZjVcXHUxY2Y2XFx1MWNmYVxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWItXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZlxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZlZlxcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjlkXFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhN2JmXFx1YTdjMi1cXHVhN2M2XFx1YTdmNy1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE4ZmRcXHVhOGZlXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWE5ZTAtXFx1YTllNFxcdWE5ZTYtXFx1YTllZlxcdWE5ZmEtXFx1YTlmZVxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTdlLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiMzAtXFx1YWI1YVxcdWFiNWMtXFx1YWI2N1xcdWFiNzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTIwMGNcXHUyMDBkXFx4YjdcXHUwMzAwLVxcdTAzNmZcXHUwMzg3XFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjY5XFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGYtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDZmMC1cXHUwNmY5XFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3YzAtXFx1MDdjOVxcdTA3ZWItXFx1MDdmM1xcdTA3ZmRcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODU5LVxcdTA4NWJcXHUwOGQzLVxcdTA4ZTFcXHUwOGUzLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5Y2ItXFx1MDljZFxcdTA5ZDdcXHUwOWUyXFx1MDllM1xcdTA5ZTYtXFx1MDllZlxcdTA5ZmVcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBhZmEtXFx1MGFmZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDAtXFx1MGMwNFxcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDAtXFx1MGQwM1xcdTBkM2JcXHUwZDNjXFx1MGQzZS1cXHUwZDQ0XFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ0YS1cXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZTYtXFx1MGRlZlxcdTBkZjJcXHUwZGYzXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlNTAtXFx1MGU1OVxcdTBlYjFcXHUwZWI0LVxcdTBlYmNcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmM2VcXHUwZjNmXFx1MGY3MS1cXHUwZjg0XFx1MGY4NlxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAyYi1cXHUxMDNlXFx1MTA0MC1cXHUxMDQ5XFx1MTA1Ni1cXHUxMDU5XFx1MTA1ZS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTM2OS1cXHUxMzcxXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3YjQtXFx1MTdkM1xcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOGE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk0Ni1cXHUxOTRmXFx1MTlkMC1cXHUxOWRhXFx1MWExNy1cXHUxYTFiXFx1MWE1NS1cXHUxYTVlXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWFiMC1cXHUxYWJkXFx1MWIwMC1cXHUxYjA0XFx1MWIzNC1cXHUxYjQ0XFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWI4MC1cXHUxYjgyXFx1MWJhMS1cXHUxYmFkXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMyNC1cXHUxYzM3XFx1MWM0MC1cXHUxYzQ5XFx1MWM1MC1cXHUxYzU5XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2U4XFx1MWNlZFxcdTFjZjRcXHUxY2Y3LVxcdTFjZjlcXHUxZGMwLVxcdTFkZjlcXHUxZGZiLVxcdTFkZmZcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmQ3ZlxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1YTYyMC1cXHVhNjI5XFx1YTY2ZlxcdWE2NzQtXFx1YTY3ZFxcdWE2OWVcXHVhNjlmXFx1YTZmMFxcdWE2ZjFcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xuXG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuICBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBudWxsO1xuXG5cbiAgdmFyIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsMTEsMiwyNSwyLDE4LDIsMSwyLDE0LDMsMTMsMzUsMTIyLDcwLDUyLDI2OCwyOCw0LDQ4LDQ4LDMxLDE0LDI5LDYsMzcsMTEsMjksMywzNSw1LDcsMiw0LDQzLDE1NywxOSwzNSw1LDM1LDUsMzksOSw1MSwxNTcsMzEwLDEwLDIxLDExLDcsMTUzLDUsMywwLDIsNDMsMiwxLDQsMCwzLDIyLDExLDIyLDEwLDMwLDY2LDE4LDIsMSwxMSwyMSwxMSwyNSw3MSw1NSw3LDEsNjUsMCwxNiwzLDIsMiwyLDI4LDQzLDI4LDQsMjgsMzYsNywyLDI3LDI4LDUzLDExLDIxLDExLDE4LDE0LDE3LDExMSw3Miw1Niw1MCwxNCw1MCwxNCwzNSw0NzcsMjgsMTEsMCw5LDIxLDE1NSwyMiwxMyw1Miw3Niw0NCwzMywyNCwyNywzNSwzMCwwLDEyLDM0LDQsMCwxMyw0NywxNSwzLDIyLDAsMiwwLDM2LDE3LDIsMjQsODUsNiwyLDAsMiwzLDIsMTQsMiw5LDgsNDYsMzksNywzLDEsMywyMSwyLDYsMiwxLDIsNCw0LDAsMTksMCwxMyw0LDE1OSw1MiwxOSwzLDIxLDAsMzMsNDcsMjEsMSwyLDAsMTg1LDQ2LDQyLDMsMzcsNDcsMjEsMCw2MCw0MiwxNCwwLDcyLDI2LDIzMCw0MywxMTcsNjMsMzIsMCwxNjEsNywzLDM4LDE3LDAsMiwwLDI5LDAsMTEsMzksOCwwLDIyLDAsMTIsNDUsMjAsMCwzNSw1NiwyNjQsOCwyLDM2LDE4LDAsNTAsMjksMTEzLDYsMiwxLDIsMzcsMjIsMCwyNiw1LDIsMSwyLDMxLDE1LDAsMzI4LDE4LDI3MCw5MjEsMTAzLDExMCwxOCwxOTUsMjc0OSwxMDcwLDQwNTAsNTgyLDg2MzQsNTY4LDgsMzAsMTE0LDI5LDE5LDQ3LDE3LDMsMzIsMjAsNiwxOCw2ODksNjMsMTI5LDc0LDYsMCw2NywxMiw2NSwxLDIsMCwyOSw2MTM1LDksNzU0LDk0ODYsMjg2LDUwLDIsMTgsMyw5LDM5NSwyMzA5LDEwNiw2LDEyLDQsOCw4LDksNTk5MSw4NCwyLDcwLDIsMSwzLDAsMywxLDMsMywyLDExLDIsMCwyLDYsMiw2NCwyLDMsMyw3LDIsNiwyLDI3LDIsMywyLDQsMiwwLDQsNiwyLDMzOSwzLDI0LDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsNywyMzU3LDQ0LDExLDYsMTcsMCwzNzAsNDMsMTMwMSwxOTYsNjAsNjcsOCwwLDEyMDUsMywyLDI2LDIsMSwyLDAsMywwLDIsOSwyLDMsMiwwLDIsMCw3LDAsNSwwLDIsMCwyLDAsMiwyLDIsMSwyLDAsMywwLDIsMCwyLDAsMiwwLDIsMCwyLDEsMiwwLDMsMywyLDYsMiwzLDIsMywyLDAsMiw5LDIsMTYsNiwyLDIsNCwyLDE2LDQ0MjEsNDI3MTAsNDIsNDE0OCwxMiwyMjEsMyw1NzYxLDE1LDc0NzIsMzEwNCw1NDFdO1xuXG4gIHZhciBhc3RyYWxJZGVudGlmaWVyQ29kZXMgPSBbNTA5LDAsMjI3LDAsMTUwLDQsMjk0LDksMTM2OCwyLDIsMSw2LDMsNDEsMiw1LDAsMTY2LDEsNTc0LDMsOSw5LDUyNSwxMCwxNzYsMiw1NCwxNCwzMiw5LDE2LDMsNDYsMTAsNTQsOSw3LDIsMzcsMTMsMiw5LDYsMSw0NSwwLDEzLDIsNDksMTMsOSwzLDQsOSw4MywxMSw3LDAsMTYxLDExLDYsOSw3LDMsNTYsMSwyLDYsMywxLDMsMiwxMCwwLDExLDEsMyw2LDQsNCwxOTMsMTcsMTAsOSw1LDAsODIsMTksMTMsOSwyMTQsNiwzLDgsMjgsMSw4MywxNiwxNiw5LDgyLDEyLDksOSw4NCwxNCw1LDksMjQzLDE0LDE2Niw5LDIzMiw2LDMsNiw0LDAsMjksOSw0MSw2LDIsMyw5LDAsMTAsMTAsNDcsMTUsNDA2LDcsMiw3LDE3LDksNTcsMjEsMiwxMywxMjMsNSw0LDAsMiwxLDIsNiwyLDAsOSw5LDQ5LDQsMiwxLDIsNCw5LDksMzMwLDMsMTkzMDYsOSwxMzUsNCw2MCw2LDI2LDksMTAxNCwwLDIsNTQsOCwzLDE5NzIzLDEsNTMxOSw0LDQsNSw5LDcsMyw2LDMxLDMsMTQ5LDIsMTQxOCw0OSw1MTMsNTQsNSw0OSw5LDAsMTUsMCwyMyw0LDIsMTQsMTM2MSw2LDIsMTYsMyw2LDIsMSwyLDQsMjYyLDYsMTAsOSw0MTksMTMsMTQ5NSw2LDExMCw2LDYsOSw3OTI0ODcsMjM5XTtcblxuICBmdW5jdGlvbiBpc0luQXN0cmFsU2V0KGNvZGUsIHNldCkge1xuICAgIHZhciBwb3MgPSAweDEwMDAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBwb3MgKz0gc2V0W2ldO1xuICAgICAgaWYgKHBvcyA+IGNvZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHBvcyArPSBzZXRbaSArIDFdO1xuICAgICAgaWYgKHBvcyA+PSBjb2RlKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIGFzdHJhbCkge1xuICAgIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgICBpZiAoY29kZSA8IDkxKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8IDk3KSB7IHJldHVybiBjb2RlID09PSA5NSB9XG4gICAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDw9IDB4ZmZmZikgeyByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSkgfVxuICAgIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpXG4gIH1cblxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSwgYXN0cmFsKSB7XG4gICAgaWYgKGNvZGUgPCA0OCkgeyByZXR1cm4gY29kZSA9PT0gMzYgfVxuICAgIGlmIChjb2RlIDwgNTgpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoY29kZSA8IDkxKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8IDk3KSB7IHJldHVybiBjb2RlID09PSA5NSB9XG4gICAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDw9IDB4ZmZmZikgeyByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgICBpZiAoYXN0cmFsID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKSB8fCBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJDb2RlcylcbiAgfVxuXG5cblxuXG5cbiAgdmFyIFRva2VuVHlwZSA9IGZ1bmN0aW9uIFRva2VuVHlwZShsYWJlbCwgY29uZikge1xuICAgIGlmICggY29uZiA9PT0gdm9pZCAwICkgY29uZiA9IHt9O1xuXG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMua2V5d29yZCA9IGNvbmYua2V5d29yZDtcbiAgICB0aGlzLmJlZm9yZUV4cHIgPSAhIWNvbmYuYmVmb3JlRXhwcjtcbiAgICB0aGlzLnN0YXJ0c0V4cHIgPSAhIWNvbmYuc3RhcnRzRXhwcjtcbiAgICB0aGlzLmlzTG9vcCA9ICEhY29uZi5pc0xvb3A7XG4gICAgdGhpcy5pc0Fzc2lnbiA9ICEhY29uZi5pc0Fzc2lnbjtcbiAgICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gICAgdGhpcy5wb3N0Zml4ID0gISFjb25mLnBvc3RmaXg7XG4gICAgdGhpcy5iaW5vcCA9IGNvbmYuYmlub3AgfHwgbnVsbDtcbiAgICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGJpbm9wKG5hbWUsIHByZWMpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuVHlwZShuYW1lLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IHByZWN9KVxuICB9XG4gIHZhciBiZWZvcmVFeHByID0ge2JlZm9yZUV4cHI6IHRydWV9LCBzdGFydHNFeHByID0ge3N0YXJ0c0V4cHI6IHRydWV9O1xuXG5cbiAgdmFyIGtleXdvcmRzJDEgPSB7fTtcblxuICBmdW5jdGlvbiBrdyhuYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgICBvcHRpb25zLmtleXdvcmQgPSBuYW1lO1xuICAgIHJldHVybiBrZXl3b3JkcyQxW25hbWVdID0gbmV3IFRva2VuVHlwZShuYW1lLCBvcHRpb25zKVxuICB9XG5cbiAgdmFyIHR5cGVzID0ge1xuICAgIG51bTogbmV3IFRva2VuVHlwZShcIm51bVwiLCBzdGFydHNFeHByKSxcbiAgICByZWdleHA6IG5ldyBUb2tlblR5cGUoXCJyZWdleHBcIiwgc3RhcnRzRXhwciksXG4gICAgc3RyaW5nOiBuZXcgVG9rZW5UeXBlKFwic3RyaW5nXCIsIHN0YXJ0c0V4cHIpLFxuICAgIG5hbWU6IG5ldyBUb2tlblR5cGUoXCJuYW1lXCIsIHN0YXJ0c0V4cHIpLFxuICAgIGVvZjogbmV3IFRva2VuVHlwZShcImVvZlwiKSxcblxuICAgIGJyYWNrZXRMOiBuZXcgVG9rZW5UeXBlKFwiW1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIGJyYWNrZXRSOiBuZXcgVG9rZW5UeXBlKFwiXVwiKSxcbiAgICBicmFjZUw6IG5ldyBUb2tlblR5cGUoXCJ7XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgYnJhY2VSOiBuZXcgVG9rZW5UeXBlKFwifVwiKSxcbiAgICBwYXJlbkw6IG5ldyBUb2tlblR5cGUoXCIoXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgcGFyZW5SOiBuZXcgVG9rZW5UeXBlKFwiKVwiKSxcbiAgICBjb21tYTogbmV3IFRva2VuVHlwZShcIixcIiwgYmVmb3JlRXhwciksXG4gICAgc2VtaTogbmV3IFRva2VuVHlwZShcIjtcIiwgYmVmb3JlRXhwciksXG4gICAgY29sb246IG5ldyBUb2tlblR5cGUoXCI6XCIsIGJlZm9yZUV4cHIpLFxuICAgIGRvdDogbmV3IFRva2VuVHlwZShcIi5cIiksXG4gICAgcXVlc3Rpb246IG5ldyBUb2tlblR5cGUoXCI/XCIsIGJlZm9yZUV4cHIpLFxuICAgIGFycm93OiBuZXcgVG9rZW5UeXBlKFwiPT5cIiwgYmVmb3JlRXhwciksXG4gICAgdGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJ0ZW1wbGF0ZVwiKSxcbiAgICBpbnZhbGlkVGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJpbnZhbGlkVGVtcGxhdGVcIiksXG4gICAgZWxsaXBzaXM6IG5ldyBUb2tlblR5cGUoXCIuLi5cIiwgYmVmb3JlRXhwciksXG4gICAgYmFja1F1b3RlOiBuZXcgVG9rZW5UeXBlKFwiYFwiLCBzdGFydHNFeHByKSxcbiAgICBkb2xsYXJCcmFjZUw6IG5ldyBUb2tlblR5cGUoXCIke1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuXG5cbiAgICBlcTogbmV3IFRva2VuVHlwZShcIj1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gICAgYXNzaWduOiBuZXcgVG9rZW5UeXBlKFwiXz1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gICAgaW5jRGVjOiBuZXcgVG9rZW5UeXBlKFwiKysvLS1cIiwge3ByZWZpeDogdHJ1ZSwgcG9zdGZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIHByZWZpeDogbmV3IFRva2VuVHlwZShcIiEvflwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgbG9naWNhbE9SOiBiaW5vcChcInx8XCIsIDEpLFxuICAgIGxvZ2ljYWxBTkQ6IGJpbm9wKFwiJiZcIiwgMiksXG4gICAgYml0d2lzZU9SOiBiaW5vcChcInxcIiwgMyksXG4gICAgYml0d2lzZVhPUjogYmlub3AoXCJeXCIsIDQpLFxuICAgIGJpdHdpc2VBTkQ6IGJpbm9wKFwiJlwiLCA1KSxcbiAgICBlcXVhbGl0eTogYmlub3AoXCI9PS8hPS89PT0vIT09XCIsIDYpLFxuICAgIHJlbGF0aW9uYWw6IGJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICAgIGJpdFNoaWZ0OiBiaW5vcChcIjw8Lz4+Lz4+PlwiLCA4KSxcbiAgICBwbHVzTWluOiBuZXcgVG9rZW5UeXBlKFwiKy8tXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogOSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgbW9kdWxvOiBiaW5vcChcIiVcIiwgMTApLFxuICAgIHN0YXI6IGJpbm9wKFwiKlwiLCAxMCksXG4gICAgc2xhc2g6IGJpbm9wKFwiL1wiLCAxMCksXG4gICAgc3RhcnN0YXI6IG5ldyBUb2tlblR5cGUoXCIqKlwiLCB7YmVmb3JlRXhwcjogdHJ1ZX0pLFxuXG4gICAgX2JyZWFrOiBrdyhcImJyZWFrXCIpLFxuICAgIF9jYXNlOiBrdyhcImNhc2VcIiwgYmVmb3JlRXhwciksXG4gICAgX2NhdGNoOiBrdyhcImNhdGNoXCIpLFxuICAgIF9jb250aW51ZToga3coXCJjb250aW51ZVwiKSxcbiAgICBfZGVidWdnZXI6IGt3KFwiZGVidWdnZXJcIiksXG4gICAgX2RlZmF1bHQ6IGt3KFwiZGVmYXVsdFwiLCBiZWZvcmVFeHByKSxcbiAgICBfZG86IGt3KFwiZG9cIiwge2lzTG9vcDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX0pLFxuICAgIF9lbHNlOiBrdyhcImVsc2VcIiwgYmVmb3JlRXhwciksXG4gICAgX2ZpbmFsbHk6IGt3KFwiZmluYWxseVwiKSxcbiAgICBfZm9yOiBrdyhcImZvclwiLCB7aXNMb29wOiB0cnVlfSksXG4gICAgX2Z1bmN0aW9uOiBrdyhcImZ1bmN0aW9uXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9pZjoga3coXCJpZlwiKSxcbiAgICBfcmV0dXJuOiBrdyhcInJldHVyblwiLCBiZWZvcmVFeHByKSxcbiAgICBfc3dpdGNoOiBrdyhcInN3aXRjaFwiKSxcbiAgICBfdGhyb3c6IGt3KFwidGhyb3dcIiwgYmVmb3JlRXhwciksXG4gICAgX3RyeToga3coXCJ0cnlcIiksXG4gICAgX3Zhcjoga3coXCJ2YXJcIiksXG4gICAgX2NvbnN0OiBrdyhcImNvbnN0XCIpLFxuICAgIF93aGlsZToga3coXCJ3aGlsZVwiLCB7aXNMb29wOiB0cnVlfSksXG4gICAgX3dpdGg6IGt3KFwid2l0aFwiKSxcbiAgICBfbmV3OiBrdyhcIm5ld1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIF90aGlzOiBrdyhcInRoaXNcIiwgc3RhcnRzRXhwciksXG4gICAgX3N1cGVyOiBrdyhcInN1cGVyXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9jbGFzczoga3coXCJjbGFzc1wiLCBzdGFydHNFeHByKSxcbiAgICBfZXh0ZW5kczoga3coXCJleHRlbmRzXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9leHBvcnQ6IGt3KFwiZXhwb3J0XCIpLFxuICAgIF9pbXBvcnQ6IGt3KFwiaW1wb3J0XCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9udWxsOiBrdyhcIm51bGxcIiwgc3RhcnRzRXhwciksXG4gICAgX3RydWU6IGt3KFwidHJ1ZVwiLCBzdGFydHNFeHByKSxcbiAgICBfZmFsc2U6IGt3KFwiZmFsc2VcIiwgc3RhcnRzRXhwciksXG4gICAgX2luOiBrdyhcImluXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICAgIF9pbnN0YW5jZW9mOiBrdyhcImluc3RhbmNlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gICAgX3R5cGVvZjoga3coXCJ0eXBlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIF92b2lkOiBrdyhcInZvaWRcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIF9kZWxldGU6IGt3KFwiZGVsZXRlXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KVxuICB9O1xuXG5cbiAgdmFyIGxpbmVCcmVhayA9IC9cXHJcXG4/fFxcbnxcXHUyMDI4fFxcdTIwMjkvO1xuICB2YXIgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuXG4gIGZ1bmN0aW9uIGlzTmV3TGluZShjb2RlLCBlY21hMjAxOVN0cmluZykge1xuICAgIHJldHVybiBjb2RlID09PSAxMCB8fCBjb2RlID09PSAxMyB8fCAoIWVjbWEyMDE5U3RyaW5nICYmIChjb2RlID09PSAweDIwMjggfHwgY29kZSA9PT0gMHgyMDI5KSlcbiAgfVxuXG4gIHZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG5cbiAgdmFyIHNraXBXaGl0ZVNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKnxcXC9cXCpbXl0qP1xcKlxcLykqL2c7XG5cbiAgdmFyIHJlZiA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IHJlZi5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHRvU3RyaW5nID0gcmVmLnRvU3RyaW5nO1xuXG5cbiAgZnVuY3Rpb24gaGFzKG9iaiwgcHJvcE5hbWUpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BOYW1lKVxuICB9XG5cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG4gICAgdG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCJcbiAgKTsgfSk7XG5cbiAgZnVuY3Rpb24gd29yZHNSZWdleHAod29yZHMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHdvcmRzLnJlcGxhY2UoLyAvZywgXCJ8XCIpICsgXCIpJFwiKVxuICB9XG5cblxuICB2YXIgUG9zaXRpb24gPSBmdW5jdGlvbiBQb3NpdGlvbihsaW5lLCBjb2wpIHtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sO1xuICB9O1xuXG4gIFBvc2l0aW9uLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQgKG4pIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZSwgdGhpcy5jb2x1bW4gKyBuKVxuICB9O1xuXG4gIHZhciBTb3VyY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKHAsIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgaWYgKHAuc291cmNlRmlsZSAhPT0gbnVsbCkgeyB0aGlzLnNvdXJjZSA9IHAuc291cmNlRmlsZTsgfVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gZ2V0TGluZUluZm8oaW5wdXQsIG9mZnNldCkge1xuICAgIGZvciAodmFyIGxpbmUgPSAxLCBjdXIgPSAwOzspIHtcbiAgICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gY3VyO1xuICAgICAgdmFyIG1hdGNoID0gbGluZUJyZWFrRy5leGVjKGlucHV0KTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA8IG9mZnNldCkge1xuICAgICAgICArK2xpbmU7XG4gICAgICAgIGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihsaW5lLCBvZmZzZXQgLSBjdXIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgZWNtYVZlcnNpb246IDEwLFxuICAgIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gICAgb25JbnNlcnRlZFNlbWljb2xvbjogbnVsbCxcbiAgICBvblRyYWlsaW5nQ29tbWE6IG51bGwsXG4gICAgYWxsb3dSZXNlcnZlZDogbnVsbCxcbiAgICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgICBhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICBhbGxvd0hhc2hCYW5nOiBmYWxzZSxcbiAgICBsb2NhdGlvbnM6IGZhbHNlLFxuICAgIG9uVG9rZW46IG51bGwsXG4gICAgb25Db21tZW50OiBudWxsLFxuICAgIHJhbmdlczogZmFsc2UsXG4gICAgcHJvZ3JhbTogbnVsbCxcbiAgICBzb3VyY2VGaWxlOiBudWxsLFxuICAgIGRpcmVjdFNvdXJjZUZpbGU6IG51bGwsXG4gICAgcHJlc2VydmVQYXJlbnM6IGZhbHNlXG4gIH07XG5cblxuICBmdW5jdGlvbiBnZXRPcHRpb25zKG9wdHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKVxuICAgICAgeyBvcHRpb25zW29wdF0gPSBvcHRzICYmIGhhcyhvcHRzLCBvcHQpID8gb3B0c1tvcHRdIDogZGVmYXVsdE9wdGlvbnNbb3B0XTsgfVxuXG4gICAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMjAxNSlcbiAgICAgIHsgb3B0aW9ucy5lY21hVmVyc2lvbiAtPSAyMDA5OyB9XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09IG51bGwpXG4gICAgICB7IG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9IG9wdGlvbnMuZWNtYVZlcnNpb24gPCA1OyB9XG5cbiAgICBpZiAoaXNBcnJheShvcHRpb25zLm9uVG9rZW4pKSB7XG4gICAgICB2YXIgdG9rZW5zID0gb3B0aW9ucy5vblRva2VuO1xuICAgICAgb3B0aW9ucy5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbnMucHVzaCh0b2tlbik7IH07XG4gICAgfVxuICAgIGlmIChpc0FycmF5KG9wdGlvbnMub25Db21tZW50KSlcbiAgICAgIHsgb3B0aW9ucy5vbkNvbW1lbnQgPSBwdXNoQ29tbWVudChvcHRpb25zLCBvcHRpb25zLm9uQ29tbWVudCk7IH1cblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBmdW5jdGlvbiBwdXNoQ29tbWVudChvcHRpb25zLCBhcnJheSkge1xuICAgIHJldHVybiBmdW5jdGlvbihibG9jaywgdGV4dCwgc3RhcnQsIGVuZCwgc3RhcnRMb2MsIGVuZExvYykge1xuICAgICAgdmFyIGNvbW1lbnQgPSB7XG4gICAgICAgIHR5cGU6IGJsb2NrID8gXCJCbG9ja1wiIDogXCJMaW5lXCIsXG4gICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kXG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgICB7IGNvbW1lbnQubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHN0YXJ0TG9jLCBlbmRMb2MpOyB9XG4gICAgICBpZiAob3B0aW9ucy5yYW5nZXMpXG4gICAgICAgIHsgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTsgfVxuICAgICAgYXJyYXkucHVzaChjb21tZW50KTtcbiAgICB9XG4gIH1cblxuICB2YXJcbiAgICAgIFNDT1BFX1RPUCA9IDEsXG4gICAgICBTQ09QRV9GVU5DVElPTiA9IDIsXG4gICAgICBTQ09QRV9WQVIgPSBTQ09QRV9UT1AgfCBTQ09QRV9GVU5DVElPTixcbiAgICAgIFNDT1BFX0FTWU5DID0gNCxcbiAgICAgIFNDT1BFX0dFTkVSQVRPUiA9IDgsXG4gICAgICBTQ09QRV9BUlJPVyA9IDE2LFxuICAgICAgU0NPUEVfU0lNUExFX0NBVENIID0gMzIsXG4gICAgICBTQ09QRV9TVVBFUiA9IDY0LFxuICAgICAgU0NPUEVfRElSRUNUX1NVUEVSID0gMTI4O1xuXG4gIGZ1bmN0aW9uIGZ1bmN0aW9uRmxhZ3MoYXN5bmMsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBTQ09QRV9GVU5DVElPTiB8IChhc3luYyA/IFNDT1BFX0FTWU5DIDogMCkgfCAoZ2VuZXJhdG9yID8gU0NPUEVfR0VORVJBVE9SIDogMClcbiAgfVxuXG4gIHZhclxuICAgICAgQklORF9OT05FID0gMCwgXG4gICAgICBCSU5EX1ZBUiA9IDEsIFxuICAgICAgQklORF9MRVhJQ0FMID0gMiwgXG4gICAgICBCSU5EX0ZVTkNUSU9OID0gMywgXG4gICAgICBCSU5EX1NJTVBMRV9DQVRDSCA9IDQsIFxuICAgICAgQklORF9PVVRTSURFID0gNTsgXG5cbiAgdmFyIFBhcnNlciA9IGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zLCBpbnB1dCwgc3RhcnRQb3MpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGU7XG4gICAgdGhpcy5rZXl3b3JkcyA9IHdvcmRzUmVnZXhwKGtleXdvcmRzW29wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IDYgOiBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIgPyBcIjVtb2R1bGVcIiA6IDVdKTtcbiAgICB2YXIgcmVzZXJ2ZWQgPSBcIlwiO1xuICAgIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IHRydWUpIHtcbiAgICAgIGZvciAodmFyIHYgPSBvcHRpb25zLmVjbWFWZXJzaW9uOzsgdi0tKVxuICAgICAgICB7IGlmIChyZXNlcnZlZCA9IHJlc2VydmVkV29yZHNbdl0pIHsgYnJlYWsgfSB9XG4gICAgICBpZiAob3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiKSB7IHJlc2VydmVkICs9IFwiIGF3YWl0XCI7IH1cbiAgICB9XG4gICAgdGhpcy5yZXNlcnZlZFdvcmRzID0gd29yZHNSZWdleHAocmVzZXJ2ZWQpO1xuICAgIHZhciByZXNlcnZlZFN0cmljdCA9IChyZXNlcnZlZCA/IHJlc2VydmVkICsgXCIgXCIgOiBcIlwiKSArIHJlc2VydmVkV29yZHMuc3RyaWN0O1xuICAgIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0KTtcbiAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kID0gd29yZHNSZWdleHAocmVzZXJ2ZWRTdHJpY3QgKyBcIiBcIiArIHJlc2VydmVkV29yZHMuc3RyaWN0QmluZCk7XG4gICAgdGhpcy5pbnB1dCA9IFN0cmluZyhpbnB1dCk7XG5cbiAgICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG5cblxuICAgIGlmIChzdGFydFBvcykge1xuICAgICAgdGhpcy5wb3MgPSBzdGFydFBvcztcbiAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCBzdGFydFBvcyAtIDEpICsgMTtcbiAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuaW5wdXQuc2xpY2UoMCwgdGhpcy5saW5lU3RhcnQpLnNwbGl0KGxpbmVCcmVhaykubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBvcyA9IHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICAgIHRoaXMuY3VyTGluZSA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gdHlwZXMuZW9mO1xuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIHRoaXMuc3RhcnQgPSB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICAgIHRoaXMuc3RhcnRMb2MgPSB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTtcblxuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva1N0YXJ0TG9jID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydCA9IHRoaXMubGFzdFRva0VuZCA9IHRoaXMucG9zO1xuXG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5pbml0aWFsQ29udGV4dCgpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5pbk1vZHVsZSA9IG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIjtcbiAgICB0aGlzLnN0cmljdCA9IHRoaXMuaW5Nb2R1bGUgfHwgdGhpcy5zdHJpY3REaXJlY3RpdmUodGhpcy5wb3MpO1xuXG4gICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gLTE7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gdGhpcy5hd2FpdFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMgPSB7fTtcblxuICAgIGlmICh0aGlzLnBvcyA9PT0gMCAmJiBvcHRpb25zLmFsbG93SGFzaEJhbmcgJiYgdGhpcy5pbnB1dC5zbGljZSgwLCAyKSA9PT0gXCIjIVwiKVxuICAgICAgeyB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTsgfVxuXG4gICAgdGhpcy5zY29wZVN0YWNrID0gW107XG4gICAgdGhpcy5lbnRlclNjb3BlKFNDT1BFX1RPUCk7XG5cbiAgICB0aGlzLnJlZ2V4cFN0YXRlID0gbnVsbDtcbiAgfTtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBpbkZ1bmN0aW9uOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluR2VuZXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluQXN5bmM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxhbGxvd0RpcmVjdFN1cGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHRyZWF0RnVuY3Rpb25zQXNWYXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5vcHRpb25zLnByb2dyYW0gfHwgdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlVG9wTGV2ZWwobm9kZSlcbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuaW5GdW5jdGlvbi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSA+IDAgfTtcbiAgcHJvdG90eXBlQWNjZXNzb3JzLmluR2VuZXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfR0VORVJBVE9SKSA+IDAgfTtcbiAgcHJvdG90eXBlQWNjZXNzb3JzLmluQXN5bmMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9BU1lOQykgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd1N1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX1NVUEVSKSA+IDAgfTtcbiAgcHJvdG90eXBlQWNjZXNzb3JzLmFsbG93RGlyZWN0U3VwZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfRElSRUNUX1NVUEVSKSA+IDAgfTtcbiAgcHJvdG90eXBlQWNjZXNzb3JzLnRyZWF0RnVuY3Rpb25zQXNWYXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSh0aGlzLmN1cnJlbnRTY29wZSgpKSB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuaW5Ob25BcnJvd0Z1bmN0aW9uID0gZnVuY3Rpb24gaW5Ob25BcnJvd0Z1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSA+IDAgfTtcblxuICBQYXJzZXIuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kICgpIHtcbiAgICAgIHZhciBwbHVnaW5zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgcGx1Z2luc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIGNscyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7IGNscyA9IHBsdWdpbnNbaV0oY2xzKTsgfVxuICAgIHJldHVybiBjbHNcbiAgfTtcblxuICBQYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQpLnBhcnNlKClcbiAgfTtcblxuICBQYXJzZXIucGFyc2VFeHByZXNzaW9uQXQgPSBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BdCAoaW5wdXQsIHBvcywgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZXIgPSBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCwgcG9zKTtcbiAgICBwYXJzZXIubmV4dFRva2VuKCk7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZUV4cHJlc3Npb24oKVxuICB9O1xuXG4gIFBhcnNlci50b2tlbml6ZXIgPSBmdW5jdGlvbiB0b2tlbml6ZXIgKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0KVxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBQYXJzZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuICB2YXIgcHAgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5cbiAgdmFyIGxpdGVyYWwgPSAvXig/OicoKD86XFxcXC58W14nXSkqPyknfFwiKCg/OlxcXFwufFteXCJdKSo/KVwiKS87XG4gIHBwLnN0cmljdERpcmVjdGl2ZSA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgICBzdGFydCArPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpWzBdLmxlbmd0aDtcbiAgICAgIHZhciBtYXRjaCA9IGxpdGVyYWwuZXhlYyh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0KSk7XG4gICAgICBpZiAoIW1hdGNoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBpZiAoKG1hdGNoWzFdIHx8IG1hdGNoWzJdKSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgc3RhcnQgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuXG4gICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuaW5wdXRbc3RhcnRdID09PSBcIjtcIilcbiAgICAgICAgeyBzdGFydCsrOyB9XG4gICAgfVxuICB9O1xuXG5cbiAgcHAuZWF0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9O1xuXG5cbiAgcHAuaXNDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgJiYgdGhpcy52YWx1ZSA9PT0gbmFtZSAmJiAhdGhpcy5jb250YWluc0VzY1xuICB9O1xuXG5cbiAgcHAuZWF0Q29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKG5hbWUpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuXG4gIHBwLmV4cGVjdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmVhdENvbnRleHR1YWwobmFtZSkpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgfTtcblxuXG4gIHBwLmNhbkluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLmVvZiB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcy5icmFjZVIgfHxcbiAgICAgIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbiAgfTtcblxuICBwcC5pbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKVxuICAgICAgICB7IHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKTsgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH07XG5cblxuICBwcC5zZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLnNlbWkpICYmICF0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cbiAgcHAuYWZ0ZXJUcmFpbGluZ0NvbW1hID0gZnVuY3Rpb24odG9rVHlwZSwgbm90TmV4dCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHRva1R5cGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKVxuICAgICAgICB7IHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva1N0YXJ0TG9jKTsgfVxuICAgICAgaWYgKCFub3ROZXh0KVxuICAgICAgICB7IHRoaXMubmV4dCgpOyB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfTtcblxuXG4gIHBwLmV4cGVjdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB0aGlzLmVhdCh0eXBlKSB8fCB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfTtcblxuXG4gIHBwLnVuZXhwZWN0ZWQgPSBmdW5jdGlvbihwb3MpIHtcbiAgICB0aGlzLnJhaXNlKHBvcyAhPSBudWxsID8gcG9zIDogdGhpcy5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIERlc3RydWN0dXJpbmdFcnJvcnMoKSB7XG4gICAgdGhpcy5zaG9ydGhhbmRBc3NpZ24gPVxuICAgIHRoaXMudHJhaWxpbmdDb21tYSA9XG4gICAgdGhpcy5wYXJlbnRoZXNpemVkQXNzaWduID1cbiAgICB0aGlzLnBhcmVudGhlc2l6ZWRCaW5kID1cbiAgICB0aGlzLmRvdWJsZVByb3RvID1cbiAgICAgIC0xO1xuICB9XG5cbiAgcHAuY2hlY2tQYXR0ZXJuRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgaXNBc3NpZ24pIHtcbiAgICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIH1cbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID4gLTEpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgdmFyIHBhcmVucyA9IGlzQXNzaWduID8gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDogcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZDtcbiAgICBpZiAocGFyZW5zID4gLTEpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBhcmVucywgXCJQYXJlbnRoZXNpemVkIHBhdHRlcm5cIik7IH1cbiAgfTtcblxuICBwcC5jaGVja0V4cHJlc3Npb25FcnJvcnMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhbmRUaHJvdykge1xuICAgIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBzaG9ydGhhbmRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbjtcbiAgICB2YXIgZG91YmxlUHJvdG8gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvO1xuICAgIGlmICghYW5kVGhyb3cpIHsgcmV0dXJuIHNob3J0aGFuZEFzc2lnbiA+PSAwIHx8IGRvdWJsZVByb3RvID49IDAgfVxuICAgIGlmIChzaG9ydGhhbmRBc3NpZ24gPj0gMClcbiAgICAgIHsgdGhpcy5yYWlzZShzaG9ydGhhbmRBc3NpZ24sIFwiU2hvcnRoYW5kIHByb3BlcnR5IGFzc2lnbm1lbnRzIGFyZSB2YWxpZCBvbmx5IGluIGRlc3RydWN0dXJpbmcgcGF0dGVybnNcIik7IH1cbiAgICBpZiAoZG91YmxlUHJvdG8gPj0gMClcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGRvdWJsZVByb3RvLCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbiAgfTtcblxuICBwcC5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy55aWVsZFBvcyAmJiAoIXRoaXMuYXdhaXRQb3MgfHwgdGhpcy55aWVsZFBvcyA8IHRoaXMuYXdhaXRQb3MpKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMueWllbGRQb3MsIFwiWWllbGQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gICAgaWYgKHRoaXMuYXdhaXRQb3MpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy5hd2FpdFBvcywgXCJBd2FpdCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgfTtcblxuICBwcC5pc1NpbXBsZUFzc2lnblRhcmdldCA9IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICBpZiAoZXhwci50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgICB7IHJldHVybiB0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIuZXhwcmVzc2lvbikgfVxuICAgIHJldHVybiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiIHx8IGV4cHIudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCJcbiAgfTtcblxuICB2YXIgcHAkMSA9IFBhcnNlci5wcm90b3R5cGU7XG5cblxuXG4gIHBwJDEucGFyc2VUb3BMZXZlbCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgZXhwb3J0cyA9IHt9O1xuICAgIGlmICghbm9kZS5ib2R5KSB7IG5vZGUuYm9keSA9IFtdOyB9XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMuZW9mKSB7XG4gICAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCwgdHJ1ZSwgZXhwb3J0cyk7XG4gICAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5Nb2R1bGUpXG4gICAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gT2JqZWN0LmtleXModGhpcy51bmRlZmluZWRFeHBvcnRzKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdLnN0YXJ0LCAoXCJFeHBvcnQgJ1wiICsgbmFtZSArIFwiJyBpcyBub3QgZGVmaW5lZFwiKSk7XG4gICAgICAgIH0gfVxuICAgIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuc291cmNlVHlwZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJQcm9ncmFtXCIpXG4gIH07XG5cbiAgdmFyIGxvb3BMYWJlbCA9IHtraW5kOiBcImxvb3BcIn0sIHN3aXRjaExhYmVsID0ge2tpbmQ6IFwic3dpdGNoXCJ9O1xuXG4gIHBwJDEuaXNMZXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgfHwgIXRoaXMuaXNDb250ZXh0dWFsKFwibGV0XCIpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgIGlmIChuZXh0Q2ggPT09IDkxKSB7IHJldHVybiB0cnVlIH0gXG4gICAgaWYgKGNvbnRleHQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmIChuZXh0Q2ggPT09IDEyMykgeyByZXR1cm4gdHJ1ZSB9IFxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0Q2gsIHRydWUpKSB7XG4gICAgICB2YXIgcG9zID0gbmV4dCArIDE7XG4gICAgICB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSwgdHJ1ZSkpIHsgKytwb3M7IH1cbiAgICAgIHZhciBpZGVudCA9IHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgcG9zKTtcbiAgICAgIGlmICgha2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvci50ZXN0KGlkZW50KSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDEuaXNBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDggfHwgIXRoaXMuaXNDb250ZXh0dWFsKFwiYXN5bmNcIikpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoO1xuICAgIHJldHVybiAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgbmV4dCkpICYmXG4gICAgICB0aGlzLmlucHV0LnNsaWNlKG5leHQsIG5leHQgKyA4KSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAobmV4dCArIDggPT09IHRoaXMuaW5wdXQubGVuZ3RoIHx8ICFpc0lkZW50aWZpZXJDaGFyKHRoaXMuaW5wdXQuY2hhckF0KG5leHQgKyA4KSkpXG4gIH07XG5cblxuICBwcCQxLnBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24oY29udGV4dCwgdG9wTGV2ZWwsIGV4cG9ydHMpIHtcbiAgICB2YXIgc3RhcnR0eXBlID0gdGhpcy50eXBlLCBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwga2luZDtcblxuICAgIGlmICh0aGlzLmlzTGV0KGNvbnRleHQpKSB7XG4gICAgICBzdGFydHR5cGUgPSB0eXBlcy5fdmFyO1xuICAgICAga2luZCA9IFwibGV0XCI7XG4gICAgfVxuXG5cbiAgICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICAgIGNhc2UgdHlwZXMuX2JyZWFrOiBjYXNlIHR5cGVzLl9jb250aW51ZTogcmV0dXJuIHRoaXMucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIHN0YXJ0dHlwZS5rZXl3b3JkKVxuICAgIGNhc2UgdHlwZXMuX2RlYnVnZ2VyOiByZXR1cm4gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fZG86IHJldHVybiB0aGlzLnBhcnNlRG9TdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9mb3I6IHJldHVybiB0aGlzLnBhcnNlRm9yU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fZnVuY3Rpb246XG4gICAgICBpZiAoKGNvbnRleHQgJiYgKHRoaXMuc3RyaWN0IHx8IGNvbnRleHQgIT09IFwiaWZcIiAmJiBjb250ZXh0ICE9PSBcImxhYmVsXCIpKSAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBmYWxzZSwgIWNvbnRleHQpXG4gICAgY2FzZSB0eXBlcy5fY2xhc3M6XG4gICAgICBpZiAoY29udGV4dCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyhub2RlLCB0cnVlKVxuICAgIGNhc2UgdHlwZXMuX2lmOiByZXR1cm4gdGhpcy5wYXJzZUlmU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fcmV0dXJuOiByZXR1cm4gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX3N3aXRjaDogcmV0dXJuIHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl90aHJvdzogcmV0dXJuIHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX3RyeTogcmV0dXJuIHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9jb25zdDogY2FzZSB0eXBlcy5fdmFyOlxuICAgICAga2luZCA9IGtpbmQgfHwgdGhpcy52YWx1ZTtcbiAgICAgIGlmIChjb250ZXh0ICYmIGtpbmQgIT09IFwidmFyXCIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQpXG4gICAgY2FzZSB0eXBlcy5fd2hpbGU6IHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl93aXRoOiByZXR1cm4gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLmJyYWNlTDogcmV0dXJuIHRoaXMucGFyc2VCbG9jayh0cnVlLCBub2RlKVxuICAgIGNhc2UgdHlwZXMuc2VtaTogcmV0dXJuIHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX2V4cG9ydDpcbiAgICBjYXNlIHR5cGVzLl9pbXBvcnQ6XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID4gMTAgJiYgc3RhcnR0eXBlID09PSB0eXBlcy5faW1wb3J0KSB7XG4gICAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICAgICAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICBpZiAobmV4dENoID09PSA0MCkgXG4gICAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgdGhpcy5wYXJzZUV4cHJlc3Npb24oKSkgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUpIHtcbiAgICAgICAgaWYgKCF0b3BMZXZlbClcbiAgICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIik7IH1cbiAgICAgICAgaWYgKCF0aGlzLmluTW9kdWxlKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogbW9kdWxlJ1wiKTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0dHlwZSA9PT0gdHlwZXMuX2ltcG9ydCA/IHRoaXMucGFyc2VJbXBvcnQobm9kZSkgOiB0aGlzLnBhcnNlRXhwb3J0KG5vZGUsIGV4cG9ydHMpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpIHtcbiAgICAgICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgdHJ1ZSwgIWNvbnRleHQpXG4gICAgICB9XG5cbiAgICAgIHZhciBtYXliZU5hbWUgPSB0aGlzLnZhbHVlLCBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIGlmIChzdGFydHR5cGUgPT09IHR5cGVzLm5hbWUgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLmVhdCh0eXBlcy5jb2xvbikpXG4gICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkgfVxuICAgICAgZWxzZSB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKSB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDEucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2V5d29yZCkge1xuICAgIHZhciBpc0JyZWFrID0ga2V5d29yZCA9PT0gXCJicmVha1wiO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5zZW1pKSB8fCB0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IG5vZGUubGFiZWwgPSBudWxsOyB9XG4gICAgZWxzZSBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5uYW1lKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgZWxzZSB7XG4gICAgICBub2RlLmxhYmVsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cblxuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGFiID0gdGhpcy5sYWJlbHNbaV07XG4gICAgICBpZiAobm9kZS5sYWJlbCA9PSBudWxsIHx8IGxhYi5uYW1lID09PSBub2RlLmxhYmVsLm5hbWUpIHtcbiAgICAgICAgaWYgKGxhYi5raW5kICE9IG51bGwgJiYgKGlzQnJlYWsgfHwgbGFiLmtpbmQgPT09IFwibG9vcFwiKSkgeyBicmVhayB9XG4gICAgICAgIGlmIChub2RlLmxhYmVsICYmIGlzQnJlYWspIHsgYnJlYWsgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gdGhpcy5sYWJlbHMubGVuZ3RoKSB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJVbnN5bnRhY3RpYyBcIiArIGtleXdvcmQpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VEZWJ1Z2dlclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VEb1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImRvXCIpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLl93aGlsZSk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICAgIHsgdGhpcy5lYXQodHlwZXMuc2VtaSk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKVxuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUZvclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB2YXIgYXdhaXRBdCA9ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiAodGhpcy5pbkFzeW5jIHx8ICghdGhpcy5pbkZ1bmN0aW9uICYmIHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uKSkgJiYgdGhpcy5lYXRDb250ZXh0dWFsKFwiYXdhaXRcIikpID8gdGhpcy5sYXN0VG9rU3RhcnQgOiAtMTtcbiAgICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgdGhpcy5lbnRlclNjb3BlKDApO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSkge1xuICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpXG4gICAgfVxuICAgIHZhciBpc0xldCA9IHRoaXMuaXNMZXQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fdmFyIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuX2NvbnN0IHx8IGlzTGV0KSB7XG4gICAgICB2YXIgaW5pdCQxID0gdGhpcy5zdGFydE5vZGUoKSwga2luZCA9IGlzTGV0ID8gXCJsZXRcIiA6IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMucGFyc2VWYXIoaW5pdCQxLCB0cnVlLCBraW5kKTtcbiAgICAgIHRoaXMuZmluaXNoTm9kZShpbml0JDEsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICAgIGlmICgodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSAmJiBpbml0JDEuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4pIHtcbiAgICAgICAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCQxKVxuICAgICAgfVxuICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQkMSlcbiAgICB9XG4gICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICB2YXIgaW5pdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4pIHtcbiAgICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgICB9XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShpbml0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChpbml0KTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdClcbiAgfTtcblxuICBwcCQxLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBpc0FzeW5jLCBkZWNsYXJhdGlvblBvc2l0aW9uKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCBGVU5DX1NUQVRFTUVOVCB8IChkZWNsYXJhdGlvblBvc2l0aW9uID8gMCA6IEZVTkNfSEFOR0lOR19TVEFURU1FTlQpLCBmYWxzZSwgaXNBc3luYylcbiAgfTtcblxuICBwcCQxLnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKTtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMuZWF0KHR5cGVzLl9lbHNlKSA/IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKSA6IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTsgfVxuICAgIHRoaXMubmV4dCgpO1xuXG5cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmFyZ3VtZW50ID0gbnVsbDsgfVxuICAgIGVsc2UgeyBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTsgdGhpcy5zZW1pY29sb24oKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlU3dpdGNoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuY2FzZXMgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICAgIHRoaXMubGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcblxuXG4gICAgdmFyIGN1cjtcbiAgICBmb3IgKHZhciBzYXdEZWZhdWx0ID0gZmFsc2U7IHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VSOykge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2Nhc2UgfHwgdGhpcy50eXBlID09PSB0eXBlcy5fZGVmYXVsdCkge1xuICAgICAgICB2YXIgaXNDYXNlID0gdGhpcy50eXBlID09PSB0eXBlcy5fY2FzZTtcbiAgICAgICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKGlzQ2FzZSkge1xuICAgICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2F3RGVmYXVsdCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5sYXN0VG9rU3RhcnQsIFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzXCIpOyB9XG4gICAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY3VyKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudChudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICB0aGlzLm5leHQoKTsgXG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAobGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSlcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93XCIpOyB9XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhyb3dTdGF0ZW1lbnRcIilcbiAgfTtcblxuXG4gIHZhciBlbXB0eSA9IFtdO1xuXG4gIHBwJDEucGFyc2VUcnlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5ibG9jayA9IHRoaXMucGFyc2VCbG9jaygpO1xuICAgIG5vZGUuaGFuZGxlciA9IG51bGw7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2NhdGNoKSB7XG4gICAgICB2YXIgY2xhdXNlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgICAgY2xhdXNlLnBhcmFtID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgICAgIHZhciBzaW1wbGUgPSBjbGF1c2UucGFyYW0udHlwZSA9PT0gXCJJZGVudGlmaWVyXCI7XG4gICAgICAgIHRoaXMuZW50ZXJTY29wZShzaW1wbGUgPyBTQ09QRV9TSU1QTEVfQ0FUQ0ggOiAwKTtcbiAgICAgICAgdGhpcy5jaGVja0xWYWwoY2xhdXNlLnBhcmFtLCBzaW1wbGUgPyBCSU5EX1NJTVBMRV9DQVRDSCA6IEJJTkRfTEVYSUNBTCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgMTApIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgY2xhdXNlLnBhcmFtID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbnRlclNjb3BlKDApO1xuICAgICAgfVxuICAgICAgY2xhdXNlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UpO1xuICAgICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICAgIG5vZGUuaGFuZGxlciA9IHRoaXMuZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG4gICAgfVxuICAgIG5vZGUuZmluYWxpemVyID0gdGhpcy5lYXQodHlwZXMuX2ZpbmFsbHkpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuICAgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcilcbiAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2VcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVZhclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtpbmQpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnBhcnNlVmFyKG5vZGUsIGZhbHNlLCBraW5kKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcIndoaWxlXCIpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICh0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5vYmplY3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcIndpdGhcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldpdGhTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlRW1wdHlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBtYXliZU5hbWUsIGV4cHIsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0ID0gdGhpcy5sYWJlbHM7IGkkMSA8IGxpc3QubGVuZ3RoOyBpJDEgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBsYWJlbCA9IGxpc3RbaSQxXTtcblxuICAgICAgaWYgKGxhYmVsLm5hbWUgPT09IG1heWJlTmFtZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gICAgfSB9XG4gICAgdmFyIGtpbmQgPSB0aGlzLnR5cGUuaXNMb29wID8gXCJsb29wXCIgOiB0aGlzLnR5cGUgPT09IHR5cGVzLl9zd2l0Y2ggPyBcInN3aXRjaFwiIDogbnVsbDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBsYWJlbCQxID0gdGhpcy5sYWJlbHNbaV07XG4gICAgICBpZiAobGFiZWwkMS5zdGF0ZW1lbnRTdGFydCA9PT0gbm9kZS5zdGFydCkge1xuICAgICAgICBsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgbGFiZWwkMS5raW5kID0ga2luZDtcbiAgICAgIH0gZWxzZSB7IGJyZWFrIH1cbiAgICB9XG4gICAgdGhpcy5sYWJlbHMucHVzaCh7bmFtZTogbWF5YmVOYW1lLCBraW5kOiBraW5kLCBzdGF0ZW1lbnRTdGFydDogdGhpcy5zdGFydH0pO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoY29udGV4dCA/IGNvbnRleHQuaW5kZXhPZihcImxhYmVsXCIpID09PSAtMSA/IGNvbnRleHQgKyBcImxhYmVsXCIgOiBjb250ZXh0IDogXCJsYWJlbFwiKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICBub2RlLmxhYmVsID0gZXhwcjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgZXhwcikge1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGV4cHI7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKVxuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUJsb2NrID0gZnVuY3Rpb24oY3JlYXRlTmV3TGV4aWNhbFNjb3BlLCBub2RlKSB7XG4gICAgaWYgKCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPT09IHZvaWQgMCApIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9IHRydWU7XG4gICAgaWYgKCBub2RlID09PSB2b2lkIDAgKSBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIG5vZGUuYm9keSA9IFtdO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmVudGVyU2NvcGUoMCk7IH1cbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZXhpdFNjb3BlKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VGb3IgPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gICAgbm9kZS5pbml0ID0gaW5pdDtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgICBub2RlLnVwZGF0ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5SID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZm9yXCIpO1xuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZvclN0YXRlbWVudFwiKVxuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUZvckluID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICAgIHZhciBpc0ZvckluID0gdGhpcy50eXBlID09PSB0eXBlcy5faW47XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAoXG4gICAgICBpbml0LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmXG4gICAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pbml0ICE9IG51bGwgJiZcbiAgICAgIChcbiAgICAgICAgIWlzRm9ySW4gfHxcbiAgICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fFxuICAgICAgICB0aGlzLnN0cmljdCB8fFxuICAgICAgICBpbml0LmtpbmQgIT09IFwidmFyXCIgfHxcbiAgICAgICAgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCJcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRoaXMucmFpc2UoXG4gICAgICAgIGluaXQuc3RhcnQsXG4gICAgICAgICgoaXNGb3JJbiA/IFwiZm9yLWluXCIgOiBcImZvci1vZlwiKSArIFwiIGxvb3AgdmFyaWFibGUgZGVjbGFyYXRpb24gbWF5IG5vdCBoYXZlIGFuIGluaXRpYWxpemVyXCIpXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaW5pdC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoaW5pdC5zdGFydCwgXCJJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1sb29wXCIpO1xuICAgIH1cbiAgICBub2RlLmxlZnQgPSBpbml0O1xuICAgIG5vZGUucmlnaHQgPSBpc0ZvckluID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNGb3JJbiA/IFwiRm9ySW5TdGF0ZW1lbnRcIiA6IFwiRm9yT2ZTdGF0ZW1lbnRcIilcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VWYXIgPSBmdW5jdGlvbihub2RlLCBpc0Zvciwga2luZCkge1xuICAgIG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gICAgbm9kZS5raW5kID0ga2luZDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZGVjbCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLnBhcnNlVmFySWQoZGVjbCwga2luZCk7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMuZXEpKSB7XG4gICAgICAgIGRlY2wuaW5pdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihpc0Zvcik7XG4gICAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwiY29uc3RcIiAmJiAhKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9IGVsc2UgaWYgKGRlY2wuaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgIShpc0ZvciAmJiAodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIkNvbXBsZXggYmluZGluZyBwYXR0ZXJucyByZXF1aXJlIGFuIGluaXRpYWxpemF0aW9uIHZhbHVlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVjbC5pbml0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUuZGVjbGFyYXRpb25zLnB1c2godGhpcy5maW5pc2hOb2RlKGRlY2wsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKTtcbiAgICAgIGlmICghdGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IGJyZWFrIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBwcCQxLnBhcnNlVmFySWQgPSBmdW5jdGlvbihkZWNsLCBraW5kKSB7XG4gICAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKGRlY2wuaWQsIGtpbmQgPT09IFwidmFyXCIgPyBCSU5EX1ZBUiA6IEJJTkRfTEVYSUNBTCwgZmFsc2UpO1xuICB9O1xuXG4gIHZhciBGVU5DX1NUQVRFTUVOVCA9IDEsIEZVTkNfSEFOR0lOR19TVEFURU1FTlQgPSAyLCBGVU5DX05VTExBQkxFX0lEID0gNDtcblxuXG4gIHBwJDEucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIHN0YXRlbWVudCwgYWxsb3dFeHByZXNzaW9uQm9keSwgaXNBc3luYykge1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhaXNBc3luYykge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3RhciAmJiAoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuZ2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gICAgaWYgKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSB7XG4gICAgICBub2RlLmlkID0gKHN0YXRlbWVudCAmIEZVTkNfTlVMTEFCTEVfSUQpICYmIHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSA/IG51bGwgOiB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIGlmIChub2RlLmlkICYmICEoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAgIHsgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgKHRoaXMuc3RyaWN0IHx8IG5vZGUuZ2VuZXJhdG9yIHx8IG5vZGUuYXN5bmMpID8gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFyID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwgOiBCSU5EX0ZVTkNUSU9OKTsgfVxuICAgIH1cblxuICAgIHZhciBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKG5vZGUuYXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSk7XG5cbiAgICBpZiAoIShzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkpXG4gICAgICB7IG5vZGUuaWQgPSB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IG51bGw7IH1cblxuICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbkJvZHksIGZhbHNlKTtcblxuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gIH07XG5cblxuICBwcCQxLnBhcnNlQ2xhc3MgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0O1xuICAgIHRoaXMuc3RyaWN0ID0gdHJ1ZTtcblxuICAgIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50KTtcbiAgICB0aGlzLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB2YXIgaGFkQ29uc3RydWN0b3IgPSBmYWxzZTtcbiAgICBjbGFzc0JvZHkuYm9keSA9IFtdO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VDbGFzc0VsZW1lbnQobm9kZS5zdXBlckNsYXNzICE9PSBudWxsKTtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIGVsZW1lbnQua2luZCA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgaWYgKGhhZENvbnN0cnVjdG9yKSB7IHRoaXMucmFpc2UoZWxlbWVudC5zdGFydCwgXCJEdXBsaWNhdGUgY29uc3RydWN0b3IgaW4gdGhlIHNhbWUgY2xhc3NcIik7IH1cbiAgICAgICAgICBoYWRDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gICAgdGhpcy5zdHJpY3QgPSBvbGRTdHJpY3Q7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQxLnBhcnNlQ2xhc3NFbGVtZW50ID0gZnVuY3Rpb24oY29uc3RydWN0b3JBbGxvd3NTdXBlcikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpKSB7IHJldHVybiBudWxsIH1cblxuICAgIHZhciBtZXRob2QgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciB0cnlDb250ZXh0dWFsID0gZnVuY3Rpb24gKGssIG5vTGluZUJyZWFrKSB7XG4gICAgICBpZiAoIG5vTGluZUJyZWFrID09PSB2b2lkIDAgKSBub0xpbmVCcmVhayA9IGZhbHNlO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzJDEuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcyQxLnN0YXJ0TG9jO1xuICAgICAgaWYgKCF0aGlzJDEuZWF0Q29udGV4dHVhbChrKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgaWYgKHRoaXMkMS50eXBlICE9PSB0eXBlcy5wYXJlbkwgJiYgKCFub0xpbmVCcmVhayB8fCAhdGhpcyQxLmNhbkluc2VydFNlbWljb2xvbigpKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICBpZiAobWV0aG9kLmtleSkgeyB0aGlzJDEudW5leHBlY3RlZCgpOyB9XG4gICAgICBtZXRob2QuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIG1ldGhvZC5rZXkgPSB0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnQsIHN0YXJ0TG9jKTtcbiAgICAgIG1ldGhvZC5rZXkubmFtZSA9IGs7XG4gICAgICB0aGlzJDEuZmluaXNoTm9kZShtZXRob2Qua2V5LCBcIklkZW50aWZpZXJcIik7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9O1xuXG4gICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgIG1ldGhvZC5zdGF0aWMgPSB0cnlDb250ZXh0dWFsKFwic3RhdGljXCIpO1xuICAgIHZhciBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIHZhciBpc0FzeW5jID0gZmFsc2U7XG4gICAgaWYgKCFpc0dlbmVyYXRvcikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIHRyeUNvbnRleHR1YWwoXCJhc3luY1wiLCB0cnVlKSkge1xuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICAgIH0gZWxzZSBpZiAodHJ5Q29udGV4dHVhbChcImdldFwiKSkge1xuICAgICAgICBtZXRob2Qua2luZCA9IFwiZ2V0XCI7XG4gICAgICB9IGVsc2UgaWYgKHRyeUNvbnRleHR1YWwoXCJzZXRcIikpIHtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcInNldFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1ldGhvZC5rZXkpIHsgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpOyB9XG4gICAgdmFyIGtleSA9IG1ldGhvZC5rZXk7XG4gICAgdmFyIGFsbG93c0RpcmVjdFN1cGVyID0gZmFsc2U7XG4gICAgaWYgKCFtZXRob2QuY29tcHV0ZWQgJiYgIW1ldGhvZC5zdGF0aWMgJiYgKGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8XG4gICAgICAgIGtleS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBrZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgIGlmIChtZXRob2Qua2luZCAhPT0gXCJtZXRob2RcIikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXJcIik7IH1cbiAgICAgIGlmIChpc0dlbmVyYXRvcikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgbWV0aG9kXCIpOyB9XG4gICAgICBtZXRob2Qua2luZCA9IFwiY29uc3RydWN0b3JcIjtcbiAgICAgIGFsbG93c0RpcmVjdFN1cGVyID0gY29uc3RydWN0b3JBbGxvd3NTdXBlcjtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZC5zdGF0aWMgJiYga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGVcIik7XG4gICAgfVxuICAgIHRoaXMucGFyc2VDbGFzc01ldGhvZChtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IDEpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShtZXRob2QudmFsdWUuc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICAgIHJldHVybiBtZXRob2RcbiAgfTtcblxuICBwcCQxLnBhcnNlQ2xhc3NNZXRob2QgPSBmdW5jdGlvbihtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAgIG1ldGhvZC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG1ldGhvZCwgXCJNZXRob2REZWZpbml0aW9uXCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUNsYXNzSWQgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIGlmIChpc1N0YXRlbWVudClcbiAgICAgICAgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBCSU5EX0xFWElDQUwsIGZhbHNlKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNTdGF0ZW1lbnQgPT09IHRydWUpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuaWQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBwcCQxLnBhcnNlQ2xhc3NTdXBlciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCh0eXBlcy5fZXh0ZW5kcykgPyB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMoKSA6IG51bGw7XG4gIH07XG5cblxuICBwcCQxLnBhcnNlRXhwb3J0ID0gZnVuY3Rpb24obm9kZSwgZXhwb3J0cykge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5zdGFyKSkge1xuICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKTtcbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIilcbiAgICB9XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLl9kZWZhdWx0KSkgeyBcbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHRoaXMubGFzdFRva1N0YXJ0KTtcbiAgICAgIHZhciBpc0FzeW5jO1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2Z1bmN0aW9uIHx8IChpc0FzeW5jID0gdGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkpIHtcbiAgICAgICAgdmFyIGZOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmIChpc0FzeW5jKSB7IHRoaXMubmV4dCgpOyB9XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb24oZk5vZGUsIEZVTkNfU1RBVEVNRU5UIHwgRlVOQ19OVUxMQUJMRV9JRCwgZmFsc2UsIGlzQXN5bmMpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9jbGFzcykge1xuICAgICAgICB2YXIgY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUNsYXNzKGNOb2RlLCBcIm51bGxhYmxlSURcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gICAgfVxuICAgIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50KCkpIHtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpO1xuICAgICAgaWYgKG5vZGUuZGVjbGFyYXRpb24udHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG4gICAgICAgIHsgdGhpcy5jaGVja1ZhcmlhYmxlRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zKTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5pZC5uYW1lLCBub2RlLmRlY2xhcmF0aW9uLmlkLnN0YXJ0KTsgfVxuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgfSBlbHNlIHsgXG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKGV4cG9ydHMpO1xuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIikpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RyaW5nKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUuc3BlY2lmaWVyczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgc3BlYyA9IGxpc3RbaV07XG5cbiAgICAgICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChzcGVjLmxvY2FsKTtcbiAgICAgICAgICB0aGlzLmNoZWNrTG9jYWxFeHBvcnQoc3BlYy5sb2NhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKVxuICB9O1xuXG4gIHBwJDEuY2hlY2tFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBwb3MpIHtcbiAgICBpZiAoIWV4cG9ydHMpIHsgcmV0dXJuIH1cbiAgICBpZiAoaGFzKGV4cG9ydHMsIG5hbWUpKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocG9zLCBcIkR1cGxpY2F0ZSBleHBvcnQgJ1wiICsgbmFtZSArIFwiJ1wiKTsgfVxuICAgIGV4cG9ydHNbbmFtZV0gPSB0cnVlO1xuICB9O1xuXG4gIHBwJDEuY2hlY2tQYXR0ZXJuRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgcGF0KSB7XG4gICAgdmFyIHR5cGUgPSBwYXQudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICB7IHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgcGF0Lm5hbWUsIHBhdC5zdGFydCk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIilcbiAgICAgIHsgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwYXQucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwcm9wKTtcbiAgICAgICAgfSB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIilcbiAgICAgIHsgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gcGF0LmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgZWx0ID0gbGlzdCQxW2kkMV07XG5cbiAgICAgICAgICBpZiAoZWx0KSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGVsdCk7IH1cbiAgICAgIH0gfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiUHJvcGVydHlcIilcbiAgICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LnZhbHVlKTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmxlZnQpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQuYXJndW1lbnQpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQuZXhwcmVzc2lvbik7IH1cbiAgfTtcblxuICBwcCQxLmNoZWNrVmFyaWFibGVFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWNscykge1xuICAgIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZGVjbHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIGRlY2wgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBkZWNsLmlkKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkMS5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJ2YXJcIiB8fFxuICAgICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY29uc3RcIiB8fFxuICAgICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY2xhc3NcIiB8fFxuICAgICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgdGhpcy5pc0xldCgpIHx8XG4gICAgICB0aGlzLmlzQXN5bmNGdW5jdGlvbigpXG4gIH07XG5cblxuICBwcCQxLnBhcnNlRXhwb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgICAgbm9kZS5leHBvcnRlZCA9IHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcy5wYXJzZUlkZW50KHRydWUpIDogbm9kZS5sb2NhbDtcbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgbm9kZS5leHBvcnRlZC5uYW1lLCBub2RlLmV4cG9ydGVkLnN0YXJ0KTtcbiAgICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0U3BlY2lmaWVyXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzXG4gIH07XG5cblxuICBwcCQxLnBhcnNlSW1wb3J0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZykge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gZW1wdHk7XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVycygpO1xuICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKTtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKVxuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUltcG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikpO1xuICAgICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHsgcmV0dXJuIG5vZGVzIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3Rhcikge1xuICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImFzXCIpO1xuICAgICAgbm9kZSQxLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChub2RlJDEubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKTtcbiAgICAgIHJldHVybiBub2Rlc1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgdmFyIG5vZGUkMiA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlJDIuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgICAgbm9kZSQyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChub2RlJDIuaW1wb3J0ZWQpO1xuICAgICAgICBub2RlJDIubG9jYWwgPSBub2RlJDIuaW1wb3J0ZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrTFZhbChub2RlJDIubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiSW1wb3J0U3BlY2lmaWVyXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzXG4gIH07XG5cbiAgcHAkMS5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlID0gZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGggJiYgdGhpcy5pc0RpcmVjdGl2ZUNhbmRpZGF0ZShzdGF0ZW1lbnRzW2ldKTsgKytpKSB7XG4gICAgICBzdGF0ZW1lbnRzW2ldLmRpcmVjdGl2ZSA9IHN0YXRlbWVudHNbaV0uZXhwcmVzc2lvbi5yYXcuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgfTtcbiAgcHAkMS5pc0RpcmVjdGl2ZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKHN0YXRlbWVudCkge1xuICAgIHJldHVybiAoXG4gICAgICBzdGF0ZW1lbnQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcbiAgICAgIHN0YXRlbWVudC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmXG4gICAgICB0eXBlb2Ygc3RhdGVtZW50LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICh0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiXFxcIlwiIHx8IHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCInXCIpXG4gICAgKVxuICB9O1xuXG4gIHZhciBwcCQyID0gUGFyc2VyLnByb3RvdHlwZTtcblxuXG4gIHBwJDIudG9Bc3NpZ25hYmxlID0gZnVuY3Rpb24obm9kZSwgaXNCaW5kaW5nLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUocHJvcCwgaXNCaW5kaW5nKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwcm9wLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJlxuICAgICAgICAgICAgKHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIiB8fCBwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShwcm9wLmFyZ3VtZW50LnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgICBpZiAobm9kZS5raW5kICE9PSBcImluaXRcIikgeyB0aGlzLnJhaXNlKG5vZGUua2V5LnN0YXJ0LCBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlclwiKTsgfVxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCBpc0JpbmRpbmcpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuYXJndW1lbnQsIGlzQmluZGluZyk7XG4gICAgICAgIGlmIChub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5hcmd1bWVudC5zdGFydCwgXCJSZXN0IGVsZW1lbnRzIGNhbm5vdCBoYXZlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiPVwiKSB7IHRoaXMucmFpc2Uobm9kZS5sZWZ0LmVuZCwgXCJPbmx5ICc9JyBvcGVyYXRvciBjYW4gYmUgdXNlZCBmb3Igc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlLlwiKTsgfVxuICAgICAgICBub2RlLnR5cGUgPSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI7XG4gICAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmxlZnQsIGlzQmluZGluZyk7XG5cbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAoIWlzQmluZGluZykgeyBicmVhayB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgIHJldHVybiBub2RlXG4gIH07XG5cblxuICBwcCQyLnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gICAgdmFyIGVuZCA9IGV4cHJMaXN0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoZWx0KSB7IHRoaXMudG9Bc3NpZ25hYmxlKGVsdCwgaXNCaW5kaW5nKTsgfVxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICB2YXIgbGFzdCA9IGV4cHJMaXN0W2VuZCAtIDFdO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiBpc0JpbmRpbmcgJiYgbGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiBsYXN0LmFyZ3VtZW50LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZChsYXN0LmFyZ3VtZW50LnN0YXJ0KTsgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwckxpc3RcbiAgfTtcblxuXG4gIHBwJDIucGFyc2VTcHJlYWQgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTcHJlYWRFbGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMi5wYXJzZVJlc3RCaW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmVzdEVsZW1lbnRcIilcbiAgfTtcblxuXG4gIHBwJDIucGFyc2VCaW5kaW5nQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgdHlwZXMuYnJhY2tldEw6XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMuYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlQYXR0ZXJuXCIpXG5cbiAgICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iaih0cnVlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50KClcbiAgfTtcblxuICBwcCQyLnBhcnNlQmluZGluZ0xpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dFbXB0eSwgYWxsb3dUcmFpbGluZ0NvbW1hKSB7XG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBmYWxzZTsgfVxuICAgICAgZWxzZSB7IHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTsgfVxuICAgICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgICAgICBlbHRzLnB1c2gobnVsbCk7XG4gICAgICB9IGVsc2UgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgICB0aGlzLnBhcnNlQmluZGluZ0xpc3RJdGVtKHJlc3QpO1xuICAgICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgICAgICAgdGhpcy5leHBlY3QoY2xvc2UpO1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVsZW0gPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpO1xuICAgICAgICB0aGlzLnBhcnNlQmluZGluZ0xpc3RJdGVtKGVsZW0pO1xuICAgICAgICBlbHRzLnB1c2goZWxlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbHRzXG4gIH07XG5cbiAgcHAkMi5wYXJzZUJpbmRpbmdMaXN0SXRlbSA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtXG4gIH07XG5cblxuICBwcCQyLnBhcnNlTWF5YmVEZWZhdWx0ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0KSB7XG4gICAgbGVmdCA9IGxlZnQgfHwgdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgfHwgIXRoaXMuZWF0KHR5cGVzLmVxKSkgeyByZXR1cm4gbGVmdCB9XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gIH07XG5cblxuICBwcCQyLmNoZWNrTFZhbCA9IGZ1bmN0aW9uKGV4cHIsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpIHtcbiAgICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9MRVhJQ0FMICYmIGV4cHIubmFtZSA9PT0gXCJsZXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJsZXQgaXMgZGlzYWxsb3dlZCBhcyBhIGxleGljYWxseSBib3VuZCBuYW1lXCIpOyB9XG4gICAgICBpZiAodGhpcy5zdHJpY3QgJiYgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZC50ZXN0KGV4cHIubmFtZSkpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIChiaW5kaW5nVHlwZSA/IFwiQmluZGluZyBcIiA6IFwiQXNzaWduaW5nIHRvIFwiKSArIGV4cHIubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICAgIGlmIChoYXMoY2hlY2tDbGFzaGVzLCBleHByLm5hbWUpKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQXJndW1lbnQgbmFtZSBjbGFzaFwiKTsgfVxuICAgICAgICBjaGVja0NsYXNoZXNbZXhwci5uYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYmluZGluZ1R5cGUgIT09IEJJTkRfTk9ORSAmJiBiaW5kaW5nVHlwZSAhPT0gQklORF9PVVRTSURFKSB7IHRoaXMuZGVjbGFyZU5hbWUoZXhwci5uYW1lLCBiaW5kaW5nVHlwZSwgZXhwci5zdGFydCk7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKGJpbmRpbmdUeXBlKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkJpbmRpbmcgbWVtYmVyIGV4cHJlc3Npb25cIik7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBleHByLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAgICB7XG4gICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMuY2hlY2tMVmFsKHByb3AsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIudmFsdWUsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IGV4cHIuZWxlbWVudHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciBlbGVtID0gbGlzdCQxW2kkMV07XG5cbiAgICAgIGlmIChlbGVtKSB7IHRoaXMuY2hlY2tMVmFsKGVsZW0sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpOyB9XG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLmxlZnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci5hcmd1bWVudCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLmV4cHJlc3Npb24sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChiaW5kaW5nVHlwZSA/IFwiQmluZGluZ1wiIDogXCJBc3NpZ25pbmcgdG9cIikgKyBcIiBydmFsdWVcIik7XG4gICAgfVxuICB9O1xuXG5cbiAgdmFyIHBwJDMgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5cbiAgcHAkMy5jaGVja1Byb3BDbGFzaCA9IGZ1bmN0aW9uKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHByb3AudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpXG4gICAgICB7IHJldHVybiB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIChwcm9wLmNvbXB1dGVkIHx8IHByb3AubWV0aG9kIHx8IHByb3Auc2hvcnRoYW5kKSlcbiAgICAgIHsgcmV0dXJuIH1cbiAgICB2YXIga2V5ID0gcHJvcC5rZXk7XG4gICAgdmFyIG5hbWU7XG4gICAgc3dpdGNoIChrZXkudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6IG5hbWUgPSBrZXkubmFtZTsgYnJlYWtcbiAgICBjYXNlIFwiTGl0ZXJhbFwiOiBuYW1lID0gU3RyaW5nKGtleS52YWx1ZSk7IGJyZWFrXG4gICAgZGVmYXVsdDogcmV0dXJuXG4gICAgfVxuICAgIHZhciBraW5kID0gcHJvcC5raW5kO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIgJiYga2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgICAgaWYgKHByb3BIYXNoLnByb3RvKSB7XG4gICAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvIDwgMClcbiAgICAgICAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0ga2V5LnN0YXJ0OyB9XG4gICAgICAgICAgfSBlbHNlIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpOyB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvcEhhc2gucHJvdG8gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIG5hbWUgPSBcIiRcIiArIG5hbWU7XG4gICAgdmFyIG90aGVyID0gcHJvcEhhc2hbbmFtZV07XG4gICAgaWYgKG90aGVyKSB7XG4gICAgICB2YXIgcmVkZWZpbml0aW9uO1xuICAgICAgaWYgKGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICAgIHJlZGVmaW5pdGlvbiA9IHRoaXMuc3RyaWN0ICYmIG90aGVyLmluaXQgfHwgb3RoZXIuZ2V0IHx8IG90aGVyLnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZGVmaW5pdGlvbiA9IG90aGVyLmluaXQgfHwgb3RoZXJba2luZF07XG4gICAgICB9XG4gICAgICBpZiAocmVkZWZpbml0aW9uKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5XCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICAgIGluaXQ6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZhbHNlLFxuICAgICAgICBzZXQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBvdGhlcltraW5kXSA9IHRydWU7XG4gIH07XG5cblxuXG5cbiAgcHAkMy5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbZXhwcl07XG4gICAgICB3aGlsZSAodGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH07XG5cblxuICBwcCQzLnBhcnNlTWF5YmVBc3NpZ24gPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbChcInlpZWxkXCIpKSB7XG4gICAgICBpZiAodGhpcy5pbkdlbmVyYXRvcikgeyByZXR1cm4gdGhpcy5wYXJzZVlpZWxkKG5vSW4pIH1cbiAgICAgIGVsc2UgeyB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7IH1cbiAgICB9XG5cbiAgICB2YXIgb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IGZhbHNlLCBvbGRQYXJlbkFzc2lnbiA9IC0xLCBvbGRUcmFpbGluZ0NvbW1hID0gLTE7XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIG9sZFBhcmVuQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduO1xuICAgICAgb2xkVHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYTtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnM7XG4gICAgICBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSlcbiAgICAgIHsgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGFydDsgfVxuICAgIHZhciBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlQ29uZGl0aW9uYWwobm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKGFmdGVyTGVmdFBhcnNlKSB7IGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0UG9zLCBzdGFydExvYyk7IH1cbiAgICBpZiAodGhpcy50eXBlLmlzQXNzaWduKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZS5sZWZ0ID0gdGhpcy50eXBlID09PSB0eXBlcy5lcSA/IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSA6IGxlZnQ7XG4gICAgICBpZiAoIW93bkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA9IC0xO1xuICAgICAgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID49IG5vZGUubGVmdC5zdGFydClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IC0xOyB9IFxuICAgICAgdGhpcy5jaGVja0xWYWwobGVmdCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIilcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG93bkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICB9XG4gICAgaWYgKG9sZFBhcmVuQXNzaWduID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gb2xkUGFyZW5Bc3NpZ247IH1cbiAgICBpZiAob2xkVHJhaWxpbmdDb21tYSA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IG9sZFRyYWlsaW5nQ29tbWE7IH1cbiAgICByZXR1cm4gbGVmdFxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZU1heWJlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJPcHMobm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgICBpZiAodGhpcy5lYXQodHlwZXMucXVlc3Rpb24pKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUudGVzdCA9IGV4cHI7XG4gICAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZUV4cHJPcHMgPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlVW5hcnkocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgcmV0dXJuIGV4cHIuc3RhcnQgPT09IHN0YXJ0UG9zICYmIGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID8gZXhwciA6IHRoaXMucGFyc2VFeHByT3AoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCAtMSwgbm9JbilcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VFeHByT3AgPSBmdW5jdGlvbihsZWZ0LCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9Jbikge1xuICAgIHZhciBwcmVjID0gdGhpcy50eXBlLmJpbm9wO1xuICAgIGlmIChwcmVjICE9IG51bGwgJiYgKCFub0luIHx8IHRoaXMudHlwZSAhPT0gdHlwZXMuX2luKSkge1xuICAgICAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG4gICAgICAgIHZhciBsb2dpY2FsID0gdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsQU5EO1xuICAgICAgICB2YXIgb3AgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcmVjLCBub0luKTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJ1aWxkQmluYXJ5KGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChub2RlLCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9JbilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlZnRcbiAgfTtcblxuICBwcCQzLmJ1aWxkQmluYXJ5ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgIG5vZGUub3BlcmF0b3IgPSBvcDtcbiAgICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpXG4gIH07XG5cblxuICBwcCQzLnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHNhd1VuYXJ5KSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBleHByO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImF3YWl0XCIpICYmICh0aGlzLmluQXN5bmMgfHwgKCF0aGlzLmluRnVuY3Rpb24gJiYgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24pKSkge1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdCgpO1xuICAgICAgc2F3VW5hcnkgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLnByZWZpeCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCB1cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmluY0RlYztcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSk7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICAgIGlmICh1cGRhdGUpIHsgdGhpcy5jaGVja0xWYWwobm9kZS5hcmd1bWVudCk7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiZcbiAgICAgICAgICAgICAgIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICAgIGVsc2UgeyBzYXdVbmFyeSA9IHRydWU7IH1cbiAgICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgICB3aGlsZSAodGhpcy50eXBlLnBvc3RmaXggJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgbm9kZSQxLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbm9kZSQxLnByZWZpeCA9IGZhbHNlO1xuICAgICAgICBub2RlJDEuYXJndW1lbnQgPSBleHByO1xuICAgICAgICB0aGlzLmNoZWNrTFZhbChleHByKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIlVwZGF0ZUV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzYXdVbmFyeSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyc3RhcikpXG4gICAgICB7IHJldHVybiB0aGlzLmJ1aWxkQmluYXJ5KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwciwgdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpLCBcIioqXCIsIGZhbHNlKSB9XG4gICAgZWxzZVxuICAgICAgeyByZXR1cm4gZXhwciB9XG4gIH07XG5cblxuICBwcCQzLnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJBdG9tKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmIChleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiB0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tFbmQpICE9PSBcIilcIilcbiAgICAgIHsgcmV0dXJuIGV4cHIgfVxuICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyhleHByLCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlc3VsdC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gLTE7IH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gLTE7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9O1xuXG4gIHBwJDMucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKSB7XG4gICAgdmFyIG1heWJlQXN5bmNBcnJvdyA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAgICAgdGhpcy5sYXN0VG9rRW5kID09PSBiYXNlLmVuZCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmlucHV0LnNsaWNlKGJhc2Uuc3RhcnQsIGJhc2UuZW5kKSA9PT0gXCJhc3luY1wiO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3cpO1xuICAgICAgaWYgKGVsZW1lbnQgPT09IGJhc2UgfHwgZWxlbWVudC50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHsgcmV0dXJuIGVsZW1lbnQgfVxuICAgICAgYmFzZSA9IGVsZW1lbnQ7XG4gICAgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VTdWJzY3JpcHQgPSBmdW5jdGlvbihiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIG1heWJlQXN5bmNBcnJvdykge1xuICAgIHZhciBjb21wdXRlZCA9IHRoaXMuZWF0KHR5cGVzLmJyYWNrZXRMKTtcbiAgICBpZiAoY29tcHV0ZWQgfHwgdGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgICBub2RlLnByb3BlcnR5ID0gY29tcHV0ZWQgPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpO1xuICAgICAgbm9kZS5jb21wdXRlZCA9ICEhY29tcHV0ZWQ7XG4gICAgICBpZiAoY29tcHV0ZWQpIHsgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldFIpOyB9XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICAgICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgICB2YXIgZXhwckxpc3QgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5hcnJvdykpIHtcbiAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgICBpZiAodGhpcy5hd2FpdElkZW50UG9zID4gMClcbiAgICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5hd2FpdElkZW50UG9zLCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdCwgdHJ1ZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcbiAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3MgfHwgdGhpcy5hd2FpdElkZW50UG9zO1xuICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMS5jYWxsZWUgPSBiYXNlO1xuICAgICAgbm9kZSQxLmFyZ3VtZW50cyA9IGV4cHJMaXN0O1xuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmJhY2tRdW90ZSkge1xuICAgICAgdmFyIG5vZGUkMiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMi50YWcgPSBiYXNlO1xuICAgICAgbm9kZSQyLnF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlKHtpc1RhZ2dlZDogdHJ1ZX0pO1xuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZUV4cHJBdG9tID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNsYXNoKSB7IHRoaXMucmVhZFJlZ2V4cCgpOyB9XG5cbiAgICB2YXIgbm9kZSwgY2FuQmVBcnJvdyA9IHRoaXMucG90ZW50aWFsQXJyb3dBdCA9PT0gdGhpcy5zdGFydDtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHlwZXMuX3N1cGVyOlxuICAgICAgaWYgKCF0aGlzLmFsbG93U3VwZXIpXG4gICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidzdXBlcicga2V5d29yZCBvdXRzaWRlIGEgbWV0aG9kXCIpOyB9XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MICYmICF0aGlzLmFsbG93RGlyZWN0U3VwZXIpXG4gICAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcInN1cGVyKCkgY2FsbCBvdXRzaWRlIGNvbnN0cnVjdG9yIG9mIGEgc3ViY2xhc3NcIik7IH1cbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLmRvdCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNrZXRMICYmIHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5MKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIilcblxuICAgIGNhc2UgdHlwZXMuX3RoaXM6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpXG5cbiAgICBjYXNlIHR5cGVzLm5hbWU6XG4gICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWNvbnRhaW5zRXNjICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5fZnVuY3Rpb24pKVxuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCAwLCBmYWxzZSwgdHJ1ZSkgfVxuICAgICAgaWYgKGNhbkJlQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmFycm93KSlcbiAgICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgZmFsc2UpIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgJiYgIWNvbnRhaW5zRXNjKSB7XG4gICAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICF0aGlzLmVhdCh0eXBlcy5hcnJvdykpXG4gICAgICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBbaWRdLCB0cnVlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaWRcblxuICAgIGNhc2UgdHlwZXMucmVnZXhwOlxuICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIG5vZGUgPSB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZS52YWx1ZSk7XG4gICAgICBub2RlLnJlZ2V4ID0ge3BhdHRlcm46IHZhbHVlLnBhdHRlcm4sIGZsYWdzOiB2YWx1ZS5mbGFnc307XG4gICAgICByZXR1cm4gbm9kZVxuXG4gICAgY2FzZSB0eXBlcy5udW06IGNhc2UgdHlwZXMuc3RyaW5nOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpXG5cbiAgICBjYXNlIHR5cGVzLl9udWxsOiBjYXNlIHR5cGVzLl90cnVlOiBjYXNlIHR5cGVzLl9mYWxzZTpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX251bGwgPyBudWxsIDogdGhpcy50eXBlID09PSB0eXBlcy5fdHJ1ZTtcbiAgICAgIG5vZGUucmF3ID0gdGhpcy50eXBlLmtleXdvcmQ7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgICBjYXNlIHR5cGVzLnBhcmVuTDpcbiAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQsIGV4cHIgPSB0aGlzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdyk7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDwgMCAmJiAhdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByKSlcbiAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHN0YXJ0OyB9XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMClcbiAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSBzdGFydDsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cHJcblxuICAgIGNhc2UgdHlwZXMuYnJhY2tldEw6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcy5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpXG5cbiAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuXG4gICAgY2FzZSB0eXBlcy5fZnVuY3Rpb246XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCAwKVxuXG4gICAgY2FzZSB0eXBlcy5fY2xhc3M6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKHRoaXMuc3RhcnROb2RlKCksIGZhbHNlKVxuXG4gICAgY2FzZSB0eXBlcy5fbmV3OlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VOZXcoKVxuXG4gICAgY2FzZSB0eXBlcy5iYWNrUXVvdGU6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKClcblxuICAgIGNhc2UgdHlwZXMuX2ltcG9ydDpcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHBySW1wb3J0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuZXhwZWN0ZWQoKVxuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfTtcblxuICBwcCQzLnBhcnNlRXhwckltcG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTsgXG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLnBhcmVuTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRHluYW1pY0ltcG9ydChub2RlKVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkMy5wYXJzZUR5bmFtaWNJbXBvcnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7IFxuXG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcblxuICAgIGlmICghdGhpcy5lYXQodHlwZXMucGFyZW5SKSkge1xuICAgICAgdmFyIGVycm9yUG9zID0gdGhpcy5zdGFydDtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5jb21tYSkgJiYgdGhpcy5lYXQodHlwZXMucGFyZW5SKSkge1xuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXJyb3JQb3MsIFwiVHJhaWxpbmcgY29tbWEgaXMgbm90IGFsbG93ZWQgaW4gaW1wb3J0KClcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoZXJyb3JQb3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZUxpdGVyYWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgbm9kZS5yYXcgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICBpZiAobm9kZS5yYXcuY2hhckNvZGVBdChub2RlLnJhdy5sZW5ndGggLSAxKSA9PT0gMTEwKSB7IG5vZGUuYmlnaW50ID0gbm9kZS5yYXcuc2xpY2UoMCwgLTEpOyB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcbiAgfTtcblxuICBwcCQzLnBhcnNlUGFyZW5FeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgICB2YXIgdmFsID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIHJldHVybiB2YWxcbiAgfTtcblxuICBwcCQzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24gPSBmdW5jdGlvbihjYW5CZUFycm93KSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCB2YWwsIGFsbG93VHJhaWxpbmdDb21tYSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGFydCwgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB2YXIgZXhwckxpc3QgPSBbXSwgZmlyc3QgPSB0cnVlLCBsYXN0SXNDb21tYSA9IGZhbHNlO1xuICAgICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycywgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIHNwcmVhZFN0YXJ0O1xuICAgICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuUikge1xuICAgICAgICBmaXJzdCA/IGZpcnN0ID0gZmFsc2UgOiB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMucGFyZW5SLCB0cnVlKSkge1xuICAgICAgICAgIGxhc3RJc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgICAgICBzcHJlYWRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpKSk7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGlubmVyRW5kUG9zID0gdGhpcy5zdGFydCwgaW5uZXJFbmRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcblxuICAgICAgaWYgKGNhbkJlQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMuYXJyb3cpKSB7XG4gICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BcnJvd0xpc3Qoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdClcbiAgICAgIH1cblxuICAgICAgaWYgKCFleHByTGlzdC5sZW5ndGggfHwgbGFzdElzQ29tbWEpIHsgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTsgfVxuICAgICAgaWYgKHNwcmVhZFN0YXJ0KSB7IHRoaXMudW5leHBlY3RlZChzcHJlYWRTdGFydCk7IH1cbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcblxuICAgICAgaWYgKGV4cHJMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsID0gdGhpcy5zdGFydE5vZGVBdChpbm5lclN0YXJ0UG9zLCBpbm5lclN0YXJ0TG9jKTtcbiAgICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICAgIHRoaXMuZmluaXNoTm9kZUF0KHZhbCwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiwgaW5uZXJFbmRQb3MsIGlubmVyRW5kTG9jKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IGV4cHJMaXN0WzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZVBhcmVucykge1xuICAgICAgdmFyIHBhciA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIHBhci5leHByZXNzaW9uID0gdmFsO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwYXIsIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgfTtcblxuICBwcCQzLnBhcnNlUGFyZW5JdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBpdGVtXG4gIH07XG5cbiAgcHAkMy5wYXJzZVBhcmVuQXJyb3dMaXN0ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZXhwckxpc3QpXG4gIH07XG5cblxuICB2YXIgZW1wdHkkMSA9IFtdO1xuXG4gIHBwJDMucGFyc2VOZXcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBuZXdcIik7IH1cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdmFyIG1ldGEgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IFwidGFyZ2V0XCIgfHwgY29udGFpbnNFc2MpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgbmV3IGlzIG5ldy50YXJnZXRcIik7IH1cbiAgICAgIGlmICghdGhpcy5pbk5vbkFycm93RnVuY3Rpb24oKSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJuZXcudGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zXCIpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpXG4gICAgfVxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgaXNJbXBvcnQgPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9pbXBvcnQ7XG4gICAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20oKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCB0cnVlKTtcbiAgICBpZiAoaXNJbXBvcnQgJiYgbm9kZS5jYWxsZWUudHlwZSA9PT0gXCJJbXBvcnRFeHByZXNzaW9uXCIpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhcnRQb3MsIFwiQ2Fubm90IHVzZSBuZXcgd2l0aCBpbXBvcnQoKVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHsgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UpOyB9XG4gICAgZWxzZSB7IG5vZGUuYXJndW1lbnRzID0gZW1wdHkkMTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOZXdFeHByZXNzaW9uXCIpXG4gIH07XG5cblxuICBwcCQzLnBhcnNlVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkO1xuXG4gICAgdmFyIGVsZW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmludmFsaWRUZW1wbGF0ZSkge1xuICAgICAgaWYgKCFpc1RhZ2dlZCkge1xuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJCYWQgZXNjYXBlIHNlcXVlbmNlIGluIHVudGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxcIik7XG4gICAgICB9XG4gICAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgICByYXc6IHRoaXMudmFsdWUsXG4gICAgICAgIGNvb2tlZDogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpLFxuICAgICAgICBjb29rZWQ6IHRoaXMudmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIGVsZW0udGFpbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuYmFja1F1b3RlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIilcbiAgfTtcblxuICBwcCQzLnBhcnNlVGVtcGxhdGUgPSBmdW5jdGlvbihyZWYpIHtcbiAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gICAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkOyBpZiAoIGlzVGFnZ2VkID09PSB2b2lkIDAgKSBpc1RhZ2dlZCA9IGZhbHNlO1xuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbXTtcbiAgICB2YXIgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSk7XG4gICAgbm9kZS5xdWFzaXMgPSBbY3VyRWx0XTtcbiAgICB3aGlsZSAoIWN1ckVsdC50YWlsKSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lb2YpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTsgfVxuICAgICAgdGhpcy5leHBlY3QodHlwZXMuZG9sbGFyQnJhY2VMKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlUik7XG4gICAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRlbXBsYXRlTGl0ZXJhbFwiKVxuICB9O1xuXG4gIHBwJDMuaXNBc3luY1Byb3AgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHByb3Aua2V5Lm5hbWUgPT09IFwiYXN5bmNcIiAmJlxuICAgICAgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmJyYWNrZXRMIHx8IHRoaXMudHlwZS5rZXl3b3JkIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIpKSAmJlxuICAgICAgIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VPYmogPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZSwgcHJvcEhhc2ggPSB7fTtcbiAgICBub2RlLnByb3BlcnRpZXMgPSBbXTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBwcm9wID0gdGhpcy5wYXJzZVByb3BlcnR5KGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAoIWlzUGF0dGVybikgeyB0aGlzLmNoZWNrUHJvcENsYXNoKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQzLnBhcnNlUHJvcGVydHkgPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCksIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLmVsbGlwc2lzKSkge1xuICAgICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUlkZW50KGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJSZXN0RWxlbWVudFwiKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA8IDApIHtcbiAgICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSB0aGlzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMCkge1xuICAgICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMCkge1xuICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuICAgICAgcHJvcC5zaG9ydGhhbmQgPSBmYWxzZTtcbiAgICAgIGlmIChpc1BhdHRlcm4gfHwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICBzdGFydFBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgIH1cbiAgICAgIGlmICghaXNQYXR0ZXJuKVxuICAgICAgICB7IGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7IH1cbiAgICB9XG4gICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhaXNHZW5lcmF0b3IgJiYgdGhpcy5pc0FzeW5jUHJvcChwcm9wKSkge1xuICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICBpc0dlbmVyYXRvciA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlUHJvcGVydHlWYWx1ZShwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUHJvcGVydHlcIilcbiAgfTtcblxuICBwcCQzLnBhcnNlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpIHtcbiAgICBpZiAoKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29sb24pXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuY29sb24pKSB7XG4gICAgICBwcm9wLnZhbHVlID0gaXNQYXR0ZXJuID8gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MKSB7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgICB9IGVsc2UgaWYgKCFpc1BhdHRlcm4gJiYgIWNvbnRhaW5zRXNjICYmXG4gICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxuICAgICAgICAgICAgICAgKHByb3Aua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgcHJvcC5rZXkubmFtZSA9PT0gXCJzZXRcIikgJiZcbiAgICAgICAgICAgICAgICh0aGlzLnR5cGUgIT09IHR5cGVzLmNvbW1hICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VSKSkge1xuICAgICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHByb3Aua2luZCA9IHByb3Aua2V5Lm5hbWU7XG4gICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoZmFsc2UpO1xuICAgICAgdmFyIHBhcmFtQ291bnQgPSBwcm9wLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgICAgIGlmIChwcm9wLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcHJvcC52YWx1ZS5zdGFydDtcbiAgICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJnZXRcIilcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHByb3AudmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHByb3Aua2V5KTtcbiAgICAgIGlmIChwcm9wLmtleS5uYW1lID09PSBcImF3YWl0XCIgJiYgIXRoaXMuYXdhaXRJZGVudFBvcylcbiAgICAgICAgeyB0aGlzLmF3YWl0SWRlbnRQb3MgPSBzdGFydFBvczsgfVxuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVxICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduIDwgMClcbiAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gdGhpcy5zdGFydDsgfVxuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AudmFsdWUgPSBwcm9wLmtleTtcbiAgICAgIH1cbiAgICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMuYnJhY2tldEwpKSB7XG4gICAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gICAgICAgIHJldHVybiBwcm9wLmtleVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcC5rZXkgPSB0aGlzLnR5cGUgPT09IHR5cGVzLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpXG4gIH07XG5cblxuICBwcCQzLmluaXRGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLmlkID0gbnVsbDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgbm9kZS5nZW5lcmF0b3IgPSBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCkgeyBub2RlLmFzeW5jID0gZmFsc2U7IH1cbiAgfTtcblxuXG4gIHBwJDMucGFyc2VNZXRob2QgPSBmdW5jdGlvbihpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dEaXJlY3RTdXBlcikge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgICB7IG5vZGUuZ2VuZXJhdG9yID0gaXNHZW5lcmF0b3I7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgbm9kZS5nZW5lcmF0b3IpIHwgU0NPUEVfU1VQRVIgfCAoYWxsb3dEaXJlY3RTdXBlciA/IFNDT1BFX0RJUkVDVF9TVVBFUiA6IDApKTtcblxuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZUFycm93RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vZGUsIHBhcmFtcywgaXNBc3luYykge1xuICAgIHZhciBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICAgIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIGZhbHNlKSB8IFNDT1BFX0FSUk9XKTtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcblxuICAgIG5vZGUucGFyYW1zID0gdGhpcy50b0Fzc2lnbmFibGVMaXN0KHBhcmFtcywgdHJ1ZSk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlLCBmYWxzZSk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cblxuICBwcCQzLnBhcnNlRnVuY3Rpb25Cb2R5ID0gZnVuY3Rpb24obm9kZSwgaXNBcnJvd0Z1bmN0aW9uLCBpc01ldGhvZCkge1xuICAgIHZhciBpc0V4cHJlc3Npb24gPSBpc0Fycm93RnVuY3Rpb24gJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZUw7XG4gICAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0LCB1c2VTdHJpY3QgPSBmYWxzZTtcblxuICAgIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9uU2ltcGxlID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgIXRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpO1xuICAgICAgaWYgKCFvbGRTdHJpY3QgfHwgbm9uU2ltcGxlKSB7XG4gICAgICAgIHVzZVN0cmljdCA9IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMuZW5kKTtcbiAgICAgICAgaWYgKHVzZVN0cmljdCAmJiBub25TaW1wbGUpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0XCIpOyB9XG4gICAgICB9XG4gICAgICB2YXIgb2xkTGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gICAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgICAgaWYgKHVzZVN0cmljdCkgeyB0aGlzLnN0cmljdCA9IHRydWU7IH1cblxuICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCAhb2xkU3RyaWN0ICYmICF1c2VTdHJpY3QgJiYgIWlzQXJyb3dGdW5jdGlvbiAmJiAhaXNNZXRob2QgJiYgdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcykpO1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keS5ib2R5KTtcbiAgICAgIHRoaXMubGFiZWxzID0gb2xkTGFiZWxzO1xuICAgIH1cbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuXG4gICAgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUuaWQpIHsgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgQklORF9PVVRTSURFKTsgfVxuICAgIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICB9O1xuXG4gIHBwJDMuaXNTaW1wbGVQYXJhbUxpc3QgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhcmFtczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgcGFyYW0gPSBsaXN0W2ldO1xuXG4gICAgICBpZiAocGFyYW0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHsgcmV0dXJuIGZhbHNlXG4gICAgfSB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuXG4gIHBwJDMuY2hlY2tQYXJhbXMgPSBmdW5jdGlvbihub2RlLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgbmFtZUhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMuY2hlY2tMVmFsKHBhcmFtLCBCSU5EX1ZBUiwgYWxsb3dEdXBsaWNhdGVzID8gbnVsbCA6IG5hbWVIYXNoKTtcbiAgICB9XG4gIH07XG5cblxuICBwcCQzLnBhcnNlRXhwckxpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd0VtcHR5LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICB2YXIgZWx0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKVxuICAgICAgICB7IGVsdCA9IG51bGw7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgICAgZWx0ID0gdGhpcy5wYXJzZVNwcmVhZChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWx0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIH1cbiAgICAgIGVsdHMucHVzaChlbHQpO1xuICAgIH1cbiAgICByZXR1cm4gZWx0c1xuICB9O1xuXG4gIHBwJDMuY2hlY2tVbnJlc2VydmVkID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgdmFyIHN0YXJ0ID0gcmVmLnN0YXJ0O1xuICAgIHZhciBlbmQgPSByZWYuZW5kO1xuICAgIHZhciBuYW1lID0gcmVmLm5hbWU7XG5cbiAgICBpZiAodGhpcy5pbkdlbmVyYXRvciAmJiBuYW1lID09PSBcInlpZWxkXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3JcIik7IH1cbiAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgIGlmICh0aGlzLmtleXdvcmRzLnRlc3QobmFtZSkpXG4gICAgICB7IHRoaXMucmFpc2Uoc3RhcnQsIChcIlVuZXhwZWN0ZWQga2V5d29yZCAnXCIgKyBuYW1lICsgXCInXCIpKTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2ICYmXG4gICAgICB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpLmluZGV4T2YoXCJcXFxcXCIpICE9PSAtMSkgeyByZXR1cm4gfVxuICAgIHZhciByZSA9IHRoaXMuc3RyaWN0ID8gdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0IDogdGhpcy5yZXNlcnZlZFdvcmRzO1xuICAgIGlmIChyZS50ZXN0KG5hbWUpKSB7XG4gICAgICBpZiAoIXRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2Uga2V5d29yZCAnYXdhaXQnIG91dHNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgKFwiVGhlIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZFwiKSk7XG4gICAgfVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZUlkZW50ID0gZnVuY3Rpb24obGliZXJhbCwgaXNCaW5kaW5nKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICAgIG5vZGUubmFtZSA9IHRoaXMudmFsdWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2V5d29yZCkge1xuICAgICAgbm9kZS5uYW1lID0gdGhpcy50eXBlLmtleXdvcmQ7XG5cbiAgICAgIGlmICgobm9kZS5uYW1lID09PSBcImNsYXNzXCIgfHwgbm9kZS5uYW1lID09PSBcImZ1bmN0aW9uXCIpICYmXG4gICAgICAgICAgKHRoaXMubGFzdFRva0VuZCAhPT0gdGhpcy5sYXN0VG9rU3RhcnQgKyAxIHx8IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmxhc3RUb2tTdGFydCkgIT09IDQ2KSkge1xuICAgICAgICB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoISFsaWJlcmFsKTtcbiAgICB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpO1xuICAgIGlmICghbGliZXJhbCkge1xuICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQobm9kZSk7XG4gICAgICBpZiAobm9kZS5uYW1lID09PSBcImF3YWl0XCIgJiYgIXRoaXMuYXdhaXRJZGVudFBvcylcbiAgICAgICAgeyB0aGlzLmF3YWl0SWRlbnRQb3MgPSBub2RlLnN0YXJ0OyB9XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH07XG5cblxuICBwcCQzLnBhcnNlWWllbGQgPSBmdW5jdGlvbihub0luKSB7XG4gICAgaWYgKCF0aGlzLnlpZWxkUG9zKSB7IHRoaXMueWllbGRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSB8fCB0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0YXIgJiYgIXRoaXMudHlwZS5zdGFydHNFeHByKSkge1xuICAgICAgbm9kZS5kZWxlZ2F0ZSA9IGZhbHNlO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZGVsZWdhdGUgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJZaWVsZEV4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQzLnBhcnNlQXdhaXQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuYXdhaXRQb3MpIHsgdGhpcy5hd2FpdFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBd2FpdEV4cHJlc3Npb25cIilcbiAgfTtcblxuICB2YXIgcHAkNCA9IFBhcnNlci5wcm90b3R5cGU7XG5cblxuICBwcCQ0LnJhaXNlID0gZnVuY3Rpb24ocG9zLCBtZXNzYWdlKSB7XG4gICAgdmFyIGxvYyA9IGdldExpbmVJbmZvKHRoaXMuaW5wdXQsIHBvcyk7XG4gICAgbWVzc2FnZSArPSBcIiAoXCIgKyBsb2MubGluZSArIFwiOlwiICsgbG9jLmNvbHVtbiArIFwiKVwiO1xuICAgIHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG4gICAgZXJyLnBvcyA9IHBvczsgZXJyLmxvYyA9IGxvYzsgZXJyLnJhaXNlZEF0ID0gdGhpcy5wb3M7XG4gICAgdGhyb3cgZXJyXG4gIH07XG5cbiAgcHAkNC5yYWlzZVJlY292ZXJhYmxlID0gcHAkNC5yYWlzZTtcblxuICBwcCQ0LmN1clBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5jdXJMaW5lLCB0aGlzLnBvcyAtIHRoaXMubGluZVN0YXJ0KVxuICAgIH1cbiAgfTtcblxuICB2YXIgcHAkNSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgdmFyIFNjb3BlID0gZnVuY3Rpb24gU2NvcGUoZmxhZ3MpIHtcbiAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgdGhpcy52YXIgPSBbXTtcbiAgICB0aGlzLmxleGljYWwgPSBbXTtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICB9O1xuXG5cbiAgcHAkNS5lbnRlclNjb3BlID0gZnVuY3Rpb24oZmxhZ3MpIHtcbiAgICB0aGlzLnNjb3BlU3RhY2sucHVzaChuZXcgU2NvcGUoZmxhZ3MpKTtcbiAgfTtcblxuICBwcCQ1LmV4aXRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wb3AoKTtcbiAgfTtcblxuICBwcCQ1LnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlID0gZnVuY3Rpb24oc2NvcGUpIHtcbiAgICByZXR1cm4gKHNjb3BlLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pIHx8ICF0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUClcbiAgfTtcblxuICBwcCQ1LmRlY2xhcmVOYW1lID0gZnVuY3Rpb24obmFtZSwgYmluZGluZ1R5cGUsIHBvcykge1xuICAgIHZhciByZWRlY2xhcmVkID0gZmFsc2U7XG4gICAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwpIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgICByZWRlY2xhcmVkID0gc2NvcGUubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS52YXIuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgICAgc2NvcGUubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgICAgaWYgKHRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVE9QKSlcbiAgICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gICAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9TSU1QTEVfQ0FUQ0gpIHtcbiAgICAgIHZhciBzY29wZSQxID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICAgIHNjb3BlJDEubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfRlVOQ1RJT04pIHtcbiAgICAgIHZhciBzY29wZSQyID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICAgIGlmICh0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIpXG4gICAgICAgIHsgcmVkZWNsYXJlZCA9IHNjb3BlJDIubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZSQyLnZhci5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICAgIHNjb3BlJDIuZnVuY3Rpb25zLnB1c2gobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHNjb3BlJDMgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICAgIGlmIChzY29wZSQzLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xICYmICEoKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9TSU1QTEVfQ0FUQ0gpICYmIHNjb3BlJDMubGV4aWNhbFswXSA9PT0gbmFtZSkgfHxcbiAgICAgICAgICAgICF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHNjb3BlJDMpICYmIHNjb3BlJDMuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICAgIHJlZGVjbGFyZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUkMy52YXIucHVzaChuYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9UT1ApKVxuICAgICAgICAgIHsgZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXTsgfVxuICAgICAgICBpZiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1ZBUikgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWRlY2xhcmVkKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIChcIklkZW50aWZpZXIgJ1wiICsgbmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTsgfVxuICB9O1xuXG4gIHBwJDUuY2hlY2tMb2NhbEV4cG9ydCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgaWYgKHRoaXMuc2NvcGVTdGFja1swXS5sZXhpY2FsLmluZGV4T2YoaWQubmFtZSkgPT09IC0xICYmXG4gICAgICAgIHRoaXMuc2NvcGVTdGFja1swXS52YXIuaW5kZXhPZihpZC5uYW1lKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tpZC5uYW1lXSA9IGlkO1xuICAgIH1cbiAgfTtcblxuICBwcCQ1LmN1cnJlbnRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdXG4gIH07XG5cbiAgcHAkNS5jdXJyZW50VmFyU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUikgeyByZXR1cm4gc2NvcGUgfVxuICAgIH1cbiAgfTtcblxuICBwcCQ1LmN1cnJlbnRUaGlzU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUiAmJiAhKHNjb3BlLmZsYWdzICYgU0NPUEVfQVJST1cpKSB7IHJldHVybiBzY29wZSB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBOb2RlID0gZnVuY3Rpb24gTm9kZShwYXJzZXIsIHBvcywgbG9jKSB7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcbiAgICB0aGlzLnN0YXJ0ID0gcG9zO1xuICAgIHRoaXMuZW5kID0gMDtcbiAgICBpZiAocGFyc2VyLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwYXJzZXIsIGxvYyk7IH1cbiAgICBpZiAocGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSlcbiAgICAgIHsgdGhpcy5zb3VyY2VGaWxlID0gcGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTsgfVxuICAgIGlmIChwYXJzZXIub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IHRoaXMucmFuZ2UgPSBbcG9zLCAwXTsgfVxuICB9O1xuXG5cbiAgdmFyIHBwJDYgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHBwJDYuc3RhcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpXG4gIH07XG5cbiAgcHAkNi5zdGFydE5vZGVBdCA9IGZ1bmN0aW9uKHBvcywgbG9jKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHBvcywgbG9jKVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICBub2RlLmVuZCA9IHBvcztcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHsgbm9kZS5sb2MuZW5kID0gbG9jOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IG5vZGUucmFuZ2VbMV0gPSBwb3M7IH1cbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgcHAkNi5maW5pc2hOb2RlID0gZnVuY3Rpb24obm9kZSwgdHlwZSkge1xuICAgIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCB0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYylcbiAgfTtcblxuXG4gIHBwJDYuZmluaXNoTm9kZUF0ID0gZnVuY3Rpb24obm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgcG9zLCBsb2MpXG4gIH07XG5cblxuICB2YXIgVG9rQ29udGV4dCA9IGZ1bmN0aW9uIFRva0NvbnRleHQodG9rZW4sIGlzRXhwciwgcHJlc2VydmVTcGFjZSwgb3ZlcnJpZGUsIGdlbmVyYXRvcikge1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLmlzRXhwciA9ICEhaXNFeHByO1xuICAgIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5nZW5lcmF0b3IgPSAhIWdlbmVyYXRvcjtcbiAgfTtcblxuICB2YXIgdHlwZXMkMSA9IHtcbiAgICBiX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwie1wiLCBmYWxzZSksXG4gICAgYl9leHByOiBuZXcgVG9rQ29udGV4dChcIntcIiwgdHJ1ZSksXG4gICAgYl90bXBsOiBuZXcgVG9rQ29udGV4dChcIiR7XCIsIGZhbHNlKSxcbiAgICBwX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCBmYWxzZSksXG4gICAgcF9leHByOiBuZXcgVG9rQ29udGV4dChcIihcIiwgdHJ1ZSksXG4gICAgcV90bXBsOiBuZXcgVG9rQ29udGV4dChcImBcIiwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudHJ5UmVhZFRlbXBsYXRlVG9rZW4oKTsgfSksXG4gICAgZl9zdGF0OiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlKSxcbiAgICBmX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSksXG4gICAgZl9leHByX2dlbjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlLCBmYWxzZSwgbnVsbCwgdHJ1ZSksXG4gICAgZl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgZmFsc2UsIGZhbHNlLCBudWxsLCB0cnVlKVxuICB9O1xuXG4gIHZhciBwcCQ3ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICBwcCQ3LmluaXRpYWxDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFt0eXBlcyQxLmJfc3RhdF1cbiAgfTtcblxuICBwcCQ3LmJyYWNlSXNCbG9jayA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICAgIGlmIChwYXJlbnQgPT09IHR5cGVzJDEuZl9leHByIHx8IHBhcmVudCA9PT0gdHlwZXMkMS5mX3N0YXQpXG4gICAgICB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLmNvbG9uICYmIChwYXJlbnQgPT09IHR5cGVzJDEuYl9zdGF0IHx8IHBhcmVudCA9PT0gdHlwZXMkMS5iX2V4cHIpKVxuICAgICAgeyByZXR1cm4gIXBhcmVudC5pc0V4cHIgfVxuXG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fcmV0dXJuIHx8IHByZXZUeXBlID09PSB0eXBlcy5uYW1lICYmIHRoaXMuZXhwckFsbG93ZWQpXG4gICAgICB7IHJldHVybiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9lbHNlIHx8IHByZXZUeXBlID09PSB0eXBlcy5zZW1pIHx8IHByZXZUeXBlID09PSB0eXBlcy5lb2YgfHwgcHJldlR5cGUgPT09IHR5cGVzLnBhcmVuUiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuYXJyb3cpXG4gICAgICB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLmJyYWNlTClcbiAgICAgIHsgcmV0dXJuIHBhcmVudCA9PT0gdHlwZXMkMS5iX3N0YXQgfVxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX3ZhciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX2NvbnN0IHx8IHByZXZUeXBlID09PSB0eXBlcy5uYW1lKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiAhdGhpcy5leHByQWxsb3dlZFxuICB9O1xuXG4gIHBwJDcuaW5HZW5lcmF0b3JDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxOyBpID49IDE7IGktLSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRbaV07XG4gICAgICBpZiAoY29udGV4dC50b2tlbiA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB7IHJldHVybiBjb250ZXh0LmdlbmVyYXRvciB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDcudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIHVwZGF0ZSwgdHlwZSA9IHRoaXMudHlwZTtcbiAgICBpZiAodHlwZS5rZXl3b3JkICYmIHByZXZUeXBlID09PSB0eXBlcy5kb3QpXG4gICAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICAgIGVsc2UgaWYgKHVwZGF0ZSA9IHR5cGUudXBkYXRlQ29udGV4dClcbiAgICAgIHsgdXBkYXRlLmNhbGwodGhpcywgcHJldlR5cGUpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByOyB9XG4gIH07XG5cblxuICB0eXBlcy5wYXJlblIudXBkYXRlQ29udGV4dCA9IHR5cGVzLmJyYWNlUi51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgaWYgKG91dCA9PT0gdHlwZXMkMS5iX3N0YXQgJiYgdGhpcy5jdXJDb250ZXh0KCkudG9rZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgb3V0ID0gdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgIH1cbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gIW91dC5pc0V4cHI7XG4gIH07XG5cbiAgdHlwZXMuYnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzJDEuYl9zdGF0IDogdHlwZXMkMS5iX2V4cHIpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzLmRvbGxhckJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5iX3RtcGwpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzLnBhcmVuTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB2YXIgc3RhdGVtZW50UGFyZW5zID0gcHJldlR5cGUgPT09IHR5cGVzLl9pZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX2ZvciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX3dpdGggfHwgcHJldlR5cGUgPT09IHR5cGVzLl93aGlsZTtcbiAgICB0aGlzLmNvbnRleHQucHVzaChzdGF0ZW1lbnRQYXJlbnMgPyB0eXBlcyQxLnBfc3RhdCA6IHR5cGVzJDEucF9leHByKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgfTtcblxuICB0eXBlcy5pbmNEZWMudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICB9O1xuXG4gIHR5cGVzLl9mdW5jdGlvbi51cGRhdGVDb250ZXh0ID0gdHlwZXMuX2NsYXNzLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIGlmIChwcmV2VHlwZS5iZWZvcmVFeHByICYmIHByZXZUeXBlICE9PSB0eXBlcy5zZW1pICYmIHByZXZUeXBlICE9PSB0eXBlcy5fZWxzZSAmJlxuICAgICAgICAhKHByZXZUeXBlID09PSB0eXBlcy5fcmV0dXJuICYmIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpICYmXG4gICAgICAgICEoKHByZXZUeXBlID09PSB0eXBlcy5jb2xvbiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKSAmJiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS5iX3N0YXQpKVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmZfZXhwcik7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuZl9zdGF0KTsgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgfTtcblxuICB0eXBlcy5iYWNrUXVvdGUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS5xX3RtcGwpXG4gICAgICB7IHRoaXMuY29udGV4dC5wb3AoKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5xX3RtcGwpOyB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHR5cGVzLnN0YXIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fZnVuY3Rpb24pIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxO1xuICAgICAgaWYgKHRoaXMuY29udGV4dFtpbmRleF0gPT09IHR5cGVzJDEuZl9leHByKVxuICAgICAgICB7IHRoaXMuY29udGV4dFtpbmRleF0gPSB0eXBlcyQxLmZfZXhwcl9nZW47IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMkMS5mX2dlbjsgfVxuICAgIH1cbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgfTtcblxuICB0eXBlcy5uYW1lLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBhbGxvd2VkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHByZXZUeXBlICE9PSB0eXBlcy5kb3QpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlID09PSBcIm9mXCIgJiYgIXRoaXMuZXhwckFsbG93ZWQgfHxcbiAgICAgICAgICB0aGlzLnZhbHVlID09PSBcInlpZWxkXCIgJiYgdGhpcy5pbkdlbmVyYXRvckNvbnRleHQoKSlcbiAgICAgICAgeyBhbGxvd2VkID0gdHJ1ZTsgfVxuICAgIH1cbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gYWxsb3dlZDtcbiAgfTtcblxuXG4gIHZhciBlY21hOUJpbmFyeVByb3BlcnRpZXMgPSBcIkFTQ0lJIEFTQ0lJX0hleF9EaWdpdCBBSGV4IEFscGhhYmV0aWMgQWxwaGEgQW55IEFzc2lnbmVkIEJpZGlfQ29udHJvbCBCaWRpX0MgQmlkaV9NaXJyb3JlZCBCaWRpX00gQ2FzZV9JZ25vcmFibGUgQ0kgQ2FzZWQgQ2hhbmdlc19XaGVuX0Nhc2Vmb2xkZWQgQ1dDRiBDaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZCBDV0NNIENoYW5nZXNfV2hlbl9Mb3dlcmNhc2VkIENXTCBDaGFuZ2VzX1doZW5fTkZLQ19DYXNlZm9sZGVkIENXS0NGIENoYW5nZXNfV2hlbl9UaXRsZWNhc2VkIENXVCBDaGFuZ2VzX1doZW5fVXBwZXJjYXNlZCBDV1UgRGFzaCBEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IERJIERlcHJlY2F0ZWQgRGVwIERpYWNyaXRpYyBEaWEgRW1vamkgRW1vamlfQ29tcG9uZW50IEVtb2ppX01vZGlmaWVyIEVtb2ppX01vZGlmaWVyX0Jhc2UgRW1vamlfUHJlc2VudGF0aW9uIEV4dGVuZGVyIEV4dCBHcmFwaGVtZV9CYXNlIEdyX0Jhc2UgR3JhcGhlbWVfRXh0ZW5kIEdyX0V4dCBIZXhfRGlnaXQgSGV4IElEU19CaW5hcnlfT3BlcmF0b3IgSURTQiBJRFNfVHJpbmFyeV9PcGVyYXRvciBJRFNUIElEX0NvbnRpbnVlIElEQyBJRF9TdGFydCBJRFMgSWRlb2dyYXBoaWMgSWRlbyBKb2luX0NvbnRyb2wgSm9pbl9DIExvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uIExPRSBMb3dlcmNhc2UgTG93ZXIgTWF0aCBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCBOQ2hhciBQYXR0ZXJuX1N5bnRheCBQYXRfU3luIFBhdHRlcm5fV2hpdGVfU3BhY2UgUGF0X1dTIFF1b3RhdGlvbl9NYXJrIFFNYXJrIFJhZGljYWwgUmVnaW9uYWxfSW5kaWNhdG9yIFJJIFNlbnRlbmNlX1Rlcm1pbmFsIFNUZXJtIFNvZnRfRG90dGVkIFNEIFRlcm1pbmFsX1B1bmN0dWF0aW9uIFRlcm0gVW5pZmllZF9JZGVvZ3JhcGggVUlkZW8gVXBwZXJjYXNlIFVwcGVyIFZhcmlhdGlvbl9TZWxlY3RvciBWUyBXaGl0ZV9TcGFjZSBzcGFjZSBYSURfQ29udGludWUgWElEQyBYSURfU3RhcnQgWElEU1wiO1xuICB2YXIgZWNtYTEwQmluYXJ5UHJvcGVydGllcyA9IGVjbWE5QmluYXJ5UHJvcGVydGllcyArIFwiIEV4dGVuZGVkX1BpY3RvZ3JhcGhpY1wiO1xuICB2YXIgZWNtYTExQmluYXJ5UHJvcGVydGllcyA9IGVjbWExMEJpbmFyeVByb3BlcnRpZXM7XG4gIHZhciB1bmljb2RlQmluYXJ5UHJvcGVydGllcyA9IHtcbiAgICA5OiBlY21hOUJpbmFyeVByb3BlcnRpZXMsXG4gICAgMTA6IGVjbWExMEJpbmFyeVByb3BlcnRpZXMsXG4gICAgMTE6IGVjbWExMUJpbmFyeVByb3BlcnRpZXNcbiAgfTtcblxuICB2YXIgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyA9IFwiQ2FzZWRfTGV0dGVyIExDIENsb3NlX1B1bmN0dWF0aW9uIFBlIENvbm5lY3Rvcl9QdW5jdHVhdGlvbiBQYyBDb250cm9sIENjIGNudHJsIEN1cnJlbmN5X1N5bWJvbCBTYyBEYXNoX1B1bmN0dWF0aW9uIFBkIERlY2ltYWxfTnVtYmVyIE5kIGRpZ2l0IEVuY2xvc2luZ19NYXJrIE1lIEZpbmFsX1B1bmN0dWF0aW9uIFBmIEZvcm1hdCBDZiBJbml0aWFsX1B1bmN0dWF0aW9uIFBpIExldHRlciBMIExldHRlcl9OdW1iZXIgTmwgTGluZV9TZXBhcmF0b3IgWmwgTG93ZXJjYXNlX0xldHRlciBMbCBNYXJrIE0gQ29tYmluaW5nX01hcmsgTWF0aF9TeW1ib2wgU20gTW9kaWZpZXJfTGV0dGVyIExtIE1vZGlmaWVyX1N5bWJvbCBTayBOb25zcGFjaW5nX01hcmsgTW4gTnVtYmVyIE4gT3Blbl9QdW5jdHVhdGlvbiBQcyBPdGhlciBDIE90aGVyX0xldHRlciBMbyBPdGhlcl9OdW1iZXIgTm8gT3RoZXJfUHVuY3R1YXRpb24gUG8gT3RoZXJfU3ltYm9sIFNvIFBhcmFncmFwaF9TZXBhcmF0b3IgWnAgUHJpdmF0ZV9Vc2UgQ28gUHVuY3R1YXRpb24gUCBwdW5jdCBTZXBhcmF0b3IgWiBTcGFjZV9TZXBhcmF0b3IgWnMgU3BhY2luZ19NYXJrIE1jIFN1cnJvZ2F0ZSBDcyBTeW1ib2wgUyBUaXRsZWNhc2VfTGV0dGVyIEx0IFVuYXNzaWduZWQgQ24gVXBwZXJjYXNlX0xldHRlciBMdVwiO1xuXG4gIHZhciBlY21hOVNjcmlwdFZhbHVlcyA9IFwiQWRsYW0gQWRsbSBBaG9tIEFob20gQW5hdG9saWFuX0hpZXJvZ2x5cGhzIEhsdXcgQXJhYmljIEFyYWIgQXJtZW5pYW4gQXJtbiBBdmVzdGFuIEF2c3QgQmFsaW5lc2UgQmFsaSBCYW11bSBCYW11IEJhc3NhX1ZhaCBCYXNzIEJhdGFrIEJhdGsgQmVuZ2FsaSBCZW5nIEJoYWlrc3VraSBCaGtzIEJvcG9tb2ZvIEJvcG8gQnJhaG1pIEJyYWggQnJhaWxsZSBCcmFpIEJ1Z2luZXNlIEJ1Z2kgQnVoaWQgQnVoZCBDYW5hZGlhbl9BYm9yaWdpbmFsIENhbnMgQ2FyaWFuIENhcmkgQ2F1Y2FzaWFuX0FsYmFuaWFuIEFnaGIgQ2hha21hIENha20gQ2hhbSBDaGFtIENoZXJva2VlIENoZXIgQ29tbW9uIFp5eXkgQ29wdGljIENvcHQgUWFhYyBDdW5laWZvcm0gWHN1eCBDeXByaW90IENwcnQgQ3lyaWxsaWMgQ3lybCBEZXNlcmV0IERzcnQgRGV2YW5hZ2FyaSBEZXZhIER1cGxveWFuIER1cGwgRWd5cHRpYW5fSGllcm9nbHlwaHMgRWd5cCBFbGJhc2FuIEVsYmEgRXRoaW9waWMgRXRoaSBHZW9yZ2lhbiBHZW9yIEdsYWdvbGl0aWMgR2xhZyBHb3RoaWMgR290aCBHcmFudGhhIEdyYW4gR3JlZWsgR3JlayBHdWphcmF0aSBHdWpyIEd1cm11a2hpIEd1cnUgSGFuIEhhbmkgSGFuZ3VsIEhhbmcgSGFudW5vbyBIYW5vIEhhdHJhbiBIYXRyIEhlYnJldyBIZWJyIEhpcmFnYW5hIEhpcmEgSW1wZXJpYWxfQXJhbWFpYyBBcm1pIEluaGVyaXRlZCBaaW5oIFFhYWkgSW5zY3JpcHRpb25hbF9QYWhsYXZpIFBobGkgSW5zY3JpcHRpb25hbF9QYXJ0aGlhbiBQcnRpIEphdmFuZXNlIEphdmEgS2FpdGhpIEt0aGkgS2FubmFkYSBLbmRhIEthdGFrYW5hIEthbmEgS2F5YWhfTGkgS2FsaSBLaGFyb3NodGhpIEtoYXIgS2htZXIgS2htciBLaG9qa2kgS2hvaiBLaHVkYXdhZGkgU2luZCBMYW8gTGFvbyBMYXRpbiBMYXRuIExlcGNoYSBMZXBjIExpbWJ1IExpbWIgTGluZWFyX0EgTGluYSBMaW5lYXJfQiBMaW5iIExpc3UgTGlzdSBMeWNpYW4gTHljaSBMeWRpYW4gTHlkaSBNYWhhamFuaSBNYWhqIE1hbGF5YWxhbSBNbHltIE1hbmRhaWMgTWFuZCBNYW5pY2hhZWFuIE1hbmkgTWFyY2hlbiBNYXJjIE1hc2FyYW1fR29uZGkgR29ubSBNZWV0ZWlfTWF5ZWsgTXRlaSBNZW5kZV9LaWtha3VpIE1lbmQgTWVyb2l0aWNfQ3Vyc2l2ZSBNZXJjIE1lcm9pdGljX0hpZXJvZ2x5cGhzIE1lcm8gTWlhbyBQbHJkIE1vZGkgTW9kaSBNb25nb2xpYW4gTW9uZyBNcm8gTXJvbyBNdWx0YW5pIE11bHQgTXlhbm1hciBNeW1yIE5hYmF0YWVhbiBOYmF0IE5ld19UYWlfTHVlIFRhbHUgTmV3YSBOZXdhIE5rbyBOa29vIE51c2h1IE5zaHUgT2doYW0gT2dhbSBPbF9DaGlraSBPbGNrIE9sZF9IdW5nYXJpYW4gSHVuZyBPbGRfSXRhbGljIEl0YWwgT2xkX05vcnRoX0FyYWJpYW4gTmFyYiBPbGRfUGVybWljIFBlcm0gT2xkX1BlcnNpYW4gWHBlbyBPbGRfU291dGhfQXJhYmlhbiBTYXJiIE9sZF9UdXJraWMgT3JraCBPcml5YSBPcnlhIE9zYWdlIE9zZ2UgT3NtYW55YSBPc21hIFBhaGF3aF9IbW9uZyBIbW5nIFBhbG15cmVuZSBQYWxtIFBhdV9DaW5fSGF1IFBhdWMgUGhhZ3NfUGEgUGhhZyBQaG9lbmljaWFuIFBobnggUHNhbHRlcl9QYWhsYXZpIFBobHAgUmVqYW5nIFJqbmcgUnVuaWMgUnVuciBTYW1hcml0YW4gU2FtciBTYXVyYXNodHJhIFNhdXIgU2hhcmFkYSBTaHJkIFNoYXZpYW4gU2hhdyBTaWRkaGFtIFNpZGQgU2lnbldyaXRpbmcgU2dudyBTaW5oYWxhIFNpbmggU29yYV9Tb21wZW5nIFNvcmEgU295b21ibyBTb3lvIFN1bmRhbmVzZSBTdW5kIFN5bG90aV9OYWdyaSBTeWxvIFN5cmlhYyBTeXJjIFRhZ2Fsb2cgVGdsZyBUYWdiYW53YSBUYWdiIFRhaV9MZSBUYWxlIFRhaV9UaGFtIExhbmEgVGFpX1ZpZXQgVGF2dCBUYWtyaSBUYWtyIFRhbWlsIFRhbWwgVGFuZ3V0IFRhbmcgVGVsdWd1IFRlbHUgVGhhYW5hIFRoYWEgVGhhaSBUaGFpIFRpYmV0YW4gVGlidCBUaWZpbmFnaCBUZm5nIFRpcmh1dGEgVGlyaCBVZ2FyaXRpYyBVZ2FyIFZhaSBWYWlpIFdhcmFuZ19DaXRpIFdhcmEgWWkgWWlpaSBaYW5hYmF6YXJfU3F1YXJlIFphbmJcIjtcbiAgdmFyIGVjbWExMFNjcmlwdFZhbHVlcyA9IGVjbWE5U2NyaXB0VmFsdWVzICsgXCIgRG9ncmEgRG9nciBHdW5qYWxhX0dvbmRpIEdvbmcgSGFuaWZpX1JvaGluZ3lhIFJvaGcgTWFrYXNhciBNYWthIE1lZGVmYWlkcmluIE1lZGYgT2xkX1NvZ2RpYW4gU29nbyBTb2dkaWFuIFNvZ2RcIjtcbiAgdmFyIGVjbWExMVNjcmlwdFZhbHVlcyA9IGVjbWExMFNjcmlwdFZhbHVlcyArIFwiIEVseW1haWMgRWx5bSBOYW5kaW5hZ2FyaSBOYW5kIE55aWFrZW5nX1B1YWNodWVfSG1vbmcgSG1ucCBXYW5jaG8gV2Nob1wiO1xuICB2YXIgdW5pY29kZVNjcmlwdFZhbHVlcyA9IHtcbiAgICA5OiBlY21hOVNjcmlwdFZhbHVlcyxcbiAgICAxMDogZWNtYTEwU2NyaXB0VmFsdWVzLFxuICAgIDExOiBlY21hMTFTY3JpcHRWYWx1ZXNcbiAgfTtcblxuICB2YXIgZGF0YSA9IHt9O1xuICBmdW5jdGlvbiBidWlsZFVuaWNvZGVEYXRhKGVjbWFWZXJzaW9uKSB7XG4gICAgdmFyIGQgPSBkYXRhW2VjbWFWZXJzaW9uXSA9IHtcbiAgICAgIGJpbmFyeTogd29yZHNSZWdleHAodW5pY29kZUJpbmFyeVByb3BlcnRpZXNbZWNtYVZlcnNpb25dICsgXCIgXCIgKyB1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzKSxcbiAgICAgIG5vbkJpbmFyeToge1xuICAgICAgICBHZW5lcmFsX0NhdGVnb3J5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzKSxcbiAgICAgICAgU2NyaXB0OiB3b3Jkc1JlZ2V4cCh1bmljb2RlU2NyaXB0VmFsdWVzW2VjbWFWZXJzaW9uXSlcbiAgICAgIH1cbiAgICB9O1xuICAgIGQubm9uQmluYXJ5LlNjcmlwdF9FeHRlbnNpb25zID0gZC5ub25CaW5hcnkuU2NyaXB0O1xuXG4gICAgZC5ub25CaW5hcnkuZ2MgPSBkLm5vbkJpbmFyeS5HZW5lcmFsX0NhdGVnb3J5O1xuICAgIGQubm9uQmluYXJ5LnNjID0gZC5ub25CaW5hcnkuU2NyaXB0O1xuICAgIGQubm9uQmluYXJ5LnNjeCA9IGQubm9uQmluYXJ5LlNjcmlwdF9FeHRlbnNpb25zO1xuICB9XG4gIGJ1aWxkVW5pY29kZURhdGEoOSk7XG4gIGJ1aWxkVW5pY29kZURhdGEoMTApO1xuICBidWlsZFVuaWNvZGVEYXRhKDExKTtcblxuICB2YXIgcHAkOCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgdmFyIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZSA9IGZ1bmN0aW9uIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZShwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLnZhbGlkRmxhZ3MgPSBcImdpbVwiICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyBcInV5XCIgOiBcIlwiKSArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ID8gXCJzXCIgOiBcIlwiKTtcbiAgICB0aGlzLnVuaWNvZGVQcm9wZXJ0aWVzID0gZGF0YVtwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSA/IDExIDogcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb25dO1xuICAgIHRoaXMuc291cmNlID0gXCJcIjtcbiAgICB0aGlzLmZsYWdzID0gXCJcIjtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnN3aXRjaFUgPSBmYWxzZTtcbiAgICB0aGlzLnN3aXRjaE4gPSBmYWxzZTtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHRoaXMubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICB0aGlzLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgICB0aGlzLm1heEJhY2tSZWZlcmVuY2UgPSAwO1xuICAgIHRoaXMuZ3JvdXBOYW1lcyA9IFtdO1xuICAgIHRoaXMuYmFja1JlZmVyZW5jZU5hbWVzID0gW107XG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0IChzdGFydCwgcGF0dGVybiwgZmxhZ3MpIHtcbiAgICB2YXIgdW5pY29kZSA9IGZsYWdzLmluZGV4T2YoXCJ1XCIpICE9PSAtMTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQgfCAwO1xuICAgIHRoaXMuc291cmNlID0gcGF0dGVybiArIFwiXCI7XG4gICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIHRoaXMuc3dpdGNoVSA9IHVuaWNvZGUgJiYgdGhpcy5wYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICAgIHRoaXMuc3dpdGNoTiA9IHVuaWNvZGUgJiYgdGhpcy5wYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5O1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmFpc2UgPSBmdW5jdGlvbiByYWlzZSAobWVzc2FnZSkge1xuICAgIHRoaXMucGFyc2VyLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgKFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC9cIiArICh0aGlzLnNvdXJjZSkgKyBcIi86IFwiICsgbWVzc2FnZSkpO1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCAoaSkge1xuICAgIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICBpZiAoaSA+PSBsKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKCF0aGlzLnN3aXRjaFUgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCkge1xuICAgICAgcmV0dXJuIGNcbiAgICB9XG4gICAgdmFyIG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgIHJldHVybiBuZXh0ID49IDB4REMwMCAmJiBuZXh0IDw9IDB4REZGRiA/IChjIDw8IDEwKSArIG5leHQgLSAweDM1RkRDMDAgOiBjXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5uZXh0SW5kZXggPSBmdW5jdGlvbiBuZXh0SW5kZXggKGkpIHtcbiAgICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgaWYgKGkgPj0gbCkge1xuICAgICAgcmV0dXJuIGxcbiAgICB9XG4gICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSksIG5leHQ7XG4gICAgaWYgKCF0aGlzLnN3aXRjaFUgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCB8fFxuICAgICAgICAobmV4dCA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhEQzAwIHx8IG5leHQgPiAweERGRkYpIHtcbiAgICAgIHJldHVybiBpICsgMVxuICAgIH1cbiAgICByZXR1cm4gaSArIDJcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5hdCh0aGlzLnBvcylcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmxvb2thaGVhZCA9IGZ1bmN0aW9uIGxvb2thaGVhZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXQodGhpcy5uZXh0SW5kZXgodGhpcy5wb3MpKVxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uIGFkdmFuY2UgKCkge1xuICAgIHRoaXMucG9zID0gdGhpcy5uZXh0SW5kZXgodGhpcy5wb3MpO1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuZWF0ID0gZnVuY3Rpb24gZWF0IChjaCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQoKSA9PT0gY2gpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmcoY2gpIHtcbiAgICBpZiAoY2ggPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSB9XG4gICAgY2ggLT0gMHgxMDAwMDtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY2ggPj4gMTApICsgMHhEODAwLCAoY2ggJiAweDAzRkYpICsgMHhEQzAwKVxuICB9XG5cbiAgcHAkOC52YWxpZGF0ZVJlZ0V4cEZsYWdzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgdmFsaWRGbGFncyA9IHN0YXRlLnZhbGlkRmxhZ3M7XG4gICAgdmFyIGZsYWdzID0gc3RhdGUuZmxhZ3M7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZsYWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZmxhZyA9IGZsYWdzLmNoYXJBdChpKTtcbiAgICAgIGlmICh2YWxpZEZsYWdzLmluZGV4T2YoZmxhZykgPT09IC0xKSB7XG4gICAgICAgIHRoaXMucmFpc2Uoc3RhdGUuc3RhcnQsIFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChmbGFncy5pbmRleE9mKGZsYWcsIGkgKyAxKSA+IC0xKSB7XG4gICAgICAgIHRoaXMucmFpc2Uoc3RhdGUuc3RhcnQsIFwiRHVwbGljYXRlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwcCQ4LnZhbGlkYXRlUmVnRXhwUGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG5cbiAgICBpZiAoIXN0YXRlLnN3aXRjaE4gJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgc3RhdGUuZ3JvdXBOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICBzdGF0ZS5zd2l0Y2hOID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVnZXhwX3BhdHRlcm4oc3RhdGUpO1xuICAgIH1cbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9wYXR0ZXJuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzdGF0ZS5wb3MgPSAwO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgICBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMgPSAwO1xuICAgIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSAwO1xuICAgIHN0YXRlLmdyb3VwTmFtZXMubGVuZ3RoID0gMDtcbiAgICBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXMubGVuZ3RoID0gMDtcblxuICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZS5wb3MgIT09IHN0YXRlLnNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyOSApKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiVW5tYXRjaGVkICcpJ1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg1RCApIHx8IHN0YXRlLmVhdCgweDdEICkpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID4gc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBuYW1lID0gbGlzdFtpXTtcblxuICAgICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIG5hbWVkIGNhcHR1cmUgcmVmZXJlbmNlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZGlzanVuY3Rpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgICB3aGlsZSAoc3RhdGUuZWF0KDB4N0MgKSkge1xuICAgICAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmVhdCgweDdCICkpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICAgIH1cbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9hbHRlcm5hdGl2ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgd2hpbGUgKHN0YXRlLnBvcyA8IHN0YXRlLnNvdXJjZS5sZW5ndGggJiYgdGhpcy5yZWdleHBfZWF0VGVybShzdGF0ZSkpXG4gICAgICB7IH1cbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRUZXJtID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0QXNzZXJ0aW9uKHN0YXRlKSkge1xuICAgICAgaWYgKHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSAmJiB0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlKSkge1xuICAgICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBxdWFudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVID8gdGhpcy5yZWdleHBfZWF0QXRvbShzdGF0ZSkgOiB0aGlzLnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20oc3RhdGUpKSB7XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0QXNzZXJ0aW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUUgKSB8fCBzdGF0ZS5lYXQoMHgyNCApKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyApKSB7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4NDIgKSB8fCBzdGF0ZS5lYXQoMHg2MiApKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4MjggKSAmJiBzdGF0ZS5lYXQoMHgzRiApKSB7XG4gICAgICB2YXIgbG9va2JlaGluZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgIGxvb2tiZWhpbmQgPSBzdGF0ZS5lYXQoMHgzQyApO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDNEICkgfHwgc3RhdGUuZWF0KDB4MjEgKSkge1xuICAgICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICAgIGlmICghc3RhdGUuZWF0KDB4MjkgKSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9ICFsb29rYmVoaW5kO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICAgIGlmICggbm9FcnJvciA9PT0gdm9pZCAwICkgbm9FcnJvciA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXgoc3RhdGUsIG5vRXJyb3IpKSB7XG4gICAgICBzdGF0ZS5lYXQoMHgzRiApO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0UXVhbnRpZmllclByZWZpeCA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHN0YXRlLmVhdCgweDJBICkgfHxcbiAgICAgIHN0YXRlLmVhdCgweDJCICkgfHxcbiAgICAgIHN0YXRlLmVhdCgweDNGICkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoc3RhdGUsIG5vRXJyb3IpXG4gICAgKVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDdCICkpIHtcbiAgICAgIHZhciBtaW4gPSAwLCBtYXggPSAtMTtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgICBtaW4gPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIGlmIChzdGF0ZS5lYXQoMHgyQyApICYmIHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICAgICAgbWF4ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5lYXQoMHg3RCApKSB7XG4gICAgICAgICAgaWYgKG1heCAhPT0gLTEgJiYgbWF4IDwgbWluICYmICFub0Vycm9yKSB7XG4gICAgICAgICAgICBzdGF0ZS5yYWlzZShcIm51bWJlcnMgb3V0IG9mIG9yZGVyIGluIHt9IHF1YW50aWZpZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmICFub0Vycm9yKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW5jb21wbGV0ZSBxdWFudGlmaWVyXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyhzdGF0ZSkgfHxcbiAgICAgIHN0YXRlLmVhdCgweDJFICkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKVxuICAgIClcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDVDICkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRBdG9tRXNjYXBlKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI4ICkpIHtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgzRiApICYmIHN0YXRlLmVhdCgweDNBICkpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4MjggKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgIHRoaXMucmVnZXhwX2dyb3VwU3BlY2lmaWVyKHN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDNGICkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgKSkge1xuICAgICAgICBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMgKz0gMTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBzdGF0ZS5lYXQoMHgyRSApIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyKHN0YXRlKVxuICAgIClcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIk5vdGhpbmcgdG8gcmVwZWF0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1N5bnRheENoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHgyNCAgfHxcbiAgICAgIGNoID49IDB4MjggICYmIGNoIDw9IDB4MkIgIHx8XG4gICAgICBjaCA9PT0gMHgyRSAgfHxcbiAgICAgIGNoID09PSAweDNGICB8fFxuICAgICAgY2ggPj0gMHg1QiAgJiYgY2ggPD0gMHg1RSAgfHxcbiAgICAgIGNoID49IDB4N0IgICYmIGNoIDw9IDB4N0QgXG4gICAgKVxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgY2ggPSAwO1xuICAgIHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpICE9PSAtMSAmJiAhaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKFxuICAgICAgY2ggIT09IC0xICYmXG4gICAgICBjaCAhPT0gMHgyNCAgJiZcbiAgICAgICEoY2ggPj0gMHgyOCAgJiYgY2ggPD0gMHgyQiApICYmXG4gICAgICBjaCAhPT0gMHgyRSAgJiZcbiAgICAgIGNoICE9PSAweDNGICAmJlxuICAgICAgY2ggIT09IDB4NUIgICYmXG4gICAgICBjaCAhPT0gMHg1RSAgJiZcbiAgICAgIGNoICE9PSAweDdDIFxuICAgICkge1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZ3JvdXBTcGVjaWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHgzRiApKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkge1xuICAgICAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJEdXBsaWNhdGUgY2FwdHVyZSBncm91cCBuYW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmdyb3VwTmFtZXMucHVzaChzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0R3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgzQyApKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNFICkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQoc3RhdGUpKSB7XG4gICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICAgIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydChzdGF0ZSkpIHtcbiAgICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuXG4gICAgaWYgKGNoID09PSAweDVDICAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB7XG4gICAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkge1xuICAgIHJldHVybiBpc0lkZW50aWZpZXJTdGFydChjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgIHx8IGNoID09PSAweDVGIFxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuXG4gICAgaWYgKGNoID09PSAweDVDICAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB7XG4gICAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgICByZXR1cm4gaXNJZGVudGlmaWVyQ2hhcihjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgIHx8IGNoID09PSAweDVGICB8fCBjaCA9PT0gMHgyMDBDICB8fCBjaCA9PT0gMHgyMDBEIFxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0QXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWdleHBfZWF0QmFja1JlZmVyZW5jZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgKHN0YXRlLnN3aXRjaE4gJiYgdGhpcy5yZWdleHBfZWF0S0dyb3VwTmFtZShzdGF0ZSkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHg2MyApIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdEJhY2tSZWZlcmVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZShzdGF0ZSkpIHtcbiAgICAgIHZhciBuID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgaWYgKG4gPiBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlKSB7XG4gICAgICAgICAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChuIDw9IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRLR3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NkIgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgICAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCByZWZlcmVuY2VcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDQ29udHJvbExldHRlcihzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFplcm8oc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSkgfHxcbiAgICAgICghc3RhdGUuc3dpdGNoVSAmJiB0aGlzLnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlKHN0YXRlKSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdElkZW50aXR5RXNjYXBlKHN0YXRlKVxuICAgIClcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4NjMgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdFplcm8gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4MzAgICYmICFpc0RlY2ltYWxEaWdpdChzdGF0ZS5sb29rYWhlYWQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoID09PSAweDc0ICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwOTsgXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NkUgKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBBOyBcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg3NiApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEI7IFxuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDY2ICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQzsgXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NzIgKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBEOyBcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNDb250cm9sTGV0dGVyKGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggJSAweDIwO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzQ29udHJvbExldHRlcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICAoY2ggPj0gMHg0MSAgJiYgY2ggPD0gMHg1QSApIHx8XG4gICAgICAoY2ggPj0gMHg2MSAgJiYgY2ggPD0gMHg3QSApXG4gICAgKVxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NzUgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgICB2YXIgbGVhZCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgbGVhZCA+PSAweEQ4MDAgJiYgbGVhZCA8PSAweERCRkYpIHtcbiAgICAgICAgICB2YXIgbGVhZFN1cnJvZ2F0ZUVuZCA9IHN0YXRlLnBvcztcbiAgICAgICAgICBpZiAoc3RhdGUuZWF0KDB4NUMgKSAmJiBzdGF0ZS5lYXQoMHg3NSApICYmIHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgICAgICAgdmFyIHRyYWlsID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICAgICAgaWYgKHRyYWlsID49IDB4REMwMCAmJiB0cmFpbCA8PSAweERGRkYpIHtcbiAgICAgICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gKGxlYWQgLSAweEQ4MDApICogMHg0MDAgKyAodHJhaWwgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUucG9zID0gbGVhZFN1cnJvZ2F0ZUVuZDtcbiAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBsZWFkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXRlLnN3aXRjaFUgJiZcbiAgICAgICAgc3RhdGUuZWF0KDB4N0IgKSAmJlxuICAgICAgICB0aGlzLnJlZ2V4cF9lYXRIZXhEaWdpdHMoc3RhdGUpICYmXG4gICAgICAgIHN0YXRlLmVhdCgweDdEICkgJiZcbiAgICAgICAgaXNWYWxpZFVuaWNvZGUoc3RhdGUubGFzdEludFZhbHVlKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNWYWxpZFVuaWNvZGUoY2gpIHtcbiAgICByZXR1cm4gY2ggPj0gMCAmJiBjaCA8PSAweDEwRkZGRlxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDJGICkpIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRjsgXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoICE9PSAweDYzICAmJiAoIXN0YXRlLnN3aXRjaE4gfHwgY2ggIT09IDB4NkIgKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCA+PSAweDMxICAmJiBjaCA8PSAweDM5ICkge1xuICAgICAgZG8ge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgKTtcbiAgICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgfSB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSA+PSAweDMwICAmJiBjaCA8PSAweDM5IClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG5cbiAgICBpZiAoaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBzdGF0ZS5zd2l0Y2hVICYmXG4gICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJlxuICAgICAgKGNoID09PSAweDUwICB8fCBjaCA9PT0gMHg3MCApXG4gICAgKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIGlmIChcbiAgICAgICAgc3RhdGUuZWF0KDB4N0IgKSAmJlxuICAgICAgICB0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24oc3RhdGUpICYmXG4gICAgICAgIHN0YXRlLmVhdCgweDdEIClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2ggPT09IDB4NjQgIHx8XG4gICAgICBjaCA9PT0gMHg0NCAgfHxcbiAgICAgIGNoID09PSAweDczICB8fFxuICAgICAgY2ggPT09IDB4NTMgIHx8XG4gICAgICBjaCA9PT0gMHg3NyAgfHxcbiAgICAgIGNoID09PSAweDU3IFxuICAgIClcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNEICkpIHtcbiAgICAgIHZhciBuYW1lID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICAgIHRoaXMucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlKHN0YXRlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSkpIHtcbiAgICAgIHZhciBuYW1lT3JWYWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgIHRoaXMucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUsIG5hbWVPclZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaGFzKHN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeSwgbmFtZSkpXG4gICAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpOyB9XG4gICAgaWYgKCFzdGF0ZS51bmljb2RlUHJvcGVydGllcy5ub25CaW5hcnlbbmFtZV0udGVzdCh2YWx1ZSkpXG4gICAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSB2YWx1ZVwiKTsgfVxuICB9O1xuICBwcCQ4LnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWVPclZhbHVlKSB7XG4gICAgaWYgKCFzdGF0ZS51bmljb2RlUHJvcGVydGllcy5iaW5hcnkudGVzdChuYW1lT3JWYWx1ZSkpXG4gICAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpOyB9XG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG4gIH07XG4gIGZ1bmN0aW9uIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHx8IGNoID09PSAweDVGIFxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbiAgfTtcbiAgZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHx8IGlzRGVjaW1hbERpZ2l0KGNoKVxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1QiApKSB7XG4gICAgICBzdGF0ZS5lYXQoMHg1RSApO1xuICAgICAgdGhpcy5yZWdleHBfY2xhc3NSYW5nZXMoc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDVEICkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfY2xhc3NSYW5nZXMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgICB2YXIgbGVmdCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyRCApICYmIHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAobGVmdCA9PT0gLTEgfHwgcmlnaHQgPT09IC0xKSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQgIT09IC0xICYmIHJpZ2h0ICE9PSAtMSAmJiBsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIlJhbmdlIG91dCBvZiBvcmRlciBpbiBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q2xhc3NBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzRXNjYXBlKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgdmFyIGNoJDEgPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgICAgIGlmIChjaCQxID09PSAweDYzICB8fCBpc09jdGFsRGlnaXQoY2gkMSkpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2xhc3MgZXNjYXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG5cbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoICE9PSAweDVEICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdENsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NjIgKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwODsgXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDJEICkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MkQ7IFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4NjMgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSlcbiAgICApXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSB8fCBjaCA9PT0gMHg1RiApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDc4ICkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgMikpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbiAgfTtcbiAgZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgICByZXR1cm4gY2ggPj0gMHgzMCAgJiYgY2ggPD0gMHgzOSBcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICB3aGlsZSAoaXNIZXhEaWdpdChjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxuICB9O1xuICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChjaCA+PSAweDMwICAmJiBjaCA8PSAweDM5ICkgfHxcbiAgICAgIChjaCA+PSAweDQxICAmJiBjaCA8PSAweDQ2ICkgfHxcbiAgICAgIChjaCA+PSAweDYxICAmJiBjaCA8PSAweDY2IClcbiAgICApXG4gIH1cbiAgZnVuY3Rpb24gaGV4VG9JbnQoY2gpIHtcbiAgICBpZiAoY2ggPj0gMHg0MSAgJiYgY2ggPD0gMHg0NiApIHtcbiAgICAgIHJldHVybiAxMCArIChjaCAtIDB4NDEgKVxuICAgIH1cbiAgICBpZiAoY2ggPj0gMHg2MSAgJiYgY2ggPD0gMHg2NiApIHtcbiAgICAgIHJldHVybiAxMCArIChjaCAtIDB4NjEgKVxuICAgIH1cbiAgICByZXR1cm4gY2ggLSAweDMwIFxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICB2YXIgbjEgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgICAgdmFyIG4yID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAobjEgPD0gMyAmJiB0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogNjQgKyBuMiAqIDggKyBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjEgKiA4ICsgbjI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0T2N0YWxEaWdpdCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAtIDB4MzA7IFxuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDB4MzAgICYmIGNoIDw9IDB4MzcgXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlLCBsZW5ndGgpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG5cbiAgdmFyIFRva2VuID0gZnVuY3Rpb24gVG9rZW4ocCkge1xuICAgIHRoaXMudHlwZSA9IHAudHlwZTtcbiAgICB0aGlzLnZhbHVlID0gcC52YWx1ZTtcbiAgICB0aGlzLnN0YXJ0ID0gcC5zdGFydDtcbiAgICB0aGlzLmVuZCA9IHAuZW5kO1xuICAgIGlmIChwLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwLCBwLnN0YXJ0TG9jLCBwLmVuZExvYyk7IH1cbiAgICBpZiAocC5vcHRpb25zLnJhbmdlcylcbiAgICAgIHsgdGhpcy5yYW5nZSA9IFtwLnN0YXJ0LCBwLmVuZF07IH1cbiAgfTtcblxuXG4gIHZhciBwcCQ5ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuXG4gIHBwJDkubmV4dCA9IGZ1bmN0aW9uKGlnbm9yZUVzY2FwZVNlcXVlbmNlSW5LZXl3b3JkKSB7XG4gICAgaWYgKCFpZ25vcmVFc2NhcGVTZXF1ZW5jZUluS2V5d29yZCAmJiB0aGlzLnR5cGUua2V5d29yZCAmJiB0aGlzLmNvbnRhaW5zRXNjKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBcIiArIHRoaXMudHlwZS5rZXl3b3JkKTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Ub2tlbilcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uVG9rZW4obmV3IFRva2VuKHRoaXMpKTsgfVxuXG4gICAgdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5lbmQ7XG4gICAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMuZW5kTG9jO1xuICAgIHRoaXMubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICB9O1xuXG4gIHBwJDkuZ2V0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gbmV3IFRva2VuKHRoaXMpXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgeyBwcCQ5W1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRva2VuID0gdGhpcyQxLmdldFRva2VuKCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRva2VuLnR5cGUgPT09IHR5cGVzLmVvZixcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07IH1cblxuXG4gIHBwJDkuY3VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdXG4gIH07XG5cblxuICBwcCQ5Lm5leHRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHsgdGhpcy5za2lwU3BhY2UoKTsgfVxuXG4gICAgdGhpcy5zdGFydCA9IHRoaXMucG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuc3RhcnRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZW9mKSB9XG5cbiAgICBpZiAoY3VyQ29udGV4dC5vdmVycmlkZSkgeyByZXR1cm4gY3VyQ29udGV4dC5vdmVycmlkZSh0aGlzKSB9XG4gICAgZWxzZSB7IHRoaXMucmVhZFRva2VuKHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSk7IH1cbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbiA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHx8IGNvZGUgPT09IDkyIClcbiAgICAgIHsgcmV0dXJuIHRoaXMucmVhZFdvcmQoKSB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbkZyb21Db2RlKGNvZGUpXG4gIH07XG5cbiAgcHAkOS5mdWxsQ2hhckNvZGVBdFBvcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGUwMDApIHsgcmV0dXJuIGNvZGUgfVxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgcmV0dXJuIChjb2RlIDw8IDEwKSArIG5leHQgLSAweDM1ZmRjMDBcbiAgfTtcblxuICBwcCQ5LnNraXBCbG9ja0NvbW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5wb3MgKz0gMik7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcyAtIDIsIFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIik7IH1cbiAgICB0aGlzLnBvcyA9IGVuZCArIDI7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICB3aGlsZSAoKG1hdGNoID0gbGluZUJyZWFrRy5leGVjKHRoaXMuaW5wdXQpKSAmJiBtYXRjaC5pbmRleCA8IHRoaXMucG9zKSB7XG4gICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudCh0cnVlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSwgc3RhcnQsIHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTsgfVxuICB9O1xuXG4gIHBwJDkuc2tpcExpbmVDb21tZW50ID0gZnVuY3Rpb24oc3RhcnRTa2lwKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICs9IHN0YXJ0U2tpcCk7XG4gICAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGggJiYgIWlzTmV3TGluZShjaCkpIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudChmYWxzZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIHN0YXJ0U2tpcCwgdGhpcy5wb3MpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG4gIH07XG5cblxuICBwcCQ5LnNraXBTcGFjZSA9IGZ1bmN0aW9uKCkge1xuICAgIGxvb3A6IHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgY2FzZSAzMjogY2FzZSAxNjA6IFxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpID09PSAxMCkge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTA6IGNhc2UgODIzMjogY2FzZSA4MjMzOlxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNDc6IFxuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpKSB7XG4gICAgICAgIGNhc2UgNDI6IFxuICAgICAgICAgIHRoaXMuc2tpcEJsb2NrQ29tbWVudCgpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjaCA+IDggJiYgY2ggPCAxNCB8fCBjaCA+PSA1NzYwICYmIG5vbkFTQ0lJd2hpdGVzcGFjZS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSkge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgcHAkOS5maW5pc2hUb2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHZhbCkge1xuICAgIHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgICB2YXIgcHJldlR5cGUgPSB0aGlzLnR5cGU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gICAgdGhpcy51cGRhdGVDb250ZXh0KHByZXZUeXBlKTtcbiAgfTtcblxuXG4gIHBwJDkucmVhZFRva2VuX2RvdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgeyByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKHRydWUpIH1cbiAgICB2YXIgbmV4dDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbmV4dCA9PT0gNDYgJiYgbmV4dDIgPT09IDQ2KSB7IFxuICAgICAgdGhpcy5wb3MgKz0gMztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmVsbGlwc2lzKVxuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG90KVxuICAgIH1cbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9zbGFzaCA9IGZ1bmN0aW9uKCkgeyBcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmICh0aGlzLmV4cHJBbGxvd2VkKSB7ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLnJlYWRSZWdleHAoKSB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnNsYXNoLCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cCA9IGZ1bmN0aW9uKGNvZGUpIHsgXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICB2YXIgc2l6ZSA9IDE7XG4gICAgdmFyIHRva2VudHlwZSA9IGNvZGUgPT09IDQyID8gdHlwZXMuc3RhciA6IHR5cGVzLm1vZHVsbztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiBjb2RlID09PSA0MiAmJiBuZXh0ID09PSA0Mikge1xuICAgICAgKytzaXplO1xuICAgICAgdG9rZW50eXBlID0gdHlwZXMuc3RhcnN0YXI7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0b2tlbnR5cGUsIHNpemUpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fcGlwZV9hbXAgPSBmdW5jdGlvbihjb2RlKSB7IFxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMubG9naWNhbE9SIDogdHlwZXMubG9naWNhbEFORCwgMikgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcy5iaXR3aXNlT1IgOiB0eXBlcy5iaXR3aXNlQU5ELCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX2NhcmV0ID0gZnVuY3Rpb24oKSB7IFxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdHdpc2VYT1IsIDEpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fcGx1c19taW4gPSBmdW5jdGlvbihjb2RlKSB7IFxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIGlmIChuZXh0ID09PSA0NSAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgJiZcbiAgICAgICAgICAodGhpcy5sYXN0VG9rRW5kID09PSAwIHx8IGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnBvcykpKSkge1xuICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgzKTtcbiAgICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmluY0RlYywgMilcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnBsdXNNaW4sIDEpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fbHRfZ3QgPSBmdW5jdGlvbihjb2RlKSB7IFxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgdmFyIHNpemUgPSAxO1xuICAgIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgICBzaXplID0gY29kZSA9PT0gNjIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyID8gMyA6IDI7XG4gICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgc2l6ZSkgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdFNoaWZ0LCBzaXplKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gMzMgJiYgY29kZSA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDQ1ICYmXG4gICAgICAgIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDMpID09PSA0NSkge1xuICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHNpemUgPSAyOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucmVsYXRpb25hbCwgc2l6ZSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9lcV9leGNsID0gZnVuY3Rpb24oY29kZSkgeyBcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5lcXVhbGl0eSwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYxID8gMyA6IDIpIH1cbiAgICBpZiAoY29kZSA9PT0gNjEgJiYgbmV4dCA9PT0gNjIgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgXG4gICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYXJyb3cpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYxID8gdHlwZXMuZXEgOiB0eXBlcy5wcmVmaXgsIDEpXG4gIH07XG5cbiAgcHAkOS5nZXRUb2tlbkZyb21Db2RlID0gZnVuY3Rpb24oY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgIGNhc2UgNDY6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2RvdCgpXG5cbiAgICBjYXNlIDQwOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5wYXJlbkwpXG4gICAgY2FzZSA0MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5SKVxuICAgIGNhc2UgNTk6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnNlbWkpXG4gICAgY2FzZSA0NDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29tbWEpXG4gICAgY2FzZSA5MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldEwpXG4gICAgY2FzZSA5MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldFIpXG4gICAgY2FzZSAxMjM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNlTClcbiAgICBjYXNlIDEyNTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VSKVxuICAgIGNhc2UgNTg6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmNvbG9uKVxuICAgIGNhc2UgNjM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnF1ZXN0aW9uKVxuXG4gICAgY2FzZSA5NjogXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyBicmVhayB9XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYmFja1F1b3RlKVxuXG4gICAgY2FzZSA0ODogXG4gICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpIH0gXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgaWYgKG5leHQgPT09IDExMSB8fCBuZXh0ID09PSA3OSkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoOCkgfSBcbiAgICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigyKSB9IFxuICAgICAgfVxuXG4gICAgY2FzZSA0OTogY2FzZSA1MDogY2FzZSA1MTogY2FzZSA1MjogY2FzZSA1MzogY2FzZSA1NDogY2FzZSA1NTogY2FzZSA1NjogY2FzZSA1NzogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKGZhbHNlKVxuXG4gICAgY2FzZSAzNDogY2FzZSAzOTogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkU3RyaW5nKGNvZGUpXG5cblxuICAgIGNhc2UgNDc6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3NsYXNoKClcblxuICAgIGNhc2UgMzc6IGNhc2UgNDI6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cChjb2RlKVxuXG4gICAgY2FzZSAxMjQ6IGNhc2UgMzg6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpXG5cbiAgICBjYXNlIDk0OiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9jYXJldCgpXG5cbiAgICBjYXNlIDQzOiBjYXNlIDQ1OiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKVxuXG4gICAgY2FzZSA2MDogY2FzZSA2MjogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbHRfZ3QoY29kZSlcblxuICAgIGNhc2UgNjE6IGNhc2UgMzM6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSlcblxuICAgIGNhc2UgMTI2OiBcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnByZWZpeCwgMSlcbiAgICB9XG5cbiAgICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nJDEoY29kZSkgKyBcIidcIik7XG4gIH07XG5cbiAgcHAkOS5maW5pc2hPcCA9IGZ1bmN0aW9uKHR5cGUsIHNpemUpIHtcbiAgICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgKyBzaXplKTtcbiAgICB0aGlzLnBvcyArPSBzaXplO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHN0cilcbiAgfTtcblxuICBwcCQ5LnJlYWRSZWdleHAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXNjYXBlZCwgaW5DbGFzcywgc3RhcnQgPSB0aGlzLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAobGluZUJyZWFrLnRlc3QoY2gpKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICAgIGlmIChjaCA9PT0gXCJbXCIpIHsgaW5DbGFzcyA9IHRydWU7IH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIHsgaW5DbGFzcyA9IGZhbHNlOyB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSBcIi9cIiAmJiAhaW5DbGFzcykgeyBicmVhayB9XG4gICAgICAgIGVzY2FwZWQgPSBjaCA9PT0gXCJcXFxcXCI7XG4gICAgICB9IGVsc2UgeyBlc2NhcGVkID0gZmFsc2U7IH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfVxuICAgIHZhciBwYXR0ZXJuID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICAgICsrdGhpcy5wb3M7XG4gICAgdmFyIGZsYWdzU3RhcnQgPSB0aGlzLnBvcztcbiAgICB2YXIgZmxhZ3MgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICAgIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMudW5leHBlY3RlZChmbGFnc1N0YXJ0KTsgfVxuXG4gICAgdmFyIHN0YXRlID0gdGhpcy5yZWdleHBTdGF0ZSB8fCAodGhpcy5yZWdleHBTdGF0ZSA9IG5ldyBSZWdFeHBWYWxpZGF0aW9uU3RhdGUodGhpcykpO1xuICAgIHN0YXRlLnJlc2V0KHN0YXJ0LCBwYXR0ZXJuLCBmbGFncyk7XG4gICAgdGhpcy52YWxpZGF0ZVJlZ0V4cEZsYWdzKHN0YXRlKTtcbiAgICB0aGlzLnZhbGlkYXRlUmVnRXhwUGF0dGVybihzdGF0ZSk7XG5cbiAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5yZWdleHAsIHtwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MsIHZhbHVlOiB2YWx1ZX0pXG4gIH07XG5cblxuICBwcCQ5LnJlYWRJbnQgPSBmdW5jdGlvbihyYWRpeCwgbGVuKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIHRvdGFsID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgZSA9IGxlbiA9PSBudWxsID8gSW5maW5pdHkgOiBsZW47IGkgPCBlOyArK2kpIHtcbiAgICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgdmFsID0gKHZvaWQgMCk7XG4gICAgICBpZiAoY29kZSA+PSA5NykgeyB2YWwgPSBjb2RlIC0gOTcgKyAxMDsgfSBcbiAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNjUpIHsgdmFsID0gY29kZSAtIDY1ICsgMTA7IH0gXG4gICAgICBlbHNlIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHsgdmFsID0gY29kZSAtIDQ4OyB9IFxuICAgICAgZWxzZSB7IHZhbCA9IEluZmluaXR5OyB9XG4gICAgICBpZiAodmFsID49IHJhZGl4KSB7IGJyZWFrIH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG4gICAgfVxuICAgIGlmICh0aGlzLnBvcyA9PT0gc3RhcnQgfHwgbGVuICE9IG51bGwgJiYgdGhpcy5wb3MgLSBzdGFydCAhPT0gbGVuKSB7IHJldHVybiBudWxsIH1cblxuICAgIHJldHVybiB0b3RhbFxuICB9O1xuXG4gIHBwJDkucmVhZFJhZGl4TnVtYmVyID0gZnVuY3Rpb24ocmFkaXgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB0aGlzLnBvcyArPSAyOyBcbiAgICB2YXIgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KTtcbiAgICBpZiAodmFsID09IG51bGwpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0ICsgMiwgXCJFeHBlY3RlZCBudW1iZXIgaW4gcmFkaXggXCIgKyByYWRpeCk7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDExMCkge1xuICAgICAgdmFsID0gdHlwZW9mIEJpZ0ludCAhPT0gXCJ1bmRlZmluZWRcIiA/IEJpZ0ludCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpIDogbnVsbDtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbClcbiAgfTtcblxuXG4gIHBwJDkucmVhZE51bWJlciA9IGZ1bmN0aW9uKHN0YXJ0c1dpdGhEb3QpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gICAgdmFyIG9jdGFsID0gdGhpcy5wb3MgLSBzdGFydCA+PSAyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChzdGFydCkgPT09IDQ4O1xuICAgIGlmIChvY3RhbCAmJiB0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmICghb2N0YWwgJiYgIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIG5leHQgPT09IDExMCkge1xuICAgICAgdmFyIHN0ciQxID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICAgICAgdmFyIHZhbCQxID0gdHlwZW9mIEJpZ0ludCAhPT0gXCJ1bmRlZmluZWRcIiA/IEJpZ0ludChzdHIkMSkgOiBudWxsO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsJDEpXG4gICAgfVxuICAgIGlmIChvY3RhbCAmJiAvWzg5XS8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpKSB7IG9jdGFsID0gZmFsc2U7IH1cbiAgICBpZiAobmV4dCA9PT0gNDYgJiYgIW9jdGFsKSB7IFxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICB9XG4gICAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkgeyBcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpIHsgKyt0aGlzLnBvczsgfSBcbiAgICAgIGlmICh0aGlzLnJlYWRJbnQoMTApID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgICB9XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuXG4gICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKTtcbiAgICB2YXIgdmFsID0gb2N0YWwgPyBwYXJzZUludChzdHIsIDgpIDogcGFyc2VGbG9hdChzdHIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsKVxuICB9O1xuXG5cbiAgcHAkOS5yZWFkQ29kZVBvaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgY29kZTtcblxuICAgIGlmIChjaCA9PT0gMTIzKSB7IFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHZhciBjb2RlUG9zID0gKyt0aGlzLnBvcztcbiAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKHRoaXMuaW5wdXQuaW5kZXhPZihcIn1cIiwgdGhpcy5wb3MpIC0gdGhpcy5wb3MpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHNcIik7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIoNCk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH07XG5cbiAgZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmckMShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIH1cbiAgICBjb2RlIC09IDB4MTAwMDA7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgPj4gMTApICsgMHhEODAwLCAoY29kZSAmIDEwMjMpICsgMHhEQzAwKVxuICB9XG5cbiAgcHAkOS5yZWFkU3RyaW5nID0gZnVuY3Rpb24ocXVvdGUpIHtcbiAgICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9ICsrdGhpcy5wb3M7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKGNoID09PSBxdW90ZSkgeyBicmVhayB9XG4gICAgICBpZiAoY2ggPT09IDkyKSB7IFxuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcihmYWxzZSk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc05ld0xpbmUoY2gsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMCkpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MrKyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc3RyaW5nLCBvdXQpXG4gIH07XG5cblxuICB2YXIgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IgPSB7fTtcblxuICBwcCQ5LnRyeVJlYWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVhZFRtcGxUb2tlbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciA9PT0gSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IpIHtcbiAgICAgICAgdGhpcy5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSBmYWxzZTtcbiAgfTtcblxuICBwcCQ5LmludmFsaWRTdHJpbmdUb2tlbiA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIHRocm93IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmFpc2UocG9zaXRpb24sIG1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcblxuICBwcCQ5LnJlYWRUbXBsVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpOyB9XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKGNoID09PSA5NiB8fCBjaCA9PT0gMzYgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEyMykgeyBcbiAgICAgICAgaWYgKHRoaXMucG9zID09PSB0aGlzLnN0YXJ0ICYmICh0aGlzLnR5cGUgPT09IHR5cGVzLnRlbXBsYXRlIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuaW52YWxpZFRlbXBsYXRlKSkge1xuICAgICAgICAgIGlmIChjaCA9PT0gMzYpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5kb2xsYXJCcmFjZUwpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMudGVtcGxhdGUsIG91dClcbiAgICAgIH1cbiAgICAgIGlmIChjaCA9PT0gOTIpIHsgXG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKHRydWUpO1xuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9IGVsc2UgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH1cbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBvdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwcCQ5LnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAoOyB0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoOyB0aGlzLnBvcysrKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuaW5wdXRbdGhpcy5wb3NdKSB7XG4gICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiJFwiOlxuICAgICAgICBpZiAodGhpcy5pbnB1dFt0aGlzLnBvcyArIDFdICE9PSBcIntcIikge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImBcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuaW52YWxpZFRlbXBsYXRlLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKSlcblxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpO1xuICB9O1xuXG5cbiAgcHAkOS5yZWFkRXNjYXBlZENoYXIgPSBmdW5jdGlvbihpblRlbXBsYXRlKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgICsrdGhpcy5wb3M7XG4gICAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMTEwOiByZXR1cm4gXCJcXG5cIiBcbiAgICBjYXNlIDExNDogcmV0dXJuIFwiXFxyXCIgXG4gICAgY2FzZSAxMjA6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEhleENoYXIoMikpIFxuICAgIGNhc2UgMTE3OiByZXR1cm4gY29kZVBvaW50VG9TdHJpbmckMSh0aGlzLnJlYWRDb2RlUG9pbnQoKSkgXG4gICAgY2FzZSAxMTY6IHJldHVybiBcIlxcdFwiIFxuICAgIGNhc2UgOTg6IHJldHVybiBcIlxcYlwiIFxuICAgIGNhc2UgMTE4OiByZXR1cm4gXCJcXHUwMDBiXCIgXG4gICAgY2FzZSAxMDI6IHJldHVybiBcIlxcZlwiIFxuICAgIGNhc2UgMTM6IGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9IFxuICAgIGNhc2UgMTA6IFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvczsgKyt0aGlzLmN1ckxpbmU7IH1cbiAgICAgIHJldHVybiBcIlwiXG4gICAgY2FzZSA1NjpcbiAgICBjYXNlIDU3OlxuICAgICAgaWYgKGluVGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcyAtIDE7XG5cbiAgICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgICAgY29kZVBvcyxcbiAgICAgICAgICBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHRlbXBsYXRlIHN0cmluZ1wiXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNoID49IDQ4ICYmIGNoIDw9IDU1KSB7XG4gICAgICAgIHZhciBvY3RhbFN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zIC0gMSwgMykubWF0Y2goL15bMC03XSsvKVswXTtcbiAgICAgICAgdmFyIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICBpZiAob2N0YWwgPiAyNTUpIHtcbiAgICAgICAgICBvY3RhbFN0ciA9IG9jdGFsU3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBvY3RhbFN0ci5sZW5ndGggLSAxO1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICgob2N0YWxTdHIgIT09IFwiMFwiIHx8IGNoID09PSA1NiB8fCBjaCA9PT0gNTcpICYmICh0aGlzLnN0cmljdCB8fCBpblRlbXBsYXRlKSkge1xuICAgICAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICAgICAgdGhpcy5wb3MgLSAxIC0gb2N0YWxTdHIubGVuZ3RoLFxuICAgICAgICAgICAgaW5UZW1wbGF0ZVxuICAgICAgICAgICAgICA/IFwiT2N0YWwgbGl0ZXJhbCBpbiB0ZW1wbGF0ZSBzdHJpbmdcIlxuICAgICAgICAgICAgICA6IFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbClcbiAgICAgIH1cbiAgICAgIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIHJldHVybiBcIlwiXG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaClcbiAgICB9XG4gIH07XG5cblxuICBwcCQ5LnJlYWRIZXhDaGFyID0gZnVuY3Rpb24obGVuKSB7XG4gICAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcztcbiAgICB2YXIgbiA9IHRoaXMucmVhZEludCgxNiwgbGVuKTtcbiAgICBpZiAobiA9PT0gbnVsbCkgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihjb2RlUG9zLCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpOyB9XG4gICAgcmV0dXJuIG5cbiAgfTtcblxuXG4gIHBwJDkucmVhZFdvcmQxID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuICAgIHZhciB3b3JkID0gXCJcIiwgZmlyc3QgPSB0cnVlLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdmFyIGFzdHJhbCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICAgIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCwgYXN0cmFsKSkge1xuICAgICAgICB0aGlzLnBvcyArPSBjaCA8PSAweGZmZmYgPyAxIDogMjtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7IFxuICAgICAgICB0aGlzLmNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgdmFyIGVzY1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcykgIT09IDExNykgXG4gICAgICAgICAgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbih0aGlzLnBvcywgXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYXCIpOyB9XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIHZhciBlc2MgPSB0aGlzLnJlYWRDb2RlUG9pbnQoKTtcbiAgICAgICAgaWYgKCEoZmlyc3QgPyBpc0lkZW50aWZpZXJTdGFydCA6IGlzSWRlbnRpZmllckNoYXIpKGVzYywgYXN0cmFsKSlcbiAgICAgICAgICB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGVzY1N0YXJ0LCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIik7IH1cbiAgICAgICAgd29yZCArPSBjb2RlUG9pbnRUb1N0cmluZyQxKGVzYyk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpXG4gIH07XG5cblxuICBwcCQ5LnJlYWRXb3JkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHdvcmQgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICAgIHZhciB0eXBlID0gdHlwZXMubmFtZTtcbiAgICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KHdvcmQpKSB7XG4gICAgICB0eXBlID0ga2V5d29yZHMkMVt3b3JkXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgd29yZClcbiAgfTtcblxuXG4gIHZhciB2ZXJzaW9uID0gXCI3LjEuMFwiO1xuXG4gIFBhcnNlci5hY29ybiA9IHtcbiAgICBQYXJzZXI6IFBhcnNlcixcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgIGRlZmF1bHRPcHRpb25zOiBkZWZhdWx0T3B0aW9ucyxcbiAgICBQb3NpdGlvbjogUG9zaXRpb24sXG4gICAgU291cmNlTG9jYXRpb246IFNvdXJjZUxvY2F0aW9uLFxuICAgIGdldExpbmVJbmZvOiBnZXRMaW5lSW5mbyxcbiAgICBOb2RlOiBOb2RlLFxuICAgIFRva2VuVHlwZTogVG9rZW5UeXBlLFxuICAgIHRva1R5cGVzOiB0eXBlcyxcbiAgICBrZXl3b3JkVHlwZXM6IGtleXdvcmRzJDEsXG4gICAgVG9rQ29udGV4dDogVG9rQ29udGV4dCxcbiAgICB0b2tDb250ZXh0czogdHlwZXMkMSxcbiAgICBpc0lkZW50aWZpZXJDaGFyOiBpc0lkZW50aWZpZXJDaGFyLFxuICAgIGlzSWRlbnRpZmllclN0YXJ0OiBpc0lkZW50aWZpZXJTdGFydCxcbiAgICBUb2tlbjogVG9rZW4sXG4gICAgaXNOZXdMaW5lOiBpc05ld0xpbmUsXG4gICAgbGluZUJyZWFrOiBsaW5lQnJlYWssXG4gICAgbGluZUJyZWFrRzogbGluZUJyZWFrRyxcbiAgICBub25BU0NJSXdoaXRlc3BhY2U6IG5vbkFTQ0lJd2hpdGVzcGFjZVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUGFyc2VyLnBhcnNlKGlucHV0LCBvcHRpb25zKVxuICB9XG5cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKVxuICB9XG5cblxuICBmdW5jdGlvbiB0b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUGFyc2VyLnRva2VuaXplcihpbnB1dCwgb3B0aW9ucylcbiAgfVxuXG4gIGV4cG9ydHMuTm9kZSA9IE5vZGU7XG4gIGV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuICBleHBvcnRzLlBvc2l0aW9uID0gUG9zaXRpb247XG4gIGV4cG9ydHMuU291cmNlTG9jYXRpb24gPSBTb3VyY2VMb2NhdGlvbjtcbiAgZXhwb3J0cy5Ub2tDb250ZXh0ID0gVG9rQ29udGV4dDtcbiAgZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xuICBleHBvcnRzLlRva2VuVHlwZSA9IFRva2VuVHlwZTtcbiAgZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICBleHBvcnRzLmdldExpbmVJbmZvID0gZ2V0TGluZUluZm87XG4gIGV4cG9ydHMuaXNJZGVudGlmaWVyQ2hhciA9IGlzSWRlbnRpZmllckNoYXI7XG4gIGV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBpc0lkZW50aWZpZXJTdGFydDtcbiAgZXhwb3J0cy5pc05ld0xpbmUgPSBpc05ld0xpbmU7XG4gIGV4cG9ydHMua2V5d29yZFR5cGVzID0ga2V5d29yZHMkMTtcbiAgZXhwb3J0cy5saW5lQnJlYWsgPSBsaW5lQnJlYWs7XG4gIGV4cG9ydHMubGluZUJyZWFrRyA9IGxpbmVCcmVha0c7XG4gIGV4cG9ydHMubm9uQVNDSUl3aGl0ZXNwYWNlID0gbm9uQVNDSUl3aGl0ZXNwYWNlO1xuICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG4gIGV4cG9ydHMucGFyc2VFeHByZXNzaW9uQXQgPSBwYXJzZUV4cHJlc3Npb25BdDtcbiAgZXhwb3J0cy50b2tDb250ZXh0cyA9IHR5cGVzJDE7XG4gIGV4cG9ydHMudG9rVHlwZXMgPSB0eXBlcztcbiAgZXhwb3J0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gIGV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuXG59LHt9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxufSx7fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5mdW5jdGlvbiBnbFdpcmV0YXAoZ2wsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgY29udGV4dE5hbWUgPSAnZ2wnLFxuICAgIHRocm93R2V0RXJyb3IsXG4gICAgdXNlVHJhY2thYmxlUHJpbWl0aXZlcyxcbiAgICByZWFkUGl4ZWxzRmlsZSxcbiAgICByZWNvcmRpbmcgPSBbXSxcbiAgICB2YXJpYWJsZXMgPSB7fSxcbiAgICBvblJlYWRQaXhlbHMsXG4gICAgb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCxcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGdsLCB7IGdldDogbGlzdGVuIH0pO1xuICBjb25zdCBjb250ZXh0VmFyaWFibGVzID0gW107XG4gIGNvbnN0IGVudGl0eU5hbWVzID0ge307XG4gIGxldCBpbWFnZUNvdW50ID0gMDtcbiAgbGV0IGluZGVudCA9ICcnO1xuICBsZXQgcmVhZFBpeGVsc1ZhcmlhYmxlTmFtZTtcbiAgcmV0dXJuIHByb3h5O1xuICBmdW5jdGlvbiBsaXN0ZW4ob2JqLCBwcm9wZXJ0eSkge1xuICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgIGNhc2UgJ2FkZENvbW1lbnQnOiByZXR1cm4gYWRkQ29tbWVudDtcbiAgICAgIGNhc2UgJ2NoZWNrVGhyb3dFcnJvcic6IHJldHVybiBjaGVja1Rocm93RXJyb3I7XG4gICAgICBjYXNlICdnZXRSZWFkUGl4ZWxzVmFyaWFibGVOYW1lJzogcmV0dXJuIHJlYWRQaXhlbHNWYXJpYWJsZU5hbWU7XG4gICAgICBjYXNlICdpbnNlcnRWYXJpYWJsZSc6IHJldHVybiBpbnNlcnRWYXJpYWJsZTtcbiAgICAgIGNhc2UgJ3Jlc2V0JzogcmV0dXJuIHJlc2V0O1xuICAgICAgY2FzZSAnc2V0SW5kZW50JzogcmV0dXJuIHNldEluZGVudDtcbiAgICAgIGNhc2UgJ3RvU3RyaW5nJzogcmV0dXJuIHRvU3RyaW5nO1xuICAgICAgY2FzZSAnZ2V0Q29udGV4dFZhcmlhYmxlTmFtZSc6IHJldHVybiBnZXRDb250ZXh0VmFyaWFibGVOYW1lO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGdsW3Byb3BlcnR5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICAgIGNhc2UgJ2dldEVycm9yJzpcbiAgICAgICAgICAgIGlmICh0aHJvd0dldEVycm9yKSB7XG4gICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1pZiAoJHtjb250ZXh0TmFtZX0uZ2V0RXJyb3IoKSAhPT0gJHtjb250ZXh0TmFtZX0uTk9ORSkgdGhyb3cgbmV3IEVycm9yKCdlcnJvcicpO2ApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fSR7Y29udGV4dE5hbWV9LmdldEVycm9yKCk7YCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdsLmdldEVycm9yKCk7XG4gICAgICAgICAgY2FzZSAnZ2V0RXh0ZW5zaW9uJzoge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gYCR7Y29udGV4dE5hbWV9VmFyaWFibGVzJHtjb250ZXh0VmFyaWFibGVzLmxlbmd0aH1gO1xuICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7dmFyaWFibGVOYW1lfSA9ICR7Y29udGV4dE5hbWV9LmdldEV4dGVuc2lvbignJHthcmd1bWVudHNbMF19Jyk7YCk7XG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb24gJiYgdHlwZW9mIGV4dGVuc2lvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgY29uc3QgdGFwcGVkRXh0ZW5zaW9uID0gZ2xFeHRlbnNpb25XaXJldGFwKGV4dGVuc2lvbiwge1xuICAgICAgICAgICAgICAgIGdldEVudGl0eSxcbiAgICAgICAgICAgICAgICB1c2VUcmFja2FibGVQcmltaXRpdmVzLFxuICAgICAgICAgICAgICAgIHJlY29yZGluZyxcbiAgICAgICAgICAgICAgICBjb250ZXh0TmFtZTogdmFyaWFibGVOYW1lLFxuICAgICAgICAgICAgICAgIGNvbnRleHRWYXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIGluZGVudCxcbiAgICAgICAgICAgICAgICBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKHRhcHBlZEV4dGVuc2lvbik7XG4gICAgICAgICAgICAgIHJldHVybiB0YXBwZWRFeHRlbnNpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdyZWFkUGl4ZWxzJzpcbiAgICAgICAgICAgIGNvbnN0IGkgPSBjb250ZXh0VmFyaWFibGVzLmluZGV4T2YoYXJndW1lbnRzWzZdKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXRWYXJpYWJsZU5hbWU7XG4gICAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gZ2V0VmFyaWFibGVOYW1lKGFyZ3VtZW50c1s2XSk7XG4gICAgICAgICAgICAgIGlmICh2YXJpYWJsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRWYXJpYWJsZU5hbWUgPSB2YXJpYWJsZU5hbWU7XG4gICAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fSR7dmFyaWFibGVOYW1lfWApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFZhcmlhYmxlTmFtZSA9IGAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtjb250ZXh0VmFyaWFibGVzLmxlbmd0aH1gO1xuICAgICAgICAgICAgICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaChhcmd1bWVudHNbNl0pO1xuICAgICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1jb25zdCAke3RhcmdldFZhcmlhYmxlTmFtZX0gPSBuZXcgJHthcmd1bWVudHNbNl0uY29uc3RydWN0b3IubmFtZX0oJHthcmd1bWVudHNbNl0ubGVuZ3RofSk7YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldFZhcmlhYmxlTmFtZSA9IGAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkUGl4ZWxzVmFyaWFibGVOYW1lID0gdGFyZ2V0VmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgY29uc3QgYXJndW1lbnRBc1N0cmluZ3MgPSBbXG4gICAgICAgICAgICAgIGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgICAgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgICBhcmd1bWVudHNbMl0sXG4gICAgICAgICAgICAgIGFyZ3VtZW50c1szXSxcbiAgICAgICAgICAgICAgZ2V0RW50aXR5KGFyZ3VtZW50c1s0XSksXG4gICAgICAgICAgICAgIGdldEVudGl0eShhcmd1bWVudHNbNV0pLFxuICAgICAgICAgICAgICB0YXJnZXRWYXJpYWJsZU5hbWVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9JHtjb250ZXh0TmFtZX0ucmVhZFBpeGVscygke2FyZ3VtZW50QXNTdHJpbmdzLmpvaW4oJywgJyl9KTtgKTtcbiAgICAgICAgICAgIGlmIChyZWFkUGl4ZWxzRmlsZSkge1xuICAgICAgICAgICAgICB3cml0ZVBQTShhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25SZWFkUGl4ZWxzKSB7XG4gICAgICAgICAgICAgIG9uUmVhZFBpeGVscyh0YXJnZXRWYXJpYWJsZU5hbWUsIGFyZ3VtZW50QXNTdHJpbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnbC5yZWFkUGl4ZWxzLmFwcGx5KGdsLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGNhc2UgJ2RyYXdCdWZmZXJzJzpcbiAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0ke2NvbnRleHROYW1lfS5kcmF3QnVmZmVycyhbJHthcmd1bWVudHNUb1N0cmluZyhhcmd1bWVudHNbMF0sIHsgY29udGV4dE5hbWUsIGNvbnRleHRWYXJpYWJsZXMsIGdldEVudGl0eSwgYWRkVmFyaWFibGUsIHZhcmlhYmxlcywgb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCB9ICl9XSk7YCk7XG4gICAgICAgICAgICByZXR1cm4gZ2wuZHJhd0J1ZmZlcnMoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gZ2xbcHJvcGVydHldLmFwcGx5KGdsLCBhcmd1bWVudHMpO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiByZXN1bHQpIHtcbiAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fSR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgaWYgKHVzZVRyYWNrYWJsZVByaW1pdGl2ZXMgJiYgY29udGV4dFZhcmlhYmxlcy5pbmRleE9mKHRyYWNrYWJsZVByaW1pdGl2ZShyZXN1bHQpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofSA9ICR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKHJlc3VsdCA9IHRyYWNrYWJsZVByaW1pdGl2ZShyZXN1bHQpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1jb25zdCAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtjb250ZXh0VmFyaWFibGVzLmxlbmd0aH0gPSAke21ldGhvZENhbGxUb1N0cmluZyhwcm9wZXJ0eSwgYXJndW1lbnRzKX07YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVudGl0eU5hbWVzW2dsW3Byb3BlcnR5XV0gPSBwcm9wZXJ0eTtcbiAgICByZXR1cm4gZ2xbcHJvcGVydHldO1xuICB9XG4gIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiByZWNvcmRpbmcuam9pbignXFxuJyk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgd2hpbGUgKHJlY29yZGluZy5sZW5ndGggPiAwKSB7XG4gICAgICByZWNvcmRpbmcucG9wKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGluc2VydFZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyaWFibGVzW25hbWVdID0gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RW50aXR5KHZhbHVlKSB7XG4gICAgY29uc3QgbmFtZSA9IGVudGl0eU5hbWVzW3ZhbHVlXTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGNvbnRleHROYW1lICsgJy4nICsgbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHNldEluZGVudChzcGFjZXMpIHtcbiAgICBpbmRlbnQgPSAnICcucmVwZWF0KHNwYWNlcyk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkVmFyaWFibGUodmFsdWUsIHNvdXJjZSkge1xuICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtjb250ZXh0VmFyaWFibGVzLmxlbmd0aH1gO1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1jb25zdCAke3ZhcmlhYmxlTmFtZX0gPSAke3NvdXJjZX07YCk7XG4gICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKHZhbHVlKTtcbiAgICByZXR1cm4gdmFyaWFibGVOYW1lO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlUFBNKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBzb3VyY2VWYXJpYWJsZSA9IGAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtjb250ZXh0VmFyaWFibGVzLmxlbmd0aH1gO1xuICAgIGNvbnN0IGltYWdlVmFyaWFibGUgPSBgaW1hZ2VEYXR1bSR7aW1hZ2VDb3VudH1gO1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1sZXQgJHtpbWFnZVZhcmlhYmxlfSA9IFtcIlAzXFxcXG4jICR7cmVhZFBpeGVsc0ZpbGV9LnBwbVxcXFxuXCIsICR7d2lkdGh9LCAnICcsICR7aGVpZ2h0fSwgXCJcXFxcbjI1NVxcXFxuXCJdLmpvaW4oXCJcIik7YCk7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWZvciAobGV0IGkgPSAwOyBpIDwgJHtpbWFnZVZhcmlhYmxlfS5sZW5ndGg7IGkgKz0gNCkge2ApO1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0gICR7aW1hZ2VWYXJpYWJsZX0gKz0gJHtzb3VyY2VWYXJpYWJsZX1baV0gKyAnICcgKyAke3NvdXJjZVZhcmlhYmxlfVtpICsgMV0gKyAnICcgKyAke3NvdXJjZVZhcmlhYmxlfVtpICsgMl0gKyAnICc7YCk7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fX1gKTtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9aWYgKHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiKSB7YCk7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fSAgcmVxdWlyZSgnZnMnKS53cml0ZUZpbGVTeW5jKCcuLyR7cmVhZFBpeGVsc0ZpbGV9LnBwbScsICR7aW1hZ2VWYXJpYWJsZX0pO2ApO1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH19YCk7XG4gICAgaW1hZ2VDb3VudCsrO1xuICB9XG4gIGZ1bmN0aW9uIGFkZENvbW1lbnQodmFsdWUpIHtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Ly8gJHt2YWx1ZX1gKTtcbiAgfVxuICBmdW5jdGlvbiBjaGVja1Rocm93RXJyb3IoKSB7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fSgoKSA9PiB7XG4ke2luZGVudH1jb25zdCBlcnJvciA9ICR7Y29udGV4dE5hbWV9LmdldEVycm9yKCk7XG4ke2luZGVudH1pZiAoZXJyb3IgIT09ICR7Y29udGV4dE5hbWV9Lk5PTkUpIHtcbiR7aW5kZW50fSAgY29uc3QgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnbCk7XG4ke2luZGVudH0gIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiR7aW5kZW50fSAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4ke2luZGVudH0gICAgaWYgKCR7Y29udGV4dE5hbWV9W25hbWVdID09PSBlcnJvcikge1xuJHtpbmRlbnR9ICAgICAgdGhyb3cgbmV3IEVycm9yKCcke2NvbnRleHROYW1lfSB0aHJldyAnICsgbmFtZSk7XG4ke2luZGVudH0gICAgfVxuJHtpbmRlbnR9ICB9XG4ke2luZGVudH19XG4ke2luZGVudH19KSgpO2ApO1xuICB9XG4gIGZ1bmN0aW9uIG1ldGhvZENhbGxUb1N0cmluZyhtZXRob2QsIGFyZ3MpIHtcbiAgICByZXR1cm4gYCR7Y29udGV4dE5hbWV9LiR7bWV0aG9kfSgke2FyZ3VtZW50c1RvU3RyaW5nKGFyZ3MsIHsgY29udGV4dE5hbWUsIGNvbnRleHRWYXJpYWJsZXMsIGdldEVudGl0eSwgYWRkVmFyaWFibGUsIHZhcmlhYmxlcywgb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCB9KX0pYDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFZhcmlhYmxlTmFtZSh2YWx1ZSkge1xuICAgIGlmICh2YXJpYWJsZXMpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKHZhcmlhYmxlc1tuYW1lXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbnRleHRWYXJpYWJsZU5hbWUodmFsdWUpIHtcbiAgICBjb25zdCBpID0gY29udGV4dFZhcmlhYmxlcy5pbmRleE9mKHZhbHVlKTtcbiAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7aX1gO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnbEV4dGVuc2lvbldpcmV0YXAoZXh0ZW5zaW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGV4dGVuc2lvbiwgeyBnZXQ6IGxpc3RlbiB9KTtcbiAgY29uc3QgZXh0ZW5zaW9uRW50aXR5TmFtZXMgPSB7fTtcbiAgY29uc3Qge1xuICAgIGNvbnRleHROYW1lLFxuICAgIGNvbnRleHRWYXJpYWJsZXMsXG4gICAgZ2V0RW50aXR5LFxuICAgIHVzZVRyYWNrYWJsZVByaW1pdGl2ZXMsXG4gICAgcmVjb3JkaW5nLFxuICAgIHZhcmlhYmxlcyxcbiAgICBpbmRlbnQsXG4gICAgb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCxcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiBwcm94eTtcbiAgZnVuY3Rpb24gbGlzdGVuKG9iaiwgcHJvcGVydHkpIHtcbiAgICBpZiAodHlwZW9mIG9ialtwcm9wZXJ0eV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICAgIGNhc2UgJ2RyYXdCdWZmZXJzV0VCR0wnOlxuICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fSR7Y29udGV4dE5hbWV9LmRyYXdCdWZmZXJzV0VCR0woWyR7YXJndW1lbnRzVG9TdHJpbmcoYXJndW1lbnRzWzBdLCB7IGNvbnRleHROYW1lLCBjb250ZXh0VmFyaWFibGVzLCBnZXRFbnRpdHk6IGdldEV4dGVuc2lvbkVudGl0eSwgYWRkVmFyaWFibGUsIHZhcmlhYmxlcywgb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCB9KX1dKTtgKTtcbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb24uZHJhd0J1ZmZlcnNXRUJHTChhcmd1bWVudHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBleHRlbnNpb25bcHJvcGVydHldLmFwcGx5KGV4dGVuc2lvbiwgYXJndW1lbnRzKTtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgcmVzdWx0KSB7XG4gICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0ke21ldGhvZENhbGxUb1N0cmluZyhwcm9wZXJ0eSwgYXJndW1lbnRzKX07YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGlmICh1c2VUcmFja2FibGVQcmltaXRpdmVzICYmIGNvbnRleHRWYXJpYWJsZXMuaW5kZXhPZih0cmFja2FibGVQcmltaXRpdmUocmVzdWx0KSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1jb25zdCAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtjb250ZXh0VmFyaWFibGVzLmxlbmd0aH0gPSAke21ldGhvZENhbGxUb1N0cmluZyhwcm9wZXJ0eSwgYXJndW1lbnRzKX07YCk7XG4gICAgICAgICAgICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaChyZXN1bHQgPSB0cmFja2FibGVQcmltaXRpdmUocmVzdWx0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9ID0gJHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke21ldGhvZENhbGxUb1N0cmluZyhwcm9wZXJ0eSwgYXJndW1lbnRzKX07YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9ID0gJHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuICAgIGV4dGVuc2lvbkVudGl0eU5hbWVzW2V4dGVuc2lvbltwcm9wZXJ0eV1dID0gcHJvcGVydHk7XG4gICAgcmV0dXJuIGV4dGVuc2lvbltwcm9wZXJ0eV07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFeHRlbnNpb25FbnRpdHkodmFsdWUpIHtcbiAgICBpZiAoZXh0ZW5zaW9uRW50aXR5TmFtZXMuaGFzT3duUHJvcGVydHkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gYCR7Y29udGV4dE5hbWV9LiR7ZXh0ZW5zaW9uRW50aXR5TmFtZXNbdmFsdWVdfWA7XG4gICAgfVxuICAgIHJldHVybiBnZXRFbnRpdHkodmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWV0aG9kQ2FsbFRvU3RyaW5nKG1ldGhvZCwgYXJncykge1xuICAgIHJldHVybiBgJHtjb250ZXh0TmFtZX0uJHttZXRob2R9KCR7YXJndW1lbnRzVG9TdHJpbmcoYXJncywgeyBjb250ZXh0TmFtZSwgY29udGV4dFZhcmlhYmxlcywgZ2V0RW50aXR5OiBnZXRFeHRlbnNpb25FbnRpdHksIGFkZFZhcmlhYmxlLCB2YXJpYWJsZXMsIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAgfSl9KWA7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWYXJpYWJsZSh2YWx1ZSwgc291cmNlKSB7XG4gICAgY29uc3QgdmFyaWFibGVOYW1lID0gYCR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofWA7XG4gICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKHZhbHVlKTtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHt2YXJpYWJsZU5hbWV9ID0gJHtzb3VyY2V9O2ApO1xuICAgIHJldHVybiB2YXJpYWJsZU5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXJndW1lbnRzVG9TdHJpbmcoYXJncywgb3B0aW9ucykge1xuICBjb25zdCB7IHZhcmlhYmxlcywgb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIChBcnJheS5mcm9tKGFyZ3MpLm1hcCgoYXJnKSA9PiB7XG4gICAgY29uc3QgdmFyaWFibGVOYW1lID0gZ2V0VmFyaWFibGVOYW1lKGFyZyk7XG4gICAgaWYgKHZhcmlhYmxlTmFtZSkge1xuICAgICAgcmV0dXJuIHZhcmlhYmxlTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3VtZW50VG9TdHJpbmcoYXJnLCBvcHRpb25zKTtcbiAgfSkuam9pbignLCAnKSk7XG5cbiAgZnVuY3Rpb24gZ2V0VmFyaWFibGVOYW1lKHZhbHVlKSB7XG4gICAgaWYgKHZhcmlhYmxlcykge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhcmlhYmxlcykge1xuICAgICAgICBpZiAoIXZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgY29udGludWU7XG4gICAgICAgIGlmICh2YXJpYWJsZXNbbmFtZV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXApIHtcbiAgICAgIHJldHVybiBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXJndW1lbnRUb1N0cmluZyhhcmcsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBjb250ZXh0TmFtZSwgY29udGV4dFZhcmlhYmxlcywgZ2V0RW50aXR5LCBhZGRWYXJpYWJsZSwgb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCB9ID0gb3B0aW9ucztcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG4gIGlmIChhcmcgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG4gIGNvbnN0IGkgPSBjb250ZXh0VmFyaWFibGVzLmluZGV4T2YoYXJnKTtcbiAgaWYgKGkgPiAtMSkge1xuICAgIHJldHVybiBgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7aX1gO1xuICB9XG4gIHN3aXRjaCAoYXJnLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgY29uc3QgaGFzTGluZXMgPSAvXFxuLy50ZXN0KGFyZyk7XG4gICAgICBjb25zdCBoYXNTaW5nbGVRdW90ZXMgPSAvJy8udGVzdChhcmcpO1xuICAgICAgY29uc3QgaGFzRG91YmxlUXVvdGVzID0gL1wiLy50ZXN0KGFyZyk7XG4gICAgICBpZiAoaGFzTGluZXMpIHtcbiAgICAgICAgcmV0dXJuICdgJyArIGFyZyArICdgJztcbiAgICAgIH0gZWxzZSBpZiAoaGFzU2luZ2xlUXVvdGVzICYmICFoYXNEb3VibGVRdW90ZXMpIHtcbiAgICAgICAgcmV0dXJuICdcIicgKyBhcmcgKyAnXCInO1xuICAgICAgfSBlbHNlIGlmICghaGFzU2luZ2xlUXVvdGVzICYmIGhhc0RvdWJsZVF1b3Rlcykge1xuICAgICAgICByZXR1cm4gXCInXCIgKyBhcmcgKyBcIidcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnXFwnJyArIGFyZyArICdcXCcnO1xuICAgICAgfVxuICAgIGNhc2UgJ051bWJlcic6IHJldHVybiBnZXRFbnRpdHkoYXJnKTtcbiAgICBjYXNlICdCb29sZWFuJzogcmV0dXJuIGdldEVudGl0eShhcmcpO1xuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHJldHVybiBhZGRWYXJpYWJsZShhcmcsIGBuZXcgJHthcmcuY29uc3RydWN0b3IubmFtZX0oWyR7QXJyYXkuZnJvbShhcmcpLmpvaW4oJywnKX1dKWApO1xuICAgIGNhc2UgJ0Zsb2F0MzJBcnJheSc6XG4gICAgY2FzZSAnVWludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDE2QXJyYXknOlxuICAgIGNhc2UgJ0ludDMyQXJyYXknOlxuICAgICAgcmV0dXJuIGFkZFZhcmlhYmxlKGFyZywgYG5ldyAke2FyZy5jb25zdHJ1Y3Rvci5uYW1lfSgke0pTT04uc3RyaW5naWZ5KEFycmF5LmZyb20oYXJnKSl9KWApO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAob25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCkge1xuICAgICAgICBjb25zdCBpbnN0YW50aWF0aW9uU3RyaW5nID0gb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cChhcmcpO1xuICAgICAgICBpZiAoaW5zdGFudGlhdGlvblN0cmluZykge1xuICAgICAgICAgIHJldHVybiBpbnN0YW50aWF0aW9uU3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBhcmd1bWVudCB0eXBlICR7YXJnLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhY2thYmxlUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgdmFsdWUuY29uc3RydWN0b3IodmFsdWUpO1xufVxuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IGdsV2lyZXRhcCwgZ2xFeHRlbnNpb25XaXJldGFwIH07XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBnbFdpcmV0YXAuZ2xFeHRlbnNpb25XaXJldGFwID0gZ2xFeHRlbnNpb25XaXJldGFwO1xuICB3aW5kb3cuZ2xXaXJldGFwID0gZ2xXaXJldGFwO1xufVxuXG59LHt9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmZ1bmN0aW9uIHNldHVwQXJndW1lbnRzKGFyZ3MpIHtcbiAgY29uc3QgbmV3QXJndW1lbnRzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXTtcbiAgICBpZiAoYXJnLnRvQXJyYXkpIHtcbiAgICAgIG5ld0FyZ3VtZW50c1tpXSA9IGFyZy50b0FycmF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0FyZ3VtZW50c1tpXSA9IGFyZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0FyZ3VtZW50cztcbn1cblxuZnVuY3Rpb24gbW9jazFEKCkge1xuICBjb25zdCBhcmdzID0gc2V0dXBBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgY29uc3Qgcm93ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm91dHB1dC54KTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLm91dHB1dC54OyB4KyspIHtcbiAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICB0aGlzLnRocmVhZC55ID0gMDtcbiAgICB0aGlzLnRocmVhZC56ID0gMDtcbiAgICByb3dbeF0gPSB0aGlzLl9mbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuICByZXR1cm4gcm93O1xufVxuXG5mdW5jdGlvbiBtb2NrMkQoKSB7XG4gIGNvbnN0IGFyZ3MgPSBzZXR1cEFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICBjb25zdCBtYXRyaXggPSBuZXcgQXJyYXkodGhpcy5vdXRwdXQueSk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5vdXRwdXQueTsgeSsrKSB7XG4gICAgY29uc3Qgcm93ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm91dHB1dC54KTtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMub3V0cHV0Lng7IHgrKykge1xuICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICB0aGlzLnRocmVhZC55ID0geTtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgcm93W3hdID0gdGhpcy5fZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIG1hdHJpeFt5XSA9IHJvdztcbiAgfVxuICByZXR1cm4gbWF0cml4O1xufVxuXG5mdW5jdGlvbiBtb2NrMkRHcmFwaGljYWwoKSB7XG4gIGNvbnN0IGFyZ3MgPSBzZXR1cEFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMub3V0cHV0Lnk7IHkrKykge1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5vdXRwdXQueDsgeCsrKSB7XG4gICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xuICAgICAgdGhpcy50aHJlYWQueiA9IDA7XG4gICAgICB0aGlzLl9mbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9jazNEKCkge1xuICBjb25zdCBhcmdzID0gc2V0dXBBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgY29uc3QgY3ViZSA9IG5ldyBBcnJheSh0aGlzLm91dHB1dC56KTtcbiAgZm9yIChsZXQgeiA9IDA7IHogPCB0aGlzLm91dHB1dC56OyB6KyspIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgQXJyYXkodGhpcy5vdXRwdXQueSk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLm91dHB1dC55OyB5KyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5vdXRwdXQueCk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMub3V0cHV0Lng7IHgrKykge1xuICAgICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICAgIHRoaXMudGhyZWFkLnogPSB6O1xuICAgICAgICByb3dbeF0gPSB0aGlzLl9mbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIG1hdHJpeFt5XSA9IHJvdztcbiAgICB9XG4gICAgY3ViZVt6XSA9IG1hdHJpeDtcbiAgfVxuICByZXR1cm4gY3ViZTtcbn1cblxuZnVuY3Rpb24gYXBpRGVjb3JhdGUoa2VybmVsKSB7XG4gIGtlcm5lbC5zZXRPdXRwdXQgPSAob3V0cHV0KSA9PiB7XG4gICAga2VybmVsLm91dHB1dCA9IHNldHVwT3V0cHV0KG91dHB1dCk7XG4gICAgaWYgKGtlcm5lbC5ncmFwaGljYWwpIHtcbiAgICAgIHNldHVwR3JhcGhpY2FsKGtlcm5lbCk7XG4gICAgfVxuICB9O1xuICBrZXJuZWwudG9KU09OID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IHVzYWJsZSB3aXRoIGdwdU1vY2snKTtcbiAgfTtcbiAga2VybmVsLnNldENvbnN0YW50cyA9IChmbGFnKSA9PiB7XG4gICAga2VybmVsLmNvbnN0YW50cyA9IGZsYWc7XG4gICAgcmV0dXJuIGtlcm5lbDtcbiAgfTtcbiAga2VybmVsLnNldEdyYXBoaWNhbCA9IChmbGFnKSA9PiB7XG4gICAga2VybmVsLmdyYXBoaWNhbCA9IGZsYWc7XG4gICAgcmV0dXJuIGtlcm5lbDtcbiAgfTtcbiAga2VybmVsLnNldENhbnZhcyA9IChmbGFnKSA9PiB7XG4gICAga2VybmVsLmNhbnZhcyA9IGZsYWc7XG4gICAgcmV0dXJuIGtlcm5lbDtcbiAgfTtcbiAga2VybmVsLnNldENvbnRleHQgPSAoZmxhZykgPT4ge1xuICAgIGtlcm5lbC5jb250ZXh0ID0gZmxhZztcbiAgICByZXR1cm4ga2VybmVsO1xuICB9O1xuICBrZXJuZWwuZGVzdHJveSA9ICgpID0+IHt9O1xuICBrZXJuZWwudmFsaWRhdGVTZXR0aW5ncyA9ICgpID0+IHt9O1xuICBpZiAoa2VybmVsLmdyYXBoaWNhbCAmJiBrZXJuZWwub3V0cHV0KSB7XG4gICAgc2V0dXBHcmFwaGljYWwoa2VybmVsKTtcbiAgfVxuICBrZXJuZWwuZXhlYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXNvbHZlKGtlcm5lbC5hcHBseShrZXJuZWwsIGFyZ3VtZW50cykpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAga2VybmVsLmdldFBpeGVscyA9IChmbGlwKSA9PiB7XG4gICAgY29uc3Qge3gsIHl9ID0ga2VybmVsLm91dHB1dDtcbiAgICByZXR1cm4gZmxpcCA/IGZsaXBQaXhlbHMoa2VybmVsLl9pbWFnZURhdGEuZGF0YSwgeCwgeSkgOiBrZXJuZWwuX2ltYWdlRGF0YS5kYXRhLnNsaWNlKDApO1xuICB9O1xuICBrZXJuZWwuY29sb3IgPSBmdW5jdGlvbihyLCBnLCBiLCBhKSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgYSA9IDE7XG4gICAgfVxuXG4gICAgciA9IE1hdGguZmxvb3IociAqIDI1NSk7XG4gICAgZyA9IE1hdGguZmxvb3IoZyAqIDI1NSk7XG4gICAgYiA9IE1hdGguZmxvb3IoYiAqIDI1NSk7XG4gICAgYSA9IE1hdGguZmxvb3IoYSAqIDI1NSk7XG5cbiAgICBjb25zdCB3aWR0aCA9IGtlcm5lbC5vdXRwdXQueDtcbiAgICBjb25zdCBoZWlnaHQgPSBrZXJuZWwub3V0cHV0Lnk7XG5cbiAgICBjb25zdCB4ID0ga2VybmVsLnRocmVhZC54O1xuICAgIGNvbnN0IHkgPSBoZWlnaHQgLSBrZXJuZWwudGhyZWFkLnkgLSAxO1xuXG4gICAgY29uc3QgaW5kZXggPSB4ICsgeSAqIHdpZHRoO1xuXG4gICAga2VybmVsLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgMF0gPSByO1xuICAgIGtlcm5lbC5fY29sb3JEYXRhW2luZGV4ICogNCArIDFdID0gZztcbiAgICBrZXJuZWwuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAyXSA9IGI7XG4gICAga2VybmVsLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgM10gPSBhO1xuICB9O1xuXG4gIGNvbnN0IG1vY2tNZXRob2QgPSAoKSA9PiBrZXJuZWw7XG4gIGNvbnN0IG1ldGhvZHMgPSBbXG4gICAgJ3NldFdhcm5WYXJVc2FnZScsXG4gICAgJ3NldEFyZ3VtZW50VHlwZXMnLFxuICAgICdzZXRUYWN0aWMnLFxuICAgICdzZXRPcHRpbWl6ZUZsb2F0TWVtb3J5JyxcbiAgICAnc2V0RGVidWcnLFxuICAgICdzZXRMb29wTWF4SXRlcmF0aW9ucycsXG4gICAgJ3NldENvbnN0YW50VHlwZXMnLFxuICAgICdzZXRGdW5jdGlvbnMnLFxuICAgICdzZXROYXRpdmVGdW5jdGlvbnMnLFxuICAgICdzZXRJbmplY3RlZE5hdGl2ZScsXG4gICAgJ3NldFBpcGVsaW5lJyxcbiAgICAnc2V0UHJlY2lzaW9uJyxcbiAgICAnc2V0T3V0cHV0VG9UZXh0dXJlJyxcbiAgICAnc2V0SW1tdXRhYmxlJyxcbiAgICAnc2V0U3RyaWN0SW50ZWdlcnMnLFxuICAgICdzZXREeW5hbWljT3V0cHV0JyxcbiAgICAnc2V0SGFyZGNvZGVDb25zdGFudHMnLFxuICAgICdzZXREeW5hbWljQXJndW1lbnRzJyxcbiAgICAnc2V0VXNlTGVnYWN5RW5jb2RlcicsXG4gICAgJ3NldFdhcm5WYXJVc2FnZScsXG4gICAgJ2FkZFN1Yktlcm5lbCcsXG4gIF07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIGtlcm5lbFttZXRob2RzW2ldXSA9IG1vY2tNZXRob2Q7XG4gIH1cbiAgcmV0dXJuIGtlcm5lbDtcbn1cblxuZnVuY3Rpb24gc2V0dXBHcmFwaGljYWwoa2VybmVsKSB7XG4gIGNvbnN0IHt4LCB5fSA9IGtlcm5lbC5vdXRwdXQ7XG4gIGlmIChrZXJuZWwuY29udGV4dCAmJiBrZXJuZWwuY29udGV4dC5jcmVhdGVJbWFnZURhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHggKiB5ICogNCk7XG4gICAga2VybmVsLl9pbWFnZURhdGEgPSBrZXJuZWwuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoeCwgeSk7XG4gICAga2VybmVsLl9jb2xvckRhdGEgPSBkYXRhO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoeCAqIHkgKiA0KTtcbiAgICBrZXJuZWwuX2ltYWdlRGF0YSA9IHsgZGF0YSB9O1xuICAgIGtlcm5lbC5fY29sb3JEYXRhID0gZGF0YTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXR1cE91dHB1dChvdXRwdXQpIHtcbiAgbGV0IHJlc3VsdCA9IG51bGw7XG4gIGlmIChvdXRwdXQubGVuZ3RoKSB7XG4gICAgaWYgKG91dHB1dC5sZW5ndGggPT09IDMpIHtcbiAgICAgIGNvbnN0IFt4LHksel0gPSBvdXRwdXQ7XG4gICAgICByZXN1bHQgPSB7IHgsIHksIHogfTtcbiAgICB9IGVsc2UgaWYgKG91dHB1dC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IFt4LHldID0gb3V0cHV0O1xuICAgICAgcmVzdWx0ID0geyB4LCB5IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFt4XSA9IG91dHB1dDtcbiAgICAgIHJlc3VsdCA9IHsgeCB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBvdXRwdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ3B1TW9jayhmbiwgc2V0dGluZ3MgPSB7fSkge1xuICBjb25zdCBvdXRwdXQgPSBzZXR0aW5ncy5vdXRwdXQgPyBzZXR1cE91dHB1dChzZXR0aW5ncy5vdXRwdXQpIDogbnVsbDtcbiAgZnVuY3Rpb24ga2VybmVsKCkge1xuICAgIGlmIChrZXJuZWwub3V0cHV0LnopIHtcbiAgICAgIHJldHVybiBtb2NrM0QuYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSBpZiAoa2VybmVsLm91dHB1dC55KSB7XG4gICAgICBpZiAoa2VybmVsLmdyYXBoaWNhbCkge1xuICAgICAgICByZXR1cm4gbW9jazJER3JhcGhpY2FsLmFwcGx5KGtlcm5lbCwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtb2NrMkQuYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbW9jazFELmFwcGx5KGtlcm5lbCwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbiAga2VybmVsLl9mbiA9IGZuO1xuICBrZXJuZWwuY29uc3RhbnRzID0gc2V0dGluZ3MuY29uc3RhbnRzIHx8IG51bGw7XG4gIGtlcm5lbC5jb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dCB8fCBudWxsO1xuICBrZXJuZWwuY2FudmFzID0gc2V0dGluZ3MuY2FudmFzIHx8IG51bGw7XG4gIGtlcm5lbC5ncmFwaGljYWwgPSBzZXR0aW5ncy5ncmFwaGljYWwgfHwgZmFsc2U7XG4gIGtlcm5lbC5faW1hZ2VEYXRhID0gbnVsbDtcbiAga2VybmVsLl9jb2xvckRhdGEgPSBudWxsO1xuICBrZXJuZWwub3V0cHV0ID0gb3V0cHV0O1xuICBrZXJuZWwudGhyZWFkID0ge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB6OiAwXG4gIH07XG4gIHJldHVybiBhcGlEZWNvcmF0ZShrZXJuZWwpO1xufVxuXG5mdW5jdGlvbiBmbGlwUGl4ZWxzKHBpeGVscywgd2lkdGgsIGhlaWdodCkge1xuICBjb25zdCBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMiB8IDA7IFxuICBjb25zdCBieXRlc1BlclJvdyA9IHdpZHRoICogNDtcbiAgY29uc3QgdGVtcCA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIDQpO1xuICBjb25zdCByZXN1bHQgPSBwaXhlbHMuc2xpY2UoMCk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgaGFsZkhlaWdodDsgKyt5KSB7XG4gICAgY29uc3QgdG9wT2Zmc2V0ID0geSAqIGJ5dGVzUGVyUm93O1xuICAgIGNvbnN0IGJvdHRvbU9mZnNldCA9IChoZWlnaHQgLSB5IC0gMSkgKiBieXRlc1BlclJvdztcblxuICAgIHRlbXAuc2V0KHJlc3VsdC5zdWJhcnJheSh0b3BPZmZzZXQsIHRvcE9mZnNldCArIGJ5dGVzUGVyUm93KSk7XG5cbiAgICByZXN1bHQuY29weVdpdGhpbih0b3BPZmZzZXQsIGJvdHRvbU9mZnNldCwgYm90dG9tT2Zmc2V0ICsgYnl0ZXNQZXJSb3cpO1xuXG4gICAgcmVzdWx0LnNldCh0ZW1wLCBib3R0b21PZmZzZXQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBncHVNb2NrXG59O1xuXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuZnVuY3Rpb24gYWxpYXMobmFtZSwgc291cmNlKSB7XG4gIGNvbnN0IGZuU3RyaW5nID0gc291cmNlLnRvU3RyaW5nKCk7XG4gIHJldHVybiBuZXcgRnVuY3Rpb24oYHJldHVybiBmdW5jdGlvbiAkeyBuYW1lIH0gKCR7IHV0aWxzLmdldEFyZ3VtZW50TmFtZXNGcm9tU3RyaW5nKGZuU3RyaW5nKS5qb2luKCcsICcpIH0pIHtcbiAgJHsgdXRpbHMuZ2V0RnVuY3Rpb25Cb2R5RnJvbVN0cmluZyhmblN0cmluZykgfVxufWApKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhbGlhc1xufTtcbn0se1wiLi91dGlsc1wiOjExNH1dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uLW5vZGUnKTtcblxuY2xhc3MgQ1BVRnVuY3Rpb25Ob2RlIGV4dGVuZHMgRnVuY3Rpb25Ob2RlIHtcbiAgYXN0RnVuY3Rpb24oYXN0LCByZXRBcnIpIHtcblxuICAgIGlmICghdGhpcy5pc1Jvb3RLZXJuZWwpIHtcbiAgICAgIHJldEFyci5wdXNoKCdmdW5jdGlvbicpO1xuICAgICAgcmV0QXJyLnB1c2goJyAnKTtcbiAgICAgIHJldEFyci5wdXNoKHRoaXMubmFtZSk7XG4gICAgICByZXRBcnIucHVzaCgnKCcpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBhcmd1bWVudE5hbWUgPSB0aGlzLmFyZ3VtZW50TmFtZXNbaV07XG5cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJywgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0QXJyLnB1c2goJ3VzZXJfJyk7XG4gICAgICAgIHJldEFyci5wdXNoKGFyZ3VtZW50TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHJldEFyci5wdXNoKCcpIHtcXG4nKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5ib2R5LmJvZHkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYm9keS5ib2R5W2ldLCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJ1xcbicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1Jvb3RLZXJuZWwpIHtcbiAgICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RSZXR1cm5TdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5yZXR1cm5UeXBlIHx8IHRoaXMuZ2V0VHlwZShhc3QuYXJndW1lbnQpO1xuXG4gICAgaWYgKCF0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIHRoaXMucmV0dXJuVHlwZSA9IHR5cGU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNSb290S2VybmVsKSB7XG4gICAgICByZXRBcnIucHVzaCh0aGlzLmxlYWRpbmdSZXR1cm5TdGF0ZW1lbnQpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5hcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc7XFxuJyk7XG4gICAgICByZXRBcnIucHVzaCh0aGlzLmZvbGxvd2luZ1JldHVyblN0YXRlbWVudCk7XG4gICAgICByZXRBcnIucHVzaCgnY29udGludWU7XFxuJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU3ViS2VybmVsKSB7XG4gICAgICByZXRBcnIucHVzaChgc3ViS2VybmVsUmVzdWx0XyR7IHRoaXMubmFtZSB9ID0gYCk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJzsnKTtcbiAgICAgIHJldEFyci5wdXNoKGByZXR1cm4gc3ViS2VybmVsUmVzdWx0XyR7IHRoaXMubmFtZSB9O2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaCgncmV0dXJuICcpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5hcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc7Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RMaXRlcmFsKGFzdCwgcmV0QXJyKSB7XG5cbiAgICBpZiAoaXNOYU4oYXN0LnZhbHVlKSkge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcbiAgICAgICAgJ05vbi1udW1lcmljIGxpdGVyYWwgbm90IHN1cHBvcnRlZCA6ICcgKyBhc3QudmFsdWUsXG4gICAgICAgIGFzdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXRBcnIucHVzaChhc3QudmFsdWUpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEJpbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaChhc3Qub3BlcmF0b3IpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0SWRlbnRpZmllckV4cHJlc3Npb24oaWR0Tm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKGlkdE5vZGUudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KFxuICAgICAgICAnSWRlbnRpZmllckV4cHJlc3Npb24gLSBub3QgYW4gSWRlbnRpZmllcicsXG4gICAgICAgIGlkdE5vZGVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChpZHROb2RlLm5hbWUpIHtcbiAgICAgIGNhc2UgJ0luZmluaXR5JzpcbiAgICAgICAgcmV0QXJyLnB1c2goJ0luZmluaXR5Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHRoaXMuY29uc3RhbnRzICYmIHRoaXMuY29uc3RhbnRzLmhhc093blByb3BlcnR5KGlkdE5vZGUubmFtZSkpIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnY29uc3RhbnRzXycgKyBpZHROb2RlLm5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldEFyci5wdXNoKCd1c2VyXycgKyBpZHROb2RlLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEZvclN0YXRlbWVudChmb3JOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoZm9yTm9kZS50eXBlICE9PSAnRm9yU3RhdGVtZW50Jykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnSW52YWxpZCBmb3Igc3RhdGVtZW50JywgZm9yTm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdEFyciA9IFtdO1xuICAgIGNvbnN0IHRlc3RBcnIgPSBbXTtcbiAgICBjb25zdCB1cGRhdGVBcnIgPSBbXTtcbiAgICBjb25zdCBib2R5QXJyID0gW107XG4gICAgbGV0IGlzU2FmZSA9IG51bGw7XG5cbiAgICBpZiAoZm9yTm9kZS5pbml0KSB7XG4gICAgICB0aGlzLnB1c2hTdGF0ZSgnaW4tZm9yLWxvb3AtaW5pdCcpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUuaW5pdCwgaW5pdEFycik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluaXRBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGluaXRBcnJbaV0uaW5jbHVkZXMgJiYgaW5pdEFycltpXS5pbmNsdWRlcygnLCcpKSB7XG4gICAgICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucG9wU3RhdGUoJ2luLWZvci1sb29wLWluaXQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZvck5vZGUudGVzdCkge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUudGVzdCwgdGVzdEFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmb3JOb2RlLnVwZGF0ZSkge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUudXBkYXRlLCB1cGRhdGVBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc1NhZmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZm9yTm9kZS5ib2R5KSB7XG4gICAgICB0aGlzLnB1c2hTdGF0ZSgnbG9vcC1ib2R5Jyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS5ib2R5LCBib2R5QXJyKTtcbiAgICAgIHRoaXMucG9wU3RhdGUoJ2xvb3AtYm9keScpO1xuICAgIH1cblxuICAgIGlmIChpc1NhZmUgPT09IG51bGwpIHtcbiAgICAgIGlzU2FmZSA9IHRoaXMuaXNTYWZlKGZvck5vZGUuaW5pdCkgJiYgdGhpcy5pc1NhZmUoZm9yTm9kZS50ZXN0KTtcbiAgICB9XG5cbiAgICBpZiAoaXNTYWZlKSB7XG4gICAgICByZXRBcnIucHVzaChgZm9yICgke2luaXRBcnIuam9pbignJyl9OyR7dGVzdEFyci5qb2luKCcnKX07JHt1cGRhdGVBcnIuam9pbignJyl9KXtcXG5gKTtcbiAgICAgIHJldEFyci5wdXNoKGJvZHlBcnIuam9pbignJykpO1xuICAgICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaVZhcmlhYmxlTmFtZSA9IHRoaXMuZ2V0SW50ZXJuYWxWYXJpYWJsZU5hbWUoJ3NhZmVJJyk7XG4gICAgICBpZiAoaW5pdEFyci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldEFyci5wdXNoKGluaXRBcnIuam9pbignJyksICc7XFxuJyk7XG4gICAgICB9XG4gICAgICByZXRBcnIucHVzaChgZm9yIChsZXQgJHtpVmFyaWFibGVOYW1lfT0wOyR7aVZhcmlhYmxlTmFtZX08TE9PUF9NQVg7JHtpVmFyaWFibGVOYW1lfSsrKXtcXG5gKTtcbiAgICAgIGlmICh0ZXN0QXJyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0QXJyLnB1c2goYGlmICghJHt0ZXN0QXJyLmpvaW4oJycpfSkgYnJlYWs7XFxuYCk7XG4gICAgICB9XG4gICAgICByZXRBcnIucHVzaChib2R5QXJyLmpvaW4oJycpKTtcbiAgICAgIHJldEFyci5wdXNoKGBcXG4ke3VwZGF0ZUFyci5qb2luKCcnKX07YCk7XG4gICAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0V2hpbGVTdGF0ZW1lbnQod2hpbGVOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAod2hpbGVOb2RlLnR5cGUgIT09ICdXaGlsZVN0YXRlbWVudCcpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG4gICAgICAgICdJbnZhbGlkIHdoaWxlIHN0YXRlbWVudCcsXG4gICAgICAgIHdoaWxlTm9kZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXRBcnIucHVzaCgnZm9yIChsZXQgaSA9IDA7IGkgPCBMT09QX01BWDsgaSsrKSB7Jyk7XG4gICAgcmV0QXJyLnB1c2goJ2lmICgnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMod2hpbGVOb2RlLnRlc3QsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJykge1xcbicpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyh3aGlsZU5vZGUuYm9keSwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnfSBlbHNlIHtcXG4nKTtcbiAgICByZXRBcnIucHVzaCgnYnJlYWs7XFxuJyk7XG4gICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdERvV2hpbGVTdGF0ZW1lbnQoZG9XaGlsZU5vZGUsIHJldEFycikge1xuICAgIGlmIChkb1doaWxlTm9kZS50eXBlICE9PSAnRG9XaGlsZVN0YXRlbWVudCcpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG4gICAgICAgICdJbnZhbGlkIHdoaWxlIHN0YXRlbWVudCcsXG4gICAgICAgIGRvV2hpbGVOb2RlXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldEFyci5wdXNoKCdmb3IgKGxldCBpID0gMDsgaSA8IExPT1BfTUFYOyBpKyspIHsnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoZG9XaGlsZU5vZGUuYm9keSwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnaWYgKCEnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoZG9XaGlsZU5vZGUudGVzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKSB7XFxuJyk7XG4gICAgcmV0QXJyLnB1c2goJ2JyZWFrO1xcbicpO1xuICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcblxuICAgIHJldHVybiByZXRBcnI7XG5cbiAgfVxuXG4gIGFzdEFzc2lnbm1lbnRFeHByZXNzaW9uKGFzc05vZGUsIHJldEFycikge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdGhpcy5nZXREZWNsYXJhdGlvbihhc3NOb2RlLmxlZnQpO1xuICAgIGlmIChkZWNsYXJhdGlvbiAmJiAhZGVjbGFyYXRpb24uYXNzaWduYWJsZSkge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVmFyaWFibGUgJHthc3NOb2RlLmxlZnQubmFtZX0gaXMgbm90IGFzc2lnbmFibGUgaGVyZWAsIGFzc05vZGUpO1xuICAgIH1cbiAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5sZWZ0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKGFzc05vZGUub3BlcmF0b3IpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLnJpZ2h0LCByZXRBcnIpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RCbG9ja1N0YXRlbWVudChiTm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKHRoaXMuaXNTdGF0ZSgnbG9vcC1ib2R5JykpIHtcbiAgICAgIHRoaXMucHVzaFN0YXRlKCdibG9jay1ib2R5Jyk7IFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiTm9kZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhiTm9kZS5ib2R5W2ldLCByZXRBcnIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wb3BTdGF0ZSgnYmxvY2stYm9keScpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaCgne1xcbicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiTm9kZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhiTm9kZS5ib2R5W2ldLCByZXRBcnIpO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdFZhcmlhYmxlRGVjbGFyYXRpb24odmFyRGVjTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goYCR7dmFyRGVjTm9kZS5raW5kfSBgKTtcbiAgICBjb25zdCB7IGRlY2xhcmF0aW9ucyB9ID0gdmFyRGVjTm9kZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHJldEFyci5wdXNoKCcsJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uc1tpXTtcbiAgICAgIGNvbnN0IGluZm8gPSB0aGlzLmdldERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLmlkKTtcbiAgICAgIGlmICghaW5mby52YWx1ZVR5cGUpIHtcbiAgICAgICAgaW5mby52YWx1ZVR5cGUgPSB0aGlzLmdldFR5cGUoZGVjbGFyYXRpb24uaW5pdCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZGVjbGFyYXRpb24sIHJldEFycik7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1N0YXRlKCdpbi1mb3ItbG9vcC1pbml0JykpIHtcbiAgICAgIHJldEFyci5wdXNoKCc7Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RJZlN0YXRlbWVudChpZk5vZGUsIHJldEFycikge1xuICAgIHJldEFyci5wdXNoKCdpZiAoJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgaWYgKGlmTm9kZS5jb25zZXF1ZW50LnR5cGUgPT09ICdCbG9ja1N0YXRlbWVudCcpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goJyB7XFxuJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmNvbnNlcXVlbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnXFxufVxcbicpO1xuICAgIH1cblxuICAgIGlmIChpZk5vZGUuYWx0ZXJuYXRlKSB7XG4gICAgICByZXRBcnIucHVzaCgnZWxzZSAnKTtcbiAgICAgIGlmIChpZk5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09ICdCbG9ja1N0YXRlbWVudCcgfHwgaWZOb2RlLmFsdGVybmF0ZS50eXBlID09PSAnSWZTdGF0ZW1lbnQnKSB7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuYWx0ZXJuYXRlLCByZXRBcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0QXJyLnB1c2goJyB7XFxuJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuYWx0ZXJuYXRlLCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnXFxufVxcbicpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuXG4gIH1cblxuICBhc3RTd2l0Y2hTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICBjb25zdCB7IGRpc2NyaW1pbmFudCwgY2FzZXMgfSA9IGFzdDtcbiAgICByZXRBcnIucHVzaCgnc3dpdGNoICgnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoZGlzY3JpbWluYW50LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpIHtcXG4nKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2FzZXNbaV0udGVzdCA9PT0gbnVsbCkge1xuICAgICAgICByZXRBcnIucHVzaCgnZGVmYXVsdDpcXG4nKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGNhc2VzW2ldLmNvbnNlcXVlbnQsIHJldEFycik7XG4gICAgICAgIGlmIChjYXNlc1tpXS5jb25zZXF1ZW50ICYmIGNhc2VzW2ldLmNvbnNlcXVlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldEFyci5wdXNoKCdicmVhaztcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldEFyci5wdXNoKCdjYXNlICcpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGNhc2VzW2ldLnRlc3QsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnOlxcbicpO1xuICAgICAgaWYgKGNhc2VzW2ldLmNvbnNlcXVlbnQgJiYgY2FzZXNbaV0uY29uc2VxdWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhjYXNlc1tpXS5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnYnJlYWs7XFxuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCdcXG59Jyk7XG4gIH1cblxuICBhc3RUaGlzRXhwcmVzc2lvbih0Tm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJ190aGlzJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdE1lbWJlckV4cHJlc3Npb24obU5vZGUsIHJldEFycikge1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wZXJ0eSxcbiAgICAgIHhQcm9wZXJ0eSxcbiAgICAgIHlQcm9wZXJ0eSxcbiAgICAgIHpQcm9wZXJ0eSxcbiAgICAgIG5hbWUsXG4gICAgICBvcmlnaW5cbiAgICB9ID0gdGhpcy5nZXRNZW1iZXJFeHByZXNzaW9uRGV0YWlscyhtTm9kZSk7XG4gICAgc3dpdGNoIChzaWduYXR1cmUpIHtcbiAgICAgIGNhc2UgJ3RoaXMudGhyZWFkLnZhbHVlJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYF90aGlzLnRocmVhZC4keyBuYW1lIH1gKTtcbiAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgIGNhc2UgJ3RoaXMub3V0cHV0LnZhbHVlJzpcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnb3V0cHV0WCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnb3V0cHV0WScpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnb3V0cHV0WicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIG1Ob2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBtTm9kZSk7XG4gICAgICBjYXNlICd2YWx1ZVtdJzpcbiAgICAgIGNhc2UgJ3ZhbHVlW11bXSc6XG4gICAgICBjYXNlICd2YWx1ZVtdW11bXSc6XG4gICAgICBjYXNlICd2YWx1ZS52YWx1ZSc6XG4gICAgICAgIGlmIChvcmlnaW4gPT09ICdNYXRoJykge1xuICAgICAgICAgIHJldEFyci5wdXNoKE1hdGhbbmFtZV0pO1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHsgbmFtZSB9WzBdYCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHsgbmFtZSB9WzFdYCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHsgbmFtZSB9WzJdYCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHsgbmFtZSB9WzNdYCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndmFsdWUudmFsdWVbXSc6IFxuICAgICAgICBpZiAodGhpcy5yZW1vdmVJc3RhbmJ1bENvdmVyYWdlKSB7XG4gICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgfVxuICAgICAgICByZXRBcnIucHVzaChgJHttTm9kZS5vYmplY3Qub2JqZWN0Lm5hbWV9LiR7bU5vZGUub2JqZWN0LnByb3BlcnR5Lm5hbWV9WyR7bU5vZGUucHJvcGVydHkudmFsdWV9XWApO1xuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgY2FzZSAndmFsdWUudmFsdWVbXVtdJzogXG4gICAgICAgIGlmICh0aGlzLnJlbW92ZUlzdGFuYnVsQ292ZXJhZ2UpIHtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldEFyci5wdXNoKGAke21Ob2RlLm9iamVjdC5vYmplY3Qub2JqZWN0Lm5hbWV9LiR7bU5vZGUub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lfVske21Ob2RlLm9iamVjdC5wcm9wZXJ0eS52YWx1ZX1dWyR7bU5vZGUucHJvcGVydHkudmFsdWV9XWApO1xuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWUnOlxuICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXSc6XG4gICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW10nOlxuICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW10nOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ZuKClbXSc6XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5vYmplY3QsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5wcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIG1Ob2RlKTtcbiAgICB9XG5cbiAgICBpZiAoIW1Ob2RlLmNvbXB1dGVkKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgICAgcmV0QXJyLnB1c2goYCR7b3JpZ2lufV8ke25hbWV9YCk7XG4gICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtYXJrdXBOYW1lID0gYCR7b3JpZ2lufV8ke25hbWV9YDtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgY2FzZSAnSFRNTEltYWdlQXJyYXknOlxuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoMyknOlxuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcbiAgICAgIGNhc2UgJ0hUTUxJbWFnZSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZXQgc2l6ZTtcbiAgICAgICAgbGV0IGlzSW5wdXQ7XG4gICAgICAgIGlmIChvcmlnaW4gPT09ICdjb25zdGFudHMnKSB7XG4gICAgICAgICAgY29uc3QgY29uc3RhbnQgPSB0aGlzLmNvbnN0YW50c1tuYW1lXTtcbiAgICAgICAgICBpc0lucHV0ID0gdGhpcy5jb25zdGFudFR5cGVzW25hbWVdID09PSAnSW5wdXQnO1xuICAgICAgICAgIHNpemUgPSBpc0lucHV0ID8gY29uc3RhbnQuc2l6ZSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNJbnB1dCA9IHRoaXMuaXNJbnB1dChuYW1lKTtcbiAgICAgICAgICBzaXplID0gaXNJbnB1dCA/IHRoaXMuYXJndW1lbnRTaXplc1t0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihuYW1lKV0gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldEFyci5wdXNoKGAkeyBtYXJrdXBOYW1lIH1gKTtcbiAgICAgICAgaWYgKHpQcm9wZXJ0eSAmJiB5UHJvcGVydHkpIHtcbiAgICAgICAgICBpZiAoaXNJbnB1dCkge1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ1soJyk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goYCokeyB0aGlzLmR5bmFtaWNBcmd1bWVudHMgPyAnKG91dHB1dFkgKiBvdXRwdXRYKScgOiBzaXplWzFdICogc2l6ZVswXSB9KSsoYCk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoeVByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goYCokeyB0aGlzLmR5bmFtaWNBcmd1bWVudHMgPyAnb3V0cHV0WCcgOiBzaXplWzBdIH0pK2ApO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHhQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoeVByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoeFByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoeVByb3BlcnR5KSB7XG4gICAgICAgICAgaWYgKGlzSW5wdXQpIHtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdbKCcpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHlQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGAqJHsgdGhpcy5keW5hbWljQXJndW1lbnRzID8gJ291dHB1dFgnIDogc2l6ZVswXSB9KStgKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh4UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHlQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHhQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB4UHJvcGVydHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoeFByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdENhbGxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnQ2FsbEV4cHJlc3Npb24nKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmtub3duIENhbGxFeHByZXNzaW9uJywgYXN0KTtcbiAgICB9XG4gICAgbGV0IGZ1bmN0aW9uTmFtZSA9IHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChhc3QuY2FsbGVlKTtcblxuICAgIGlmICh0aGlzLmNhbGxlZEZ1bmN0aW9ucy5pbmRleE9mKGZ1bmN0aW9uTmFtZSkgPCAwKSB7XG4gICAgICB0aGlzLmNhbGxlZEZ1bmN0aW9ucy5wdXNoKGZ1bmN0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNNYXRoRnVuY3Rpb24gPSB0aGlzLmlzQXN0TWF0aEZ1bmN0aW9uKGFzdCk7XG5cbiAgICBpZiAodGhpcy5vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgdGhpcy5vbkZ1bmN0aW9uQ2FsbCh0aGlzLm5hbWUsIGZ1bmN0aW9uTmFtZSwgYXN0LmFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0QXJyLnB1c2goZnVuY3Rpb25OYW1lKTtcblxuICAgIHJldEFyci5wdXNoKCcoJyk7XG4gICAgY29uc3QgdGFyZ2V0VHlwZXMgPSB0aGlzLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyhmdW5jdGlvbk5hbWUpIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LmFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgYXJndW1lbnQgPSBhc3QuYXJndW1lbnRzW2ldO1xuXG4gICAgICBsZXQgYXJndW1lbnRUeXBlID0gdGhpcy5nZXRUeXBlKGFyZ3VtZW50KTtcbiAgICAgIGlmICghdGFyZ2V0VHlwZXNbaV0pIHtcbiAgICAgICAgdGhpcy50cmlnZ2VySW1wbHlBcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpLCBhcmd1bWVudFR5cGUsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgcmV0QXJyLnB1c2goJywgJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcpJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0QXJyYXlFeHByZXNzaW9uKGFyck5vZGUsIHJldEFycikge1xuICAgIGNvbnN0IGFyckxlbiA9IGFyck5vZGUuZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgcmV0QXJyLnB1c2goJ25ldyBGbG9hdDMyQXJyYXkoWycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyTGVuOyArK2kpIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICByZXRBcnIucHVzaCgnLCAnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1Yk5vZGUgPSBhcnJOb2RlLmVsZW1lbnRzW2ldO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKHN1Yk5vZGUsIHJldEFycilcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJ10pJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0RGVidWdnZXJTdGF0ZW1lbnQoYXJyTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJ2RlYnVnZ2VyOycpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENQVUZ1bmN0aW9uTm9kZVxufTtcbn0se1wiLi4vZnVuY3Rpb24tbm9kZVwiOjEwfV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBjb25zdGFudHNUb1N0cmluZyhjb25zdGFudHMsIHR5cGVzKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChjb25zdCBuYW1lIGluIHR5cGVzKSB7XG4gICAgaWYgKCF0eXBlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgY29udGludWU7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVzW25hbWVdO1xuICAgIGNvbnN0IGNvbnN0YW50ID0gY29uc3RhbnRzW25hbWVdO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgIHJlc3VsdHMucHVzaChgJHtuYW1lfToke2NvbnN0YW50fWApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgcmVzdWx0cy5wdXNoKGAke25hbWV9Om5ldyAke2NvbnN0YW50LmNvbnN0cnVjdG9yLm5hbWV9KCR7SlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbShjb25zdGFudCkpfSlgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBgeyAkeyByZXN1bHRzLmpvaW4oKSB9IH1gO1xufVxuXG5mdW5jdGlvbiBjcHVLZXJuZWxTdHJpbmcoY3B1S2VybmVsLCBuYW1lKSB7XG4gIGNvbnN0IGhlYWRlciA9IFtdO1xuICBjb25zdCB0aGlzUHJvcGVydGllcyA9IFtdO1xuICBjb25zdCBiZWZvcmVSZXR1cm4gPSBbXTtcblxuICBjb25zdCB1c2VGdW5jdGlvbktleXdvcmQgPSAhL15mdW5jdGlvbi8udGVzdChjcHVLZXJuZWwuY29sb3IudG9TdHJpbmcoKSk7XG5cbiAgaGVhZGVyLnB1c2goXG4gICAgJyAgY29uc3QgeyBjb250ZXh0LCBjYW52YXMsIGNvbnN0YW50czogaW5jb21pbmdDb25zdGFudHMgfSA9IHNldHRpbmdzOycsXG4gICAgYCAgY29uc3Qgb3V0cHV0ID0gbmV3IEludDMyQXJyYXkoJHtKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKGNwdUtlcm5lbC5vdXRwdXQpKX0pO2AsXG4gICAgYCAgY29uc3QgX2NvbnN0YW50VHlwZXMgPSAke0pTT04uc3RyaW5naWZ5KGNwdUtlcm5lbC5jb25zdGFudFR5cGVzKX07YCxcbiAgICBgICBjb25zdCBfY29uc3RhbnRzID0gJHtjb25zdGFudHNUb1N0cmluZyhjcHVLZXJuZWwuY29uc3RhbnRzLCBjcHVLZXJuZWwuY29uc3RhbnRUeXBlcyl9O2AsXG4gICk7XG5cbiAgdGhpc1Byb3BlcnRpZXMucHVzaChcbiAgICAnICAgIGNvbnN0YW50czogX2NvbnN0YW50cywnLFxuICAgICcgICAgY29udGV4dCwnLFxuICAgICcgICAgb3V0cHV0LCcsXG4gICAgJyAgICB0aHJlYWQ6IHt4OiAwLCB5OiAwLCB6OiAwfSwnLFxuICApO1xuXG4gIGlmIChjcHVLZXJuZWwuZ3JhcGhpY2FsKSB7XG4gICAgaGVhZGVyLnB1c2goYCAgY29uc3QgX2ltYWdlRGF0YSA9IGNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKCR7Y3B1S2VybmVsLm91dHB1dFswXX0sICR7Y3B1S2VybmVsLm91dHB1dFsxXX0pO2ApO1xuICAgIGhlYWRlci5wdXNoKGAgIGNvbnN0IF9jb2xvckRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoJHtjcHVLZXJuZWwub3V0cHV0WzBdfSAqICR7Y3B1S2VybmVsLm91dHB1dFsxXX0gKiA0KTtgKTtcblxuICAgIGNvbnN0IGNvbG9yRm4gPSB1dGlscy5mbGF0dGVuRnVuY3Rpb25Ub1N0cmluZygodXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJykgKyBjcHVLZXJuZWwuY29sb3IudG9TdHJpbmcoKSwge1xuICAgICAgdGhpc0xvb2t1cDogKHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIGNhc2UgJ19jb2xvckRhdGEnOlxuICAgICAgICAgICAgcmV0dXJuICdfY29sb3JEYXRhJztcbiAgICAgICAgICBjYXNlICdfaW1hZ2VEYXRhJzpcbiAgICAgICAgICAgIHJldHVybiAnX2ltYWdlRGF0YSc7XG4gICAgICAgICAgY2FzZSAnb3V0cHV0JzpcbiAgICAgICAgICAgIHJldHVybiAnb3V0cHV0JztcbiAgICAgICAgICBjYXNlICd0aHJlYWQnOlxuICAgICAgICAgICAgcmV0dXJuICd0aGlzLnRocmVhZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNwdUtlcm5lbFtwcm9wZXJ0eU5hbWVdKTtcbiAgICAgIH0sXG4gICAgICBmaW5kRGVwZW5kZW5jeTogKG9iamVjdCwgbmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGdldFBpeGVsc0ZuID0gdXRpbHMuZmxhdHRlbkZ1bmN0aW9uVG9TdHJpbmcoKHVzZUZ1bmN0aW9uS2V5d29yZCA/ICdmdW5jdGlvbiAnIDogJycpICsgY3B1S2VybmVsLmdldFBpeGVscy50b1N0cmluZygpLCB7XG4gICAgICB0aGlzTG9va3VwOiAocHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgY2FzZSAnX2NvbG9yRGF0YSc6XG4gICAgICAgICAgICByZXR1cm4gJ19jb2xvckRhdGEnO1xuICAgICAgICAgIGNhc2UgJ19pbWFnZURhdGEnOlxuICAgICAgICAgICAgcmV0dXJuICdfaW1hZ2VEYXRhJztcbiAgICAgICAgICBjYXNlICdvdXRwdXQnOlxuICAgICAgICAgICAgcmV0dXJuICdvdXRwdXQnO1xuICAgICAgICAgIGNhc2UgJ3RocmVhZCc6XG4gICAgICAgICAgICByZXR1cm4gJ3RoaXMudGhyZWFkJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY3B1S2VybmVsW3Byb3BlcnR5TmFtZV0pO1xuICAgICAgfSxcbiAgICAgIGZpbmREZXBlbmRlbmN5OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpc1Byb3BlcnRpZXMucHVzaChcbiAgICAgICcgICAgX2ltYWdlRGF0YSwnLFxuICAgICAgJyAgICBfY29sb3JEYXRhLCcsXG4gICAgICBgICAgIGNvbG9yOiAke2NvbG9yRm59LGAsXG4gICAgKTtcblxuICAgIGJlZm9yZVJldHVybi5wdXNoKFxuICAgICAgYCAga2VybmVsLmdldFBpeGVscyA9ICR7Z2V0UGl4ZWxzRm59O2BcbiAgICApO1xuICB9XG5cbiAgY29uc3QgY29uc3RhbnRUeXBlcyA9IFtdO1xuICBjb25zdCBjb25zdGFudEtleXMgPSBPYmplY3Qua2V5cyhjcHVLZXJuZWwuY29uc3RhbnRUeXBlcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29uc3RhbnRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3RhbnRUeXBlcy5wdXNoKGNwdUtlcm5lbC5jb25zdGFudFR5cGVzW2NvbnN0YW50S2V5c10pO1xuICB9XG4gIGlmIChjcHVLZXJuZWwuYXJndW1lbnRUeXBlcy5pbmRleE9mKCdIVE1MSW1hZ2VBcnJheScpICE9PSAtMSB8fCBjb25zdGFudFR5cGVzLmluZGV4T2YoJ0hUTUxJbWFnZUFycmF5JykgIT09IC0xKSB7XG4gICAgY29uc3QgZmxhdHRlbmVkSW1hZ2VUbzNEQXJyYXkgPSB1dGlscy5mbGF0dGVuRnVuY3Rpb25Ub1N0cmluZygodXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJykgKyBjcHVLZXJuZWwuX2ltYWdlVG8zREFycmF5LnRvU3RyaW5nKCksIHtcbiAgICAgIGRvTm90RGVmaW5lOiBbJ2NhbnZhcyddLFxuICAgICAgZmluZERlcGVuZGVuY3k6IChvYmplY3QsIG5hbWUpID0+IHtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gJ3RoaXMnKSB7XG4gICAgICAgICAgcmV0dXJuICh1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnKSArIGNwdUtlcm5lbFtuYW1lXS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHRoaXNMb29rdXA6IChwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICBjYXNlICdjYW52YXMnOlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgJ2NvbnRleHQnOlxuICAgICAgICAgICAgcmV0dXJuICdjb250ZXh0JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGJlZm9yZVJldHVybi5wdXNoKGZsYXR0ZW5lZEltYWdlVG8zREFycmF5KTtcbiAgICB0aGlzUHJvcGVydGllcy5wdXNoKGAgICAgX21lZGlhVG8yREFycmF5LGApO1xuICAgIHRoaXNQcm9wZXJ0aWVzLnB1c2goYCAgICBfaW1hZ2VUbzNEQXJyYXksYCk7XG4gIH0gZWxzZSBpZiAoY3B1S2VybmVsLmFyZ3VtZW50VHlwZXMuaW5kZXhPZignSFRNTEltYWdlJykgIT09IC0xIHx8IGNvbnN0YW50VHlwZXMuaW5kZXhPZignSFRNTEltYWdlJykgIT09IC0xKSB7XG4gICAgY29uc3QgZmxhdHRlbmVkSW1hZ2VUbzJEQXJyYXkgPSB1dGlscy5mbGF0dGVuRnVuY3Rpb25Ub1N0cmluZygodXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJykgKyBjcHVLZXJuZWwuX21lZGlhVG8yREFycmF5LnRvU3RyaW5nKCksIHtcbiAgICAgIGZpbmREZXBlbmRlbmN5OiAob2JqZWN0LCBuYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHRoaXNMb29rdXA6IChwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICBjYXNlICdjYW52YXMnOlxuICAgICAgICAgICAgcmV0dXJuICdzZXR0aW5ncy5jYW52YXMnO1xuICAgICAgICAgIGNhc2UgJ2NvbnRleHQnOlxuICAgICAgICAgICAgcmV0dXJuICdzZXR0aW5ncy5jb250ZXh0JztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaGFuZGxlZCB0aGlzTG9va3VwJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYmVmb3JlUmV0dXJuLnB1c2goZmxhdHRlbmVkSW1hZ2VUbzJEQXJyYXkpO1xuICAgIHRoaXNQcm9wZXJ0aWVzLnB1c2goYCAgICBfbWVkaWFUbzJEQXJyYXksYCk7XG4gIH1cblxuICByZXR1cm4gYGZ1bmN0aW9uKHNldHRpbmdzKSB7XG4keyBoZWFkZXIuam9pbignXFxuJykgfVxuICBmb3IgKGNvbnN0IHAgaW4gX2NvbnN0YW50VHlwZXMpIHtcbiAgICBpZiAoIV9jb25zdGFudFR5cGVzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICBjb25zdCB0eXBlID0gX2NvbnN0YW50VHlwZXNbcF07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgaWYgKGluY29taW5nQ29uc3RhbnRzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdjb25zdGFudCAnICsgcCArICcgb2YgdHlwZSAnICsgdHlwZSArICcgY2Fubm90IGJlIHJlc2lnbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghaW5jb21pbmdDb25zdGFudHMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY29uc3RhbnQgJyArIHAgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBfY29uc3RhbnRzW3BdID0gaW5jb21pbmdDb25zdGFudHNbcF07XG4gIH1cbiAgY29uc3Qga2VybmVsID0gKGZ1bmN0aW9uKCkge1xuJHtjcHVLZXJuZWwuX2tlcm5lbFN0cmluZ31cbiAgfSlcbiAgICAuYXBwbHkoeyAke3RoaXNQcm9wZXJ0aWVzLmpvaW4oJ1xcbicpfSB9KTtcbiAgJHsgYmVmb3JlUmV0dXJuLmpvaW4oJ1xcbicpIH1cbiAgcmV0dXJuIGtlcm5lbDtcbn1gO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3B1S2VybmVsU3RyaW5nXG59O1xufSx7XCIuLi8uLi91dGlsc1wiOjExNH1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBLZXJuZWwgfSA9IHJlcXVpcmUoJy4uL2tlcm5lbCcpO1xuY29uc3QgeyBGdW5jdGlvbkJ1aWxkZXIgfSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uLWJ1aWxkZXInKTtcbmNvbnN0IHsgQ1BVRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uLW5vZGUnKTtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IGNwdUtlcm5lbFN0cmluZyB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtc3RyaW5nJyk7XG5cbmNsYXNzIENQVUtlcm5lbCBleHRlbmRzIEtlcm5lbCB7XG4gIHN0YXRpYyBnZXRGZWF0dXJlcygpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlcztcbiAgfVxuICBzdGF0aWMgZ2V0IGZlYXR1cmVzKCkge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgIGtlcm5lbE1hcDogdHJ1ZSxcbiAgICAgIGlzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0NvbnRleHRNYXRjaChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBnZXQgbW9kZSgpIHtcbiAgICByZXR1cm4gJ2NwdSc7XG4gIH1cblxuICBzdGF0aWMgbmF0aXZlRnVuY3Rpb25Bcmd1bWVudHMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzdGF0aWMgbmF0aXZlRnVuY3Rpb25SZXR1cm5UeXBlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTG9va2luZyB1cCBuYXRpdmUgZnVuY3Rpb24gcmV0dXJuIHR5cGUgbm90IHN1cHBvcnRlZCBvbiAke3RoaXMubmFtZX1gKTtcbiAgfVxuXG4gIHN0YXRpYyBjb21iaW5lS2VybmVscyhjb21iaW5lZEtlcm5lbCkge1xuICAgIHJldHVybiBjb21iaW5lZEtlcm5lbDtcbiAgfVxuXG4gIHN0YXRpYyBnZXRTaWduYXR1cmUoa2VybmVsLCBhcmd1bWVudFR5cGVzKSB7XG4gICAgcmV0dXJuICdjcHUnICsgKGFyZ3VtZW50VHlwZXMubGVuZ3RoID4gMCA/ICc6JyArIGFyZ3VtZW50VHlwZXMuam9pbignLCcpIDogJycpO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioc291cmNlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHNvdXJjZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMubWVyZ2VTZXR0aW5ncyhzb3VyY2Uuc2V0dGluZ3MgfHwgc2V0dGluZ3MpO1xuXG4gICAgdGhpcy5faW1hZ2VEYXRhID0gbnVsbDtcbiAgICB0aGlzLl9jb2xvckRhdGEgPSBudWxsO1xuICAgIHRoaXMuX2tlcm5lbFN0cmluZyA9IG51bGw7XG4gICAgdGhpcy5fcHJlcGVuZGVkU3RyaW5nID0gW107XG4gICAgdGhpcy50aHJlYWQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHo6IDBcbiAgICB9O1xuICAgIHRoaXMudHJhbnNsYXRlZFNvdXJjZXMgPSBudWxsO1xuICB9XG5cbiAgaW5pdENhbnZhcygpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuICAgIH1cbiAgfVxuXG4gIGluaXRDb250ZXh0KCkge1xuICAgIGlmICghdGhpcy5jYW52YXMpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICB9XG5cbiAgaW5pdFBsdWdpbnMoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YWxpZGF0ZVNldHRpbmdzKGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMub3V0cHV0IHx8IHRoaXMub3V0cHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0byBvdXRwdXQgb25seSBzdXBwb3J0ZWQgZm9yIGtlcm5lbHMgd2l0aCBvbmx5IG9uZSBpbnB1dCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhcmdUeXBlID0gdXRpbHMuZ2V0VmFyaWFibGVUeXBlKGFyZ3NbMF0sIHRoaXMuc3RyaWN0SW50ZWdlcnMpO1xuICAgICAgaWYgKGFyZ1R5cGUgPT09ICdBcnJheScpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSB1dGlscy5nZXREaW1lbnNpb25zKGFyZ1R5cGUpO1xuICAgICAgfSBlbHNlIGlmIChhcmdUeXBlID09PSAnTnVtYmVyVGV4dHVyZScgfHwgYXJnVHlwZSA9PT0gJ0FycmF5VGV4dHVyZSg0KScpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBhcmdzWzBdLm91dHB1dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0byBvdXRwdXQgbm90IHN1cHBvcnRlZCBmb3IgaW5wdXQgdHlwZTogJyArIGFyZ1R5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgaWYgKHRoaXMub3V0cHV0Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dHB1dCBtdXN0IGhhdmUgMiBkaW1lbnNpb25zIG9uIGdyYXBoaWNhbCBtb2RlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja091dHB1dCgpO1xuICB9XG5cbiAgdHJhbnNsYXRlU291cmNlKCkge1xuICAgIHRoaXMubGVhZGluZ1JldHVyblN0YXRlbWVudCA9IHRoaXMub3V0cHV0Lmxlbmd0aCA+IDEgPyAncmVzdWx0WFt4XSA9ICcgOiAncmVzdWx0W3hdID0gJztcbiAgICBpZiAodGhpcy5zdWJLZXJuZWxzKSB7XG4gICAgICBjb25zdCBmb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH0gPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICAgIGZvbGxvd2luZ1JldHVyblN0YXRlbWVudC5wdXNoKHRoaXMub3V0cHV0Lmxlbmd0aCA+IDEgPyBgcmVzdWx0WF8keyBuYW1lIH1beF0gPSBzdWJLZXJuZWxSZXN1bHRfJHsgbmFtZSB9O1xcbmAgOiBgcmVzdWx0XyR7IG5hbWUgfVt4XSA9IHN1Yktlcm5lbFJlc3VsdF8keyBuYW1lIH07XFxuYCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvbGxvd2luZ1JldHVyblN0YXRlbWVudCA9IGZvbGxvd2luZ1JldHVyblN0YXRlbWVudC5qb2luKCcnKTtcbiAgICB9XG4gICAgY29uc3QgZnVuY3Rpb25CdWlsZGVyID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgQ1BVRnVuY3Rpb25Ob2RlKTtcbiAgICB0aGlzLnRyYW5zbGF0ZWRTb3VyY2VzID0gZnVuY3Rpb25CdWlsZGVyLmdldFByb3RvdHlwZXMoJ2tlcm5lbCcpO1xuICAgIGlmICghdGhpcy5ncmFwaGljYWwgJiYgIXRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgdGhpcy5yZXR1cm5UeXBlID0gZnVuY3Rpb25CdWlsZGVyLmdldEtlcm5lbFJlc3VsdFR5cGUoKTtcbiAgICB9XG4gIH1cblxuICBidWlsZCgpIHtcbiAgICBpZiAodGhpcy5idWlsdCkgcmV0dXJuO1xuICAgIHRoaXMuc2V0dXBDb25zdGFudHMoKTtcbiAgICB0aGlzLnNldHVwQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgdGhpcy52YWxpZGF0ZVNldHRpbmdzKGFyZ3VtZW50cyk7XG4gICAgdGhpcy50cmFuc2xhdGVTb3VyY2UoKTtcblxuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjYW52YXMsXG4gICAgICAgIG91dHB1dFxuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGNhbnZhcyBhdmFpbGFibGUgZm9yIHVzaW5nIGdyYXBoaWNhbCBvdXRwdXQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdpZHRoID0gb3V0cHV0WzBdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gb3V0cHV0WzFdIHx8IDE7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLl9pbWFnZURhdGEgPSB0aGlzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5fY29sb3JEYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgfVxuXG4gICAgY29uc3Qga2VybmVsU3RyaW5nID0gdGhpcy5nZXRLZXJuZWxTdHJpbmcoKTtcbiAgICB0aGlzLmtlcm5lbFN0cmluZyA9IGtlcm5lbFN0cmluZztcblxuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZygnRnVuY3Rpb24gb3V0cHV0OicpO1xuICAgICAgY29uc29sZS5sb2coa2VybmVsU3RyaW5nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5ydW4gPSBuZXcgRnVuY3Rpb24oW10sIGtlcm5lbFN0cmluZykuYmluZCh0aGlzKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIGNvbXBpbGluZyB0aGUgamF2YXNjcmlwdDogJywgZSk7XG4gICAgfVxuICAgIHRoaXMuYnVpbGRTaWduYXR1cmUoYXJndW1lbnRzKTtcbiAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbG9yKHIsIGcsIGIsIGEpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhID0gMTtcbiAgICB9XG5cbiAgICByID0gTWF0aC5mbG9vcihyICogMjU1KTtcbiAgICBnID0gTWF0aC5mbG9vcihnICogMjU1KTtcbiAgICBiID0gTWF0aC5mbG9vcihiICogMjU1KTtcbiAgICBhID0gTWF0aC5mbG9vcihhICogMjU1KTtcblxuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5vdXRwdXRbMV07XG5cbiAgICBjb25zdCB4ID0gdGhpcy50aHJlYWQueDtcbiAgICBjb25zdCB5ID0gaGVpZ2h0IC0gdGhpcy50aHJlYWQueSAtIDE7XG5cbiAgICBjb25zdCBpbmRleCA9IHggKyB5ICogd2lkdGg7XG5cbiAgICB0aGlzLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgMF0gPSByO1xuICAgIHRoaXMuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAxXSA9IGc7XG4gICAgdGhpcy5fY29sb3JEYXRhW2luZGV4ICogNCArIDJdID0gYjtcbiAgICB0aGlzLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgM10gPSBhO1xuICB9XG5cbiAgZ2V0S2VybmVsU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLl9rZXJuZWxTdHJpbmcgIT09IG51bGwpIHJldHVybiB0aGlzLl9rZXJuZWxTdHJpbmc7XG5cbiAgICBsZXQga2VybmVsVGhyZWFkU3RyaW5nID0gbnVsbDtcbiAgICBsZXQge1xuICAgICAgdHJhbnNsYXRlZFNvdXJjZXNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAodHJhbnNsYXRlZFNvdXJjZXMubGVuZ3RoID4gMSkge1xuICAgICAgdHJhbnNsYXRlZFNvdXJjZXMgPSB0cmFuc2xhdGVkU291cmNlcy5maWx0ZXIoZm4gPT4ge1xuICAgICAgICBpZiAoL15mdW5jdGlvbi8udGVzdChmbikpIHJldHVybiBmbjtcbiAgICAgICAga2VybmVsVGhyZWFkU3RyaW5nID0gZm47XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXJuZWxUaHJlYWRTdHJpbmcgPSB0cmFuc2xhdGVkU291cmNlcy5zaGlmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fa2VybmVsU3RyaW5nID0gYCAgY29uc3QgTE9PUF9NQVggPSAkeyB0aGlzLl9nZXRMb29wTWF4U3RyaW5nKCkgfTtcbiAgJHsgdGhpcy5pbmplY3RlZE5hdGl2ZSB8fCAnJyB9XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgJHsgdGhpcy5fcmVzdWx0S2VybmVsSGVhZGVyKCkgfVxuICAkeyB0aGlzLl9wcm9jZXNzQ29uc3RhbnRzKCkgfVxuICByZXR1cm4gKCR7IHRoaXMuYXJndW1lbnROYW1lcy5tYXAoYXJndW1lbnROYW1lID0+ICd1c2VyXycgKyBhcmd1bWVudE5hbWUpLmpvaW4oJywgJykgfSkgPT4ge1xuICAgICR7IHRoaXMuX3ByZXBlbmRlZFN0cmluZy5qb2luKCcnKSB9XG4gICAgJHsgdGhpcy5fZWFybHlUaHJvd3MoKSB9XG4gICAgJHsgdGhpcy5fcHJvY2Vzc0FyZ3VtZW50cygpIH1cbiAgICAkeyB0aGlzLmdyYXBoaWNhbCA/IHRoaXMuX2dyYXBoaWNhbEtlcm5lbEJvZHkoa2VybmVsVGhyZWFkU3RyaW5nKSA6IHRoaXMuX3Jlc3VsdEtlcm5lbEJvZHkoa2VybmVsVGhyZWFkU3RyaW5nKSB9XG4gICAgJHsgdHJhbnNsYXRlZFNvdXJjZXMubGVuZ3RoID4gMCA/IHRyYW5zbGF0ZWRTb3VyY2VzLmpvaW4oJ1xcbicpIDogJycgfVxuICB9O2A7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gY3B1S2VybmVsU3RyaW5nKHRoaXMpO1xuICB9XG5cbiAgX2dldExvb3BNYXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9vcE1heEl0ZXJhdGlvbnMgP1xuICAgICAgYCAkeyBwYXJzZUludCh0aGlzLmxvb3BNYXhJdGVyYXRpb25zKSB9O2AgOlxuICAgICAgJyAxMDAwOydcbiAgICApO1xuICB9XG5cbiAgX3Byb2Nlc3NDb25zdGFudHMoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0YW50cykgcmV0dXJuICcnO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgcCBpbiB0aGlzLmNvbnN0YW50cykge1xuICAgICAgY29uc3QgdHlwZSA9IHRoaXMuY29uc3RhbnRUeXBlc1twXTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdIVE1MQ2FudmFzJzpcbiAgICAgICAgY2FzZSAnSFRNTEltYWdlJzpcbiAgICAgICAgY2FzZSAnSFRNTFZpZGVvJzpcbiAgICAgICAgICByZXN1bHQucHVzaChgICAgIGNvbnN0IGNvbnN0YW50c18ke3B9ID0gdGhpcy5fbWVkaWFUbzJEQXJyYXkodGhpcy5jb25zdGFudHMuJHtwfSk7XFxuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0hUTUxJbWFnZUFycmF5JzpcbiAgICAgICAgICByZXN1bHQucHVzaChgICAgIGNvbnN0IGNvbnN0YW50c18ke3B9ID0gdGhpcy5faW1hZ2VUbzNEQXJyYXkodGhpcy5jb25zdGFudHMuJHtwfSk7XFxuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0lucHV0JzpcbiAgICAgICAgICByZXN1bHQucHVzaChgICAgIGNvbnN0IGNvbnN0YW50c18ke3B9ID0gdGhpcy5jb25zdGFudHMuJHtwfS52YWx1ZTtcXG5gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXN1bHQucHVzaChgICAgIGNvbnN0IGNvbnN0YW50c18ke3B9ID0gdGhpcy5jb25zdGFudHMuJHtwfTtcXG5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgfVxuXG4gIF9lYXJseVRocm93cygpIHtcbiAgICBpZiAodGhpcy5ncmFwaGljYWwpIHJldHVybiAnJztcbiAgICBpZiAodGhpcy5pbW11dGFibGUpIHJldHVybiAnJztcbiAgICBpZiAoIXRoaXMucGlwZWxpbmUpIHJldHVybiAnJztcbiAgICBjb25zdCBhcnJheUFyZ3VtZW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hcmd1bWVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5hcmd1bWVudFR5cGVzW2ldID09PSAnQXJyYXknKSB7XG4gICAgICAgIGFycmF5QXJndW1lbnRzLnB1c2godGhpcy5hcmd1bWVudE5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFycmF5QXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIGNvbnN0IGNoZWNrcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlBcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGFyZ3VtZW50TmFtZSA9IGFycmF5QXJndW1lbnRzW2ldO1xuICAgICAgY29uc3QgY2hlY2tTdWJLZXJuZWxzID0gdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYHVzZXJfJHthcmd1bWVudE5hbWV9ID09PSByZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1gKS5qb2luKCcgfHwgJyk7XG4gICAgICBjaGVja3MucHVzaChgdXNlcl8ke2FyZ3VtZW50TmFtZX0gPT09IHJlc3VsdCR7Y2hlY2tTdWJLZXJuZWxzID8gYCB8fCAke2NoZWNrU3ViS2VybmVsc31gIDogJyd9YCk7XG4gICAgfVxuICAgIHJldHVybiBgaWYgKCR7Y2hlY2tzLmpvaW4oJyB8fCAnKX0pIHRocm93IG5ldyBFcnJvcignU291cmNlIGFuZCBkZXN0aW5hdGlvbiBhcnJheXMgYXJlIHRoZSBzYW1lLiAgVXNlIGltbXV0YWJsZSA9IHRydWUnKTtgO1xuICB9XG5cbiAgX3Byb2Nlc3NBcmd1bWVudHMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGB1c2VyXyR7dGhpcy5hcmd1bWVudE5hbWVzW2ldfWA7XG4gICAgICBzd2l0Y2ggKHRoaXMuYXJndW1lbnRUeXBlc1tpXSkge1xuICAgICAgICBjYXNlICdIVE1MQ2FudmFzJzpcbiAgICAgICAgY2FzZSAnSFRNTEltYWdlJzpcbiAgICAgICAgY2FzZSAnSFRNTFZpZGVvJzpcbiAgICAgICAgICByZXN1bHQucHVzaChgICAgICR7dmFyaWFibGVOYW1lfSA9IHRoaXMuX21lZGlhVG8yREFycmF5KCR7dmFyaWFibGVOYW1lfSk7XFxuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0hUTUxJbWFnZUFycmF5JzpcbiAgICAgICAgICByZXN1bHQucHVzaChgICAgICR7dmFyaWFibGVOYW1lfSA9IHRoaXMuX2ltYWdlVG8zREFycmF5KCR7dmFyaWFibGVOYW1lfSk7XFxuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0lucHV0JzpcbiAgICAgICAgICByZXN1bHQucHVzaChgICAgICR7dmFyaWFibGVOYW1lfSA9ICR7dmFyaWFibGVOYW1lfS52YWx1ZTtcXG5gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDIpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcbiAgICAgICAgY2FzZSAnTnVtYmVyVGV4dHVyZSc6XG4gICAgICAgIGNhc2UgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGBcbiAgICBpZiAoJHt2YXJpYWJsZU5hbWV9LnRvQXJyYXkpIHtcbiAgICAgIGlmICghX3RoaXMudGV4dHVyZUNhY2hlKSB7XG4gICAgICAgIF90aGlzLnRleHR1cmVDYWNoZSA9IFtdO1xuICAgICAgICBfdGhpcy5hcnJheUNhY2hlID0gW107XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0dXJlSW5kZXggPSBfdGhpcy50ZXh0dXJlQ2FjaGUuaW5kZXhPZigke3ZhcmlhYmxlTmFtZX0pO1xuICAgICAgaWYgKHRleHR1cmVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgJHt2YXJpYWJsZU5hbWV9ID0gX3RoaXMuYXJyYXlDYWNoZVt0ZXh0dXJlSW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMudGV4dHVyZUNhY2hlLnB1c2goJHt2YXJpYWJsZU5hbWV9KTtcbiAgICAgICAgJHt2YXJpYWJsZU5hbWV9ID0gJHt2YXJpYWJsZU5hbWV9LnRvQXJyYXkoKTtcbiAgICAgICAgX3RoaXMuYXJyYXlDYWNoZS5wdXNoKCR7dmFyaWFibGVOYW1lfSk7XG4gICAgICB9XG4gICAgfWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICB9XG5cbiAgX21lZGlhVG8yREFycmF5KG1lZGlhKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3Qgd2lkdGggPSBtZWRpYS53aWR0aCA+IDAgPyBtZWRpYS53aWR0aCA6IG1lZGlhLnZpZGVvV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gbWVkaWEuaGVpZ2h0ID4gMCA/IG1lZGlhLmhlaWdodCA6IG1lZGlhLnZpZGVvSGVpZ2h0O1xuICAgIGlmIChjYW52YXMud2lkdGggPCB3aWR0aCkge1xuICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgfVxuICAgIGlmIChjYW52YXMuaGVpZ2h0IDwgaGVpZ2h0KSB7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgY3R4LmRyYXdJbWFnZShtZWRpYSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgcGl4ZWxzRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICBjb25zdCBpbWFnZUFycmF5ID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGxldCB5ID0gaGVpZ2h0IC0gMTsgeSA+PSAwOyB5LS0pIHtcbiAgICAgIGNvbnN0IHJvdyA9IGltYWdlQXJyYXlbeV0gPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgIGNvbnN0IHBpeGVsID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICAgICAgcGl4ZWxbMF0gPSBwaXhlbHNEYXRhW2luZGV4KytdIC8gMjU1OyBcbiAgICAgICAgcGl4ZWxbMV0gPSBwaXhlbHNEYXRhW2luZGV4KytdIC8gMjU1OyBcbiAgICAgICAgcGl4ZWxbMl0gPSBwaXhlbHNEYXRhW2luZGV4KytdIC8gMjU1OyBcbiAgICAgICAgcGl4ZWxbM10gPSBwaXhlbHNEYXRhW2luZGV4KytdIC8gMjU1OyBcbiAgICAgICAgcm93W3hdID0gcGl4ZWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbWFnZUFycmF5O1xuICB9XG5cbiAgZ2V0UGl4ZWxzKGZsaXApIHtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLm91dHB1dDtcbiAgICByZXR1cm4gZmxpcCA/IHV0aWxzLmZsaXBQaXhlbHModGhpcy5faW1hZ2VEYXRhLmRhdGEsIHdpZHRoLCBoZWlnaHQpIDogdGhpcy5faW1hZ2VEYXRhLmRhdGEuc2xpY2UoMCk7XG4gIH1cblxuICBfaW1hZ2VUbzNEQXJyYXkoaW1hZ2VzKSB7XG4gICAgY29uc3QgaW1hZ2VzQXJyYXkgPSBuZXcgQXJyYXkoaW1hZ2VzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGltYWdlc0FycmF5W2ldID0gdGhpcy5fbWVkaWFUbzJEQXJyYXkoaW1hZ2VzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGltYWdlc0FycmF5O1xuICB9XG5cbiAgX3Jlc3VsdEtlcm5lbEhlYWRlcigpIHtcbiAgICBpZiAodGhpcy5ncmFwaGljYWwpIHJldHVybiAnJztcbiAgICBpZiAodGhpcy5pbW11dGFibGUpIHJldHVybiAnJztcbiAgICBpZiAoIXRoaXMucGlwZWxpbmUpIHJldHVybiAnJztcbiAgICBzd2l0Y2ggKHRoaXMub3V0cHV0Lmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5fbXV0YWJsZUtlcm5lbDFEUmVzdWx0cygpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5fbXV0YWJsZUtlcm5lbDJEUmVzdWx0cygpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5fbXV0YWJsZUtlcm5lbDNEUmVzdWx0cygpO1xuICAgIH1cbiAgfVxuXG4gIF9yZXN1bHRLZXJuZWxCb2R5KGtlcm5lbFN0cmluZykge1xuICAgIHN3aXRjaCAodGhpcy5vdXRwdXQubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiAoIXRoaXMuaW1tdXRhYmxlICYmIHRoaXMucGlwZWxpbmUgPyB0aGlzLl9yZXN1bHRNdXRhYmxlS2VybmVsMURMb29wKGtlcm5lbFN0cmluZykgOiB0aGlzLl9yZXN1bHRJbW11dGFibGVLZXJuZWwxRExvb3Aoa2VybmVsU3RyaW5nKSkgKyB0aGlzLl9rZXJuZWxPdXRwdXQoKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuICghdGhpcy5pbW11dGFibGUgJiYgdGhpcy5waXBlbGluZSA/IHRoaXMuX3Jlc3VsdE11dGFibGVLZXJuZWwyRExvb3Aoa2VybmVsU3RyaW5nKSA6IHRoaXMuX3Jlc3VsdEltbXV0YWJsZUtlcm5lbDJETG9vcChrZXJuZWxTdHJpbmcpKSArIHRoaXMuX2tlcm5lbE91dHB1dCgpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gKCF0aGlzLmltbXV0YWJsZSAmJiB0aGlzLnBpcGVsaW5lID8gdGhpcy5fcmVzdWx0TXV0YWJsZUtlcm5lbDNETG9vcChrZXJuZWxTdHJpbmcpIDogdGhpcy5fcmVzdWx0SW1tdXRhYmxlS2VybmVsM0RMb29wKGtlcm5lbFN0cmluZykpICsgdGhpcy5fa2VybmVsT3V0cHV0KCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHNpemUga2VybmVsJyk7XG4gICAgfVxuICB9XG5cbiAgX2dyYXBoaWNhbEtlcm5lbEJvZHkoa2VybmVsVGhyZWFkU3RyaW5nKSB7XG4gICAgc3dpdGNoICh0aGlzLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyYXBoaWNhbEtlcm5lbDJETG9vcChrZXJuZWxUaHJlYWRTdHJpbmcpICsgdGhpcy5fZ3JhcGhpY2FsT3V0cHV0KCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHNpemUga2VybmVsJyk7XG4gICAgfVxuICB9XG5cbiAgX2dyYXBoaWNhbE91dHB1dCgpIHtcbiAgICByZXR1cm4gYFxuICAgIHRoaXMuX2ltYWdlRGF0YS5kYXRhLnNldCh0aGlzLl9jb2xvckRhdGEpO1xuICAgIHRoaXMuY29udGV4dC5wdXRJbWFnZURhdGEodGhpcy5faW1hZ2VEYXRhLCAwLCAwKTtcbiAgICByZXR1cm47YFxuICB9XG5cbiAgX2dldEtlcm5lbFJlc3VsdFR5cGVDb25zdHJ1Y3RvclN0cmluZygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICByZXR1cm4gJ0Zsb2F0MzJBcnJheSc7XG4gICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgIHJldHVybiAnQXJyYXknO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICAgICAgcmV0dXJuICdGbG9hdDMyQXJyYXknO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHJldHVyblR5cGUgJHsgdGhpcy5yZXR1cm5UeXBlIH1gKTtcbiAgICB9XG4gIH1cblxuICBfcmVzdWx0SW1tdXRhYmxlS2VybmVsMURMb29wKGtlcm5lbFN0cmluZykge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yU3RyaW5nID0gdGhpcy5fZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCk7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBsZXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH07XFxuYCkuam9pbignICAgICcpIH1cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICB0aGlzLnRocmVhZC55ID0gMDtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9tdXRhYmxlS2VybmVsMURSZXN1bHRzKCkge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yU3RyaW5nID0gdGhpcy5fZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCk7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBsZXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH07XFxuYCkuam9pbignICAgICcpIH1gO1xuICB9XG5cbiAgX3Jlc3VsdE11dGFibGVLZXJuZWwxRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBvdXRwdXRYOyB4KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgdGhpcy50aHJlYWQueSA9IDA7XG4gICAgICB0aGlzLnRocmVhZC56ID0gMDtcbiAgICAgICR7IGtlcm5lbFN0cmluZyB9XG4gICAgfWA7XG4gIH1cblxuICBfcmVzdWx0SW1tdXRhYmxlS2VybmVsMkRMb29wKGtlcm5lbFN0cmluZykge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yU3RyaW5nID0gdGhpcy5fZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCk7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3Qgb3V0cHV0WSA9IF90aGlzLm91dHB1dFsxXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkob3V0cHV0WSk7XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3IEFycmF5KG91dHB1dFkpO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0cHV0WTsgeSsrKSB7XG4gICAgICB0aGlzLnRocmVhZC56ID0gMDtcbiAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xuICAgICAgY29uc3QgcmVzdWx0WCA9IHJlc3VsdFt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcbiAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRYXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1beV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XFxuYCkuam9pbignJykgfVxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBvdXRwdXRYOyB4KyspIHtcbiAgICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICAgICR7IGtlcm5lbFN0cmluZyB9XG4gICAgICB9XG4gICAgfWA7XG4gIH1cblxuICBfbXV0YWJsZUtlcm5lbDJEUmVzdWx0cygpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvclN0cmluZyA9IHRoaXMuX2dldEtlcm5lbFJlc3VsdFR5cGVDb25zdHJ1Y3RvclN0cmluZygpO1xuICAgIHJldHVybiBgICBjb25zdCBvdXRwdXRYID0gX3RoaXMub3V0cHV0WzBdO1xuICAgIGNvbnN0IG91dHB1dFkgPSBfdGhpcy5vdXRwdXRbMV07XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KG91dHB1dFkpO1xuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IG5ldyBBcnJheShvdXRwdXRZKTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBsZXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH07XFxuYCkuam9pbignICAgICcpIH1cbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dHB1dFk7IHkrKykge1xuICAgICAgY29uc3QgcmVzdWx0WCA9IHJlc3VsdFt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcbiAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRYXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1beV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XFxuYCkuam9pbignJykgfVxuICAgIH1gO1xuICB9XG5cbiAgX3Jlc3VsdE11dGFibGVLZXJuZWwyRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCBvdXRwdXRZID0gX3RoaXMub3V0cHV0WzFdO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0cHV0WTsgeSsrKSB7XG4gICAgICB0aGlzLnRocmVhZC56ID0gMDtcbiAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xuICAgICAgY29uc3QgcmVzdWx0WCA9IHJlc3VsdFt5XTtcbiAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRYXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1beV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XFxuYCkuam9pbignJykgfVxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBvdXRwdXRYOyB4KyspIHtcbiAgICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICAgICR7IGtlcm5lbFN0cmluZyB9XG4gICAgICB9XG4gICAgfWA7XG4gIH1cblxuICBfZ3JhcGhpY2FsS2VybmVsMkRMb29wKGtlcm5lbFN0cmluZykge1xuICAgIHJldHVybiBgICBjb25zdCBvdXRwdXRYID0gX3RoaXMub3V0cHV0WzBdO1xuICAgIGNvbnN0IG91dHB1dFkgPSBfdGhpcy5vdXRwdXRbMV07XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRwdXRZOyB5KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9yZXN1bHRJbW11dGFibGVLZXJuZWwzRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCBvdXRwdXRZID0gX3RoaXMub3V0cHV0WzFdO1xuICAgIGNvbnN0IG91dHB1dFogPSBfdGhpcy5vdXRwdXRbMl07XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KG91dHB1dFopO1xuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IG5ldyBBcnJheShvdXRwdXRaKTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBsZXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH07XFxuYCkuam9pbignICAgICcpIH1cbiAgICBmb3IgKGxldCB6ID0gMDsgeiA8IG91dHB1dFo7IHorKykge1xuICAgICAgdGhpcy50aHJlYWQueiA9IHo7XG4gICAgICBjb25zdCByZXN1bHRZID0gcmVzdWx0W3pdID0gbmV3IEFycmF5KG91dHB1dFkpO1xuICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFlfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVt6XSA9IG5ldyBBcnJheShvdXRwdXRZKTtcXG5gKS5qb2luKCcgICAgICAnKSB9XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dHB1dFk7IHkrKykge1xuICAgICAgICB0aGlzLnRocmVhZC55ID0geTtcbiAgICAgICAgY29uc3QgcmVzdWx0WCA9IHJlc3VsdFlbeV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XG4gICAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRYXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRZXyR7c3ViS2VybmVsLm5hbWV9W3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xcbmApLmpvaW4oJyAgICAgICAgJykgfVxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgICAgICR7IGtlcm5lbFN0cmluZyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9tdXRhYmxlS2VybmVsM0RSZXN1bHRzKCkge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yU3RyaW5nID0gdGhpcy5fZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCk7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3Qgb3V0cHV0WSA9IF90aGlzLm91dHB1dFsxXTtcbiAgICBjb25zdCBvdXRwdXRaID0gX3RoaXMub3V0cHV0WzJdO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShvdXRwdXRaKTtcbiAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgY29uc3QgcmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH0gPSBuZXcgQXJyYXkob3V0cHV0Wik7XFxuYCkuam9pbignICAgICcpIH1cbiAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgbGV0IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9O1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBvdXRwdXRaOyB6KyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdFkgPSByZXN1bHRbel0gPSBuZXcgQXJyYXkob3V0cHV0WSk7XG4gICAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgY29uc3QgcmVzdWx0WV8keyBzdWJLZXJuZWwubmFtZSB9ID0gcmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9W3pdID0gbmV3IEFycmF5KG91dHB1dFkpO1xcbmApLmpvaW4oJyAgICAgICcpIH1cbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0cHV0WTsgeSsrKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdFggPSByZXN1bHRZW3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xuICAgICAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgY29uc3QgcmVzdWx0WF8keyBzdWJLZXJuZWwubmFtZSB9ID0gcmVzdWx0WV8ke3N1Yktlcm5lbC5uYW1lfVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcgICAgICAgICcpIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9yZXN1bHRNdXRhYmxlS2VybmVsM0RMb29wKGtlcm5lbFN0cmluZykge1xuICAgIHJldHVybiBgICBjb25zdCBvdXRwdXRYID0gX3RoaXMub3V0cHV0WzBdO1xuICAgIGNvbnN0IG91dHB1dFkgPSBfdGhpcy5vdXRwdXRbMV07XG4gICAgY29uc3Qgb3V0cHV0WiA9IF90aGlzLm91dHB1dFsyXTtcbiAgICBmb3IgKGxldCB6ID0gMDsgeiA8IG91dHB1dFo7IHorKykge1xuICAgICAgdGhpcy50aHJlYWQueiA9IHo7XG4gICAgICBjb25zdCByZXN1bHRZID0gcmVzdWx0W3pdO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRwdXRZOyB5KyspIHtcbiAgICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICAgIGNvbnN0IHJlc3VsdFggPSByZXN1bHRZW3ldO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgICAgICR7IGtlcm5lbFN0cmluZyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9rZXJuZWxPdXRwdXQoKSB7XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHtcbiAgICAgIHJldHVybiAnXFxuICAgIHJldHVybiByZXN1bHQ7JztcbiAgICB9XG4gICAgcmV0dXJuIGBcXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgJHsgdGhpcy5zdWJLZXJuZWxzLm1hcChzdWJLZXJuZWwgPT4gYCR7IHN1Yktlcm5lbC5wcm9wZXJ0eSB9OiByZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfWApLmpvaW4oJyxcXG4gICAgICAnKSB9XG4gICAgfTtgO1xuICB9XG5cbiAgX21hcFN1Yktlcm5lbHMoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5zdWJLZXJuZWxzID09PSBudWxsID8gWycnXSA6XG4gICAgICB0aGlzLnN1Yktlcm5lbHMubWFwKGZuKTtcbiAgfVxuXG4gIGRlc3Ryb3kocmVtb3ZlQ2FudmFzUmVmZXJlbmNlKSB7XG4gICAgaWYgKHJlbW92ZUNhbnZhc1JlZmVyZW5jZSkge1xuICAgICAgZGVsZXRlIHRoaXMuY2FudmFzO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBkZXN0cm95Q29udGV4dChjb250ZXh0KSB7fVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBqc29uID0gc3VwZXIudG9KU09OKCk7XG4gICAganNvbi5mdW5jdGlvbk5vZGVzID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgQ1BVRnVuY3Rpb25Ob2RlKS50b0pTT04oKTtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHNldE91dHB1dChvdXRwdXQpIHtcbiAgICBzdXBlci5zZXRPdXRwdXQob3V0cHV0KTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLm91dHB1dDtcbiAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcbiAgICAgIHRoaXMuX2ltYWdlRGF0YSA9IHRoaXMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLl9jb2xvckRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICB9XG4gIH1cblxuICBwcmVwZW5kU3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2tlcm5lbFN0cmluZykgdGhyb3cgbmV3IEVycm9yKCdLZXJuZWwgYWxyZWFkeSBidWlsdCcpO1xuICAgIHRoaXMuX3ByZXBlbmRlZFN0cmluZy5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIGhhc1ByZXBlbmRTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlcGVuZGVkU3RyaW5nLmluZGV4T2YodmFsdWUpID4gLTE7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENQVUtlcm5lbFxufTtcbn0se1wiLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi9mdW5jdGlvbi1idWlsZGVyXCI6OSxcIi4uL2tlcm5lbFwiOjM2LFwiLi9mdW5jdGlvbi1ub2RlXCI6NixcIi4va2VybmVsLXN0cmluZ1wiOjd9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNsYXNzIEZ1bmN0aW9uQnVpbGRlciB7XG4gIHN0YXRpYyBmcm9tS2VybmVsKGtlcm5lbCwgRnVuY3Rpb25Ob2RlLCBleHRyYU5vZGVPcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAga2VybmVsQXJndW1lbnRzLFxuICAgICAga2VybmVsQ29uc3RhbnRzLFxuICAgICAgYXJndW1lbnROYW1lcyxcbiAgICAgIGFyZ3VtZW50U2l6ZXMsXG4gICAgICBhcmd1bWVudEJpdFJhdGlvcyxcbiAgICAgIGNvbnN0YW50cyxcbiAgICAgIGNvbnN0YW50Qml0UmF0aW9zLFxuICAgICAgZGVidWcsXG4gICAgICBsb29wTWF4SXRlcmF0aW9ucyxcbiAgICAgIG5hdGl2ZUZ1bmN0aW9ucyxcbiAgICAgIG91dHB1dCxcbiAgICAgIG9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICBwcmVjaXNpb24sXG4gICAgICBwbHVnaW5zLFxuICAgICAgc291cmNlLFxuICAgICAgc3ViS2VybmVscyxcbiAgICAgIGZ1bmN0aW9ucyxcbiAgICAgIGxlYWRpbmdSZXR1cm5TdGF0ZW1lbnQsXG4gICAgICBmb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQsXG4gICAgICBkeW5hbWljQXJndW1lbnRzLFxuICAgICAgZHluYW1pY091dHB1dCxcbiAgICAgIG9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlLFxuICAgICAgcmVtb3ZlSXN0YW5idWxDb3ZlcmFnZSxcbiAgICB9ID0ga2VybmVsO1xuXG4gICAgY29uc3QgYXJndW1lbnRUeXBlcyA9IG5ldyBBcnJheShrZXJuZWxBcmd1bWVudHMubGVuZ3RoKTtcbiAgICBjb25zdCBjb25zdGFudFR5cGVzID0ge307XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbEFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJndW1lbnRUeXBlc1tpXSA9IGtlcm5lbEFyZ3VtZW50c1tpXS50eXBlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsQ29uc3RhbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXJuZWxDb25zdGFudCA9IGtlcm5lbENvbnN0YW50c1tpXTtcbiAgICAgIGNvbnN0YW50VHlwZXNba2VybmVsQ29uc3RhbnQubmFtZV0gPSBrZXJuZWxDb25zdGFudC50eXBlO1xuICAgIH1cblxuICAgIGNvbnN0IG5lZWRzQXJndW1lbnRUeXBlID0gKGZ1bmN0aW9uTmFtZSwgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBmdW5jdGlvbkJ1aWxkZXIubmVlZHNBcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpbmRleCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFzc2lnbkFyZ3VtZW50VHlwZSA9IChmdW5jdGlvbk5hbWUsIGluZGV4LCB0eXBlKSA9PiB7XG4gICAgICBmdW5jdGlvbkJ1aWxkZXIuYXNzaWduQXJndW1lbnRUeXBlKGZ1bmN0aW9uTmFtZSwgaW5kZXgsIHR5cGUpO1xuICAgIH07XG5cbiAgICBjb25zdCBsb29rdXBSZXR1cm5UeXBlID0gKGZ1bmN0aW9uTmFtZSwgYXN0LCByZXF1ZXN0aW5nTm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlci5sb29rdXBSZXR1cm5UeXBlKGZ1bmN0aW9uTmFtZSwgYXN0LCByZXF1ZXN0aW5nTm9kZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyA9IChmdW5jdGlvbk5hbWUpID0+IHtcbiAgICAgIHJldHVybiBmdW5jdGlvbkJ1aWxkZXIubG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzKGZ1bmN0aW9uTmFtZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lID0gKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlci5sb29rdXBGdW5jdGlvbkFyZ3VtZW50TmFtZShmdW5jdGlvbk5hbWUsIGFyZ3VtZW50SW5kZXgpO1xuICAgIH07XG5cbiAgICBjb25zdCBsb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8gPSAoZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUpID0+IHtcbiAgICAgIHJldHVybiBmdW5jdGlvbkJ1aWxkZXIubG9va3VwRnVuY3Rpb25Bcmd1bWVudEJpdFJhdGlvKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnROYW1lKTtcbiAgICB9O1xuXG4gICAgY29uc3QgdHJpZ2dlckltcGx5QXJndW1lbnRUeXBlID0gKGZ1bmN0aW9uTmFtZSwgaSwgYXJndW1lbnRUeXBlLCByZXF1ZXN0aW5nTm9kZSkgPT4ge1xuICAgICAgZnVuY3Rpb25CdWlsZGVyLmFzc2lnbkFyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGksIGFyZ3VtZW50VHlwZSwgcmVxdWVzdGluZ05vZGUpO1xuICAgIH07XG5cbiAgICBjb25zdCB0cmlnZ2VySW1wbHlBcmd1bWVudEJpdFJhdGlvID0gKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnROYW1lLCBjYWxsZWVGdW5jdGlvbk5hbWUsIGFyZ3VtZW50SW5kZXgpID0+IHtcbiAgICAgIGZ1bmN0aW9uQnVpbGRlci5hc3NpZ25Bcmd1bWVudEJpdFJhdGlvKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnROYW1lLCBjYWxsZWVGdW5jdGlvbk5hbWUsIGFyZ3VtZW50SW5kZXgpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbkZ1bmN0aW9uQ2FsbCA9IChmdW5jdGlvbk5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSwgYXJncykgPT4ge1xuICAgICAgZnVuY3Rpb25CdWlsZGVyLnRyYWNrRnVuY3Rpb25DYWxsKGZ1bmN0aW9uTmFtZSwgY2FsbGVlRnVuY3Rpb25OYW1lLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25OZXN0ZWRGdW5jdGlvbiA9IChhc3QsIHJldHVyblR5cGUpID0+IHtcbiAgICAgIGNvbnN0IGFyZ3VtZW50TmFtZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LnBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcmd1bWVudE5hbWVzLnB1c2goYXN0LnBhcmFtc1tpXS5uYW1lKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5lc3RlZEZ1bmN0aW9uID0gbmV3IEZ1bmN0aW9uTm9kZShudWxsLCBPYmplY3QuYXNzaWduKHt9LCBub2RlT3B0aW9ucywge1xuICAgICAgICByZXR1cm5UeXBlOiBudWxsLFxuICAgICAgICBhc3QsXG4gICAgICAgIG5hbWU6IGFzdC5pZC5uYW1lLFxuICAgICAgICBhcmd1bWVudE5hbWVzLFxuICAgICAgICBsb29rdXBSZXR1cm5UeXBlLFxuICAgICAgICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMsXG4gICAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lLFxuICAgICAgICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8sXG4gICAgICAgIG5lZWRzQXJndW1lbnRUeXBlLFxuICAgICAgICBhc3NpZ25Bcmd1bWVudFR5cGUsXG4gICAgICAgIHRyaWdnZXJJbXBseUFyZ3VtZW50VHlwZSxcbiAgICAgICAgdHJpZ2dlckltcGx5QXJndW1lbnRCaXRSYXRpbyxcbiAgICAgICAgb25GdW5jdGlvbkNhbGwsXG4gICAgICB9KSk7XG4gICAgICBuZXN0ZWRGdW5jdGlvbi50cmFjZUZ1bmN0aW9uQVNUKGFzdCk7XG4gICAgICBmdW5jdGlvbkJ1aWxkZXIuYWRkRnVuY3Rpb25Ob2RlKG5lc3RlZEZ1bmN0aW9uKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgbm9kZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGlzUm9vdEtlcm5lbDogZmFsc2UsXG4gICAgICBvbk5lc3RlZEZ1bmN0aW9uLFxuICAgICAgbG9va3VwUmV0dXJuVHlwZSxcbiAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyxcbiAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lLFxuICAgICAgbG9va3VwRnVuY3Rpb25Bcmd1bWVudEJpdFJhdGlvLFxuICAgICAgbmVlZHNBcmd1bWVudFR5cGUsXG4gICAgICBhc3NpZ25Bcmd1bWVudFR5cGUsXG4gICAgICB0cmlnZ2VySW1wbHlBcmd1bWVudFR5cGUsXG4gICAgICB0cmlnZ2VySW1wbHlBcmd1bWVudEJpdFJhdGlvLFxuICAgICAgb25GdW5jdGlvbkNhbGwsXG4gICAgICBvbklzdGFuYnVsQ292ZXJhZ2VWYXJpYWJsZTogb25Jc3RhbmJ1bENvdmVyYWdlVmFyaWFibGUgPyAobmFtZSkgPT4gb25Jc3RhbmJ1bENvdmVyYWdlVmFyaWFibGUobmFtZSwga2VybmVsKSA6IG51bGwsXG4gICAgICByZW1vdmVJc3RhbmJ1bENvdmVyYWdlLFxuICAgICAgb3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgIHByZWNpc2lvbixcbiAgICAgIGNvbnN0YW50cyxcbiAgICAgIGNvbnN0YW50VHlwZXMsXG4gICAgICBjb25zdGFudEJpdFJhdGlvcyxcbiAgICAgIGRlYnVnLFxuICAgICAgbG9vcE1heEl0ZXJhdGlvbnMsXG4gICAgICBvdXRwdXQsXG4gICAgICBwbHVnaW5zLFxuICAgICAgZHluYW1pY0FyZ3VtZW50cyxcbiAgICAgIGR5bmFtaWNPdXRwdXQsXG4gICAgfSwgZXh0cmFOb2RlT3B0aW9ucyB8fCB7fSk7XG5cbiAgICBjb25zdCByb290Tm9kZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlT3B0aW9ucywge1xuICAgICAgaXNSb290S2VybmVsOiB0cnVlLFxuICAgICAgbmFtZTogJ2tlcm5lbCcsXG4gICAgICBhcmd1bWVudE5hbWVzLFxuICAgICAgYXJndW1lbnRUeXBlcyxcbiAgICAgIGFyZ3VtZW50U2l6ZXMsXG4gICAgICBhcmd1bWVudEJpdFJhdGlvcyxcbiAgICAgIGxlYWRpbmdSZXR1cm5TdGF0ZW1lbnQsXG4gICAgICBmb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQsXG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcgJiYgc291cmNlLmZ1bmN0aW9uTm9kZXMpIHtcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25CdWlsZGVyKCkuZnJvbUpTT04oc291cmNlLmZ1bmN0aW9uTm9kZXMsIEZ1bmN0aW9uTm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgcm9vdE5vZGUgPSBuZXcgRnVuY3Rpb25Ob2RlKHNvdXJjZSwgcm9vdE5vZGVPcHRpb25zKTtcblxuICAgIGxldCBmdW5jdGlvbk5vZGVzID0gbnVsbDtcbiAgICBpZiAoZnVuY3Rpb25zKSB7XG4gICAgICBmdW5jdGlvbk5vZGVzID0gZnVuY3Rpb25zLm1hcCgoZm4pID0+IG5ldyBGdW5jdGlvbk5vZGUoZm4uc291cmNlLCB7XG4gICAgICAgIHJldHVyblR5cGU6IGZuLnJldHVyblR5cGUsXG4gICAgICAgIGFyZ3VtZW50VHlwZXM6IGZuLmFyZ3VtZW50VHlwZXMsXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgcGx1Z2lucyxcbiAgICAgICAgY29uc3RhbnRzLFxuICAgICAgICBjb25zdGFudFR5cGVzLFxuICAgICAgICBjb25zdGFudEJpdFJhdGlvcyxcbiAgICAgICAgb3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgICAgcHJlY2lzaW9uLFxuICAgICAgICBsb29rdXBSZXR1cm5UeXBlLFxuICAgICAgICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMsXG4gICAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lLFxuICAgICAgICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8sXG4gICAgICAgIG5lZWRzQXJndW1lbnRUeXBlLFxuICAgICAgICBhc3NpZ25Bcmd1bWVudFR5cGUsXG4gICAgICAgIHRyaWdnZXJJbXBseUFyZ3VtZW50VHlwZSxcbiAgICAgICAgdHJpZ2dlckltcGx5QXJndW1lbnRCaXRSYXRpbyxcbiAgICAgICAgb25GdW5jdGlvbkNhbGwsXG4gICAgICAgIG9uTmVzdGVkRnVuY3Rpb24sXG4gICAgICAgIG9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlOiBvbklzdGFuYnVsQ292ZXJhZ2VWYXJpYWJsZSA/IChuYW1lKSA9PiBvbklzdGFuYnVsQ292ZXJhZ2VWYXJpYWJsZShuYW1lLCBrZXJuZWwpIDogbnVsbCxcbiAgICAgICAgcmVtb3ZlSXN0YW5idWxDb3ZlcmFnZSxcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBsZXQgc3ViS2VybmVsTm9kZXMgPSBudWxsO1xuICAgIGlmIChzdWJLZXJuZWxzKSB7XG4gICAgICBzdWJLZXJuZWxOb2RlcyA9IHN1Yktlcm5lbHMubWFwKChzdWJLZXJuZWwpID0+IHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBzb3VyY2UgfSA9IHN1Yktlcm5lbDtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbk5vZGUoc291cmNlLCBPYmplY3QuYXNzaWduKHt9LCBub2RlT3B0aW9ucywge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaXNTdWJLZXJuZWw6IHRydWUsXG4gICAgICAgICAgaXNSb290S2VybmVsOiBmYWxzZSxcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZnVuY3Rpb25CdWlsZGVyID0gbmV3IEZ1bmN0aW9uQnVpbGRlcih7XG4gICAgICBrZXJuZWwsXG4gICAgICByb290Tm9kZSxcbiAgICAgIGZ1bmN0aW9uTm9kZXMsXG4gICAgICBuYXRpdmVGdW5jdGlvbnMsXG4gICAgICBzdWJLZXJuZWxOb2Rlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlcjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICB0aGlzLmtlcm5lbCA9IHNldHRpbmdzLmtlcm5lbDtcbiAgICB0aGlzLnJvb3ROb2RlID0gc2V0dGluZ3Mucm9vdE5vZGU7XG4gICAgdGhpcy5mdW5jdGlvbk5vZGVzID0gc2V0dGluZ3MuZnVuY3Rpb25Ob2RlcyB8fCBbXTtcbiAgICB0aGlzLnN1Yktlcm5lbE5vZGVzID0gc2V0dGluZ3Muc3ViS2VybmVsTm9kZXMgfHwgW107XG4gICAgdGhpcy5uYXRpdmVGdW5jdGlvbnMgPSBzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMgfHwgW107XG4gICAgdGhpcy5mdW5jdGlvbk1hcCA9IHt9O1xuICAgIHRoaXMubmF0aXZlRnVuY3Rpb25OYW1lcyA9IFtdO1xuICAgIHRoaXMubG9va3VwQ2hhaW4gPSBbXTtcbiAgICB0aGlzLmZ1bmN0aW9uTm9kZURlcGVuZGVuY2llcyA9IHt9O1xuICAgIHRoaXMuZnVuY3Rpb25DYWxscyA9IHt9O1xuXG4gICAgaWYgKHRoaXMucm9vdE5vZGUpIHtcbiAgICAgIHRoaXMuZnVuY3Rpb25NYXBbJ2tlcm5lbCddID0gdGhpcy5yb290Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mdW5jdGlvbk5vZGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZnVuY3Rpb25Ob2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTWFwW3RoaXMuZnVuY3Rpb25Ob2Rlc1tpXS5uYW1lXSA9IHRoaXMuZnVuY3Rpb25Ob2Rlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdWJLZXJuZWxOb2Rlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25NYXBbdGhpcy5zdWJLZXJuZWxOb2Rlc1tpXS5uYW1lXSA9IHRoaXMuc3ViS2VybmVsTm9kZXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmF0aXZlRnVuY3Rpb25zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmF0aXZlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUZ1bmN0aW9uID0gdGhpcy5uYXRpdmVGdW5jdGlvbnNbaV07XG4gICAgICAgIHRoaXMubmF0aXZlRnVuY3Rpb25OYW1lcy5wdXNoKG5hdGl2ZUZ1bmN0aW9uLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFkZEZ1bmN0aW9uTm9kZShmdW5jdGlvbk5vZGUpIHtcbiAgICBpZiAoIWZ1bmN0aW9uTm9kZS5uYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uTm9kZS5uYW1lIG5lZWRzIHNldCcpO1xuICAgIHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25Ob2RlLm5hbWVdID0gZnVuY3Rpb25Ob2RlO1xuICAgIGlmIChmdW5jdGlvbk5vZGUuaXNSb290S2VybmVsKSB7XG4gICAgICB0aGlzLnJvb3ROb2RlID0gZnVuY3Rpb25Ob2RlO1xuICAgIH1cbiAgfVxuXG4gIHRyYWNlRnVuY3Rpb25DYWxscyhmdW5jdGlvbk5hbWUsIHJldExpc3QpIHtcbiAgICBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWUgfHwgJ2tlcm5lbCc7XG4gICAgcmV0TGlzdCA9IHJldExpc3QgfHwgW107XG5cbiAgICBpZiAodGhpcy5uYXRpdmVGdW5jdGlvbk5hbWVzLmluZGV4T2YoZnVuY3Rpb25OYW1lKSA+IC0xKSB7XG4gICAgICBpZiAocmV0TGlzdC5pbmRleE9mKGZ1bmN0aW9uTmFtZSkgPT09IC0xKSB7XG4gICAgICAgIHJldExpc3QucHVzaChmdW5jdGlvbk5hbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldExpc3Q7XG4gICAgfVxuXG4gICAgY29uc3QgZnVuY3Rpb25Ob2RlID0gdGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbk5hbWVdO1xuICAgIGlmIChmdW5jdGlvbk5vZGUpIHtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uSW5kZXggPSByZXRMaXN0LmluZGV4T2YoZnVuY3Rpb25OYW1lKTtcbiAgICAgIGlmIChmdW5jdGlvbkluZGV4ID09PSAtMSkge1xuICAgICAgICByZXRMaXN0LnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICAgICAgZnVuY3Rpb25Ob2RlLnRvU3RyaW5nKCk7IFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9uTm9kZS5jYWxsZWRGdW5jdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB0aGlzLnRyYWNlRnVuY3Rpb25DYWxscyhmdW5jdGlvbk5vZGUuY2FsbGVkRnVuY3Rpb25zW2ldLCByZXRMaXN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVwZW5kYW50RnVuY3Rpb25OYW1lID0gcmV0TGlzdC5zcGxpY2UoZnVuY3Rpb25JbmRleCwgMSlbMF07XG4gICAgICAgIHJldExpc3QucHVzaChkZXBlbmRhbnRGdW5jdGlvbk5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXRMaXN0O1xuICB9XG5cbiAgZ2V0UHJvdG90eXBlU3RyaW5nKGZ1bmN0aW9uTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdldFByb3RvdHlwZXMoZnVuY3Rpb25OYW1lKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGdldFByb3RvdHlwZXMoZnVuY3Rpb25OYW1lKSB7XG4gICAgaWYgKHRoaXMucm9vdE5vZGUpIHtcbiAgICAgIHRoaXMucm9vdE5vZGUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvdG90eXBlc0Zyb21GdW5jdGlvbk5hbWVzKHRoaXMudHJhY2VGdW5jdGlvbkNhbGxzKGZ1bmN0aW9uTmFtZSwgW10pLnJldmVyc2UoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFByb3RvdHlwZXNGcm9tRnVuY3Rpb25OYW1lcyhPYmplY3Qua2V5cyh0aGlzLmZ1bmN0aW9uTWFwKSk7XG4gIH1cblxuICBnZXRTdHJpbmdGcm9tRnVuY3Rpb25OYW1lcyhmdW5jdGlvbkxpc3QpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9uTGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25MaXN0W2ldXTtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIHJldC5wdXNoKHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25MaXN0W2ldXS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGdldFByb3RvdHlwZXNGcm9tRnVuY3Rpb25OYW1lcyhmdW5jdGlvbkxpc3QpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9uTGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25MaXN0W2ldO1xuICAgICAgY29uc3QgZnVuY3Rpb25JbmRleCA9IHRoaXMubmF0aXZlRnVuY3Rpb25OYW1lcy5pbmRleE9mKGZ1bmN0aW9uTmFtZSk7XG4gICAgICBpZiAoZnVuY3Rpb25JbmRleCA+IC0xKSB7XG4gICAgICAgIHJldC5wdXNoKHRoaXMubmF0aXZlRnVuY3Rpb25zW2Z1bmN0aW9uSW5kZXhdLnNvdXJjZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25OYW1lXTtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIHJldC5wdXNoKG5vZGUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2VGdW5jdGlvbkNhbGxzKHRoaXMucm9vdE5vZGUubmFtZSkucmV2ZXJzZSgpLm1hcChuYW1lID0+IHtcbiAgICAgIGNvbnN0IG5hdGl2ZUluZGV4ID0gdGhpcy5uYXRpdmVGdW5jdGlvbnMuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChuYXRpdmVJbmRleCA+IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBzb3VyY2U6IHRoaXMubmF0aXZlRnVuY3Rpb25zW25hdGl2ZUluZGV4XS5zb3VyY2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5mdW5jdGlvbk1hcFtuYW1lXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbk1hcFtuYW1lXS50b0pTT04oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZnVuY3Rpb24gJHsgbmFtZSB9IG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnJvbUpTT04oanNvbkZ1bmN0aW9uTm9kZXMsIEZ1bmN0aW9uTm9kZSkge1xuICAgIHRoaXMuZnVuY3Rpb25NYXAgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb25GdW5jdGlvbk5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBqc29uRnVuY3Rpb25Ob2RlID0ganNvbkZ1bmN0aW9uTm9kZXNbaV07XG4gICAgICB0aGlzLmZ1bmN0aW9uTWFwW2pzb25GdW5jdGlvbk5vZGUuc2V0dGluZ3MubmFtZV0gPSBuZXcgRnVuY3Rpb25Ob2RlKGpzb25GdW5jdGlvbk5vZGUuYXN0LCBqc29uRnVuY3Rpb25Ob2RlLnNldHRpbmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRTdHJpbmcoZnVuY3Rpb25OYW1lKSB7XG4gICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RyaW5nRnJvbUZ1bmN0aW9uTmFtZXModGhpcy50cmFjZUZ1bmN0aW9uQ2FsbHMoZnVuY3Rpb25OYW1lKS5yZXZlcnNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRTdHJpbmdGcm9tRnVuY3Rpb25OYW1lcyhPYmplY3Qua2V5cyh0aGlzLmZ1bmN0aW9uTWFwKSk7XG4gIH1cblxuICBsb29rdXBSZXR1cm5UeXBlKGZ1bmN0aW9uTmFtZSwgYXN0LCByZXF1ZXN0aW5nTm9kZSkge1xuICAgIGlmIChhc3QudHlwZSAhPT0gJ0NhbGxFeHByZXNzaW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBhc3QgdHlwZSBvZiBcIkNhbGxFeHByZXNzaW9uXCIsIGJ1dCBpcyAkeyBhc3QudHlwZSB9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc05hdGl2ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb29rdXBOYXRpdmVGdW5jdGlvblJldHVyblR5cGUoZnVuY3Rpb25OYW1lKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgICBpZiAobm9kZS5yZXR1cm5UeXBlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnJldHVyblR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9va3VwQ2hhaW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5sb29rdXBDaGFpbltpXS5hc3QgPT09IGFzdCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuYXJndW1lbnRUeXBlcy5sZW5ndGggPT09IDAgJiYgYXN0LmFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBhc3QuYXJndW1lbnRzO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFyZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvb2t1cENoYWluLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbmFtZTogcmVxdWVzdGluZ05vZGUubmFtZSxcbiAgICAgICAgICAgICAgICAgIGFzdDogYXJnc1tpXSxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdOb2RlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudFR5cGVzW2pdID0gcmVxdWVzdGluZ05vZGUuZ2V0VHlwZShhcmdzW2pdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvb2t1cENoYWluLnBvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBub2RlLnJldHVyblR5cGUgPSBub2RlLmdldFR5cGUobm9kZS5nZXRKc0FTVCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaXJjbGljYWwgbG9naWMgZGV0ZWN0ZWQhJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9va3VwQ2hhaW4ucHVzaCh7XG4gICAgICAgICAgbmFtZTogcmVxdWVzdGluZ05vZGUubmFtZSxcbiAgICAgICAgICBhc3QsXG4gICAgICAgICAgcmVxdWVzdGluZ05vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBub2RlLmdldFR5cGUobm9kZS5nZXRKc0FTVCgpKTtcbiAgICAgICAgdGhpcy5sb29rdXBDaGFpbi5wb3AoKTtcbiAgICAgICAgcmV0dXJuIG5vZGUucmV0dXJuVHlwZSA9IHR5cGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBfZ2V0RnVuY3Rpb24oZnVuY3Rpb25OYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9pc0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgIG5ldyBFcnJvcihgRnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbk5hbWVdO1xuICB9XG5cbiAgX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbk5hbWVdKTtcbiAgfVxuXG4gIF9nZXROYXRpdmVGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmF0aXZlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5uYXRpdmVGdW5jdGlvbnNbaV0ubmFtZSA9PT0gZnVuY3Rpb25OYW1lKSByZXR1cm4gdGhpcy5uYXRpdmVGdW5jdGlvbnNbaV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgX2lzTmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fZ2V0TmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSk7XG4gIH1cblxuICBfbG9va3VwTmF0aXZlRnVuY3Rpb25SZXR1cm5UeXBlKGZ1bmN0aW9uTmFtZSkge1xuICAgIGxldCBuYXRpdmVGdW5jdGlvbiA9IHRoaXMuX2dldE5hdGl2ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgaWYgKG5hdGl2ZUZ1bmN0aW9uKSB7XG4gICAgICByZXR1cm4gbmF0aXZlRnVuY3Rpb24ucmV0dXJuVHlwZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOYXRpdmUgZnVuY3Rpb24gJHsgZnVuY3Rpb25OYW1lIH0gbm90IGZvdW5kYCk7XG4gIH1cblxuICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMoZnVuY3Rpb25OYW1lKSB7XG4gICAgaWYgKHRoaXMuX2lzTmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldE5hdGl2ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSkuYXJndW1lbnRUeXBlcztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSkuYXJndW1lbnRUeXBlcztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50TmFtZShmdW5jdGlvbk5hbWUsIGFyZ3VtZW50SW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0RnVuY3Rpb24oZnVuY3Rpb25OYW1lKS5hcmd1bWVudE5hbWVzW2FyZ3VtZW50SW5kZXhdO1xuICB9XG5cbiAgbG9va3VwRnVuY3Rpb25Bcmd1bWVudEJpdFJhdGlvKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnROYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9pc0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJvb3ROb2RlLm5hbWUgPT09IGZ1bmN0aW9uTmFtZSkge1xuICAgICAgY29uc3QgaSA9IHRoaXMucm9vdE5vZGUuYXJndW1lbnROYW1lcy5pbmRleE9mKGFyZ3VtZW50TmFtZSk7XG4gICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdE5vZGUuYXJndW1lbnRCaXRSYXRpb3NbaV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpO1xuICAgIGNvbnN0IGkgPSBub2RlLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihhcmd1bWVudE5hbWUpO1xuICAgIGlmIChpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcmd1bWVudCBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgYml0UmF0aW8gPSBub2RlLmFyZ3VtZW50Qml0UmF0aW9zW2ldO1xuICAgIGlmICh0eXBlb2YgYml0UmF0aW8gIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyZ3VtZW50IGJpdCByYXRpbyBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpdFJhdGlvO1xuICB9XG5cbiAgbmVlZHNBcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpKSB7XG4gICAgaWYgKCF0aGlzLl9pc0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBmbk5vZGUgPSB0aGlzLl9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpO1xuICAgIHJldHVybiAhZm5Ob2RlLmFyZ3VtZW50VHlwZXNbaV07XG4gIH1cblxuICBhc3NpZ25Bcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpLCBhcmd1bWVudFR5cGUsIHJlcXVlc3RpbmdOb2RlKSB7XG4gICAgaWYgKCF0aGlzLl9pc0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSkpIHJldHVybjtcbiAgICBjb25zdCBmbk5vZGUgPSB0aGlzLl9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpO1xuICAgIGlmICghZm5Ob2RlLmFyZ3VtZW50VHlwZXNbaV0pIHtcbiAgICAgIGZuTm9kZS5hcmd1bWVudFR5cGVzW2ldID0gYXJndW1lbnRUeXBlO1xuICAgIH1cbiAgfVxuXG4gIGFzc2lnbkFyZ3VtZW50Qml0UmF0aW8oZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpO1xuICAgIGlmICh0aGlzLl9pc05hdGl2ZUZ1bmN0aW9uKGNhbGxlZUZ1bmN0aW9uTmFtZSkpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGNhbGxlZU5vZGUgPSB0aGlzLl9nZXRGdW5jdGlvbihjYWxsZWVGdW5jdGlvbk5hbWUpO1xuICAgIGNvbnN0IGkgPSBub2RlLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihhcmd1bWVudE5hbWUpO1xuICAgIGlmIChpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCAke2FyZ3VtZW50TmFtZX0gbm90IGZvdW5kIGluIGFyZ3VtZW50cyBmcm9tIGZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfWApO1xuICAgIH1cbiAgICBjb25zdCBiaXRSYXRpbyA9IG5vZGUuYXJndW1lbnRCaXRSYXRpb3NbaV07XG4gICAgaWYgKHR5cGVvZiBiaXRSYXRpbyAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQml0IHJhdGlvIGZvciBhcmd1bWVudCAke2FyZ3VtZW50TmFtZX0gbm90IGZvdW5kIGluIGZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfWApO1xuICAgIH1cbiAgICBpZiAoIWNhbGxlZU5vZGUuYXJndW1lbnRCaXRSYXRpb3MpIHtcbiAgICAgIGNhbGxlZU5vZGUuYXJndW1lbnRCaXRSYXRpb3MgPSBuZXcgQXJyYXkoY2FsbGVlTm9kZS5hcmd1bWVudE5hbWVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbGxlZUJpdFJhdGlvID0gY2FsbGVlTm9kZS5hcmd1bWVudEJpdFJhdGlvc1tpXTtcbiAgICBpZiAodHlwZW9mIGNhbGxlZUJpdFJhdGlvID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGNhbGxlZUJpdFJhdGlvICE9PSBiaXRSYXRpbykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29tcGF0aWJsZSBiaXQgcmF0aW8gZm91bmQgYXQgZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9IGF0IGFyZ3VtZW50ICR7YXJndW1lbnROYW1lfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGxlZUJpdFJhdGlvO1xuICAgIH1cbiAgICBjYWxsZWVOb2RlLmFyZ3VtZW50Qml0UmF0aW9zW2ldID0gYml0UmF0aW87XG4gICAgcmV0dXJuIGJpdFJhdGlvO1xuICB9XG5cbiAgdHJhY2tGdW5jdGlvbkNhbGwoZnVuY3Rpb25OYW1lLCBjYWxsZWVGdW5jdGlvbk5hbWUsIGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuZnVuY3Rpb25Ob2RlRGVwZW5kZW5jaWVzW2Z1bmN0aW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuZnVuY3Rpb25Ob2RlRGVwZW5kZW5jaWVzW2Z1bmN0aW9uTmFtZV0gPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmZ1bmN0aW9uQ2FsbHNbZnVuY3Rpb25OYW1lXSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmZ1bmN0aW9uTm9kZURlcGVuZGVuY2llc1tmdW5jdGlvbk5hbWVdLmFkZChjYWxsZWVGdW5jdGlvbk5hbWUpO1xuICAgIHRoaXMuZnVuY3Rpb25DYWxsc1tmdW5jdGlvbk5hbWVdLnB1c2goYXJncyk7XG4gIH1cblxuICBnZXRLZXJuZWxSZXN1bHRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3ROb2RlLnJldHVyblR5cGUgfHwgdGhpcy5yb290Tm9kZS5nZXRUeXBlKHRoaXMucm9vdE5vZGUuYXN0KTtcbiAgfVxuXG4gIGdldFN1Yktlcm5lbFJlc3VsdFR5cGUoaW5kZXgpIHtcbiAgICBjb25zdCBzdWJLZXJuZWxOb2RlID0gdGhpcy5zdWJLZXJuZWxOb2Rlc1tpbmRleF07XG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGZ1bmN0aW9uQ2FsbEluZGV4ID0gMDsgZnVuY3Rpb25DYWxsSW5kZXggPCB0aGlzLnJvb3ROb2RlLmZ1bmN0aW9uQ2FsbHMubGVuZ3RoOyBmdW5jdGlvbkNhbGxJbmRleCsrKSB7XG4gICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSB0aGlzLnJvb3ROb2RlLmZ1bmN0aW9uQ2FsbHNbZnVuY3Rpb25DYWxsSW5kZXhdO1xuICAgICAgaWYgKGZ1bmN0aW9uQ2FsbC5hc3QuY2FsbGVlLm5hbWUgPT09IHN1Yktlcm5lbE5vZGUubmFtZSkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJLZXJuZWwgJHsgc3ViS2VybmVsTm9kZS5uYW1lIH0gbmV2ZXIgY2FsbGVkIGJ5IGtlcm5lbGApO1xuICAgIH1cbiAgICByZXR1cm4gc3ViS2VybmVsTm9kZS5yZXR1cm5UeXBlIHx8IHN1Yktlcm5lbE5vZGUuZ2V0VHlwZShzdWJLZXJuZWxOb2RlLmdldEpzQVNUKCkpO1xuICB9XG5cbiAgZ2V0UmV0dXJuVHlwZXMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgW3RoaXMucm9vdE5vZGUubmFtZV06IHRoaXMucm9vdE5vZGUuZ2V0VHlwZSh0aGlzLnJvb3ROb2RlLmFzdCksXG4gICAgfTtcbiAgICBjb25zdCBsaXN0ID0gdGhpcy50cmFjZUZ1bmN0aW9uQ2FsbHModGhpcy5yb290Tm9kZS5uYW1lKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGxpc3RbaV07XG4gICAgICBjb25zdCBmdW5jdGlvbk5vZGUgPSB0aGlzLmZ1bmN0aW9uTWFwW2Z1bmN0aW9uTmFtZV07XG4gICAgICByZXN1bHRbZnVuY3Rpb25OYW1lXSA9IGZ1bmN0aW9uTm9kZS5nZXRUeXBlKGZ1bmN0aW9uTm9kZS5hc3QpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBGdW5jdGlvbkJ1aWxkZXJcbn07XG59LHt9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCBhY29ybiA9IHJlcXVpcmUoJ2Fjb3JuJyk7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgeyBGdW5jdGlvblRyYWNlciB9ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi10cmFjZXInKTtcblxuY2xhc3MgRnVuY3Rpb25Ob2RlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBzZXR0aW5ncykge1xuICAgIGlmICghc291cmNlICYmICFzZXR0aW5ncy5hc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIHBhcmFtZXRlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5hc3QgPSBudWxsO1xuICAgIHRoaXMubmFtZSA9IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gc2V0dGluZ3MuaXNSb290S2VybmVsID9cbiAgICAgICdrZXJuZWwnIDpcbiAgICAgIChzZXR0aW5ncy5uYW1lIHx8IHV0aWxzLmdldEZ1bmN0aW9uTmFtZUZyb21TdHJpbmcoc291cmNlKSkgOiBudWxsO1xuICAgIHRoaXMuY2FsbGVkRnVuY3Rpb25zID0gW107XG4gICAgdGhpcy5jb25zdGFudHMgPSB7fTtcbiAgICB0aGlzLmNvbnN0YW50VHlwZXMgPSB7fTtcbiAgICB0aGlzLmNvbnN0YW50Qml0UmF0aW9zID0ge307XG4gICAgdGhpcy5pc1Jvb3RLZXJuZWwgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3ViS2VybmVsID0gZmFsc2U7XG4gICAgdGhpcy5kZWJ1ZyA9IG51bGw7XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBudWxsO1xuICAgIHRoaXMuaWRlbnRpZmllcnMgPSBudWxsO1xuICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgIHRoaXMuZnVuY3Rpb25DYWxscyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICB0aGlzLm5lZWRzQXJndW1lbnRUeXBlID0gbnVsbDtcbiAgICB0aGlzLmFzc2lnbkFyZ3VtZW50VHlwZSA9IG51bGw7XG4gICAgdGhpcy5sb29rdXBSZXR1cm5UeXBlID0gbnVsbDtcbiAgICB0aGlzLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyA9IG51bGw7XG4gICAgdGhpcy5sb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8gPSBudWxsO1xuICAgIHRoaXMudHJpZ2dlckltcGx5QXJndW1lbnRUeXBlID0gbnVsbDtcbiAgICB0aGlzLnRyaWdnZXJJbXBseUFyZ3VtZW50Qml0UmF0aW8gPSBudWxsO1xuICAgIHRoaXMub25OZXN0ZWRGdW5jdGlvbiA9IG51bGw7XG4gICAgdGhpcy5vbkZ1bmN0aW9uQ2FsbCA9IG51bGw7XG4gICAgdGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5ID0gbnVsbDtcbiAgICB0aGlzLnByZWNpc2lvbiA9IG51bGw7XG4gICAgdGhpcy5sb29wTWF4SXRlcmF0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5hcmd1bWVudE5hbWVzID0gKHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ3N0cmluZycgPyB1dGlscy5nZXRBcmd1bWVudE5hbWVzRnJvbVN0cmluZyh0aGlzLnNvdXJjZSkgOiBudWxsKTtcbiAgICB0aGlzLmFyZ3VtZW50VHlwZXMgPSBbXTtcbiAgICB0aGlzLmFyZ3VtZW50U2l6ZXMgPSBbXTtcbiAgICB0aGlzLmFyZ3VtZW50Qml0UmF0aW9zID0gbnVsbDtcbiAgICB0aGlzLnJldHVyblR5cGUgPSBudWxsO1xuICAgIHRoaXMub3V0cHV0ID0gW107XG4gICAgdGhpcy5wbHVnaW5zID0gbnVsbDtcbiAgICB0aGlzLmxlYWRpbmdSZXR1cm5TdGF0ZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmR5bmFtaWNPdXRwdXQgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY0FyZ3VtZW50cyA9IG51bGw7XG4gICAgdGhpcy5zdHJpY3RUeXBpbmdDaGVja2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBudWxsO1xuICAgIHRoaXMub25Jc3RhbmJ1bENvdmVyYWdlVmFyaWFibGUgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlSXN0YW5idWxDb3ZlcmFnZSA9IGZhbHNlO1xuXG4gICAgaWYgKHNldHRpbmdzKSB7XG4gICAgICBmb3IgKGNvbnN0IHAgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKCFzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIHRoaXNbcF0gPSBzZXR0aW5nc1twXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxpdGVyYWxUeXBlcyA9IHt9O1xuXG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIHRoaXMuX3N0cmluZyA9IG51bGw7XG4gICAgdGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzID0ge307XG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuc291cmNlICE9PSAnc3RyaW5nJyAmJiAhdGhpcy5hc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhpcy5zb3VyY2Ugbm90IGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFzdCAmJiAhdXRpbHMuaXNGdW5jdGlvblN0cmluZyh0aGlzLnNvdXJjZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhpcy5zb3VyY2Ugbm90IGEgZnVuY3Rpb24gc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhpcy5uYW1lIGNvdWxkIG5vdCBiZSBzZXQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcmd1bWVudFR5cGVzLmxlbmd0aCA+IDAgJiYgdGhpcy5hcmd1bWVudFR5cGVzLmxlbmd0aCAhPT0gdGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcmd1bWVudFR5cGVzIGNvdW50IG9mICR7IHRoaXMuYXJndW1lbnRUeXBlcy5sZW5ndGggfSBleGNlZWRzICR7IHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGggfWApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm91dHB1dC5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoaXMub3V0cHV0IGlzIG5vdCBiaWcgZW5vdWdoJyk7XG4gICAgfVxuICB9XG5cbiAgaXNJZGVudGlmaWVyQ29uc3RhbnQobmFtZSkge1xuICAgIGlmICghdGhpcy5jb25zdGFudHMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5jb25zdGFudHMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH1cblxuICBpc0lucHV0KGFyZ3VtZW50TmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFyZ3VtZW50VHlwZXNbdGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YoYXJndW1lbnROYW1lKV0gPT09ICdJbnB1dCc7XG4gIH1cblxuICBwdXNoU3RhdGUoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgfVxuXG4gIHBvcFN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwb3BTdGF0ZSAkeyBzdGF0ZSB9IHdoZW4gaW4gJHsgdGhpcy5zdGF0ZSB9YCk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVzLnBvcCgpO1xuICB9XG5cbiAgaXNTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBzdGF0ZTtcbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNbdGhpcy5zdGF0ZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICBhc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKGFzdCkge1xuICAgIGlmIChhc3QudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICByZXR1cm4gYXN0Lm5hbWU7XG4gICAgfSBlbHNlIGlmIChhc3QudHlwZSA9PT0gJ1RoaXNFeHByZXNzaW9uJykge1xuICAgICAgcmV0dXJuICd0aGlzJztcbiAgICB9XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgaWYgKGFzdC5vYmplY3QgJiYgYXN0LnByb3BlcnR5KSB7XG4gICAgICAgIGlmIChhc3Qub2JqZWN0Lmhhc093blByb3BlcnR5KCduYW1lJykgJiYgYXN0Lm9iamVjdC5uYW1lWzBdID09PSAnXycpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKGFzdC5wcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChhc3Qub2JqZWN0KSArXG4gICAgICAgICAgJy4nICtcbiAgICAgICAgICB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0LnByb3BlcnR5KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhc3QuaGFzT3duUHJvcGVydHkoJ2V4cHJlc3Npb25zJykpIHtcbiAgICAgIGNvbnN0IGZpcnN0RXhwcmVzc2lvbiA9IGFzdC5leHByZXNzaW9uc1swXTtcbiAgICAgIGlmIChmaXJzdEV4cHJlc3Npb24udHlwZSA9PT0gJ0xpdGVyYWwnICYmIGZpcnN0RXhwcmVzc2lvbi52YWx1ZSA9PT0gMCAmJiBhc3QuZXhwcmVzc2lvbnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0LmV4cHJlc3Npb25zWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmtub3duIGFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwnLCBhc3QpO1xuICB9XG5cbiAgZ2V0SnNBU1QoaW5QYXJzZXIpIHtcbiAgICBpZiAodGhpcy5hc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMudHJhY2VGdW5jdGlvbkFTVCh0aGlzLnNvdXJjZSk7XG4gICAgICByZXR1cm4gdGhpcy5hc3QgPSB0aGlzLnNvdXJjZTtcbiAgICB9XG5cbiAgICBpblBhcnNlciA9IGluUGFyc2VyIHx8IGFjb3JuO1xuICAgIGlmIChpblBhcnNlciA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIEpTIHRvIEFTVCBwYXJzZXInKTtcbiAgICB9XG5cbiAgICBjb25zdCBhc3QgPSBPYmplY3QuZnJlZXplKGluUGFyc2VyLnBhcnNlKGBjb25zdCBwYXJzZXJfJHsgdGhpcy5uYW1lIH0gPSAkeyB0aGlzLnNvdXJjZSB9O2AsIHtcbiAgICAgIGxvY2F0aW9uczogdHJ1ZVxuICAgIH0pKTtcbiAgICBjb25zdCBmdW5jdGlvbkFTVCA9IGFzdC5ib2R5WzBdLmRlY2xhcmF0aW9uc1swXS5pbml0O1xuICAgIHRoaXMudHJhY2VGdW5jdGlvbkFTVChmdW5jdGlvbkFTVCk7XG5cbiAgICBpZiAoIWFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgSlMgY29kZScpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFzdCA9IGZ1bmN0aW9uQVNUO1xuICB9XG5cbiAgdHJhY2VGdW5jdGlvbkFTVChhc3QpIHtcbiAgICBjb25zdCB7IGNvbnRleHRzLCBkZWNsYXJhdGlvbnMsIGZ1bmN0aW9ucywgaWRlbnRpZmllcnMsIGZ1bmN0aW9uQ2FsbHMgfSA9IG5ldyBGdW5jdGlvblRyYWNlcihhc3QpO1xuICAgIHRoaXMuY29udGV4dHMgPSBjb250ZXh0cztcbiAgICB0aGlzLmlkZW50aWZpZXJzID0gaWRlbnRpZmllcnM7XG4gICAgdGhpcy5mdW5jdGlvbkNhbGxzID0gZnVuY3Rpb25DYWxscztcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbnNbaV07XG4gICAgICBjb25zdCB7IGFzdCwgaW5Gb3JMb29wSW5pdCwgaW5Gb3JMb29wVGVzdCB9ID0gZGVjbGFyYXRpb247XG4gICAgICBjb25zdCB7IGluaXQgfSA9IGFzdDtcbiAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGluaXQpO1xuICAgICAgbGV0IHZhbHVlVHlwZSA9IG51bGw7XG5cbiAgICAgIGlmIChpbkZvckxvb3BJbml0ICYmIGluRm9yTG9vcFRlc3QpIHtcbiAgICAgICAgdmFsdWVUeXBlID0gJ0ludGVnZXInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICBjb25zdCByZWFsVHlwZSA9IHRoaXMuZ2V0VHlwZShpbml0KTtcbiAgICAgICAgICBzd2l0Y2ggKHJlYWxUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICAgIGlmIChpbml0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IHJlYWxUeXBlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9ICdOdW1iZXInO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSAnTnVtYmVyJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSByZWFsVHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlY2xhcmF0aW9uLnZhbHVlVHlwZSA9IHZhbHVlVHlwZTtcbiAgICAgIGRlY2xhcmF0aW9uLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgICAgIGRlY2xhcmF0aW9uLmlzU2FmZSA9IHRoaXMuaXNTYWZlRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMub25OZXN0ZWRGdW5jdGlvbihmdW5jdGlvbnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGdldERlY2xhcmF0aW9uKGFzdCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMuaWRlbnRpZmllcnNbaV07XG4gICAgICBpZiAoYXN0ID09PSBpZGVudGlmaWVyLmFzdCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllci5kZWNsYXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRWYXJpYWJsZVR5cGUoYXN0KSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYXN0IG9mICR7YXN0LnR5cGV9IG5vdCBcIklkZW50aWZpZXJcImApO1xuICAgIH1cbiAgICBsZXQgdHlwZSA9IG51bGw7XG4gICAgY29uc3QgYXJndW1lbnRJbmRleCA9IHRoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKGFzdC5uYW1lKTtcbiAgICBpZiAoYXJndW1lbnRJbmRleCA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdGhpcy5nZXREZWNsYXJhdGlvbihhc3QpO1xuICAgICAgaWYgKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBkZWNsYXJhdGlvbi52YWx1ZVR5cGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFyZ3VtZW50VHlwZSA9IHRoaXMuYXJndW1lbnRUeXBlc1thcmd1bWVudEluZGV4XTtcbiAgICAgIGlmIChhcmd1bWVudFR5cGUpIHtcbiAgICAgICAgdHlwZSA9IGFyZ3VtZW50VHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlICYmIHRoaXMuc3RyaWN0VHlwaW5nQ2hlY2tpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRGVjbGFyYXRpb24gb2YgJHtuYW1lfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBnZXRMb29rdXBUeXBlKHR5cGUpIHtcbiAgICBpZiAoIXR5cGVMb29rdXBNYXAuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlTG9va3VwTWFwICR7IHR5cGUgfWApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZUxvb2t1cE1hcFt0eXBlXTtcbiAgfVxuXG4gIGdldENvbnN0YW50VHlwZShjb25zdGFudE5hbWUpIHtcbiAgICBpZiAodGhpcy5jb25zdGFudFR5cGVzW2NvbnN0YW50TmFtZV0pIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmNvbnN0YW50VHlwZXNbY29uc3RhbnROYW1lXTtcbiAgICAgIGlmICh0eXBlID09PSAnRmxvYXQnKSB7XG4gICAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgZm9yIGNvbnN0YW50IFwiJHsgY29uc3RhbnROYW1lIH1cIiBub3QgZGVjbGFyZWRgKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLl9zdHJpbmcpIHJldHVybiB0aGlzLl9zdHJpbmc7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmluZyA9IHRoaXMuYXN0R2VuZXJpYyh0aGlzLmdldEpzQVNUKCksIFtdKS5qb2luKCcnKS50cmltKCk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgY29uc3RhbnRzOiB0aGlzLmNvbnN0YW50cyxcbiAgICAgIGNvbnN0YW50VHlwZXM6IHRoaXMuY29uc3RhbnRUeXBlcyxcbiAgICAgIGlzUm9vdEtlcm5lbDogdGhpcy5pc1Jvb3RLZXJuZWwsXG4gICAgICBpc1N1Yktlcm5lbDogdGhpcy5pc1N1Yktlcm5lbCxcbiAgICAgIGRlYnVnOiB0aGlzLmRlYnVnLFxuICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgIGxvb3BNYXhJdGVyYXRpb25zOiB0aGlzLmxvb3BNYXhJdGVyYXRpb25zLFxuICAgICAgYXJndW1lbnROYW1lczogdGhpcy5hcmd1bWVudE5hbWVzLFxuICAgICAgYXJndW1lbnRUeXBlczogdGhpcy5hcmd1bWVudFR5cGVzLFxuICAgICAgYXJndW1lbnRTaXplczogdGhpcy5hcmd1bWVudFNpemVzLFxuICAgICAgcmV0dXJuVHlwZTogdGhpcy5yZXR1cm5UeXBlLFxuICAgICAgbGVhZGluZ1JldHVyblN0YXRlbWVudDogdGhpcy5sZWFkaW5nUmV0dXJuU3RhdGVtZW50LFxuICAgICAgZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50OiB0aGlzLmZvbGxvd2luZ1JldHVyblN0YXRlbWVudCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFzdDogdGhpcy5hc3QsXG4gICAgICBzZXR0aW5nc1xuICAgIH07XG4gIH1cblxuICBnZXRUeXBlKGFzdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0W2FzdC5sZW5ndGggLSAxXSk7XG4gICAgfVxuICAgIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuYm9keSk7XG4gICAgICBjYXNlICdBcnJheUV4cHJlc3Npb24nOlxuICAgICAgICByZXR1cm4gYEFycmF5KCR7IGFzdC5lbGVtZW50cy5sZW5ndGggfSlgO1xuICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgIGNvbnN0IGxpdGVyYWxLZXkgPSB0aGlzLmFzdEtleShhc3QpO1xuICAgICAgICBpZiAodGhpcy5saXRlcmFsVHlwZXNbbGl0ZXJhbEtleV0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5saXRlcmFsVHlwZXNbbGl0ZXJhbEtleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoYXN0LnZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiAnTGl0ZXJhbEludGVnZXInO1xuICAgICAgICB9IGVsc2UgaWYgKGFzdC52YWx1ZSA9PT0gdHJ1ZSB8fCBhc3QudmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuICdCb29sZWFuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJ051bWJlcic7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmxlZnQpO1xuICAgICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6XG4gICAgICAgICAgaWYgKHRoaXMuaXNBc3RNYXRoRnVuY3Rpb24oYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWFzdC5jYWxsZWUgfHwgIWFzdC5jYWxsZWUubmFtZSkge1xuICAgICAgICAgICAgaWYgKGFzdC5jYWxsZWUudHlwZSA9PT0gJ1NlcXVlbmNlRXhwcmVzc2lvbicgJiYgYXN0LmNhbGxlZS5leHByZXNzaW9uc1thc3QuY2FsbGVlLmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdLnByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYXN0LmNhbGxlZS5leHByZXNzaW9uc1thc3QuY2FsbGVlLmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdLnByb3BlcnR5Lm5hbWU7XG4gICAgICAgICAgICAgIHRoaXMuaW5mZXJBcmd1bWVudFR5cGVzSWZOZWVkZWQoZnVuY3Rpb25OYW1lLCBhc3QuYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwUmV0dXJuVHlwZShmdW5jdGlvbk5hbWUsIGFzdCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRWYXJpYWJsZVNpZ25hdHVyZShhc3QuY2FsbGVlLCB0cnVlKSA9PT0gJ3RoaXMuY29sb3InKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5rbm93biBjYWxsIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXN0LmNhbGxlZSAmJiBhc3QuY2FsbGVlLm5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGFzdC5jYWxsZWUubmFtZTtcbiAgICAgICAgICAgIHRoaXMuaW5mZXJBcmd1bWVudFR5cGVzSWZOZWVkZWQoZnVuY3Rpb25OYW1lLCBhc3QuYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvb2t1cFJldHVyblR5cGUoZnVuY3Rpb25OYW1lLCBhc3QsIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgZ2V0VHlwZSBUeXBlIFwiJHsgYXN0LnR5cGUgfVwiYCwgYXN0KTtcbiAgICAgICAgY2FzZSAnTG9naWNhbEV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiAnQm9vbGVhbic7XG4gICAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdCb29sZWFuJztcbiAgICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICAgICAgY2FzZSAnPDwnOlxuICAgICAgICAgICAgICBjYXNlICc+Pic6XG4gICAgICAgICAgICAgIGNhc2UgJz4+Pic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QubGVmdCk7XG4gICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnc2tpcC1saXRlcmFsLWNvcnJlY3Rpb24nKSkgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QucmlnaHQpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0VHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuICAgICAgICAgICAgICBpZiAoYXN0LmxlZnQudmFsdWUgJSAxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0Zsb2F0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0VHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVMb29rdXBNYXBbdHlwZV0gfHwgdHlwZTtcbiAgICAgICAgY2FzZSAnVXBkYXRlRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuYXJndW1lbnQpO1xuICAgICAgICBjYXNlICdVbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgIGlmIChhc3Qub3BlcmF0b3IgPT09ICd+Jykge1xuICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuYXJndW1lbnQpO1xuICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzoge1xuICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IGFzdC5kZWNsYXJhdGlvbnM7XG4gICAgICAgICAgbGV0IGxhc3RUeXBlO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIGxhc3RUeXBlID0gdGhpcy5nZXRUeXBlKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFsYXN0VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5hYmxlIHRvIGZpbmQgdHlwZSBmb3IgZGVjbGFyYXRpb25gLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGFzdFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzpcbiAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHRoaXMuZ2V0RGVjbGFyYXRpb24oYXN0LmlkKTtcbiAgICAgICAgICBpZiAoIWRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmFibGUgdG8gZmluZCBkZWNsYXJhdG9yYCwgYXN0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWRlY2xhcmF0aW9uLnZhbHVlVHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5hYmxlIHRvIGZpbmQgZGVjbGFyYXRvciB2YWx1ZVR5cGVgLCBhc3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvbi52YWx1ZVR5cGU7XG4gICAgICAgIGNhc2UgJ0lkZW50aWZpZXInOlxuICAgICAgICAgIGlmIChhc3QubmFtZSA9PT0gJ0luZmluaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5pc0FzdFZhcmlhYmxlKGFzdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuZ2V0VmFyaWFibGVTaWduYXR1cmUoYXN0KTtcbiAgICAgICAgICAgIGlmIChzaWduYXR1cmUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5maW5kSWRlbnRpZmllck9yaWdpbihhc3QpO1xuICAgICAgICAgIGlmIChvcmlnaW4gJiYgb3JpZ2luLmluaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUob3JpZ2luLmluaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnUmV0dXJuU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGFzdC5hcmd1bWVudCk7XG4gICAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICAgIGlmICh0aGlzLmlzQXN0TWF0aEZ1bmN0aW9uKGFzdCkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXN0LnByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY2VpbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICAgICAgICAgIHJldHVybiAnSW50ZWdlcic7XG4gICAgICAgICAgICAgIGNhc2UgJ3JvdW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0ludGVnZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5pc0FzdFZhcmlhYmxlKGFzdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlU2lnbmF0dXJlID0gdGhpcy5nZXRWYXJpYWJsZVNpZ25hdHVyZShhc3QpO1xuICAgICAgICAgICAgc3dpdGNoICh2YXJpYWJsZVNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZVtdW10nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFR5cGUodGhpcy5nZXRDaGVja1ZhcmlhYmxlVHlwZShhc3Qub2JqZWN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZVtdW11bXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENoZWNrVmFyaWFibGVUeXBlKGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZVtdW11bXVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZS50aHJlYWQudmFsdWUnOlxuICAgICAgICAgICAgICBjYXNlICd0aGlzLnRocmVhZC52YWx1ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5vdXRwdXQudmFsdWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmR5bmFtaWNPdXRwdXQgPyAnSW50ZWdlcicgOiAnTGl0ZXJhbEludGVnZXInO1xuICAgICAgICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uc3RhbnRUeXBlKGFzdC5wcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENvbnN0YW50VHlwZShhc3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q29uc3RhbnRUeXBlKGFzdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW10nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFR5cGUodGhpcy5nZXRDb25zdGFudFR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW11bXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENvbnN0YW50VHlwZShhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgY2FzZSAnZm4oKVtdJzpcbiAgICAgICAgICAgICAgY2FzZSAnZm4oKVtdW10nOlxuICAgICAgICAgICAgICBjYXNlICdmbigpW11bXVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0VHlwZShhc3Qub2JqZWN0KSk7XG4gICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlLnZhbHVlJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FzdE1hdGhWYXJpYWJsZShhc3QpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJ051bWJlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXN0LnByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdbXVtdJzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuaGFuZGxlZCBnZXRUeXBlIE1lbWJlckV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmhhbmRsZWQgZ2V0VHlwZSBNZW1iZXJFeHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGFzdC5jb25zZXF1ZW50KTtcbiAgICAgICAgY2FzZSAnRnVuY3Rpb25EZWNsYXJhdGlvbic6XG4gICAgICAgIGNhc2UgJ0Z1bmN0aW9uRXhwcmVzc2lvbic6XG4gICAgICAgICAgY29uc3QgbGFzdFJldHVybiA9IHRoaXMuZmluZExhc3RSZXR1cm4oYXN0LmJvZHkpO1xuICAgICAgICAgIGlmIChsYXN0UmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGxhc3RSZXR1cm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmNvbnNlcXVlbnQpO1xuICAgICAgICBjYXNlICdTZXF1ZW5jZUV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmV4cHJlc3Npb25zW2FzdC5leHByZXNzaW9ucy5sZW5ndGggLSAxXSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIGdldFR5cGUgVHlwZSBcIiR7IGFzdC50eXBlIH1cImAsIGFzdCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0KSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VmFyaWFibGVUeXBlKGFzdCk7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGAke2FzdC50eXBlfSBpcyBub3QgZGVmaW5lZGAsIGFzdCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgaW5mZXJBcmd1bWVudFR5cGVzSWZOZWVkZWQoZnVuY3Rpb25OYW1lLCBhcmdzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMubmVlZHNBcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpKSkgY29udGludWU7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGFyZ3NbaV0pO1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuYWJsZSB0byBpbmZlciBhcmd1bWVudCAke2l9YCwgYXJnc1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFzc2lnbkFyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGksIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlzQXN0TWF0aFZhcmlhYmxlKGFzdCkge1xuICAgIGNvbnN0IG1hdGhQcm9wZXJ0aWVzID0gW1xuICAgICAgJ0UnLFxuICAgICAgJ1BJJyxcbiAgICAgICdTUVJUMicsXG4gICAgICAnU1FSVDFfMicsXG4gICAgICAnTE4yJyxcbiAgICAgICdMTjEwJyxcbiAgICAgICdMT0cyRScsXG4gICAgICAnTE9HMTBFJyxcbiAgICBdO1xuICAgIHJldHVybiBhc3QudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmXG4gICAgICBhc3Qub2JqZWN0ICYmIGFzdC5vYmplY3QudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG4gICAgICBhc3Qub2JqZWN0Lm5hbWUgPT09ICdNYXRoJyAmJlxuICAgICAgYXN0LnByb3BlcnR5ICYmXG4gICAgICBhc3QucHJvcGVydHkudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG4gICAgICBtYXRoUHJvcGVydGllcy5pbmRleE9mKGFzdC5wcm9wZXJ0eS5uYW1lKSA+IC0xO1xuICB9XG5cbiAgaXNBc3RNYXRoRnVuY3Rpb24oYXN0KSB7XG4gICAgY29uc3QgbWF0aEZ1bmN0aW9ucyA9IFtcbiAgICAgICdhYnMnLFxuICAgICAgJ2Fjb3MnLFxuICAgICAgJ2Fjb3NoJyxcbiAgICAgICdhc2luJyxcbiAgICAgICdhc2luaCcsXG4gICAgICAnYXRhbicsXG4gICAgICAnYXRhbjInLFxuICAgICAgJ2F0YW5oJyxcbiAgICAgICdjYnJ0JyxcbiAgICAgICdjZWlsJyxcbiAgICAgICdjbHozMicsXG4gICAgICAnY29zJyxcbiAgICAgICdjb3NoJyxcbiAgICAgICdleHBtMScsXG4gICAgICAnZXhwJyxcbiAgICAgICdmbG9vcicsXG4gICAgICAnZnJvdW5kJyxcbiAgICAgICdpbXVsJyxcbiAgICAgICdsb2cnLFxuICAgICAgJ2xvZzInLFxuICAgICAgJ2xvZzEwJyxcbiAgICAgICdsb2cxcCcsXG4gICAgICAnbWF4JyxcbiAgICAgICdtaW4nLFxuICAgICAgJ3BvdycsXG4gICAgICAncmFuZG9tJyxcbiAgICAgICdyb3VuZCcsXG4gICAgICAnc2lnbicsXG4gICAgICAnc2luJyxcbiAgICAgICdzaW5oJyxcbiAgICAgICdzcXJ0JyxcbiAgICAgICd0YW4nLFxuICAgICAgJ3RhbmgnLFxuICAgICAgJ3RydW5jJyxcbiAgICBdO1xuICAgIHJldHVybiBhc3QudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJyAmJlxuICAgICAgYXN0LmNhbGxlZSAmJlxuICAgICAgYXN0LmNhbGxlZS50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgJiZcbiAgICAgIGFzdC5jYWxsZWUub2JqZWN0ICYmXG4gICAgICBhc3QuY2FsbGVlLm9iamVjdC50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgIGFzdC5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdNYXRoJyAmJlxuICAgICAgYXN0LmNhbGxlZS5wcm9wZXJ0eSAmJlxuICAgICAgYXN0LmNhbGxlZS5wcm9wZXJ0eS50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgIG1hdGhGdW5jdGlvbnMuaW5kZXhPZihhc3QuY2FsbGVlLnByb3BlcnR5Lm5hbWUpID4gLTE7XG4gIH1cblxuICBpc0FzdFZhcmlhYmxlKGFzdCkge1xuICAgIHJldHVybiBhc3QudHlwZSA9PT0gJ0lkZW50aWZpZXInIHx8IGFzdC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbic7XG4gIH1cblxuICBpc1NhZmUoYXN0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTYWZlRGVwZW5kZW5jaWVzKHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdCkpO1xuICB9XG5cbiAgaXNTYWZlRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcykge1xuICAgIHJldHVybiBkZXBlbmRlbmNpZXMgJiYgZGVwZW5kZW5jaWVzLmV2ZXJ5ID8gZGVwZW5kZW5jaWVzLmV2ZXJ5KGRlcGVuZGVuY3kgPT4gZGVwZW5kZW5jeS5pc1NhZmUpIDogdHJ1ZTtcbiAgfVxuXG4gIGdldERlcGVuZGVuY2llcyhhc3QsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKSB7XG4gICAgaWYgKCFkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoIWFzdCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXN0KSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0W2ldLCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5sZWZ0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5yaWdodCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LnRlc3QsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmFsdGVybmF0ZSwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QuY29uc2VxdWVudCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICBvcmlnaW46ICdsaXRlcmFsJyxcbiAgICAgICAgICB2YWx1ZTogYXN0LnZhbHVlLFxuICAgICAgICAgIGlzU2FmZTogaXNOb3RTYWZlID09PSB0cnVlID8gZmFsc2UgOiBhc3QudmFsdWUgPiAtSW5maW5pdHkgJiYgYXN0LnZhbHVlIDwgSW5maW5pdHkgJiYgIWlzTmFOKGFzdC52YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5pbml0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICBjYXNlICdJZGVudGlmaWVyJzpcbiAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLmdldERlY2xhcmF0aW9uKGFzdCk7XG4gICAgICAgIGlmIChkZWNsYXJhdGlvbikge1xuICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGFzdC5uYW1lLFxuICAgICAgICAgICAgb3JpZ2luOiAnZGVjbGFyYXRpb24nLFxuICAgICAgICAgICAgaXNTYWZlOiBpc05vdFNhZmUgPyBmYWxzZSA6IHRoaXMuaXNTYWZlRGVwZW5kZW5jaWVzKGRlY2xhcmF0aW9uLmRlcGVuZGVuY2llcyksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YoYXN0Lm5hbWUpID4gLTEpIHtcbiAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBhc3QubmFtZSxcbiAgICAgICAgICAgIG9yaWdpbjogJ2FyZ3VtZW50JyxcbiAgICAgICAgICAgIGlzU2FmZTogZmFsc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdHJpY3RUeXBpbmdDaGVja2luZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgaWRlbnRpZmllciBvcmlnaW4gXCIke2FzdC5uYW1lfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdGdW5jdGlvbkRlY2xhcmF0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5ib2R5LmJvZHlbYXN0LmJvZHkuYm9keS5sZW5ndGggLSAxXSwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgY2FzZSAnUmV0dXJuU3RhdGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5hcmd1bWVudCwgZGVwZW5kZW5jaWVzKTtcbiAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnTG9naWNhbEV4cHJlc3Npb24nOlxuICAgICAgICBpc05vdFNhZmUgPSAoYXN0Lm9wZXJhdG9yID09PSAnLycgfHwgYXN0Lm9wZXJhdG9yID09PSAnKicpO1xuICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QubGVmdCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QucmlnaHQsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgICAgIGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG4gICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5hcmd1bWVudCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdGlvbic6XG4gICAgICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QuZGVjbGFyYXRpb25zLCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICBjYXNlICdBcnJheUV4cHJlc3Npb24nOlxuICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgb3JpZ2luOiAnZGVjbGFyYXRpb24nLFxuICAgICAgICAgIGlzU2FmZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6XG4gICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICBvcmlnaW46ICdmdW5jdGlvbicsXG4gICAgICAgICAgaXNTYWZlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICBjb25zdCBkZXRhaWxzID0gdGhpcy5nZXRNZW1iZXJFeHByZXNzaW9uRGV0YWlscyhhc3QpO1xuICAgICAgICBzd2l0Y2ggKGRldGFpbHMuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgY2FzZSAndmFsdWVbXSc6XG4gICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3Qub2JqZWN0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd2YWx1ZVtdW10nOlxuICAgICAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0Lm9iamVjdC5vYmplY3QsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3ZhbHVlW11bXVtdJzpcbiAgICAgICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGhpcy5vdXRwdXQudmFsdWUnOlxuICAgICAgICAgICAgaWYgKHRoaXMuZHluYW1pY091dHB1dCkge1xuICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogZGV0YWlscy5uYW1lLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogJ291dHB1dCcsXG4gICAgICAgICAgICAgICAgaXNTYWZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICAgIGlmIChkZXRhaWxzLnByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhkZXRhaWxzLnByb3BlcnR5LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZXRhaWxzLnhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoZGV0YWlscy54UHJvcGVydHksIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRldGFpbHMueVByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhkZXRhaWxzLnlQcm9wZXJ0eSwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGV0YWlscy56UHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGRldGFpbHMuelByb3BlcnR5LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnU2VxdWVuY2VFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmV4cHJlc3Npb25zLCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIHR5cGUgJHsgYXN0LnR5cGUgfSBpbiBnZXREZXBlbmRlbmNpZXNgLCBhc3QpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVTaWduYXR1cmUoYXN0LCByZXR1cm5SYXdWYWx1ZSkge1xuICAgIGlmICghdGhpcy5pc0FzdFZhcmlhYmxlKGFzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYXN0IG9mIHR5cGUgXCIkeyBhc3QudHlwZSB9XCIgaXMgbm90IGEgdmFyaWFibGUgc2lnbmF0dXJlYCk7XG4gICAgfVxuICAgIGlmIChhc3QudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICByZXR1cm4gJ3ZhbHVlJztcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gW107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICghYXN0KSBicmVhaztcbiAgICAgIGlmIChhc3QuY29tcHV0ZWQpIHtcbiAgICAgICAgc2lnbmF0dXJlLnB1c2goJ1tdJyk7XG4gICAgICB9IGVsc2UgaWYgKGFzdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSB7XG4gICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KCd0aGlzJyk7XG4gICAgICB9IGVsc2UgaWYgKGFzdC5wcm9wZXJ0eSAmJiBhc3QucHJvcGVydHkubmFtZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYXN0LnByb3BlcnR5Lm5hbWUgPT09ICd4JyB8fFxuICAgICAgICAgIGFzdC5wcm9wZXJ0eS5uYW1lID09PSAneScgfHxcbiAgICAgICAgICBhc3QucHJvcGVydHkubmFtZSA9PT0gJ3onXG4gICAgICAgICkge1xuICAgICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KHJldHVyblJhd1ZhbHVlID8gJy4nICsgYXN0LnByb3BlcnR5Lm5hbWUgOiAnLnZhbHVlJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgYXN0LnByb3BlcnR5Lm5hbWUgPT09ICdjb25zdGFudHMnIHx8XG4gICAgICAgICAgYXN0LnByb3BlcnR5Lm5hbWUgPT09ICd0aHJlYWQnIHx8XG4gICAgICAgICAgYXN0LnByb3BlcnR5Lm5hbWUgPT09ICdvdXRwdXQnXG4gICAgICAgICkge1xuICAgICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KCcuJyArIGFzdC5wcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaWduYXR1cmUudW5zaGlmdChyZXR1cm5SYXdWYWx1ZSA/ICcuJyArIGFzdC5wcm9wZXJ0eS5uYW1lIDogJy52YWx1ZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFzdC5uYW1lKSB7XG4gICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KHJldHVyblJhd1ZhbHVlID8gYXN0Lm5hbWUgOiAndmFsdWUnKTtcbiAgICAgIH0gZWxzZSBpZiAoYXN0LmNhbGxlZSAmJiBhc3QuY2FsbGVlLm5hbWUpIHtcbiAgICAgICAgc2lnbmF0dXJlLnVuc2hpZnQocmV0dXJuUmF3VmFsdWUgPyBhc3QuY2FsbGVlLm5hbWUgKyAnKCknIDogJ2ZuKCknKTtcbiAgICAgIH0gZWxzZSBpZiAoYXN0LmVsZW1lbnRzKSB7XG4gICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KCdbXScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2lnbmF0dXJlLnVuc2hpZnQoJ3Vua25vd24nKTtcbiAgICAgIH1cbiAgICAgIGFzdCA9IGFzdC5vYmplY3Q7XG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmF0dXJlU3RyaW5nID0gc2lnbmF0dXJlLmpvaW4oJycpO1xuICAgIGlmIChyZXR1cm5SYXdWYWx1ZSkge1xuICAgICAgcmV0dXJuIHNpZ25hdHVyZVN0cmluZztcbiAgICB9XG5cbiAgICBjb25zdCBhbGxvd2VkRXhwcmVzc2lvbnMgPSBbXG4gICAgICAndmFsdWUnLFxuICAgICAgJ3ZhbHVlW10nLFxuICAgICAgJ3ZhbHVlW11bXScsXG4gICAgICAndmFsdWVbXVtdW10nLFxuICAgICAgJ3ZhbHVlW11bXVtdW10nLFxuICAgICAgJ3ZhbHVlLnZhbHVlJyxcbiAgICAgICd2YWx1ZS52YWx1ZVtdJywgXG4gICAgICAndmFsdWUudmFsdWVbXVtdJywgXG4gICAgICAndmFsdWUudGhyZWFkLnZhbHVlJyxcbiAgICAgICd0aGlzLnRocmVhZC52YWx1ZScsXG4gICAgICAndGhpcy5vdXRwdXQudmFsdWUnLFxuICAgICAgJ3RoaXMuY29uc3RhbnRzLnZhbHVlJyxcbiAgICAgICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdJyxcbiAgICAgICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW10nLFxuICAgICAgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdJyxcbiAgICAgICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXVtdJyxcbiAgICAgICdmbigpW10nLFxuICAgICAgJ2ZuKClbXVtdJyxcbiAgICAgICdmbigpW11bXVtdJyxcbiAgICAgICdbXVtdJyxcbiAgICBdO1xuICAgIGlmIChhbGxvd2VkRXhwcmVzc2lvbnMuaW5kZXhPZihzaWduYXR1cmVTdHJpbmcpID4gLTEpIHtcbiAgICAgIHJldHVybiBzaWduYXR1cmVTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYnVpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgYXN0R2VuZXJpYyhhc3QsIHJldEFycikge1xuICAgIGlmIChhc3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ05VTEwgYXN0JywgYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXN0KSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3RbaV0sIHJldEFycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChhc3QudHlwZSkge1xuICAgICAgICBjYXNlICdGdW5jdGlvbkRlY2xhcmF0aW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RGdW5jdGlvbkRlY2xhcmF0aW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnRnVuY3Rpb25FeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RGdW5jdGlvbkV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdSZXR1cm5TdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFJldHVyblN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0xpdGVyYWwnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdExpdGVyYWwoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RCaW5hcnlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnSWRlbnRpZmllcic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0SWRlbnRpZmllckV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0QXNzaWdubWVudEV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdFeHByZXNzaW9uU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RFeHByZXNzaW9uU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnRW1wdHlTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEVtcHR5U3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEJsb2NrU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdElmU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnU3dpdGNoU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RTd2l0Y2hTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdCcmVha1N0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0QnJlYWtTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdDb250aW51ZVN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0Q29udGludWVTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdGb3JTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEZvclN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RXaGlsZVN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0RvV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdERvV2hpbGVTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RWYXJpYWJsZURlY2xhcmF0aW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RWYXJpYWJsZURlY2xhcmF0b3IoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdUaGlzRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0VGhpc0V4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdTZXF1ZW5jZUV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFNlcXVlbmNlRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0VW5hcnlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnVXBkYXRlRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0VXBkYXRlRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0xvZ2ljYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RMb2dpY2FsRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0Q2FsbEV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdBcnJheUV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEFycmF5RXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0RlYnVnZ2VyU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3REZWJ1Z2dlclN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0Q29uZGl0aW9uYWxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5rbm93biBhc3QgdHlwZSA6ICcgKyBhc3QudHlwZSwgYXN0KTtcbiAgICB9XG4gIH1cbiAgYXN0RXJyb3JPdXRwdXQoZXJyb3IsIGFzdCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWJ1Z1N0cmluZyA9IHV0aWxzLmdldEFzdFN0cmluZyh0aGlzLnNvdXJjZSwgYXN0KTtcbiAgICBjb25zdCBsZWFkaW5nU291cmNlID0gdGhpcy5zb3VyY2Uuc3Vic3RyKGFzdC5zdGFydCk7XG4gICAgY29uc3Qgc3BsaXRMaW5lcyA9IGxlYWRpbmdTb3VyY2Uuc3BsaXQoL1xcbi8pO1xuICAgIGNvbnN0IGxpbmVCZWZvcmUgPSBzcGxpdExpbmVzLmxlbmd0aCA+IDAgPyBzcGxpdExpbmVzW3NwbGl0TGluZXMubGVuZ3RoIC0gMV0gOiAwO1xuICAgIHJldHVybiBuZXcgRXJyb3IoYCR7ZXJyb3J9IG9uIGxpbmUgJHsgc3BsaXRMaW5lcy5sZW5ndGggfSwgcG9zaXRpb24gJHsgbGluZUJlZm9yZS5sZW5ndGggfTpcXG4gJHsgZGVidWdTdHJpbmcgfWApO1xuICB9XG5cbiAgYXN0RGVidWdnZXJTdGF0ZW1lbnQoYXJyTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdENvbmRpdGlvbmFsRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIGlmIChhc3QudHlwZSAhPT0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ05vdCBhIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QudGVzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnPycpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnOicpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYWx0ZXJuYXRlLCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEZ1bmN0aW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImFzdEZ1bmN0aW9uXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIGFzdEZ1bmN0aW9uRGVjbGFyYXRpb24oYXN0LCByZXRBcnIpIHtcbiAgICBpZiAodGhpcy5pc0NoaWxkRnVuY3Rpb24oYXN0KSkge1xuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXN0RnVuY3Rpb24oYXN0LCByZXRBcnIpO1xuICB9XG4gIGFzdEZ1bmN0aW9uRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIGlmICh0aGlzLmlzQ2hpbGRGdW5jdGlvbihhc3QpKSB7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hc3RGdW5jdGlvbihhc3QsIHJldEFycik7XG4gIH1cbiAgaXNDaGlsZEZ1bmN0aW9uKGFzdCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmZ1bmN0aW9uc1tpXSA9PT0gYXN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN0UmV0dXJuU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RMaXRlcmFsKGFzdCwgcmV0QXJyKSB7XG4gICAgdGhpcy5saXRlcmFsVHlwZXNbdGhpcy5hc3RLZXkoYXN0KV0gPSAnTnVtYmVyJztcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdEJpbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdElkZW50aWZpZXJFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RBc3NpZ25tZW50RXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0RXhwcmVzc2lvblN0YXRlbWVudChlc05vZGUsIHJldEFycikge1xuICAgIHRoaXMuYXN0R2VuZXJpYyhlc05vZGUuZXhwcmVzc2lvbiwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnOycpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0RW1wdHlTdGF0ZW1lbnQoZU5vZGUsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0QmxvY2tTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdElmU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RTd2l0Y2hTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdEJyZWFrU3RhdGVtZW50KGJyTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJ2JyZWFrOycpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0Q29udGludWVTdGF0ZW1lbnQoY3JOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnY29udGludWU7XFxuJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RGb3JTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdFdoaWxlU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3REb1doaWxlU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RWYXJpYWJsZURlY2xhcmF0b3IoaVZhckRlY05vZGUsIHJldEFycikge1xuICAgIHRoaXMuYXN0R2VuZXJpYyhpVmFyRGVjTm9kZS5pZCwgcmV0QXJyKTtcbiAgICBpZiAoaVZhckRlY05vZGUuaW5pdCAhPT0gbnVsbCkge1xuICAgICAgcmV0QXJyLnB1c2goJz0nKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhpVmFyRGVjTm9kZS5pbml0LCByZXRBcnIpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdFRoaXNFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBpc0lzdGFuYnVsQVNUKGFzdCkge1xuICAgIGNvbnN0IHZhcmlhYmxlU2lnbmF0dXJlID0gdGhpcy5nZXRWYXJpYWJsZVNpZ25hdHVyZShhc3QpO1xuICAgIHJldHVybiB2YXJpYWJsZVNpZ25hdHVyZSA9PT0gJ3ZhbHVlLnZhbHVlW10nIHx8IHZhcmlhYmxlU2lnbmF0dXJlID09PSAndmFsdWUudmFsdWVbXVtdJztcbiAgfVxuICBhc3RTZXF1ZW5jZUV4cHJlc3Npb24oc05vZGUsIHJldEFycikge1xuICAgIGNvbnN0IHsgZXhwcmVzc2lvbnMgfSA9IHNOb2RlO1xuICAgIGNvbnN0IHNlcXVlbmNlUmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25zW2ldO1xuICAgICAgaWYgKHRoaXMucmVtb3ZlSXN0YW5idWxDb3ZlcmFnZSkge1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnVXBkYXRlRXhwcmVzc2lvbicgJiYgdGhpcy5pc0lzdGFuYnVsQVNUKGV4cHJlc3Npb24uYXJndW1lbnQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4cHJlc3Npb25SZXN1bHQgPSBbXTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhleHByZXNzaW9uLCBleHByZXNzaW9uUmVzdWx0KTtcbiAgICAgIHNlcXVlbmNlUmVzdWx0LnB1c2goZXhwcmVzc2lvblJlc3VsdC5qb2luKCcnKSk7XG4gICAgfVxuICAgIGlmIChzZXF1ZW5jZVJlc3VsdC5sZW5ndGggPiAxKSB7XG4gICAgICByZXRBcnIucHVzaCgnKCcsIHNlcXVlbmNlUmVzdWx0LmpvaW4oJywnKSwgJyknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goc2VxdWVuY2VSZXN1bHRbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdFVuYXJ5RXhwcmVzc2lvbih1Tm9kZSwgcmV0QXJyKSB7XG4gICAgY29uc3QgdW5hcnlSZXN1bHQgPSB0aGlzLmNoZWNrQW5kVXBjb252ZXJ0Qml0d2lzZVVuYXJ5KHVOb2RlLCByZXRBcnIpO1xuICAgIGlmICh1bmFyeVJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9XG5cbiAgICBpZiAodU5vZGUucHJlZml4KSB7XG4gICAgICByZXRBcnIucHVzaCh1Tm9kZS5vcGVyYXRvcik7XG4gICAgICB0aGlzLmFzdEdlbmVyaWModU5vZGUuYXJndW1lbnQsIHJldEFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyh1Tm9kZS5hcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKHVOb2RlLm9wZXJhdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgY2hlY2tBbmRVcGNvbnZlcnRCaXR3aXNlVW5hcnkodU5vZGUsIHJldEFycikge31cblxuICBhc3RVcGRhdGVFeHByZXNzaW9uKHVOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAodGhpcy5yZW1vdmVJc3RhbmJ1bENvdmVyYWdlKSB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSB0aGlzLmdldFZhcmlhYmxlU2lnbmF0dXJlKHVOb2RlLmFyZ3VtZW50KTtcbiAgICAgIGlmICh0aGlzLmlzSXN0YW5idWxBU1QodU5vZGUuYXJndW1lbnQpKSB7XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1Tm9kZS5wcmVmaXgpIHtcbiAgICAgIHJldEFyci5wdXNoKHVOb2RlLm9wZXJhdG9yKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyh1Tm9kZS5hcmd1bWVudCwgcmV0QXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKHVOb2RlLmFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2godU5vZGUub3BlcmF0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0TG9naWNhbEV4cHJlc3Npb24obG9nTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMobG9nTm9kZS5sZWZ0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKGxvZ05vZGUub3BlcmF0b3IpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhsb2dOb2RlLnJpZ2h0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RNZW1iZXJFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RDYWxsRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0QXJyYXlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGdldE1lbWJlckV4cHJlc3Npb25EZXRhaWxzKGFzdCkge1xuICAgIGlmIChhc3QudHlwZSAhPT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBFeHByZXNzaW9uICR7IGFzdC50eXBlIH0gbm90IGEgTWVtYmVyRXhwcmVzc2lvbmAsIGFzdCk7XG4gICAgfVxuICAgIGxldCBuYW1lID0gbnVsbDtcbiAgICBsZXQgdHlwZSA9IG51bGw7XG4gICAgY29uc3QgdmFyaWFibGVTaWduYXR1cmUgPSB0aGlzLmdldFZhcmlhYmxlU2lnbmF0dXJlKGFzdCk7XG4gICAgc3dpdGNoICh2YXJpYWJsZVNpZ25hdHVyZSkge1xuICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgJ3ZhbHVlLnRocmVhZC52YWx1ZSc6XG4gICAgICBjYXNlICd0aGlzLnRocmVhZC52YWx1ZSc6XG4gICAgICBjYXNlICd0aGlzLm91dHB1dC52YWx1ZSc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgIHR5cGU6ICdJbnRlZ2VyJyxcbiAgICAgICAgICAgIG5hbWU6IGFzdC5wcm9wZXJ0eS5uYW1lXG4gICAgICAgIH07XG4gICAgICBjYXNlICd2YWx1ZVtdJzpcbiAgICAgICAgaWYgKHR5cGVvZiBhc3Qub2JqZWN0Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5uYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgb3JpZ2luOiAndXNlcicsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdCksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eVxuICAgICAgICB9O1xuICAgICAgY2FzZSAndmFsdWVbXVtdJzpcbiAgICAgICAgaWYgKHR5cGVvZiBhc3Qub2JqZWN0Lm9iamVjdC5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IGFzdC5vYmplY3Qub2JqZWN0Lm5hbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBvcmlnaW46ICd1c2VyJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLmdldFZhcmlhYmxlVHlwZShhc3Qub2JqZWN0Lm9iamVjdCksXG4gICAgICAgICAgICB5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3ZhbHVlW11bXVtdJzpcbiAgICAgICAgaWYgKHR5cGVvZiBhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3QubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3QubmFtZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIG9yaWdpbjogJ3VzZXInLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0VmFyaWFibGVUeXBlKGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdCksXG4gICAgICAgICAgICB6UHJvcGVydHk6IGFzdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5LFxuICAgICAgICAgICAgeVByb3BlcnR5OiBhc3Qub2JqZWN0LnByb3BlcnR5LFxuICAgICAgICAgICAgeFByb3BlcnR5OiBhc3QucHJvcGVydHksXG4gICAgICAgIH07XG4gICAgICBjYXNlICd2YWx1ZVtdW11bXVtdJzpcbiAgICAgICAgaWYgKHR5cGVvZiBhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5uYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgb3JpZ2luOiAndXNlcicsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm9iamVjdCksXG4gICAgICAgICAgICB6UHJvcGVydHk6IGFzdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5LFxuICAgICAgICAgICAgeVByb3BlcnR5OiBhc3Qub2JqZWN0LnByb3BlcnR5LFxuICAgICAgICAgICAgeFByb3BlcnR5OiBhc3QucHJvcGVydHksXG4gICAgICAgIH07XG4gICAgICBjYXNlICd2YWx1ZS52YWx1ZSc6XG4gICAgICAgIGlmICh0eXBlb2YgYXN0LnByb3BlcnR5Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0FzdE1hdGhWYXJpYWJsZShhc3QpKSB7XG4gICAgICAgICAgbmFtZSA9IGFzdC5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgb3JpZ2luOiAnTWF0aCcsXG4gICAgICAgICAgICB0eXBlOiAnTnVtYmVyJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFzdC5wcm9wZXJ0eS5uYW1lKSB7XG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgcHJvcGVydHk6IGFzdC5wcm9wZXJ0eS5uYW1lLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogJ3VzZXInLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ051bWJlcidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWUnOlxuICAgICAgICAgIGlmICh0eXBlb2YgYXN0LnByb3BlcnR5Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuYW1lID0gYXN0LnByb3BlcnR5Lm5hbWU7XG4gICAgICAgICAgdHlwZSA9IHRoaXMuZ2V0Q29uc3RhbnRUeXBlKG5hbWUpO1xuICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnQ29uc3RhbnQgaGFzIG5vIHR5cGUnLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBvcmlnaW46ICdjb25zdGFudHMnLFxuICAgICAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW10nOlxuICAgICAgICAgIGlmICh0eXBlb2YgYXN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmFtZSA9IGFzdC5vYmplY3QucHJvcGVydHkubmFtZTtcbiAgICAgICAgICB0eXBlID0gdGhpcy5nZXRDb25zdGFudFR5cGUobmFtZSk7XG4gICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdDb25zdGFudCBoYXMgbm8gdHlwZScsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG9yaWdpbjogJ2NvbnN0YW50cycsXG4gICAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICAgIHhQcm9wZXJ0eTogYXN0LnByb3BlcnR5LFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXSc6IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHkubmFtZTtcbiAgICAgICAgICB0eXBlID0gdGhpcy5nZXRDb25zdGFudFR5cGUobmFtZSk7XG4gICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdDb25zdGFudCBoYXMgbm8gdHlwZScsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG9yaWdpbjogJ2NvbnN0YW50cycsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgICAgeVByb3BlcnR5OiBhc3Qub2JqZWN0LnByb3BlcnR5LFxuICAgICAgICAgICAgeFByb3BlcnR5OiBhc3QucHJvcGVydHksXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXSc6IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmFtZSA9IGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgIHR5cGUgPSB0aGlzLmdldENvbnN0YW50VHlwZShuYW1lKTtcbiAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0NvbnN0YW50IGhhcyBubyB0eXBlJywgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb3JpZ2luOiAnY29uc3RhbnRzJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICB6UHJvcGVydHk6IGFzdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5LFxuICAgICAgICAgICAgeVByb3BlcnR5OiBhc3Qub2JqZWN0LnByb3BlcnR5LFxuICAgICAgICAgICAgeFByb3BlcnR5OiBhc3QucHJvcGVydHksXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdmbigpW10nOlxuICAgICAgICBjYXNlICdbXVtdJzpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgcHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlICd2YWx1ZS52YWx1ZVtdJzogXG4gICAgICAgICAgaWYgKHRoaXMucmVtb3ZlSXN0YW5idWxDb3ZlcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vbklzdGFuYnVsQ292ZXJhZ2VWYXJpYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5vbklzdGFuYnVsQ292ZXJhZ2VWYXJpYWJsZShhc3Qub2JqZWN0Lm9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3ZhbHVlLnZhbHVlW11bXSc6IFxuICAgICAgICAgICAgaWYgKHRoaXMucmVtb3ZlSXN0YW5idWxDb3ZlcmFnZSkge1xuICAgICAgICAgICAgICByZXR1cm4geyBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vbklzdGFuYnVsQ292ZXJhZ2VWYXJpYWJsZSkge1xuICAgICAgICAgICAgICB0aGlzLm9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlKGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgIH1cbiAgfVxuXG4gIGZpbmRJZGVudGlmaWVyT3JpZ2luKGFzdFRvRmluZCkge1xuICAgIGNvbnN0IHN0YWNrID0gW3RoaXMuYXN0XTtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBhdE5vZGUgPSBzdGFja1swXTtcbiAgICAgIGlmIChhdE5vZGUudHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRvcicgJiYgYXROb2RlLmlkICYmIGF0Tm9kZS5pZC5uYW1lICYmIGF0Tm9kZS5pZC5uYW1lID09PSBhc3RUb0ZpbmQubmFtZSkge1xuICAgICAgICByZXR1cm4gYXROb2RlO1xuICAgICAgfVxuICAgICAgc3RhY2suc2hpZnQoKTtcbiAgICAgIGlmIChhdE5vZGUuYXJndW1lbnQpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuYXJndW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChhdE5vZGUuYm9keSkge1xuICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZS5ib2R5KTtcbiAgICAgIH0gZWxzZSBpZiAoYXROb2RlLmRlY2xhcmF0aW9ucykge1xuICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZS5kZWNsYXJhdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGF0Tm9kZSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdE5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmaW5kTGFzdFJldHVybihhc3QpIHtcbiAgICBjb25zdCBzdGFjayA9IFthc3QgfHwgdGhpcy5hc3RdO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGF0Tm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgaWYgKGF0Tm9kZS50eXBlID09PSAnUmV0dXJuU3RhdGVtZW50Jykge1xuICAgICAgICByZXR1cm4gYXROb2RlO1xuICAgICAgfVxuICAgICAgaWYgKGF0Tm9kZS50eXBlID09PSAnRnVuY3Rpb25EZWNsYXJhdGlvbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYXROb2RlLmFyZ3VtZW50KSB7XG4gICAgICAgIHN0YWNrLnB1c2goYXROb2RlLmFyZ3VtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoYXROb2RlLmJvZHkpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuYm9keSk7XG4gICAgICB9IGVsc2UgaWYgKGF0Tm9kZS5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuZGVjbGFyYXRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhdE5vZGUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXROb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChhdE5vZGVbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGF0Tm9kZS5jb25zZXF1ZW50KSB7XG4gICAgICAgIHN0YWNrLnB1c2goYXROb2RlLmNvbnNlcXVlbnQpO1xuICAgICAgfSBlbHNlIGlmIChhdE5vZGUuY2FzZXMpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuY2FzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldEludGVybmFsVmFyaWFibGVOYW1lKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2ludGVybmFsVmFyaWFibGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgdGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzW25hbWVdID0gMDtcbiAgICB9XG4gICAgdGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzW25hbWVdKys7XG4gICAgaWYgKHRoaXMuX2ludGVybmFsVmFyaWFibGVOYW1lc1tuYW1lXSA9PT0gMSkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBuYW1lICsgdGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzW25hbWVdO1xuICB9XG5cbiAgYXN0S2V5KGFzdCwgc2VwYXJhdG9yID0gJywnKSB7XG4gICAgaWYgKCFhc3Quc3RhcnQgfHwgIWFzdC5lbmQpIHRocm93IG5ldyBFcnJvcignQVNUIHN0YXJ0IGFuZCBlbmQgbmVlZGVkJyk7XG4gICAgcmV0dXJuIGAke2FzdC5zdGFydH0ke3NlcGFyYXRvcn0ke2FzdC5lbmR9YDtcbiAgfVxufVxuXG5jb25zdCB0eXBlTG9va3VwTWFwID0ge1xuICAnTnVtYmVyJzogJ051bWJlcicsXG4gICdGbG9hdCc6ICdGbG9hdCcsXG4gICdJbnRlZ2VyJzogJ0ludGVnZXInLFxuICAnQXJyYXknOiAnTnVtYmVyJyxcbiAgJ0FycmF5KDIpJzogJ051bWJlcicsXG4gICdBcnJheSgzKSc6ICdOdW1iZXInLFxuICAnQXJyYXkoNCknOiAnTnVtYmVyJyxcbiAgJ0FycmF5MkQnOiAnTnVtYmVyJyxcbiAgJ0FycmF5M0QnOiAnTnVtYmVyJyxcbiAgJ0lucHV0JzogJ051bWJlcicsXG4gICdIVE1MQ2FudmFzJzogJ0FycmF5KDQpJyxcbiAgJ0hUTUxJbWFnZSc6ICdBcnJheSg0KScsXG4gICdIVE1MVmlkZW8nOiAnQXJyYXkoNCknLFxuICAnSFRNTEltYWdlQXJyYXknOiAnQXJyYXkoNCknLFxuICAnTnVtYmVyVGV4dHVyZSc6ICdOdW1iZXInLFxuICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6ICdOdW1iZXInLFxuICAnQXJyYXkxRCgyKSc6ICdBcnJheSgyKScsXG4gICdBcnJheTFEKDMpJzogJ0FycmF5KDMpJyxcbiAgJ0FycmF5MUQoNCknOiAnQXJyYXkoNCknLFxuICAnQXJyYXkyRCgyKSc6ICdBcnJheSgyKScsXG4gICdBcnJheTJEKDMpJzogJ0FycmF5KDMpJyxcbiAgJ0FycmF5MkQoNCknOiAnQXJyYXkoNCknLFxuICAnQXJyYXkzRCgyKSc6ICdBcnJheSgyKScsXG4gICdBcnJheTNEKDMpJzogJ0FycmF5KDMpJyxcbiAgJ0FycmF5M0QoNCknOiAnQXJyYXkoNCknLFxuICAnQXJyYXlUZXh0dXJlKDEpJzogJ051bWJlcicsXG4gICdBcnJheVRleHR1cmUoMiknOiAnQXJyYXkoMiknLFxuICAnQXJyYXlUZXh0dXJlKDMpJzogJ0FycmF5KDMpJyxcbiAgJ0FycmF5VGV4dHVyZSg0KSc6ICdBcnJheSg0KScsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRnVuY3Rpb25Ob2RlXG59O1xufSx7XCIuLi91dGlsc1wiOjExNCxcIi4vZnVuY3Rpb24tdHJhY2VyXCI6MTEsXCJhY29yblwiOjF9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5sZW5ndGggPiAwID8gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV0gOiBudWxsO1xufVxuXG5jb25zdCBzdGF0ZXMgPSB7XG4gIHRyYWNrSWRlbnRpZmllcnM6ICd0cmFja0lkZW50aWZpZXJzJyxcbiAgbWVtYmVyRXhwcmVzc2lvbjogJ21lbWJlckV4cHJlc3Npb24nLFxuICBpbkZvckxvb3BJbml0OiAnaW5Gb3JMb29wSW5pdCdcbn07XG5cbmNsYXNzIEZ1bmN0aW9uVHJhY2VyIHtcbiAgY29uc3RydWN0b3IoYXN0KSB7XG4gICAgdGhpcy5ydW5uaW5nQ29udGV4dHMgPSBbXTtcbiAgICB0aGlzLmZ1bmN0aW9uQ29udGV4dHMgPSBbXTtcbiAgICB0aGlzLmNvbnRleHRzID0gW107XG4gICAgdGhpcy5mdW5jdGlvbkNhbGxzID0gW107XG4gICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgICB0aGlzLmlkZW50aWZpZXJzID0gW107XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbiAgICB0aGlzLnJldHVyblN0YXRlbWVudHMgPSBbXTtcbiAgICB0aGlzLnRyYWNrZWRJZGVudGlmaWVycyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICB0aGlzLm5ld0Z1bmN0aW9uQ29udGV4dCgpO1xuICAgIHRoaXMuc2Nhbihhc3QpO1xuICB9XG5cbiAgaXNTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlc1t0aGlzLnN0YXRlcy5sZW5ndGggLSAxXSA9PT0gc3RhdGU7XG4gIH1cblxuICBoYXNTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlcy5pbmRleE9mKHN0YXRlKSA+IC0xO1xuICB9XG5cbiAgcHVzaFN0YXRlKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZSk7XG4gIH1cblxuICBwb3BTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLmlzU3RhdGUoc3RhdGUpKSB7XG4gICAgICB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcG9wIHRoZSBub24tYWN0aXZlIHN0YXRlIFwiJHtzdGF0ZX1cImApO1xuICAgIH1cbiAgfVxuXG4gIGdldCBjdXJyZW50RnVuY3Rpb25Db250ZXh0KCkge1xuICAgIHJldHVybiBsYXN0KHRoaXMuZnVuY3Rpb25Db250ZXh0cyk7XG4gIH1cblxuICBnZXQgY3VycmVudENvbnRleHQoKSB7XG4gICAgcmV0dXJuIGxhc3QodGhpcy5ydW5uaW5nQ29udGV4dHMpO1xuICB9XG5cbiAgbmV3RnVuY3Rpb25Db250ZXh0KCkge1xuICAgIGNvbnN0IG5ld0NvbnRleHQgPSB7ICdAY29udGV4dFR5cGUnOiAnZnVuY3Rpb24nIH07XG4gICAgdGhpcy5jb250ZXh0cy5wdXNoKG5ld0NvbnRleHQpO1xuICAgIHRoaXMuZnVuY3Rpb25Db250ZXh0cy5wdXNoKG5ld0NvbnRleHQpO1xuICB9XG5cbiAgbmV3Q29udGV4dChydW4pIHtcbiAgICBjb25zdCBuZXdDb250ZXh0ID0gT2JqZWN0LmFzc2lnbih7ICdAY29udGV4dFR5cGUnOiAnY29uc3QvbGV0JyB9LCB0aGlzLmN1cnJlbnRDb250ZXh0KTtcbiAgICB0aGlzLmNvbnRleHRzLnB1c2gobmV3Q29udGV4dCk7XG4gICAgdGhpcy5ydW5uaW5nQ29udGV4dHMucHVzaChuZXdDb250ZXh0KTtcbiAgICBydW4oKTtcbiAgICBjb25zdCB7IGN1cnJlbnRGdW5jdGlvbkNvbnRleHQgfSA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBwIGluIGN1cnJlbnRGdW5jdGlvbkNvbnRleHQpIHtcbiAgICAgIGlmICghY3VycmVudEZ1bmN0aW9uQ29udGV4dC5oYXNPd25Qcm9wZXJ0eShwKSB8fCBuZXdDb250ZXh0Lmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgIG5ld0NvbnRleHRbcF0gPSBjdXJyZW50RnVuY3Rpb25Db250ZXh0W3BdO1xuICAgIH1cbiAgICB0aGlzLnJ1bm5pbmdDb250ZXh0cy5wb3AoKTtcbiAgICByZXR1cm4gbmV3Q29udGV4dDtcbiAgfVxuXG4gIHVzZUZ1bmN0aW9uQ29udGV4dChydW4pIHtcbiAgICBjb25zdCBmdW5jdGlvbkNvbnRleHQgPSBsYXN0KHRoaXMuZnVuY3Rpb25Db250ZXh0cyk7XG4gICAgdGhpcy5ydW5uaW5nQ29udGV4dHMucHVzaChmdW5jdGlvbkNvbnRleHQpO1xuICAgIHJ1bigpO1xuICAgIHRoaXMucnVubmluZ0NvbnRleHRzLnBvcCgpO1xuICB9XG5cbiAgZ2V0SWRlbnRpZmllcnMocnVuKSB7XG4gICAgY29uc3QgdHJhY2tlZElkZW50aWZpZXJzID0gdGhpcy50cmFja2VkSWRlbnRpZmllcnMgPSBbXTtcbiAgICB0aGlzLnB1c2hTdGF0ZShzdGF0ZXMudHJhY2tJZGVudGlmaWVycyk7XG4gICAgcnVuKCk7XG4gICAgdGhpcy50cmFja2VkSWRlbnRpZmllcnMgPSBudWxsO1xuICAgIHRoaXMucG9wU3RhdGUoc3RhdGVzLnRyYWNrSWRlbnRpZmllcnMpO1xuICAgIHJldHVybiB0cmFja2VkSWRlbnRpZmllcnM7XG4gIH1cblxuICBnZXREZWNsYXJhdGlvbihuYW1lKSB7XG4gICAgY29uc3QgeyBjdXJyZW50Q29udGV4dCwgY3VycmVudEZ1bmN0aW9uQ29udGV4dCwgcnVubmluZ0NvbnRleHRzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gY3VycmVudENvbnRleHRbbmFtZV0gfHwgY3VycmVudEZ1bmN0aW9uQ29udGV4dFtuYW1lXSB8fCBudWxsO1xuXG4gICAgaWYgKFxuICAgICAgIWRlY2xhcmF0aW9uICYmXG4gICAgICBjdXJyZW50Q29udGV4dCA9PT0gY3VycmVudEZ1bmN0aW9uQ29udGV4dCAmJlxuICAgICAgcnVubmluZ0NvbnRleHRzLmxlbmd0aCA+IDBcbiAgICApIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzUnVubmluZ0NvbnRleHQgPSBydW5uaW5nQ29udGV4dHNbcnVubmluZ0NvbnRleHRzLmxlbmd0aCAtIDJdO1xuICAgICAgaWYgKHByZXZpb3VzUnVubmluZ0NvbnRleHRbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzUnVubmluZ0NvbnRleHRbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY2xhcmF0aW9uO1xuICB9XG5cbiAgc2Nhbihhc3QpIHtcbiAgICBpZiAoIWFzdCkgcmV0dXJuO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuc2Nhbihhc3RbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICBjYXNlICdQcm9ncmFtJzpcbiAgICAgICAgdGhpcy51c2VGdW5jdGlvbkNvbnRleHQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2Nhbihhc3QuYm9keSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50JzpcbiAgICAgICAgdGhpcy5uZXdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNjYW4oYXN0LmJvZHkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICBjYXNlICdMb2dpY2FsRXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QubGVmdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QucmlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LmxlZnQpO1xuICAgICAgICB0aGlzLnNjYW4oYXN0LnJpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgaWYgKGFzdC5vcGVyYXRvciA9PT0gJysrJykge1xuICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdGhpcy5nZXREZWNsYXJhdGlvbihhc3QuYXJndW1lbnQubmFtZSk7XG4gICAgICAgICAgaWYgKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbi5zdWdnZXN0ZWRUeXBlID0gJ0ludGVnZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYW4oYXN0LmFyZ3VtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdVbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LmFyZ3VtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcbiAgICAgICAgaWYgKGFzdC5raW5kID09PSAndmFyJykge1xuICAgICAgICAgIHRoaXMudXNlRnVuY3Rpb25Db250ZXh0KCgpID0+IHtcbiAgICAgICAgICAgIGFzdC5kZWNsYXJhdGlvbnMgPSB1dGlscy5ub3JtYWxpemVEZWNsYXJhdGlvbnMoYXN0KTtcbiAgICAgICAgICAgIHRoaXMuc2Nhbihhc3QuZGVjbGFyYXRpb25zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3QuZGVjbGFyYXRpb25zID0gdXRpbHMubm9ybWFsaXplRGVjbGFyYXRpb25zKGFzdCk7XG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC5kZWNsYXJhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzoge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRDb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpbkZvckxvb3BJbml0ID0gdGhpcy5oYXNTdGF0ZShzdGF0ZXMuaW5Gb3JMb29wSW5pdCk7XG4gICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0ge1xuICAgICAgICAgIGFzdDogYXN0LFxuICAgICAgICAgIGNvbnRleHQ6IGN1cnJlbnRDb250ZXh0LFxuICAgICAgICAgIG5hbWU6IGFzdC5pZC5uYW1lLFxuICAgICAgICAgIG9yaWdpbjogJ2RlY2xhcmF0aW9uJyxcbiAgICAgICAgICBpbkZvckxvb3BJbml0LFxuICAgICAgICAgIGluRm9yTG9vcFRlc3Q6IG51bGwsXG4gICAgICAgICAgYXNzaWduYWJsZTogY3VycmVudENvbnRleHQgPT09IHRoaXMuY3VycmVudEZ1bmN0aW9uQ29udGV4dCB8fCAoIWluRm9yTG9vcEluaXQgJiYgIWN1cnJlbnRDb250ZXh0Lmhhc093blByb3BlcnR5KGFzdC5pZC5uYW1lKSksXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZTogbnVsbCxcbiAgICAgICAgICB2YWx1ZVR5cGU6IG51bGwsXG4gICAgICAgICAgZGVwZW5kZW5jaWVzOiBudWxsLFxuICAgICAgICAgIGlzU2FmZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFjdXJyZW50Q29udGV4dFthc3QuaWQubmFtZV0pIHtcbiAgICAgICAgICBjdXJyZW50Q29udGV4dFthc3QuaWQubmFtZV0gPSBkZWNsYXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY2xhcmF0aW9ucy5wdXNoKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5pZCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuaW5pdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnRnVuY3Rpb25FeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ0Z1bmN0aW9uRGVjbGFyYXRpb24nOlxuICAgICAgICBpZiAodGhpcy5ydW5uaW5nQ29udGV4dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC5ib2R5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdJZlN0YXRlbWVudCc6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QudGVzdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuY29uc2VxdWVudCk7XG4gICAgICAgIGlmIChhc3QuYWx0ZXJuYXRlKSB0aGlzLnNjYW4oYXN0LmFsdGVybmF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRm9yU3RhdGVtZW50Jzoge1xuICAgICAgICBsZXQgdGVzdElkZW50aWZpZXJzO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5uZXdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShzdGF0ZXMuaW5Gb3JMb29wSW5pdCk7XG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC5pbml0KTtcbiAgICAgICAgICB0aGlzLnBvcFN0YXRlKHN0YXRlcy5pbkZvckxvb3BJbml0KTtcblxuICAgICAgICAgIHRlc3RJZGVudGlmaWVycyA9IHRoaXMuZ2V0SWRlbnRpZmllcnMoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY2FuKGFzdC50ZXN0KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMuc2Nhbihhc3QudXBkYXRlKTtcbiAgICAgICAgICB0aGlzLm5ld0NvbnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY2FuKGFzdC5ib2R5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRlc3RJZGVudGlmaWVycykge1xuICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAocCA9PT0gJ0Bjb250ZXh0VHlwZScpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRlc3RJZGVudGlmaWVycy5pbmRleE9mKHApID4gLTEpIHtcbiAgICAgICAgICAgICAgY29udGV4dFtwXS5pbkZvckxvb3BUZXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdEb1doaWxlU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgdGhpcy5uZXdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNjYW4oYXN0LmJvZHkpO1xuICAgICAgICAgIHRoaXMuc2Nhbihhc3QudGVzdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0lkZW50aWZpZXInOiB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGUoc3RhdGVzLnRyYWNrSWRlbnRpZmllcnMpKSB7XG4gICAgICAgICAgdGhpcy50cmFja2VkSWRlbnRpZmllcnMucHVzaChhc3QubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZGVudGlmaWVycy5wdXNoKHtcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLmN1cnJlbnRDb250ZXh0LFxuICAgICAgICAgIGRlY2xhcmF0aW9uOiB0aGlzLmdldERlY2xhcmF0aW9uKGFzdC5uYW1lKSxcbiAgICAgICAgICBhc3QsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgIHRoaXMucmV0dXJuU3RhdGVtZW50cy5wdXNoKGFzdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuYXJndW1lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICB0aGlzLnB1c2hTdGF0ZShzdGF0ZXMubWVtYmVyRXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMuc2Nhbihhc3Qub2JqZWN0KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5wcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoc3RhdGVzLm1lbWJlckV4cHJlc3Npb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LmV4cHJlc3Npb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1NlcXVlbmNlRXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuZXhwcmVzc2lvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5mdW5jdGlvbkNhbGxzLnB1c2goe1xuICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY3VycmVudENvbnRleHQsXG4gICAgICAgICAgYXN0LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5hcmd1bWVudHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuZWxlbWVudHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QudGVzdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuYWx0ZXJuYXRlKTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5jb25zZXF1ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdTd2l0Y2hTdGF0ZW1lbnQnOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LmRpc2NyaW1pbmFudCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuY2FzZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1N3aXRjaENhc2UnOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LnRlc3QpO1xuICAgICAgICB0aGlzLnNjYW4oYXN0LmNvbnNlcXVlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVGhpc0V4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICBjYXNlICdEZWJ1Z2dlclN0YXRlbWVudCc6XG4gICAgICBjYXNlICdFbXB0eVN0YXRlbWVudCc6XG4gICAgICBjYXNlICdCcmVha1N0YXRlbWVudCc6XG4gICAgICBjYXNlICdDb250aW51ZVN0YXRlbWVudCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgdHlwZSBcIiR7YXN0LnR5cGV9XCJgKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEZ1bmN0aW9uVHJhY2VyLFxufTtcbn0se1wiLi4vdXRpbHNcIjoxMTR9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IGdsV2lyZXRhcCB9ID0gcmVxdWlyZSgnZ2wtd2lyZXRhcCcpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gdG9TdHJpbmdXaXRob3V0VXRpbHMoZm4pIHtcbiAgcmV0dXJuIGZuLnRvU3RyaW5nKClcbiAgICAucmVwbGFjZSgnPT4nLCAnJylcbiAgICAucmVwbGFjZSgvXmZ1bmN0aW9uIC8sICcnKVxuICAgIC5yZXBsYWNlKC91dGlsc1suXS9nLCAnLyp1dGlscy4qLycpO1xufVxuXG5mdW5jdGlvbiBnbEtlcm5lbFN0cmluZyhLZXJuZWwsIGFyZ3MsIG9yaWdpbktlcm5lbCwgc2V0dXBDb250ZXh0U3RyaW5nLCBkZXN0cm95Q29udGV4dFN0cmluZykge1xuICBpZiAoIW9yaWdpbktlcm5lbC5idWlsdCkge1xuICAgIG9yaWdpbktlcm5lbC5idWlsZC5hcHBseShvcmlnaW5LZXJuZWwsIGFyZ3MpO1xuICB9XG4gIGFyZ3MgPSBhcmdzID8gQXJyYXkuZnJvbShhcmdzKS5tYXAoYXJnID0+IHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBhcmcpIHtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW4oYXJnKTtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyKGFyZyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgfSkgOiBudWxsO1xuICBjb25zdCB1cGxvYWRlZFZhbHVlcyA9IFtdO1xuICBjb25zdCBwb3N0UmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBnbFdpcmV0YXAob3JpZ2luS2VybmVsLmNvbnRleHQsIHtcbiAgICB1c2VUcmFja2FibGVQcmltaXRpdmVzOiB0cnVlLFxuICAgIG9uUmVhZFBpeGVsczogKHRhcmdldE5hbWUpID0+IHtcbiAgICAgIGlmIChrZXJuZWwuc3ViS2VybmVscykge1xuICAgICAgICBpZiAoIXN1Yktlcm5lbHNSZXN1bHRWYXJpYWJsZVNldHVwKSB7XG4gICAgICAgICAgcG9zdFJlc3VsdC5wdXNoKGAgICAgY29uc3QgcmVzdWx0ID0geyByZXN1bHQ6ICR7Z2V0UmVuZGVyU3RyaW5nKHRhcmdldE5hbWUsIGtlcm5lbCl9IH07YCk7XG4gICAgICAgICAgc3ViS2VybmVsc1Jlc3VsdFZhcmlhYmxlU2V0dXAgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0ga2VybmVsLnN1Yktlcm5lbHNbc3ViS2VybmVsc1Jlc3VsdEluZGV4KytdLnByb3BlcnR5O1xuICAgICAgICAgIHBvc3RSZXN1bHQucHVzaChgICAgIHJlc3VsdCR7aXNOYU4ocHJvcGVydHkpID8gJy4nICsgcHJvcGVydHkgOiBgWyR7cHJvcGVydHl9XWB9ID0gJHtnZXRSZW5kZXJTdHJpbmcodGFyZ2V0TmFtZSwga2VybmVsKX07YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Yktlcm5lbHNSZXN1bHRJbmRleCA9PT0ga2VybmVsLnN1Yktlcm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgcG9zdFJlc3VsdC5wdXNoKCcgICAgcmV0dXJuIHJlc3VsdDsnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0TmFtZSkge1xuICAgICAgICBwb3N0UmVzdWx0LnB1c2goYCAgICByZXR1cm4gJHtnZXRSZW5kZXJTdHJpbmcodGFyZ2V0TmFtZSwga2VybmVsKX07YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3N0UmVzdWx0LnB1c2goYCAgICByZXR1cm4gbnVsbDtgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXA6IChhcmd1bWVudCkgPT4ge1xuICAgICAgY29uc3QgYXJndW1lbnROYW1lID0gZmluZEtlcm5lbFZhbHVlKGFyZ3VtZW50LCBrZXJuZWwua2VybmVsQXJndW1lbnRzLCBbXSwgY29udGV4dCwgdXBsb2FkZWRWYWx1ZXMpO1xuICAgICAgaWYgKGFyZ3VtZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnROYW1lO1xuICAgICAgfVxuICAgICAgY29uc3QgY29uc3RhbnROYW1lID0gZmluZEtlcm5lbFZhbHVlKGFyZ3VtZW50LCBrZXJuZWwua2VybmVsQ29uc3RhbnRzLCBjb25zdGFudHMgPyBPYmplY3Qua2V5cyhjb25zdGFudHMpLm1hcChrZXkgPT4gY29uc3RhbnRzW2tleV0pIDogW10sIGNvbnRleHQsIHVwbG9hZGVkVmFsdWVzKTtcbiAgICAgIGlmIChjb25zdGFudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50TmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSk7XG4gIGxldCBzdWJLZXJuZWxzUmVzdWx0VmFyaWFibGVTZXR1cCA9IGZhbHNlO1xuICBsZXQgc3ViS2VybmVsc1Jlc3VsdEluZGV4ID0gMDtcbiAgY29uc3Qge1xuICAgIHNvdXJjZSxcbiAgICBjYW52YXMsXG4gICAgb3V0cHV0LFxuICAgIHBpcGVsaW5lLFxuICAgIGdyYXBoaWNhbCxcbiAgICBsb29wTWF4SXRlcmF0aW9ucyxcbiAgICBjb25zdGFudHMsXG4gICAgb3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICBwcmVjaXNpb24sXG4gICAgZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3ksXG4gICAgZnVuY3Rpb25zLFxuICAgIG5hdGl2ZUZ1bmN0aW9ucyxcbiAgICBzdWJLZXJuZWxzLFxuICAgIGltbXV0YWJsZSxcbiAgICBhcmd1bWVudFR5cGVzLFxuICAgIGNvbnN0YW50VHlwZXMsXG4gICAga2VybmVsQXJndW1lbnRzLFxuICAgIGtlcm5lbENvbnN0YW50cyxcbiAgICB0YWN0aWMsXG4gIH0gPSBvcmlnaW5LZXJuZWw7XG4gIGNvbnN0IGtlcm5lbCA9IG5ldyBLZXJuZWwoc291cmNlLCB7XG4gICAgY2FudmFzLFxuICAgIGNvbnRleHQsXG4gICAgY2hlY2tDb250ZXh0OiBmYWxzZSxcbiAgICBvdXRwdXQsXG4gICAgcGlwZWxpbmUsXG4gICAgZ3JhcGhpY2FsLFxuICAgIGxvb3BNYXhJdGVyYXRpb25zLFxuICAgIGNvbnN0YW50cyxcbiAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgIHByZWNpc2lvbixcbiAgICBmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSxcbiAgICBmdW5jdGlvbnMsXG4gICAgbmF0aXZlRnVuY3Rpb25zLFxuICAgIHN1Yktlcm5lbHMsXG4gICAgaW1tdXRhYmxlLFxuICAgIGFyZ3VtZW50VHlwZXMsXG4gICAgY29uc3RhbnRUeXBlcyxcbiAgICB0YWN0aWMsXG4gIH0pO1xuICBsZXQgcmVzdWx0ID0gW107XG4gIGNvbnRleHQuc2V0SW5kZW50KDIpO1xuICBrZXJuZWwuYnVpbGQuYXBwbHkoa2VybmVsLCBhcmdzKTtcbiAgcmVzdWx0LnB1c2goY29udGV4dC50b1N0cmluZygpKTtcbiAgY29udGV4dC5yZXNldCgpO1xuXG4gIGtlcm5lbC5rZXJuZWxBcmd1bWVudHMuZm9yRWFjaCgoa2VybmVsQXJndW1lbnQsIGkpID0+IHtcbiAgICBzd2l0Y2ggKGtlcm5lbEFyZ3VtZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgY2FzZSAnSFRNTENhbnZhcyc6XG4gICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgY2FzZSAnSFRNTFZpZGVvJzpcbiAgICAgICAgY29udGV4dC5pbnNlcnRWYXJpYWJsZShgdXBsb2FkVmFsdWVfJHtrZXJuZWxBcmd1bWVudC5uYW1lfWAsIGtlcm5lbEFyZ3VtZW50LnVwbG9hZFZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG4gICAgICAgIGZvciAobGV0IGltYWdlSW5kZXggPSAwOyBpbWFnZUluZGV4IDwgYXJnc1tpXS5sZW5ndGg7IGltYWdlSW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgY29udGV4dC5pbnNlcnRWYXJpYWJsZShgdXBsb2FkVmFsdWVfJHtrZXJuZWxBcmd1bWVudC5uYW1lfVske2ltYWdlSW5kZXh9XWAsIGFyZ1tpbWFnZUluZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdJbnB1dCc6XG4gICAgICAgIGNvbnRleHQuaW5zZXJ0VmFyaWFibGUoYHVwbG9hZFZhbHVlXyR7a2VybmVsQXJndW1lbnQubmFtZX1gLCBrZXJuZWxBcmd1bWVudC51cGxvYWRWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG4gICAgICBjYXNlICdOdW1iZXJUZXh0dXJlJzpcbiAgICAgIGNhc2UgJ0FycmF5MUQoMiknOlxuICAgICAgY2FzZSAnQXJyYXkxRCgzKSc6XG4gICAgICBjYXNlICdBcnJheTFEKDQpJzpcbiAgICAgIGNhc2UgJ0FycmF5MkQoMiknOlxuICAgICAgY2FzZSAnQXJyYXkyRCgzKSc6XG4gICAgICBjYXNlICdBcnJheTJEKDQpJzpcbiAgICAgIGNhc2UgJ0FycmF5M0QoMiknOlxuICAgICAgY2FzZSAnQXJyYXkzRCgzKSc6XG4gICAgICBjYXNlICdBcnJheTNEKDQpJzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoMiknOlxuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG4gICAgICAgIGNvbnRleHQuaW5zZXJ0VmFyaWFibGUoYHVwbG9hZFZhbHVlXyR7a2VybmVsQXJndW1lbnQubmFtZX1gLCBhcmdzW2ldLnRleHR1cmUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIGtlcm5lbEFyZ3VtZW50VHlwZSBpbnNlcnRpb24gZm9yIGdsV2lyZXRhcCBvZiB0eXBlICR7a2VybmVsQXJndW1lbnQudHlwZX1gKTtcbiAgICB9XG4gIH0pO1xuICByZXN1bHQucHVzaCgnLyoqIHN0YXJ0IG9mIGluamVjdGVkIGZ1bmN0aW9ucyAqKi8nKTtcbiAgcmVzdWx0LnB1c2goYGZ1bmN0aW9uICR7dG9TdHJpbmdXaXRob3V0VXRpbHModXRpbHMuZmxhdHRlblRvKX1gKTtcbiAgcmVzdWx0LnB1c2goYGZ1bmN0aW9uICR7dG9TdHJpbmdXaXRob3V0VXRpbHModXRpbHMuZmxhdHRlbjJkQXJyYXlUbyl9YCk7XG4gIHJlc3VsdC5wdXNoKGBmdW5jdGlvbiAke3RvU3RyaW5nV2l0aG91dFV0aWxzKHV0aWxzLmZsYXR0ZW4zZEFycmF5VG8pfWApO1xuICByZXN1bHQucHVzaChgZnVuY3Rpb24gJHt0b1N0cmluZ1dpdGhvdXRVdGlscyh1dGlscy5mbGF0dGVuNGRBcnJheVRvKX1gKTtcbiAgcmVzdWx0LnB1c2goYGZ1bmN0aW9uICR7dG9TdHJpbmdXaXRob3V0VXRpbHModXRpbHMuaXNBcnJheSl9YCk7XG4gIGlmIChrZXJuZWwucmVuZGVyT3V0cHV0ICE9PSBrZXJuZWwucmVuZGVyVGV4dHVyZSAmJiBrZXJuZWwuZm9ybWF0VmFsdWVzKSB7XG4gICAgcmVzdWx0LnB1c2goXG4gICAgICBgICBjb25zdCByZW5kZXJPdXRwdXQgPSBmdW5jdGlvbiAke3RvU3RyaW5nV2l0aG91dFV0aWxzKGtlcm5lbC5mb3JtYXRWYWx1ZXMpfTtgXG4gICAgKTtcbiAgfVxuICByZXN1bHQucHVzaCgnLyoqIGVuZCBvZiBpbmplY3RlZCBmdW5jdGlvbnMgKiovJyk7XG4gIHJlc3VsdC5wdXNoKGAgIGNvbnN0IGlubmVyS2VybmVsID0gZnVuY3Rpb24gKCR7a2VybmVsLmtlcm5lbEFyZ3VtZW50cy5tYXAoa2VybmVsQXJndW1lbnQgPT4ga2VybmVsQXJndW1lbnQudmFyTmFtZSkuam9pbignLCAnKX0pIHtgKTtcbiAgY29udGV4dC5zZXRJbmRlbnQoNCk7XG4gIGtlcm5lbC5ydW4uYXBwbHkoa2VybmVsLCBhcmdzKTtcbiAgaWYgKGtlcm5lbC5yZW5kZXJLZXJuZWxzKSB7XG4gICAga2VybmVsLnJlbmRlcktlcm5lbHMoKTtcbiAgfSBlbHNlIGlmIChrZXJuZWwucmVuZGVyT3V0cHV0KSB7XG4gICAga2VybmVsLnJlbmRlck91dHB1dCgpO1xuICB9XG4gIHJlc3VsdC5wdXNoKCcgICAgLyoqIHN0YXJ0IHNldHVwIHVwbG9hZHMgZm9yIGtlcm5lbCB2YWx1ZXMgKiovJyk7XG4gIGtlcm5lbC5rZXJuZWxBcmd1bWVudHMuZm9yRWFjaChrZXJuZWxBcmd1bWVudCA9PiB7XG4gICAgcmVzdWx0LnB1c2goJyAgICAnICsga2VybmVsQXJndW1lbnQuZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkuc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbiAgICAnKSk7XG4gIH0pO1xuICByZXN1bHQucHVzaCgnICAgIC8qKiBlbmQgc2V0dXAgdXBsb2FkcyBmb3Iga2VybmVsIHZhbHVlcyAqKi8nKTtcbiAgcmVzdWx0LnB1c2goY29udGV4dC50b1N0cmluZygpKTtcbiAgaWYgKGtlcm5lbC5yZW5kZXJPdXRwdXQgPT09IGtlcm5lbC5yZW5kZXJUZXh0dXJlKSB7XG4gICAgY29udGV4dC5yZXNldCgpO1xuICAgIGlmIChrZXJuZWwucmVuZGVyS2VybmVscykge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGtlcm5lbC5yZW5kZXJLZXJuZWxzKCk7XG4gICAgICBjb25zdCB0ZXh0dXJlTmFtZSA9IGNvbnRleHQuZ2V0Q29udGV4dFZhcmlhYmxlTmFtZShrZXJuZWwudGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgIHJlc3VsdC5wdXNoKGAgICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDoge1xuICAgICAgICB0ZXh0dXJlOiAkeyB0ZXh0dXJlTmFtZSB9LFxuICAgICAgICB0eXBlOiAnJHsgcmVzdWx0cy5yZXN1bHQudHlwZSB9JyxcbiAgICAgICAgdG9BcnJheTogJHsgZ2V0VG9BcnJheVN0cmluZyhyZXN1bHRzLnJlc3VsdCwgdGV4dHVyZU5hbWUpIH1cbiAgICAgIH0sYCk7XG4gICAgICBjb25zdCB7IHN1Yktlcm5lbHMsIG1hcHBlZFRleHR1cmVzIH0gPSBrZXJuZWw7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IG1hcHBlZFRleHR1cmVzW2ldO1xuICAgICAgICBjb25zdCBzdWJLZXJuZWwgPSBzdWJLZXJuZWxzW2ldO1xuICAgICAgICBjb25zdCBzdWJLZXJuZWxSZXN1bHQgPSByZXN1bHRzW3N1Yktlcm5lbC5wcm9wZXJ0eV07XG4gICAgICAgIGNvbnN0IHN1Yktlcm5lbFRleHR1cmVOYW1lID0gY29udGV4dC5nZXRDb250ZXh0VmFyaWFibGVOYW1lKHRleHR1cmUudGV4dHVyZSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGBcbiAgICAgICR7c3ViS2VybmVsLnByb3BlcnR5fToge1xuICAgICAgICB0ZXh0dXJlOiAkeyBzdWJLZXJuZWxUZXh0dXJlTmFtZSB9LFxuICAgICAgICB0eXBlOiAnJHsgc3ViS2VybmVsUmVzdWx0LnR5cGUgfScsXG4gICAgICAgIHRvQXJyYXk6ICR7IGdldFRvQXJyYXlTdHJpbmcoc3ViS2VybmVsUmVzdWx0LCBzdWJLZXJuZWxUZXh0dXJlTmFtZSkgfVxuICAgICAgfSxgKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGAgICAgfTtgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVuZGVyZWQgPSBrZXJuZWwucmVuZGVyT3V0cHV0KCk7XG4gICAgICBjb25zdCB0ZXh0dXJlTmFtZSA9IGNvbnRleHQuZ2V0Q29udGV4dFZhcmlhYmxlTmFtZShrZXJuZWwudGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgIHJlc3VsdC5wdXNoKGAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dHVyZTogJHsgdGV4dHVyZU5hbWUgfSxcbiAgICAgICAgdHlwZTogJyR7IHJlbmRlcmVkLnR5cGUgfScsXG4gICAgICAgIHRvQXJyYXk6ICR7IGdldFRvQXJyYXlTdHJpbmcocmVuZGVyZWQsIHRleHR1cmVOYW1lKSB9XG4gICAgICB9O2ApO1xuICAgIH1cbiAgfVxuICByZXN1bHQucHVzaChgICAgICR7ZGVzdHJveUNvbnRleHRTdHJpbmcgPyAnXFxuJyArIGRlc3Ryb3lDb250ZXh0U3RyaW5nICsgJyAgICAnOiAnJ31gKTtcbiAgcmVzdWx0LnB1c2gocG9zdFJlc3VsdC5qb2luKCdcXG4nKSk7XG4gIHJlc3VsdC5wdXNoKCcgIH07Jyk7XG4gIGlmIChrZXJuZWwuZ3JhcGhpY2FsKSB7XG4gICAgcmVzdWx0LnB1c2goZ2V0R2V0UGl4ZWxzU3RyaW5nKGtlcm5lbCkpO1xuICAgIHJlc3VsdC5wdXNoKGAgIGlubmVyS2VybmVsLmdldFBpeGVscyA9IGdldFBpeGVscztgKTtcbiAgfVxuICByZXN1bHQucHVzaCgnICByZXR1cm4gaW5uZXJLZXJuZWw7Jyk7XG5cbiAgbGV0IGNvbnN0YW50c1VwbG9hZCA9IFtdO1xuICBrZXJuZWxDb25zdGFudHMuZm9yRWFjaCgoa2VybmVsQ29uc3RhbnQpID0+IHtcbiAgICBjb25zdGFudHNVcGxvYWQucHVzaChgJHsgIGtlcm5lbENvbnN0YW50LmdldFN0cmluZ1ZhbHVlSGFuZGxlcigpfWApO1xuICB9KTtcbiAgcmV0dXJuIGBmdW5jdGlvbiBrZXJuZWwoc2V0dGluZ3MpIHtcbiAgY29uc3QgeyBjb250ZXh0LCBjb25zdGFudHMgfSA9IHNldHRpbmdzO1xuICAke2NvbnN0YW50c1VwbG9hZC5qb2luKCcnKX1cbiAgJHtzZXR1cENvbnRleHRTdHJpbmcgPyBzZXR1cENvbnRleHRTdHJpbmcgOiAnJ31cbiR7cmVzdWx0LmpvaW4oJ1xcbicpfVxufWA7XG59XG5cbmZ1bmN0aW9uIGdldFJlbmRlclN0cmluZyh0YXJnZXROYW1lLCBrZXJuZWwpIHtcbiAgY29uc3QgcmVhZEJhY2tWYWx1ZSA9IGtlcm5lbC5wcmVjaXNpb24gPT09ICdzaW5nbGUnID8gdGFyZ2V0TmFtZSA6IGBuZXcgRmxvYXQzMkFycmF5KCR7dGFyZ2V0TmFtZX0uYnVmZmVyKWA7XG4gIGlmIChrZXJuZWwub3V0cHV0WzJdKSB7XG4gICAgcmV0dXJuIGByZW5kZXJPdXRwdXQoJHtyZWFkQmFja1ZhbHVlfSwgJHtrZXJuZWwub3V0cHV0WzBdfSwgJHtrZXJuZWwub3V0cHV0WzFdfSwgJHtrZXJuZWwub3V0cHV0WzJdfSlgO1xuICB9XG4gIGlmIChrZXJuZWwub3V0cHV0WzFdKSB7XG4gICAgcmV0dXJuIGByZW5kZXJPdXRwdXQoJHtyZWFkQmFja1ZhbHVlfSwgJHtrZXJuZWwub3V0cHV0WzBdfSwgJHtrZXJuZWwub3V0cHV0WzFdfSlgO1xuICB9XG5cbiAgcmV0dXJuIGByZW5kZXJPdXRwdXQoJHtyZWFkQmFja1ZhbHVlfSwgJHtrZXJuZWwub3V0cHV0WzBdfSlgO1xufVxuXG5mdW5jdGlvbiBnZXRHZXRQaXhlbHNTdHJpbmcoa2VybmVsKSB7XG4gIGNvbnN0IGdldFBpeGVscyA9IGtlcm5lbC5nZXRQaXhlbHMudG9TdHJpbmcoKTtcbiAgY29uc3QgdXNlRnVuY3Rpb25LZXl3b3JkID0gIS9eZnVuY3Rpb24vLnRlc3QoZ2V0UGl4ZWxzKTtcbiAgcmV0dXJuIHV0aWxzLmZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nKGAke3VzZUZ1bmN0aW9uS2V5d29yZCA/ICdmdW5jdGlvbiAnIDogJyd9JHsgZ2V0UGl4ZWxzIH1gLCB7XG4gICAgZmluZERlcGVuZGVuY3k6IChvYmplY3QsIG5hbWUpID0+IHtcbiAgICAgIGlmIChvYmplY3QgPT09ICd1dGlscycpIHtcbiAgICAgICAgcmV0dXJuIGBjb25zdCAke25hbWV9ID0gJHt1dGlsc1tuYW1lXS50b1N0cmluZygpfTtgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICB0aGlzTG9va3VwOiAocHJvcGVydHkpID0+IHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2NvbnRleHQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGtlcm5lbC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtlcm5lbFtwcm9wZXJ0eV0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgdGhpc0xvb2t1cCAkeyBwcm9wZXJ0eSB9YCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9BcnJheVN0cmluZyhrZXJuZWxSZXN1bHQsIHRleHR1cmVOYW1lKSB7XG4gIGNvbnN0IHRvQXJyYXkgPSBrZXJuZWxSZXN1bHQudG9BcnJheS50b1N0cmluZygpO1xuICBjb25zdCB1c2VGdW5jdGlvbktleXdvcmQgPSAhL15mdW5jdGlvbi8udGVzdCh0b0FycmF5KTtcbiAgY29uc3QgZmxhdHRlbmVkRnVuY3Rpb25zID0gdXRpbHMuZmxhdHRlbkZ1bmN0aW9uVG9TdHJpbmcoYCR7dXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJ30keyB0b0FycmF5IH1gLCB7XG4gICAgZmluZERlcGVuZGVuY3k6IChvYmplY3QsIG5hbWUpID0+IHtcbiAgICAgIGlmIChvYmplY3QgPT09ICd1dGlscycpIHtcbiAgICAgICAgcmV0dXJuIGBjb25zdCAke25hbWV9ID0gJHt1dGlsc1tuYW1lXS50b1N0cmluZygpfTtgO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3QgPT09ICd0aGlzJykge1xuICAgICAgICByZXR1cm4gYCR7dXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJ30ke2tlcm5lbFJlc3VsdFtuYW1lXS50b1N0cmluZygpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaGFuZGxlZCBmcm9tT2JqZWN0Jyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0aGlzTG9va3VwOiAocHJvcGVydHksIGlzRGVjbGFyYXRpb24pID0+IHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ3RleHR1cmUnKSB7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlTmFtZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2NvbnRleHQnKSB7XG4gICAgICAgIGlmIChpc0RlY2xhcmF0aW9uKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuICdnbCc7XG4gICAgICB9XG4gICAgICBpZiAocHJvcGVydHkgPT09ICdfZnJhbWVidWZmZXInKSB7XG4gICAgICAgIHJldHVybiAnX2ZyYW1lYnVmZmVyJztcbiAgICAgIH1cbiAgICAgIGlmIChrZXJuZWxSZXN1bHQuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXJuZWxSZXN1bHRbcHJvcGVydHldKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHRoaXNMb29rdXAgJHsgcHJvcGVydHkgfWApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBgKCkgPT4ge1xuICBsZXQgX2ZyYW1lYnVmZmVyO1xuICAke2ZsYXR0ZW5lZEZ1bmN0aW9uc31cbiAgcmV0dXJuIHRvQXJyYXkoKTtcbiAgfWA7XG59XG5cbmZ1bmN0aW9uIGZpbmRLZXJuZWxWYWx1ZShhcmd1bWVudCwga2VybmVsVmFsdWVzLCB2YWx1ZXMsIGNvbnRleHQsIHVwbG9hZGVkVmFsdWVzKSB7XG4gIGlmIChhcmd1bWVudCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIGlmIChrZXJuZWxWYWx1ZXMgPT09IG51bGwpIHJldHVybiBudWxsO1xuICBzd2l0Y2ggKHR5cGVvZiBhcmd1bWVudCkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoXG4gICAgdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgYXJndW1lbnQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50XG4gICkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXJuZWxWYWx1ZSA9IGtlcm5lbFZhbHVlc1tpXTtcbiAgICAgIGlmIChrZXJuZWxWYWx1ZS50eXBlICE9PSAnSFRNTEltYWdlQXJyYXknICYmIGtlcm5lbFZhbHVlKSBjb250aW51ZTtcbiAgICAgIGlmIChrZXJuZWxWYWx1ZS51cGxvYWRWYWx1ZSAhPT0gYXJndW1lbnQpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdmFyaWFibGVJbmRleCA9IHZhbHVlc1tpXS5pbmRleE9mKGFyZ3VtZW50KTtcbiAgICAgIGlmICh2YXJpYWJsZUluZGV4ID09PSAtMSkgY29udGludWU7XG4gICAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBgdXBsb2FkVmFsdWVfJHtrZXJuZWxWYWx1ZS5uYW1lfVske3ZhcmlhYmxlSW5kZXh9XWA7XG4gICAgICBjb250ZXh0Lmluc2VydFZhcmlhYmxlKHZhcmlhYmxlTmFtZSwgYXJndW1lbnQpO1xuICAgICAgcmV0dXJuIHZhcmlhYmxlTmFtZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtlcm5lbFZhbHVlID0ga2VybmVsVmFsdWVzW2ldO1xuICAgIGlmIChhcmd1bWVudCAhPT0ga2VybmVsVmFsdWUudXBsb2FkVmFsdWUpIGNvbnRpbnVlO1xuICAgIGNvbnN0IHZhcmlhYmxlID0gYHVwbG9hZFZhbHVlXyR7a2VybmVsVmFsdWUubmFtZX1gO1xuICAgIGNvbnRleHQuaW5zZXJ0VmFyaWFibGUodmFyaWFibGUsIGtlcm5lbFZhbHVlKTtcbiAgICByZXR1cm4gdmFyaWFibGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnbEtlcm5lbFN0cmluZ1xufTtcbn0se1wiLi4vLi4vdXRpbHNcIjoxMTQsXCJnbC13aXJldGFwXCI6M31dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgS2VybmVsIH0gPSByZXF1aXJlKCcuLi9rZXJuZWwnKTtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5MkZsb2F0IH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktMi1mbG9hdCcpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTJGbG9hdDJEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktMi1mbG9hdC0yZCcpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTJGbG9hdDNEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktMi1mbG9hdC0zZCcpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTNGbG9hdCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTMtZmxvYXQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXkzRmxvYXQyRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTMtZmxvYXQtMmQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXkzRmxvYXQzRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTMtZmxvYXQtM2QnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXk0RmxvYXQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS00LWZsb2F0Jyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5NEZsb2F0MkQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS00LWZsb2F0LTJkJyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5NEZsb2F0M0QgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS00LWZsb2F0LTNkJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL3RleHR1cmUvZmxvYXQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQyRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2Zsb2F0LTJkJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0M0QgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9mbG9hdC0zZCcpO1xuY29uc3QgeyBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9tZW1vcnktb3B0aW1pemVkJyk7XG5jb25zdCB7IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDJEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvbWVtb3J5LW9wdGltaXplZC0yZCcpO1xuY29uc3QgeyBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQzRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL21lbW9yeS1vcHRpbWl6ZWQtM2QnKTtcbmNvbnN0IHsgR0xUZXh0dXJlVW5zaWduZWQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS91bnNpZ25lZCcpO1xuY29uc3QgeyBHTFRleHR1cmVVbnNpZ25lZDJEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvdW5zaWduZWQtMmQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlVW5zaWduZWQzRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL3Vuc2lnbmVkLTNkJyk7XG5jb25zdCB7IEdMVGV4dHVyZUdyYXBoaWNhbCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2dyYXBoaWNhbCcpO1xuXG5jbGFzcyBHTEtlcm5lbCBleHRlbmRzIEtlcm5lbCB7XG4gIHN0YXRpYyBnZXQgbW9kZSgpIHtcbiAgICByZXR1cm4gJ2dwdSc7XG4gIH1cblxuICBzdGF0aWMgZ2V0SXNGbG9hdFJlYWQoKSB7XG4gICAgY29uc3Qga2VybmVsU3RyaW5nID0gYGZ1bmN0aW9uIGtlcm5lbEZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfWA7XG4gICAgY29uc3Qga2VybmVsID0gbmV3IHRoaXMoa2VybmVsU3RyaW5nLCB7XG4gICAgICBjb250ZXh0OiB0aGlzLnRlc3RDb250ZXh0LFxuICAgICAgY2FudmFzOiB0aGlzLnRlc3RDYW52YXMsXG4gICAgICB2YWxpZGF0ZTogZmFsc2UsXG4gICAgICBvdXRwdXQ6IFsxXSxcbiAgICAgIHByZWNpc2lvbjogJ3NpbmdsZScsXG4gICAgICByZXR1cm5UeXBlOiAnTnVtYmVyJyxcbiAgICAgIHRhY3RpYzogJ3NwZWVkJyxcbiAgICB9KTtcbiAgICBrZXJuZWwuYnVpbGQoKTtcbiAgICBrZXJuZWwucnVuKCk7XG4gICAgY29uc3QgcmVzdWx0ID0ga2VybmVsLnJlbmRlck91dHB1dCgpO1xuICAgIGtlcm5lbC5kZXN0cm95KHRydWUpO1xuICAgIHJldHVybiByZXN1bHRbMF0gPT09IDE7XG4gIH1cblxuICBzdGF0aWMgZ2V0SXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZSgpIHtcbiAgICBmdW5jdGlvbiBrZXJuZWxGdW5jdGlvbih2MSwgdjIpIHtcbiAgICAgIHJldHVybiB2MVt0aGlzLnRocmVhZC54XSAvIHYyW3RoaXMudGhyZWFkLnhdO1xuICAgIH1cbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgdGhpcyhrZXJuZWxGdW5jdGlvbi50b1N0cmluZygpLCB7XG4gICAgICBjb250ZXh0OiB0aGlzLnRlc3RDb250ZXh0LFxuICAgICAgY2FudmFzOiB0aGlzLnRlc3RDYW52YXMsXG4gICAgICB2YWxpZGF0ZTogZmFsc2UsXG4gICAgICBvdXRwdXQ6IFsyXSxcbiAgICAgIHJldHVyblR5cGU6ICdOdW1iZXInLFxuICAgICAgcHJlY2lzaW9uOiAndW5zaWduZWQnLFxuICAgICAgdGFjdGljOiAnc3BlZWQnLFxuICAgIH0pO1xuICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICBbNiwgNjAzMDQwMV0sXG4gICAgICBbMywgMzk5MV1cbiAgICBdO1xuICAgIGtlcm5lbC5idWlsZC5hcHBseShrZXJuZWwsIGFyZ3MpO1xuICAgIGtlcm5lbC5ydW4uYXBwbHkoa2VybmVsLCBhcmdzKTtcbiAgICBjb25zdCByZXN1bHQgPSBrZXJuZWwucmVuZGVyT3V0cHV0KCk7XG4gICAga2VybmVsLmRlc3Ryb3kodHJ1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdFswXSA9PT0gMiAmJiByZXN1bHRbMV0gPT09IDE1MTE7XG4gIH1cblxuICBzdGF0aWMgZ2V0SXNTcGVlZFRhY3RpY1N1cHBvcnRlZCgpIHtcbiAgICBmdW5jdGlvbiBrZXJuZWxGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlW3RoaXMudGhyZWFkLnhdO1xuICAgIH1cbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgdGhpcyhrZXJuZWxGdW5jdGlvbi50b1N0cmluZygpLCB7XG4gICAgICBjb250ZXh0OiB0aGlzLnRlc3RDb250ZXh0LFxuICAgICAgY2FudmFzOiB0aGlzLnRlc3RDYW52YXMsXG4gICAgICB2YWxpZGF0ZTogZmFsc2UsXG4gICAgICBvdXRwdXQ6IFs0XSxcbiAgICAgIHJldHVyblR5cGU6ICdOdW1iZXInLFxuICAgICAgcHJlY2lzaW9uOiAndW5zaWduZWQnLFxuICAgICAgdGFjdGljOiAnc3BlZWQnLFxuICAgIH0pO1xuICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICBbMCwgMSwgMiwgM11cbiAgICBdO1xuICAgIGtlcm5lbC5idWlsZC5hcHBseShrZXJuZWwsIGFyZ3MpO1xuICAgIGtlcm5lbC5ydW4uYXBwbHkoa2VybmVsLCBhcmdzKTtcbiAgICBjb25zdCByZXN1bHQgPSBrZXJuZWwucmVuZGVyT3V0cHV0KCk7XG4gICAga2VybmVsLmRlc3Ryb3kodHJ1ZSk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQocmVzdWx0WzBdKSA9PT0gMCAmJiBNYXRoLnJvdW5kKHJlc3VsdFsxXSkgPT09IDEgJiYgTWF0aC5yb3VuZChyZXN1bHRbMl0pID09PSAyICYmIE1hdGgucm91bmQocmVzdWx0WzNdKSA9PT0gMztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVzdENhbnZhcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwidGVzdENhbnZhc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlc3RDb250ZXh0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJ0ZXN0Q29udGV4dFwiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0RmVhdHVyZXMoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLnRlc3RDb250ZXh0O1xuICAgIGNvbnN0IGlzRHJhd0J1ZmZlcnMgPSB0aGlzLmdldElzRHJhd0J1ZmZlcnMoKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBpc0Zsb2F0UmVhZDogdGhpcy5nZXRJc0Zsb2F0UmVhZCgpLFxuICAgICAgaXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZTogdGhpcy5nZXRJc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlKCksXG4gICAgICBpc1NwZWVkVGFjdGljU3VwcG9ydGVkOiB0aGlzLmdldElzU3BlZWRUYWN0aWNTdXBwb3J0ZWQoKSxcbiAgICAgIGlzVGV4dHVyZUZsb2F0OiB0aGlzLmdldElzVGV4dHVyZUZsb2F0KCksXG4gICAgICBpc0RyYXdCdWZmZXJzLFxuICAgICAga2VybmVsTWFwOiBpc0RyYXdCdWZmZXJzLFxuICAgICAgY2hhbm5lbENvdW50OiB0aGlzLmdldENoYW5uZWxDb3VudCgpLFxuICAgICAgbWF4VGV4dHVyZVNpemU6IHRoaXMuZ2V0TWF4VGV4dHVyZVNpemUoKSxcbiAgICAgIGxvd0ludFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTE9XX0lOVCksXG4gICAgICBsb3dGbG9hdFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTE9XX0ZMT0FUKSxcbiAgICAgIG1lZGl1bUludFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0lOVCksXG4gICAgICBtZWRpdW1GbG9hdFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUKSxcbiAgICAgIGhpZ2hJbnRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfSU5UKSxcbiAgICAgIGhpZ2hGbG9hdFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCksXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgc2V0dXBGZWF0dXJlQ2hlY2tzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJzZXR1cEZlYXR1cmVDaGVja3NcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgc3RhdGljIGdldFNpZ25hdHVyZShrZXJuZWwsIGFyZ3VtZW50VHlwZXMpIHtcbiAgICByZXR1cm4ga2VybmVsLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCkgKyAoYXJndW1lbnRUeXBlcy5sZW5ndGggPiAwID8gJzonICsgYXJndW1lbnRUeXBlcy5qb2luKCcsJykgOiAnJyk7XG4gIH1cblxuICBzZXRGaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeShmaXgpIHtcbiAgICB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gZml4O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0UHJlY2lzaW9uKGZsYWcpIHtcbiAgICB0aGlzLnByZWNpc2lvbiA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRGbG9hdFRleHR1cmVzKGZsYWcpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnbWV0aG9kJywgJ3NldEZsb2F0VGV4dHVyZXMnLCAnc2V0T3B0aW1pemVGbG9hdE1lbW9yeScpO1xuICAgIHRoaXMuZmxvYXRUZXh0dXJlcyA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGF0aWMgbmF0aXZlRnVuY3Rpb25Bcmd1bWVudHMoc291cmNlKSB7XG4gICAgY29uc3QgYXJndW1lbnRUeXBlcyA9IFtdO1xuICAgIGNvbnN0IGFyZ3VtZW50TmFtZXMgPSBbXTtcbiAgICBjb25zdCBzdGF0ZXMgPSBbXTtcbiAgICBjb25zdCBpc1N0YXJ0aW5nVmFyaWFibGVOYW1lID0gL15bYS16QS1aX10vO1xuICAgIGNvbnN0IGlzVmFyaWFibGVDaGFyID0gL1thLXpBLVpfMC05XS87XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBhcmd1bWVudE5hbWUgPSBudWxsO1xuICAgIGxldCBhcmd1bWVudFR5cGUgPSBudWxsO1xuICAgIHdoaWxlIChpIDwgc291cmNlLmxlbmd0aCkge1xuICAgICAgY29uc3QgY2hhciA9IHNvdXJjZVtpXTtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gc291cmNlW2kgKyAxXTtcbiAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzLmxlbmd0aCA+IDAgPyBzdGF0ZXNbc3RhdGVzLmxlbmd0aCAtIDFdIDogbnVsbDtcblxuICAgICAgaWYgKHN0YXRlID09PSAnRlVOQ1RJT05fQVJHVU1FTlRTJyAmJiBjaGFyID09PSAnLycgJiYgbmV4dENoYXIgPT09ICcqJykge1xuICAgICAgICBzdGF0ZXMucHVzaCgnTVVMVElfTElORV9DT01NRU5UJyk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnTVVMVElfTElORV9DT01NRU5UJyAmJiBjaGFyID09PSAnKicgJiYgbmV4dENoYXIgPT09ICcvJykge1xuICAgICAgICBzdGF0ZXMucG9wKCk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnRlVOQ1RJT05fQVJHVU1FTlRTJyAmJiBjaGFyID09PSAnLycgJiYgbmV4dENoYXIgPT09ICcvJykge1xuICAgICAgICBzdGF0ZXMucHVzaCgnQ09NTUVOVCcpO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ0NPTU1FTlQnICYmIGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICAgIHN0YXRlcy5wb3AoKTtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZWxzZSBpZiAoc3RhdGUgPT09IG51bGwgJiYgY2hhciA9PT0gJygnKSB7XG4gICAgICAgIHN0YXRlcy5wdXNoKCdGVU5DVElPTl9BUkdVTUVOVFMnKTtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdGVU5DVElPTl9BUkdVTUVOVFMnKSB7XG4gICAgICAgIGlmIChjaGFyID09PSAnKScpIHtcbiAgICAgICAgICBzdGF0ZXMucG9wKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICdmJyAmJiBuZXh0Q2hhciA9PT0gJ2wnICYmIHNvdXJjZVtpICsgMl0gPT09ICdvJyAmJiBzb3VyY2VbaSArIDNdID09PSAnYScgJiYgc291cmNlW2kgKyA0XSA9PT0gJ3QnICYmIHNvdXJjZVtpICsgNV0gPT09ICcgJykge1xuICAgICAgICAgIHN0YXRlcy5wdXNoKCdERUNMQVJFX1ZBUklBQkxFJyk7XG4gICAgICAgICAgYXJndW1lbnRUeXBlID0gJ2Zsb2F0JztcbiAgICAgICAgICBhcmd1bWVudE5hbWUgPSAnJztcbiAgICAgICAgICBpICs9IDY7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ2knICYmIG5leHRDaGFyID09PSAnbicgJiYgc291cmNlW2kgKyAyXSA9PT0gJ3QnICYmIHNvdXJjZVtpICsgM10gPT09ICcgJykge1xuICAgICAgICAgIHN0YXRlcy5wdXNoKCdERUNMQVJFX1ZBUklBQkxFJyk7XG4gICAgICAgICAgYXJndW1lbnRUeXBlID0gJ2ludCc7XG4gICAgICAgICAgYXJndW1lbnROYW1lID0gJyc7XG4gICAgICAgICAgaSArPSA0O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICd2JyAmJiBuZXh0Q2hhciA9PT0gJ2UnICYmIHNvdXJjZVtpICsgMl0gPT09ICdjJyAmJiBzb3VyY2VbaSArIDNdID09PSAnMicgJiYgc291cmNlW2kgKyA0XSA9PT0gJyAnKSB7XG4gICAgICAgICAgc3RhdGVzLnB1c2goJ0RFQ0xBUkVfVkFSSUFCTEUnKTtcbiAgICAgICAgICBhcmd1bWVudFR5cGUgPSAndmVjMic7XG4gICAgICAgICAgYXJndW1lbnROYW1lID0gJyc7XG4gICAgICAgICAgaSArPSA1O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICd2JyAmJiBuZXh0Q2hhciA9PT0gJ2UnICYmIHNvdXJjZVtpICsgMl0gPT09ICdjJyAmJiBzb3VyY2VbaSArIDNdID09PSAnMycgJiYgc291cmNlW2kgKyA0XSA9PT0gJyAnKSB7XG4gICAgICAgICAgc3RhdGVzLnB1c2goJ0RFQ0xBUkVfVkFSSUFCTEUnKTtcbiAgICAgICAgICBhcmd1bWVudFR5cGUgPSAndmVjMyc7XG4gICAgICAgICAgYXJndW1lbnROYW1lID0gJyc7XG4gICAgICAgICAgaSArPSA1O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICd2JyAmJiBuZXh0Q2hhciA9PT0gJ2UnICYmIHNvdXJjZVtpICsgMl0gPT09ICdjJyAmJiBzb3VyY2VbaSArIDNdID09PSAnNCcgJiYgc291cmNlW2kgKyA0XSA9PT0gJyAnKSB7XG4gICAgICAgICAgc3RhdGVzLnB1c2goJ0RFQ0xBUkVfVkFSSUFCTEUnKTtcbiAgICAgICAgICBhcmd1bWVudFR5cGUgPSAndmVjNCc7XG4gICAgICAgICAgYXJndW1lbnROYW1lID0gJyc7XG4gICAgICAgICAgaSArPSA1O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnREVDTEFSRV9WQVJJQUJMRScpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50TmFtZSA9PT0gJycpIHtcbiAgICAgICAgICBpZiAoY2hhciA9PT0gJyAnKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1N0YXJ0aW5nVmFyaWFibGVOYW1lLnRlc3QoY2hhcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndmFyaWFibGUgbmFtZSBpcyBub3QgZXhwZWN0ZWQgc3RyaW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyZ3VtZW50TmFtZSArPSBjaGFyO1xuICAgICAgICBpZiAoIWlzVmFyaWFibGVDaGFyLnRlc3QobmV4dENoYXIpKSB7XG4gICAgICAgICAgc3RhdGVzLnBvcCgpO1xuICAgICAgICAgIGFyZ3VtZW50TmFtZXMucHVzaChhcmd1bWVudE5hbWUpO1xuICAgICAgICAgIGFyZ3VtZW50VHlwZXMucHVzaCh0eXBlTWFwW2FyZ3VtZW50VHlwZV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG4gICAgaWYgKHN0YXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dMU0wgZnVuY3Rpb24gd2FzIG5vdCBwYXJzYWJsZScpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYXJndW1lbnROYW1lcyxcbiAgICAgIGFyZ3VtZW50VHlwZXMsXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBuYXRpdmVGdW5jdGlvblJldHVyblR5cGUoc291cmNlKSB7XG4gICAgcmV0dXJuIHR5cGVNYXBbc291cmNlLm1hdGNoKC9pbnR8ZmxvYXR8dmVjWzItNF0vKVswXV07XG4gIH1cblxuICBzdGF0aWMgY29tYmluZUtlcm5lbHMoY29tYmluZWRLZXJuZWwsIGxhc3RLZXJuZWwpIHtcbiAgICBjb21iaW5lZEtlcm5lbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRleFNpemUsXG4gICAgICBjb250ZXh0LFxuICAgICAgdGhyZWFkRGltXG4gICAgfSA9IGxhc3RLZXJuZWwudGV4U2l6ZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChsYXN0S2VybmVsLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIGNvbnN0IHcgPSB0ZXhTaXplWzBdO1xuICAgICAgY29uc3QgaCA9IE1hdGguY2VpbCh0ZXhTaXplWzFdIC8gNCk7XG4gICAgICByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KHcgKiBoICogNCAqIDQpO1xuICAgICAgY29udGV4dC5yZWFkUGl4ZWxzKDAsIDAsIHcsIGggKiA0LCBjb250ZXh0LlJHQkEsIGNvbnRleHQuRkxPQVQsIHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGV4U2l6ZVswXSAqIHRleFNpemVbMV0gKiA0KTtcbiAgICAgIGNvbnRleHQucmVhZFBpeGVscygwLCAwLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCBjb250ZXh0LlJHQkEsIGNvbnRleHQuVU5TSUdORURfQllURSwgYnl0ZXMpO1xuICAgICAgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShieXRlcy5idWZmZXIpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJhcnJheSgwLCB0aHJlYWREaW1bMF0gKiB0aHJlYWREaW1bMV0gKiB0aHJlYWREaW1bMl0pO1xuXG4gICAgaWYgKGxhc3RLZXJuZWwub3V0cHV0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKGxhc3RLZXJuZWwub3V0cHV0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIHV0aWxzLnNwbGl0QXJyYXkocmVzdWx0LCBsYXN0S2VybmVsLm91dHB1dFswXSk7XG4gICAgfSBlbHNlIGlmIChsYXN0S2VybmVsLm91dHB1dC5sZW5ndGggPT09IDMpIHtcbiAgICAgIGNvbnN0IGN1YmUgPSB1dGlscy5zcGxpdEFycmF5KHJlc3VsdCwgbGFzdEtlcm5lbC5vdXRwdXRbMF0gKiBsYXN0S2VybmVsLm91dHB1dFsxXSk7XG4gICAgICByZXR1cm4gY3ViZS5tYXAoZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdXRpbHMuc3BsaXRBcnJheSh4LCBsYXN0S2VybmVsLm91dHB1dFswXSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc291cmNlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy50cmFuc2ZlclZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSBudWxsO1xuICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlck91dHB1dCA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJSYXdPdXRwdXQgPSBudWxsO1xuICAgIHRoaXMudGV4U2l6ZSA9IG51bGw7XG4gICAgdGhpcy50cmFuc2xhdGVkU291cmNlID0gbnVsbDtcbiAgICB0aGlzLmNvbXBpbGVkRnJhZ21lbnRTaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuY29tcGlsZWRWZXJ0ZXhTaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuc3dpdGNoaW5nS2VybmVscyA9IG51bGw7XG4gICAgdGhpcy5fdGV4dHVyZVN3aXRjaGVkID0gbnVsbDtcbiAgICB0aGlzLl9tYXBwZWRUZXh0dXJlU3dpdGNoZWQgPSBudWxsO1xuICB9XG5cbiAgY2hlY2tUZXh0dXJlU2l6ZSgpIHtcbiAgICBjb25zdCB7IGZlYXR1cmVzIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIGlmICh0aGlzLnRleFNpemVbMF0gPiBmZWF0dXJlcy5tYXhUZXh0dXJlU2l6ZSB8fCB0aGlzLnRleFNpemVbMV0gPiBmZWF0dXJlcy5tYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZXh0dXJlIHNpemUgWyR7dGhpcy50ZXhTaXplWzBdfSwke3RoaXMudGV4U2l6ZVsxXX1dIGdlbmVyYXRlZCBieSBrZXJuZWwgaXMgbGFyZ2VyIHRoYW4gc3VwcG9ydGVkIHNpemUgWyR7ZmVhdHVyZXMubWF4VGV4dHVyZVNpemV9LCR7ZmVhdHVyZXMubWF4VGV4dHVyZVNpemV9XWApO1xuICAgIH1cbiAgfVxuXG4gIHRyYW5zbGF0ZVNvdXJjZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwidHJhbnNsYXRlU291cmNlXCIgbm90IGRlZmluZWQgb24gJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gIH1cblxuICBwaWNrUmVuZGVyU3RyYXRlZ3koYXJncykge1xuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgdGhpcy5yZW5kZXJSYXdPdXRwdXQgPSB0aGlzLnJlYWRQYWNrZWRQaXhlbHNUb1VpbnQ4QXJyYXk7XG4gICAgICB0aGlzLnRyYW5zZmVyVmFsdWVzID0gKHBpeGVscykgPT4gcGl4ZWxzO1xuICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVHcmFwaGljYWw7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAndW5zaWduZWQnKSB7XG4gICAgICB0aGlzLnJlbmRlclJhd091dHB1dCA9IHRoaXMucmVhZFBhY2tlZFBpeGVsc1RvVWludDhBcnJheTtcbiAgICAgIHRoaXMudHJhbnNmZXJWYWx1ZXMgPSB0aGlzLnJlYWRQYWNrZWRQaXhlbHNUb0Zsb2F0MzJBcnJheTtcbiAgICAgIGlmICh0aGlzLnBpcGVsaW5lKSB7XG4gICAgICAgIHRoaXMucmVuZGVyT3V0cHV0ID0gdGhpcy5yZW5kZXJUZXh0dXJlO1xuICAgICAgICBpZiAodGhpcy5zdWJLZXJuZWxzICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJLZXJuZWxzID0gdGhpcy5yZW5kZXJLZXJuZWxzVG9UZXh0dXJlcztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVVbnNpZ25lZDNEO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlVW5zaWduZWQyRDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZVVuc2lnbmVkO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEZhbGxiYWNrKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zdWJLZXJuZWxzICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJLZXJuZWxzID0gdGhpcy5yZW5kZXJLZXJuZWxzVG9BcnJheXM7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgICB0aGlzLnJlbmRlck91dHB1dCA9IHRoaXMucmVuZGVyVmFsdWVzO1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZVVuc2lnbmVkM0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QzRFBhY2tlZEZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlVW5zaWduZWQyRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDJEUGFja2VkRmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVVbnNpZ25lZDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdFBhY2tlZEZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEZhbGxiYWNrKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIHRoaXMucmVuZGVyUmF3T3V0cHV0ID0gdGhpcy5yZWFkRmxvYXRQaXhlbHNUb0Zsb2F0MzJBcnJheTtcbiAgICAgIHRoaXMudHJhbnNmZXJWYWx1ZXMgPSB0aGlzLnJlYWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5O1xuICAgICAgaWYgKHRoaXMucGlwZWxpbmUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJPdXRwdXQgPSB0aGlzLnJlbmRlclRleHR1cmU7XG4gICAgICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcktlcm5lbHMgPSB0aGlzLnJlbmRlcktlcm5lbHNUb1RleHR1cmVzO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDNEO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkMkQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUZsb2F0M0Q7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVGbG9hdDJEO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlRmxvYXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMiknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkyRmxvYXQzRDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0MkQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDMpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0M0Q7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTNGbG9hdDJEO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSg0KSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDNEO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQyRDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5NEZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT3V0cHV0ID0gdGhpcy5yZW5kZXJWYWx1ZXM7XG4gICAgICBpZiAodGhpcy5zdWJLZXJuZWxzICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVuZGVyS2VybmVscyA9IHRoaXMucmVuZGVyS2VybmVsc1RvQXJyYXlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0TWVtb3J5T3B0aW1pemVkM0RGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0TWVtb3J5T3B0aW1pemVkMkRGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZEZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMiknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkyRmxvYXQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDNEQXJyYXkyO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkyRmxvYXQyRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDJEQXJyYXkyO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkyRmxvYXQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RBcnJheTI7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSgzKSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTNGbG9hdDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0M0RBcnJheTM7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTNGbG9hdDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0MkRBcnJheTM7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTNGbG9hdDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdEFycmF5MztcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDQpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5NEZsb2F0M0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QzREFycmF5NDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5NEZsb2F0MkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QyREFycmF5NDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5NEZsb2F0O1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0QXJyYXk0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlRmxvYXQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDNERmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVGbG9hdDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0MkRGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUZsb2F0O1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0RmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSgyKSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0M0RBcnJheTI7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0MkRBcnJheTI7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdEFycmF5MjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDMpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0M0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QzREFycmF5MztcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0MkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QyREFycmF5MztcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0O1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0QXJyYXkzO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoNCknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDNEQXJyYXk0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQyRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDJEQXJyYXk0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RBcnJheTQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCBwcmVjaXNpb24gb2YgXCIke3RoaXMucHJlY2lzaW9ufVwiYCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgcmV0dXJuIHR5cGUgXCIke3RoaXMucmV0dXJuVHlwZX1cImApO1xuICB9XG5cbiAgZ2V0S2VybmVsU3RyaW5nKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRUZXh0dXJlKCkge1xuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHROdW1iZXJUZXh0dXJlKCk7XG4gICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRBcnJheTJUZXh0dXJlKCk7XG4gICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRBcnJheTNUZXh0dXJlKCk7XG4gICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRBcnJheTRUZXh0dXJlKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCByZXR1cm5UeXBlIHR5cGUgJHsgdGhpcy5yZXR1cm5UeXBlIH1gKTtcbiAgICB9XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsTnVtYmVyVGV4dHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbE51bWJlclRleHR1cmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTJUZXh0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXkyVGV4dHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5M1RleHR1cmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTNUZXh0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXk0VGV4dHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5NFRleHR1cmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG4gIGdldE1haW5SZXN1bHRHcmFwaGljYWwoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG4gIGdldE1haW5SZXN1bHRNZW1vcnlPcHRpbWl6ZWRGbG9hdHMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG4gIGdldE1haW5SZXN1bHRQYWNrZWRQaXhlbHMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN0cmluZygpIHtcbiAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRHcmFwaGljYWwoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgaWYgKHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYWluUmVzdWx0TWVtb3J5T3B0aW1pemVkRmxvYXRzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRNYWluUmVzdWx0VGV4dHVyZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRNYWluUmVzdWx0UGFja2VkUGl4ZWxzKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TWFpblJlc3VsdE51bWJlclRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0S2VybmVsTnVtYmVyVGV4dHVyZSgpKSArXG4gICAgICB1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdFN1Yktlcm5lbE51bWJlclRleHR1cmUoKSk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0QXJyYXkyVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxBcnJheTJUZXh0dXJlKCkpICtcbiAgICAgIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXkyVGV4dHVyZSgpKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRBcnJheTNUZXh0dXJlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5M1RleHR1cmUoKSkgK1xuICAgICAgdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTNUZXh0dXJlKCkpO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEFycmF5NFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0S2VybmVsQXJyYXk0VGV4dHVyZSgpKSArXG4gICAgICB1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5NFRleHR1cmUoKSk7XG4gIH1cblxuICBnZXRGbG9hdFRhY3RpY0RlY2xhcmF0aW9uKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZyh0aGlzLnRleFNpemUsIHRoaXMudGFjdGljKTtcbiAgICByZXR1cm4gYHByZWNpc2lvbiAke3ZhcmlhYmxlUHJlY2lzaW9ufSBmbG9hdDtcXG5gO1xuICB9XG5cbiAgZ2V0SW50VGFjdGljRGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIGBwcmVjaXNpb24gJHt0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4U2l6ZSwgdGhpcy50YWN0aWMsIHRydWUpfSBpbnQ7XFxuYDtcbiAgfVxuXG4gIGdldFNhbXBsZXIyRFRhY3RpY0RlY2xhcmF0aW9uKCkge1xuICAgIHJldHVybiBgcHJlY2lzaW9uICR7dGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZyh0aGlzLnRleFNpemUsIHRoaXMudGFjdGljKX0gc2FtcGxlcjJEO1xcbmA7XG4gIH1cblxuICBnZXRTYW1wbGVyMkRBcnJheVRhY3RpY0RlY2xhcmF0aW9uKCkge1xuICAgIHJldHVybiBgcHJlY2lzaW9uICR7dGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZyh0aGlzLnRleFNpemUsIHRoaXMudGFjdGljKX0gc2FtcGxlcjJEQXJyYXk7XFxuYDtcbiAgfVxuXG4gIHJlbmRlclRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1tdXRhYmxlID8gdGhpcy50ZXh0dXJlLmNsb25lKCkgOiB0aGlzLnRleHR1cmU7XG4gIH1cbiAgcmVhZFBhY2tlZFBpeGVsc1RvVWludDhBcnJheSgpIHtcbiAgICBpZiAodGhpcy5wcmVjaXNpb24gIT09ICd1bnNpZ25lZCcpIHRocm93IG5ldyBFcnJvcignUmVxdWlyZXMgdGhpcy5wcmVjaXNpb24gdG8gYmUgXCJ1bnNpZ25lZFwiJyk7XG4gICAgY29uc3Qge1xuICAgICAgdGV4U2l6ZSxcbiAgICAgIGNvbnRleHQ6IGdsXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodGV4U2l6ZVswXSAqIHRleFNpemVbMV0gKiA0KTtcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJlYWRQYWNrZWRQaXhlbHNUb0Zsb2F0MzJBcnJheSgpIHtcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnJlYWRQYWNrZWRQaXhlbHNUb1VpbnQ4QXJyYXkoKS5idWZmZXIpO1xuICB9XG5cbiAgcmVhZEZsb2F0UGl4ZWxzVG9GbG9hdDMyQXJyYXkoKSB7XG4gICAgaWYgKHRoaXMucHJlY2lzaW9uICE9PSAnc2luZ2xlJykgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlcyB0aGlzLnByZWNpc2lvbiB0byBiZSBcInNpbmdsZVwiJyk7XG4gICAgY29uc3Qge1xuICAgICAgdGV4U2l6ZSxcbiAgICAgIGNvbnRleHQ6IGdsXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgdyA9IHRleFNpemVbMF07XG4gICAgY29uc3QgaCA9IHRleFNpemVbMV07XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheSh3ICogaCAqIDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgdywgaCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldFBpeGVscyhmbGlwKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dDogZ2wsXG4gICAgICBvdXRwdXRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSBvdXRwdXQ7XG4gICAgY29uc3QgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVscyk7XG4gICAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheSgoZmxpcCA/IHBpeGVscyA6IHV0aWxzLmZsaXBQaXhlbHMocGl4ZWxzLCB3aWR0aCwgaGVpZ2h0KSkuYnVmZmVyKTtcbiAgfVxuXG4gIHJlbmRlcktlcm5lbHNUb0FycmF5cygpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICByZXN1bHQ6IHRoaXMucmVuZGVyT3V0cHV0KCksXG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W3RoaXMuc3ViS2VybmVsc1tpXS5wcm9wZXJ0eV0gPSB0aGlzLm1hcHBlZFRleHR1cmVzW2ldLnRvQXJyYXkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJlbmRlcktlcm5lbHNUb1RleHR1cmVzKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHJlc3VsdDogdGhpcy5yZW5kZXJPdXRwdXQoKSxcbiAgICB9O1xuICAgIGlmICh0aGlzLmltbXV0YWJsZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W3RoaXMuc3ViS2VybmVsc1tpXS5wcm9wZXJ0eV0gPSB0aGlzLm1hcHBlZFRleHR1cmVzW2ldLmNsb25lKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFt0aGlzLnN1Yktlcm5lbHNbaV0ucHJvcGVydHldID0gdGhpcy5tYXBwZWRUZXh0dXJlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJlc2V0U3dpdGNoaW5nS2VybmVscygpIHtcbiAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gdGhpcy5zd2l0Y2hpbmdLZXJuZWxzO1xuICAgIHRoaXMuc3dpdGNoaW5nS2VybmVscyA9IG51bGw7XG4gICAgcmV0dXJuIGV4aXN0aW5nVmFsdWU7XG4gIH1cblxuICBzZXRPdXRwdXQob3V0cHV0KSB7XG4gICAgY29uc3QgbmV3T3V0cHV0ID0gdGhpcy50b0tlcm5lbE91dHB1dChvdXRwdXQpO1xuICAgIGlmICh0aGlzLnByb2dyYW0pIHtcbiAgICAgIGlmICghdGhpcy5keW5hbWljT3V0cHV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXppbmcgYSBrZXJuZWwgd2l0aCBkeW5hbWljT3V0cHV0OiBmYWxzZSBpcyBub3QgcG9zc2libGUnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld1RocmVhZERpbSA9IFtuZXdPdXRwdXRbMF0sIG5ld091dHB1dFsxXSB8fCAxLCBuZXdPdXRwdXRbMl0gfHwgMV07XG4gICAgICBjb25zdCBuZXdUZXhTaXplID0gdXRpbHMuZ2V0S2VybmVsVGV4dHVyZVNpemUoe1xuICAgICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICAgIHByZWNpc2lvbjogdGhpcy5wcmVjaXNpb24sXG4gICAgICB9LCBuZXdUaHJlYWREaW0pO1xuICAgICAgY29uc3Qgb2xkVGV4U2l6ZSA9IHRoaXMudGV4U2l6ZTtcbiAgICAgIGlmIChvbGRUZXhTaXplKSB7XG4gICAgICAgIGNvbnN0IG9sZFByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcob2xkVGV4U2l6ZSwgdGhpcy50YWN0aWMpO1xuICAgICAgICBjb25zdCBuZXdQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKG5ld1RleFNpemUsIHRoaXMudGFjdGljKTtcbiAgICAgICAgaWYgKG9sZFByZWNpc2lvbiAhPT0gbmV3UHJlY2lzaW9uKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUHJlY2lzaW9uIHJlcXVpcmVtZW50IGNoYW5nZWQsIGFza2luZyBHUFUgaW5zdGFuY2UgdG8gcmVjb21waWxlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3dpdGNoS2VybmVscyh7XG4gICAgICAgICAgICB0eXBlOiAnb3V0cHV0UHJlY2lzaW9uTWlzbWF0Y2gnLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiBuZXdQcmVjaXNpb24sXG4gICAgICAgICAgICBuZWVkZWQ6IG91dHB1dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vdXRwdXQgPSBuZXdPdXRwdXQ7XG4gICAgICB0aGlzLnRocmVhZERpbSA9IG5ld1RocmVhZERpbTtcbiAgICAgIHRoaXMudGV4U2l6ZSA9IG5ld1RleFNpemU7XG4gICAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgIHRoaXMudXBkYXRlTWF4VGV4U2l6ZSgpO1xuICAgICAgdGhpcy5mcmFtZWJ1ZmZlci53aWR0aCA9IHRoaXMudGV4U2l6ZVswXTtcbiAgICAgIHRoaXMuZnJhbWVidWZmZXIuaGVpZ2h0ID0gdGhpcy50ZXhTaXplWzFdO1xuICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5tYXhUZXhTaXplWzBdLCB0aGlzLm1heFRleFNpemVbMV0pO1xuICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLm1heFRleFNpemVbMF07XG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLm1heFRleFNpemVbMV07XG4gICAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZS5kZWxldGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgICB0aGlzLl9zZXR1cE91dHB1dFRleHR1cmUoKTtcbiAgICAgIGlmICh0aGlzLm1hcHBlZFRleHR1cmVzICYmIHRoaXMubWFwcGVkVGV4dHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFwcGVkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLm1hcHBlZFRleHR1cmVzW2ldLmRlbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9zZXR1cFN1Yk91dHB1dFRleHR1cmVzKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3V0cHV0ID0gbmV3T3V0cHV0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZW5kZXJWYWx1ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0VmFsdWVzKFxuICAgICAgdGhpcy50cmFuc2ZlclZhbHVlcygpLFxuICAgICAgdGhpcy5vdXRwdXRbMF0sXG4gICAgICB0aGlzLm91dHB1dFsxXSxcbiAgICAgIHRoaXMub3V0cHV0WzJdXG4gICAgKTtcbiAgfVxuICBzd2l0Y2hLZXJuZWxzKHJlYXNvbikge1xuICAgIGlmICh0aGlzLnN3aXRjaGluZ0tlcm5lbHMpIHtcbiAgICAgIHRoaXMuc3dpdGNoaW5nS2VybmVscy5wdXNoKHJlYXNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3dpdGNoaW5nS2VybmVscyA9IFtyZWFzb25dO1xuICAgIH1cbiAgfVxuICBnZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZyh0ZXh0dXJlU2l6ZSA9IHRoaXMudGV4U2l6ZSwgdGFjdGljID0gdGhpcy50YWN0aWMsIGlzSW50ID0gZmFsc2UpIHtcbiAgICBpZiAoIXRhY3RpYykge1xuICAgICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLmZlYXR1cmVzLmlzU3BlZWRUYWN0aWNTdXBwb3J0ZWQpIHJldHVybiAnaGlnaHAnO1xuICAgICAgY29uc3QgbG93ID0gdGhpcy5jb25zdHJ1Y3Rvci5mZWF0dXJlc1tpc0ludCA/ICdsb3dJbnRQcmVjaXNpb24nIDogJ2xvd0Zsb2F0UHJlY2lzaW9uJ107XG4gICAgICBjb25zdCBtZWRpdW0gPSB0aGlzLmNvbnN0cnVjdG9yLmZlYXR1cmVzW2lzSW50ID8gJ21lZGl1bUludFByZWNpc2lvbicgOiAnbWVkaXVtRmxvYXRQcmVjaXNpb24nXTtcbiAgICAgIGNvbnN0IGhpZ2ggPSB0aGlzLmNvbnN0cnVjdG9yLmZlYXR1cmVzW2lzSW50ID8gJ2hpZ2hJbnRQcmVjaXNpb24nIDogJ2hpZ2hGbG9hdFByZWNpc2lvbiddO1xuICAgICAgY29uc3QgcmVxdWlyZWRTaXplID0gTWF0aC5sb2cyKHRleHR1cmVTaXplWzBdICogdGV4dHVyZVNpemVbMV0pO1xuICAgICAgaWYgKHJlcXVpcmVkU2l6ZSA8PSBsb3cucmFuZ2VNYXgpIHtcbiAgICAgICAgcmV0dXJuICdsb3dwJztcbiAgICAgIH0gZWxzZSBpZiAocmVxdWlyZWRTaXplIDw9IG1lZGl1bS5yYW5nZU1heCkge1xuICAgICAgICByZXR1cm4gJ21lZGl1bXAnO1xuICAgICAgfSBlbHNlIGlmIChyZXF1aXJlZFNpemUgPD0gaGlnaC5yYW5nZU1heCkge1xuICAgICAgICByZXR1cm4gJ2hpZ2hwJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHJlcXVpcmVkIHNpemUgZXhjZWVkcyB0aGF0IG9mIHRoZSBhYmlsaXR5IG9mIHlvdXIgc3lzdGVtYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodGFjdGljKSB7XG4gICAgICBjYXNlICdzcGVlZCc6XG4gICAgICAgIHJldHVybiAnbG93cCc7XG4gICAgICBjYXNlICdiYWxhbmNlZCc6XG4gICAgICAgIHJldHVybiAnbWVkaXVtcCc7XG4gICAgICBjYXNlICdwcmVjaXNpb24nOlxuICAgICAgICByZXR1cm4gJ2hpZ2hwJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0YWN0aWMgXCIke3RhY3RpY31cIiB1c2UgXCJzcGVlZFwiLCBcImJhbGFuY2VkXCIsIFwicHJlY2lzaW9uXCIsIG9yIGVtcHR5IGZvciBhdXRvYCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlVGV4dHVyZUFyZ3VtZW50UmVmcyhrZXJuZWxWYWx1ZSwgYXJnKSB7XG4gICAgaWYgKCF0aGlzLmltbXV0YWJsZSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnRleHR1cmUudGV4dHVyZSA9PT0gYXJnLnRleHR1cmUpIHtcbiAgICAgIGNvbnN0IHsgcHJldkFyZyB9ID0ga2VybmVsVmFsdWU7XG4gICAgICBpZiAocHJldkFyZykge1xuICAgICAgICBpZiAocHJldkFyZy50ZXh0dXJlLl9yZWZzID09PSAxKSB7XG4gICAgICAgICAgdGhpcy50ZXh0dXJlLmRlbGV0ZSgpO1xuICAgICAgICAgIHRoaXMudGV4dHVyZSA9IHByZXZBcmcuY2xvbmUoKTtcbiAgICAgICAgICB0aGlzLl90ZXh0dXJlU3dpdGNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHByZXZBcmcuZGVsZXRlKCk7XG4gICAgICB9XG4gICAgICBrZXJuZWxWYWx1ZS5wcmV2QXJnID0gYXJnLmNsb25lKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hcHBlZFRleHR1cmVzICYmIHRoaXMubWFwcGVkVGV4dHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeyBtYXBwZWRUZXh0dXJlcyB9ID0gdGhpcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcGVkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbWFwcGVkVGV4dHVyZSA9IG1hcHBlZFRleHR1cmVzW2ldO1xuICAgICAgICBpZiAobWFwcGVkVGV4dHVyZS50ZXh0dXJlID09PSBhcmcudGV4dHVyZSkge1xuICAgICAgICAgIGNvbnN0IHsgcHJldkFyZyB9ID0ga2VybmVsVmFsdWU7XG4gICAgICAgICAgaWYgKHByZXZBcmcpIHtcbiAgICAgICAgICAgIGlmIChwcmV2QXJnLnRleHR1cmUuX3JlZnMgPT09IDEpIHtcbiAgICAgICAgICAgICAgbWFwcGVkVGV4dHVyZS5kZWxldGUoKTtcbiAgICAgICAgICAgICAgbWFwcGVkVGV4dHVyZXNbaV0gPSBwcmV2QXJnLmNsb25lKCk7XG4gICAgICAgICAgICAgIHRoaXMuX21hcHBlZFRleHR1cmVTd2l0Y2hlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2QXJnLmRlbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXJuZWxWYWx1ZS5wcmV2QXJnID0gYXJnLmNsb25lKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25BY3RpdmF0ZShwcmV2aW91c0tlcm5lbCkge1xuICAgIHRoaXMuX3RleHR1cmVTd2l0Y2hlZCA9IHRydWU7XG4gICAgdGhpcy50ZXh0dXJlID0gcHJldmlvdXNLZXJuZWwudGV4dHVyZTtcbiAgICBpZiAodGhpcy5tYXBwZWRUZXh0dXJlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcHBlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX21hcHBlZFRleHR1cmVTd2l0Y2hlZFtpXSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLm1hcHBlZFRleHR1cmVzID0gcHJldmlvdXNLZXJuZWwubWFwcGVkVGV4dHVyZXM7XG4gICAgfVxuICB9XG5cbiAgaW5pdENhbnZhcygpIHt9XG59XG5cbmNvbnN0IHR5cGVNYXAgPSB7XG4gIGludDogJ0ludGVnZXInLFxuICBmbG9hdDogJ051bWJlcicsXG4gIHZlYzI6ICdBcnJheSgyKScsXG4gIHZlYzM6ICdBcnJheSgzKScsXG4gIHZlYzQ6ICdBcnJheSg0KScsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xLZXJuZWxcbn07XG59LHtcIi4uLy4uL3V0aWxzXCI6MTE0LFwiLi4va2VybmVsXCI6MzYsXCIuL3RleHR1cmUvYXJyYXktMi1mbG9hdFwiOjE2LFwiLi90ZXh0dXJlL2FycmF5LTItZmxvYXQtMmRcIjoxNCxcIi4vdGV4dHVyZS9hcnJheS0yLWZsb2F0LTNkXCI6MTUsXCIuL3RleHR1cmUvYXJyYXktMy1mbG9hdFwiOjE5LFwiLi90ZXh0dXJlL2FycmF5LTMtZmxvYXQtMmRcIjoxNyxcIi4vdGV4dHVyZS9hcnJheS0zLWZsb2F0LTNkXCI6MTgsXCIuL3RleHR1cmUvYXJyYXktNC1mbG9hdFwiOjIyLFwiLi90ZXh0dXJlL2FycmF5LTQtZmxvYXQtMmRcIjoyMCxcIi4vdGV4dHVyZS9hcnJheS00LWZsb2F0LTNkXCI6MjEsXCIuL3RleHR1cmUvZmxvYXRcIjoyNSxcIi4vdGV4dHVyZS9mbG9hdC0yZFwiOjIzLFwiLi90ZXh0dXJlL2Zsb2F0LTNkXCI6MjQsXCIuL3RleHR1cmUvZ3JhcGhpY2FsXCI6MjYsXCIuL3RleHR1cmUvbWVtb3J5LW9wdGltaXplZFwiOjMwLFwiLi90ZXh0dXJlL21lbW9yeS1vcHRpbWl6ZWQtMmRcIjoyOCxcIi4vdGV4dHVyZS9tZW1vcnktb3B0aW1pemVkLTNkXCI6MjksXCIuL3RleHR1cmUvdW5zaWduZWRcIjozMyxcIi4vdGV4dHVyZS91bnNpZ25lZC0yZFwiOjMxLFwiLi90ZXh0dXJlL3Vuc2lnbmVkLTNkXCI6MzJ9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTJGbG9hdDJEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDIpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDJEQXJyYXkyKHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUFycmF5MkZsb2F0MkRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlQXJyYXkyRmxvYXQzRCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgyKSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QzREFycmF5Mih0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0sIHRoaXMub3V0cHV0WzJdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXkyRmxvYXQzRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTJGbG9hdCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgyKSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RBcnJheTIodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXkyRmxvYXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlQXJyYXkzRmxvYXQyRCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgzKSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QyREFycmF5Myh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTNGbG9hdDJEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUFycmF5M0Zsb2F0M0QgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoMyknO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0M0RBcnJheTModGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdLCB0aGlzLm91dHB1dFsyXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUFycmF5M0Zsb2F0M0Rcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlQXJyYXkzRmxvYXQgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoMyknO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0QXJyYXkzKHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXkzRmxvYXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlQXJyYXk0RmxvYXQyRCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSg0KSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QyREFycmF5NCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTRGbG9hdDJEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUFycmF5NEZsb2F0M0QgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoNCknO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0M0RBcnJheTQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdLCB0aGlzLm91dHB1dFsyXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUFycmF5NEZsb2F0M0Rcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlQXJyYXk0RmxvYXQgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoNCknO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0QXJyYXk0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXk0RmxvYXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlRmxvYXQyRCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgxKSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QyREZsb2F0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUZsb2F0MkRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlRmxvYXQzRCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgxKSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QzREZsb2F0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSwgdGhpcy5vdXRwdXRbMl0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVGbG9hdDNEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5jbGFzcyBHTFRleHR1cmVGbG9hdCBleHRlbmRzIEdMVGV4dHVyZSB7XG4gIGdldCB0ZXh0dXJlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LkZMT0FUO1xuICB9XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoMSknO1xuICB9XG4gIHJlbmRlclJhd091dHB1dCgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBzaXplID0gdGhpcy5zaXplO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcigpKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgICAgZ2wuQ09MT1JfQVRUQUNITUVOVDAsXG4gICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgdGhpcy50ZXh0dXJlLFxuICAgICAgMFxuICAgICk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShzaXplWzBdICogc2l6ZVsxXSAqIDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgc2l6ZVswXSwgc2l6ZVsxXSwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZW5kZXJWYWx1ZXMoKSB7XG4gICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLnJlbmRlclJhd091dHB1dCgpO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0RmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVGbG9hdFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2luZGV4XCI6Mjd9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IEdMVGV4dHVyZVVuc2lnbmVkIH0gPSByZXF1aXJlKCcuL3Vuc2lnbmVkJyk7XG5cbmNsYXNzIEdMVGV4dHVyZUdyYXBoaWNhbCBleHRlbmRzIEdMVGV4dHVyZVVuc2lnbmVkIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSg0KSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJWYWx1ZXMoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlR3JhcGhpY2FsXG59O1xufSx7XCIuL3Vuc2lnbmVkXCI6MzN9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFRleHR1cmUgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3RleHR1cmUnKTtcblxuY2xhc3MgR0xUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG4gIGdldCB0ZXh0dXJlVHlwZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwidGV4dHVyZVR5cGVcIiBub3QgaW1wbGVtZW50ZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgfVxuXG4gIGJlZm9yZU11dGF0ZSgpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlLl9yZWZzID4gMSkge1xuICAgICAgdGhpcy5uZXdUZXh0dXJlKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2xvbmVUZXh0dXJlKCkge1xuICAgIHRoaXMudGV4dHVyZS5fcmVmcy0tO1xuICAgIGNvbnN0IHsgY29udGV4dDogZ2wsIHNpemUsIHRleHR1cmUsIGtlcm5lbCB9ID0gdGhpcztcbiAgICBpZiAoa2VybmVsLmRlYnVnKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2Nsb25pbmcgaW50ZXJuYWwgdGV4dHVyZScpO1xuICAgIH1cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIoKSk7XG4gICAgc2VsZWN0VGV4dHVyZShnbCwgdGV4dHVyZSk7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcbiAgICBjb25zdCB0YXJnZXQgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgc2VsZWN0VGV4dHVyZShnbCwgdGFyZ2V0KTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuaW50ZXJuYWxGb3JtYXQsIHNpemVbMF0sIHNpemVbMV0sIDAsIHRoaXMudGV4dHVyZUZvcm1hdCwgdGhpcy50ZXh0dXJlVHlwZSwgbnVsbCk7XG4gICAgZ2wuY29weVRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgMCwgMCwgc2l6ZVswXSwgc2l6ZVsxXSk7XG4gICAgdGFyZ2V0Ll9yZWZzID0gMTtcbiAgICB0aGlzLnRleHR1cmUgPSB0YXJnZXQ7XG4gIH1cblxuICBuZXdUZXh0dXJlKCkge1xuICAgIHRoaXMudGV4dHVyZS5fcmVmcy0tO1xuICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgY29uc3Qga2VybmVsID0gdGhpcy5rZXJuZWw7XG4gICAgaWYgKGtlcm5lbC5kZWJ1Zykge1xuICAgICAgY29uc29sZS53YXJuKCduZXcgaW50ZXJuYWwgdGV4dHVyZScpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgc2VsZWN0VGV4dHVyZShnbCwgdGFyZ2V0KTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuaW50ZXJuYWxGb3JtYXQsIHNpemVbMF0sIHNpemVbMV0sIDAsIHRoaXMudGV4dHVyZUZvcm1hdCwgdGhpcy50ZXh0dXJlVHlwZSwgbnVsbCk7XG4gICAgdGFyZ2V0Ll9yZWZzID0gMTtcbiAgICB0aGlzLnRleHR1cmUgPSB0YXJnZXQ7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlLl9yZWZzKSB7XG4gICAgICB0aGlzLnRleHR1cmUuX3JlZnMtLTtcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgc2VsZWN0VGV4dHVyZShnbCwgdGFyZ2V0KTtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgICB0YXJnZXQuX3JlZnMgPSAxO1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLmludGVybmFsRm9ybWF0LCBzaXplWzBdLCBzaXplWzFdLCAwLCB0aGlzLnRleHR1cmVGb3JtYXQsIHRoaXMudGV4dHVyZVR5cGUsIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsLCB0ZXh0dXJlIH0gPSB0aGlzO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcigpKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBzZWxlY3RUZXh0dXJlKGdsLCB0ZXh0dXJlKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuICB9XG5cbiAgZGVsZXRlKCkge1xuICAgIGlmICh0aGlzLl9kZWxldGVkKSByZXR1cm47XG4gICAgdGhpcy5fZGVsZXRlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMudGV4dHVyZS5fcmVmcykge1xuICAgICAgdGhpcy50ZXh0dXJlLl9yZWZzLS07XG4gICAgICBpZiAodGhpcy50ZXh0dXJlLl9yZWZzKSByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29udGV4dC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZSk7XG4gICAgaWYgKHRoaXMudGV4dHVyZS5fcmVmcyA9PT0gMCAmJiB0aGlzLl9mcmFtZWJ1ZmZlcikge1xuICAgICAgdGhpcy5jb250ZXh0LmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuX2ZyYW1lYnVmZmVyKTtcbiAgICAgIHRoaXMuX2ZyYW1lYnVmZmVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmcmFtZWJ1ZmZlcigpIHtcbiAgICBpZiAoIXRoaXMuX2ZyYW1lYnVmZmVyKSB7XG4gICAgICB0aGlzLl9mcmFtZWJ1ZmZlciA9IHRoaXMuY29udGV4dC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIH1cbiAgICB0aGlzLl9mcmFtZWJ1ZmZlci53aWR0aCA9IHRoaXMuc2l6ZVswXTtcbiAgICB0aGlzLl9mcmFtZWJ1ZmZlci5oZWlnaHQgPSB0aGlzLnNpemVbMV07XG4gICAgcmV0dXJuIHRoaXMuX2ZyYW1lYnVmZmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlbGVjdFRleHR1cmUoZ2wsIHRleHR1cmUpIHtcbiAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMTUpO1xuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IEdMVGV4dHVyZSB9O1xufSx7XCIuLi8uLi8uLi90ZXh0dXJlXCI6MTEzfV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkMkQgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZDJERmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkMkRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkM0QgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZDNERmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdLCB0aGlzLm91dHB1dFsyXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDNEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0TWVtb3J5T3B0aW1pemVkRmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlVW5zaWduZWQgfSA9IHJlcXVpcmUoJy4vdW5zaWduZWQnKTtcblxuY2xhc3MgR0xUZXh0dXJlVW5zaWduZWQyRCBleHRlbmRzIEdMVGV4dHVyZVVuc2lnbmVkIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ051bWJlclRleHR1cmUnO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0MkRQYWNrZWRGbG9hdCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVVbnNpZ25lZDJEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vdW5zaWduZWRcIjozM31dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZVVuc2lnbmVkIH0gPSByZXF1aXJlKCcuL3Vuc2lnbmVkJyk7XG5cbmNsYXNzIEdMVGV4dHVyZVVuc2lnbmVkM0QgZXh0ZW5kcyBHTFRleHR1cmVVbnNpZ25lZCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdOdW1iZXJUZXh0dXJlJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDNEUGFja2VkRmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdLCB0aGlzLm91dHB1dFsyXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZVVuc2lnbmVkM0Rcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi91bnNpZ25lZFwiOjMzfV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZVVuc2lnbmVkIGV4dGVuZHMgR0xUZXh0dXJlIHtcbiAgZ2V0IHRleHR1cmVUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuVU5TSUdORURfQllURTtcbiAgfVxuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnTnVtYmVyVGV4dHVyZSc7XG4gIH1cbiAgcmVuZGVyUmF3T3V0cHV0KCkge1xuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgY29uc3QgZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCxcbiAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICB0aGlzLnRleHR1cmUsXG4gICAgICAwXG4gICAgKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0aGlzLnNpemVbMF0gKiB0aGlzLnNpemVbMV0gKiA0KTtcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmVuZGVyVmFsdWVzKCkge1xuICAgIGlmICh0aGlzLl9kZWxldGVkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnJlbmRlclJhd091dHB1dCgpLmJ1ZmZlcik7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RQYWNrZWRGbG9hdCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZVVuc2lnbmVkXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaW5kZXhcIjoyN31dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IGdldENvbnRleHQgPSByZXF1aXJlKCdnbCcpO1xuY29uc3QgeyBXZWJHTEtlcm5lbCB9ID0gcmVxdWlyZSgnLi4vd2ViLWdsL2tlcm5lbCcpO1xuY29uc3QgeyBnbEtlcm5lbFN0cmluZyB9ID0gcmVxdWlyZSgnLi4vZ2wva2VybmVsLXN0cmluZycpO1xuXG5sZXQgaXNTdXBwb3J0ZWQgPSBudWxsO1xubGV0IHRlc3RDYW52YXMgPSBudWxsO1xubGV0IHRlc3RDb250ZXh0ID0gbnVsbDtcbmxldCB0ZXN0RXh0ZW5zaW9ucyA9IG51bGw7XG5sZXQgZmVhdHVyZXMgPSBudWxsO1xuXG5jbGFzcyBIZWFkbGVzc0dMS2VybmVsIGV4dGVuZHMgV2ViR0xLZXJuZWwge1xuICBzdGF0aWMgZ2V0IGlzU3VwcG9ydGVkKCkge1xuICAgIGlmIChpc1N1cHBvcnRlZCAhPT0gbnVsbCkgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgIHRoaXMuc2V0dXBGZWF0dXJlQ2hlY2tzKCk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0ZXN0Q29udGV4dCAhPT0gbnVsbDtcbiAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgc2V0dXBGZWF0dXJlQ2hlY2tzKCkge1xuICAgIHRlc3RDYW52YXMgPSBudWxsO1xuICAgIHRlc3RFeHRlbnNpb25zID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIGdldENvbnRleHQgIT09ICdmdW5jdGlvbicpIHJldHVybjtcbiAgICB0cnkgeyBcbiAgICAgIHRlc3RDb250ZXh0ID0gZ2V0Q29udGV4dCgyLCAyLCB7XG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoIXRlc3RDb250ZXh0IHx8ICF0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24pIHJldHVybjtcbiAgICAgIHRlc3RFeHRlbnNpb25zID0ge1xuICAgICAgICBTVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ1NUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXInKSxcbiAgICAgICAgU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQnKSxcbiAgICAgICAgT0VTX3RleHR1cmVfZmxvYXQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSxcbiAgICAgICAgT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpLFxuICAgICAgICBPRVNfZWxlbWVudF9pbmRleF91aW50OiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSxcbiAgICAgICAgV0VCR0xfZHJhd19idWZmZXJzOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpLFxuICAgICAgICBXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JyksXG4gICAgICB9O1xuICAgICAgZmVhdHVyZXMgPSB0aGlzLmdldEZlYXR1cmVzKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBpc0NvbnRleHRNYXRjaChjb250ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb250ZXh0LmdldFBhcmFtZXRlcihjb250ZXh0LlJFTkRFUkVSKSA9PT0gJ0FOR0xFJztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldElzVGV4dHVyZUZsb2F0KCkge1xuICAgIHJldHVybiBCb29sZWFuKHRlc3RFeHRlbnNpb25zLk9FU190ZXh0dXJlX2Zsb2F0KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc0RyYXdCdWZmZXJzKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRlc3RFeHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0Q2hhbm5lbENvdW50KCkge1xuICAgIHJldHVybiB0ZXN0RXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMgP1xuICAgICAgdGVzdENvbnRleHQuZ2V0UGFyYW1ldGVyKHRlc3RFeHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycy5NQVhfRFJBV19CVUZGRVJTX1dFQkdMKSA6XG4gICAgICAxO1xuICB9XG5cbiAgc3RhdGljIGdldE1heFRleHR1cmVTaXplKCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dC5nZXRQYXJhbWV0ZXIodGVzdENvbnRleHQuTUFYX1RFWFRVUkVfU0laRSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlc3RDYW52YXMoKSB7XG4gICAgcmV0dXJuIHRlc3RDYW52YXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlc3RDb250ZXh0KCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgaW5pdENhbnZhcygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBpbml0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgyLCAyLCB7XG4gICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGluaXRFeHRlbnNpb25zKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHtcbiAgICAgIFNUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXI6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ1NUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXInKSxcbiAgICAgIFNUQUNLR0xfZGVzdHJveV9jb250ZXh0OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdTVEFDS0dMX2Rlc3Ryb3lfY29udGV4dCcpLFxuICAgICAgT0VTX3RleHR1cmVfZmxvYXQ6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JyksXG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXI6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpLFxuICAgICAgT0VTX2VsZW1lbnRfaW5kZXhfdWludDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpLFxuICAgICAgV0VCR0xfZHJhd19idWZmZXJzOiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKSxcbiAgICB9O1xuICB9XG5cbiAgYnVpbGQoKSB7XG4gICAgc3VwZXIuYnVpbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoIXRoaXMuZmFsbGJhY2tSZXF1ZXN0ZWQpIHtcbiAgICAgIHRoaXMuZXh0ZW5zaW9ucy5TVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyLnJlc2l6ZSh0aGlzLm1heFRleFNpemVbMF0sIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveUV4dGVuc2lvbnMoKSB7XG4gICAgdGhpcy5leHRlbnNpb25zLlNUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXIgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5TVEFDS0dMX2Rlc3Ryb3lfY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLk9FU190ZXh0dXJlX2Zsb2F0ID0gbnVsbDtcbiAgICB0aGlzLmV4dGVuc2lvbnMuT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyID0gbnVsbDtcbiAgICB0aGlzLmV4dGVuc2lvbnMuT0VTX2VsZW1lbnRfaW5kZXhfdWludCA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycyA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZGVzdHJveUNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdTVEFDS0dMX2Rlc3Ryb3lfY29udGV4dCcpO1xuICAgIGlmIChleHRlbnNpb24gJiYgZXh0ZW5zaW9uLmRlc3Ryb3kpIHtcbiAgICAgIGV4dGVuc2lvbi5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3Qgc2V0dXBDb250ZXh0U3RyaW5nID0gYGNvbnN0IGdsID0gY29udGV4dCB8fCByZXF1aXJlKCdnbCcpKDEsIDEpO1xcbmA7XG4gICAgY29uc3QgZGVzdHJveUNvbnRleHRTdHJpbmcgPSBgICAgIGlmICghY29udGV4dCkgeyBnbC5nZXRFeHRlbnNpb24oJ1NUQUNLR0xfZGVzdHJveV9jb250ZXh0JykuZGVzdHJveSgpOyB9XFxuYDtcbiAgICByZXR1cm4gZ2xLZXJuZWxTdHJpbmcodGhpcy5jb25zdHJ1Y3RvciwgYXJndW1lbnRzLCB0aGlzLCBzZXR1cENvbnRleHRTdHJpbmcsIGRlc3Ryb3lDb250ZXh0U3RyaW5nKTtcbiAgfVxuXG4gIHNldE91dHB1dChvdXRwdXQpIHtcbiAgICBzdXBlci5zZXRPdXRwdXQob3V0cHV0KTtcbiAgICBpZiAodGhpcy5ncmFwaGljYWwgJiYgdGhpcy5leHRlbnNpb25zLlNUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXIpIHtcbiAgICAgIHRoaXMuZXh0ZW5zaW9ucy5TVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyLnJlc2l6ZSh0aGlzLm1heFRleFNpemVbMF0sIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBIZWFkbGVzc0dMS2VybmVsXG59O1xufSx7XCIuLi9nbC9rZXJuZWwtc3RyaW5nXCI6MTIsXCIuLi93ZWItZ2wva2VybmVsXCI6NzAsXCJnbFwiOjJ9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jbGFzcyBLZXJuZWxWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBrZXJuZWwsXG4gICAgICBjb250ZXh0LFxuICAgICAgY2hlY2tDb250ZXh0LFxuICAgICAgb25SZXF1ZXN0Q29udGV4dEhhbmRsZSxcbiAgICAgIG9uVXBkYXRlVmFsdWVNaXNtYXRjaCxcbiAgICAgIG9yaWdpbixcbiAgICAgIHN0cmljdEludGVnZXJzLFxuICAgICAgdHlwZSxcbiAgICAgIHRhY3RpYyxcbiAgICB9ID0gc2V0dGluZ3M7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWUgbm90IHNldCcpO1xuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBub3Qgc2V0Jyk7XG4gICAgfVxuICAgIGlmICghb3JpZ2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29yaWdpbiBub3Qgc2V0Jyk7XG4gICAgfVxuICAgIGlmIChvcmlnaW4gIT09ICd1c2VyJyAmJiBvcmlnaW4gIT09ICdjb25zdGFudHMnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG9yaWdpbiBtdXN0IGJlIFwidXNlclwiIG9yIFwiY29uc3RhbnRzXCIgdmFsdWUgaXMgXCIkeyBvcmlnaW4gfVwiYCk7XG4gICAgfVxuICAgIGlmICghb25SZXF1ZXN0Q29udGV4dEhhbmRsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvblJlcXVlc3RDb250ZXh0SGFuZGxlIGlzIG5vdCBzZXQnKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICB0aGlzLnRhY3RpYyA9IHRhY3RpYztcbiAgICB0aGlzLnZhck5hbWUgPSBvcmlnaW4gPT09ICdjb25zdGFudHMnID8gYGNvbnN0YW50cy4ke25hbWV9YCA6IG5hbWU7XG4gICAgdGhpcy5rZXJuZWwgPSBrZXJuZWw7XG4gICAgdGhpcy5zdHJpY3RJbnRlZ2VycyA9IHN0cmljdEludGVnZXJzO1xuICAgIHRoaXMudHlwZSA9IHZhbHVlLnR5cGUgfHwgdHlwZTtcbiAgICB0aGlzLnNpemUgPSB2YWx1ZS5zaXplIHx8IG51bGw7XG4gICAgdGhpcy5pbmRleCA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmNoZWNrQ29udGV4dCA9IGNoZWNrQ29udGV4dCAhPT0gbnVsbCAmJiBjaGVja0NvbnRleHQgIT09IHVuZGVmaW5lZCA/IGNoZWNrQ29udGV4dCA6IHRydWU7XG4gICAgdGhpcy5jb250ZXh0SGFuZGxlID0gbnVsbDtcbiAgICB0aGlzLm9uUmVxdWVzdENvbnRleHRIYW5kbGUgPSBvblJlcXVlc3RDb250ZXh0SGFuZGxlO1xuICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoID0gb25VcGRhdGVWYWx1ZU1pc21hdGNoO1xuICAgIHRoaXMuZm9yY2VVcGxvYWRFYWNoUnVuID0gbnVsbDtcbiAgfVxuXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcmlnaW59XyR7bmFtZX1gO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJnZXRTb3VyY2VcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwidXBkYXRlVmFsdWVcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBLZXJuZWxWYWx1ZVxufTtcbn0se31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCB7IElucHV0IH0gPSByZXF1aXJlKCcuLi9pbnB1dCcpO1xuXG5jbGFzcyBLZXJuZWwge1xuICBzdGF0aWMgZ2V0IGlzU3VwcG9ydGVkKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJpc1N1cHBvcnRlZFwiIG5vdCBpbXBsZW1lbnRlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgc3RhdGljIGlzQ29udGV4dE1hdGNoKGNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiaXNDb250ZXh0TWF0Y2hcIiBub3QgaW1wbGVtZW50ZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRGZWF0dXJlcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZ2V0RmVhdHVyZXNcIiBub3QgaW1wbGVtZW50ZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBkZXN0cm95Q29udGV4dChjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImRlc3Ryb3lDb250ZXh0XCIgY2FsbGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgbmF0aXZlRnVuY3Rpb25Bcmd1bWVudHMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIm5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzXCIgY2FsbGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgbmF0aXZlRnVuY3Rpb25SZXR1cm5UeXBlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJuYXRpdmVGdW5jdGlvblJldHVyblR5cGVcIiBjYWxsZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBjb21iaW5lS2VybmVscygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiY29tYmluZUtlcm5lbHNcIiBjYWxsZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgc2V0dGluZ3MpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBub3QgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbHMuaXNGdW5jdGlvblN0cmluZyhzb3VyY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIG5vdCBhIGZ1bmN0aW9uIHN0cmluZycpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVzZUxlZ2FjeUVuY29kZXIgPSBmYWxzZTtcbiAgICB0aGlzLmZhbGxiYWNrUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy5vblJlcXVlc3RGYWxsYmFjayA9IG51bGw7XG5cbiAgICB0aGlzLmFyZ3VtZW50TmFtZXMgPSB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IHV0aWxzLmdldEFyZ3VtZW50TmFtZXNGcm9tU3RyaW5nKHNvdXJjZSkgOiBudWxsO1xuICAgIHRoaXMuYXJndW1lbnRUeXBlcyA9IG51bGw7XG4gICAgdGhpcy5hcmd1bWVudFNpemVzID0gbnVsbDtcbiAgICB0aGlzLmFyZ3VtZW50Qml0UmF0aW9zID0gbnVsbDtcbiAgICB0aGlzLmtlcm5lbEFyZ3VtZW50cyA9IG51bGw7XG4gICAgdGhpcy5rZXJuZWxDb25zdGFudHMgPSBudWxsO1xuICAgIHRoaXMuZm9yY2VVcGxvYWRLZXJuZWxDb25zdGFudHMgPSBudWxsO1xuXG5cbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxuICAgIHRoaXMub3V0cHV0ID0gbnVsbDtcblxuICAgIHRoaXMuZGVidWcgPSBmYWxzZTtcblxuICAgIHRoaXMuZ3JhcGhpY2FsID0gZmFsc2U7XG5cbiAgICB0aGlzLmxvb3BNYXhJdGVyYXRpb25zID0gMDtcblxuICAgIHRoaXMuY29uc3RhbnRzID0gbnVsbDtcblxuICAgIHRoaXMuY29uc3RhbnRUeXBlcyA9IG51bGw7XG5cbiAgICB0aGlzLmNvbnN0YW50Qml0UmF0aW9zID0gbnVsbDtcblxuICAgIHRoaXMuZHluYW1pY0FyZ3VtZW50cyA9IGZhbHNlO1xuXG4gICAgdGhpcy5keW5hbWljT3V0cHV0ID0gZmFsc2U7XG5cbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuXG4gICAgdGhpcy5jaGVja0NvbnRleHQgPSBudWxsO1xuXG4gICAgdGhpcy5ncHUgPSBudWxsO1xuXG4gICAgdGhpcy5mdW5jdGlvbnMgPSBudWxsO1xuXG4gICAgdGhpcy5uYXRpdmVGdW5jdGlvbnMgPSBudWxsO1xuXG4gICAgdGhpcy5pbmplY3RlZE5hdGl2ZSA9IG51bGw7XG5cbiAgICB0aGlzLnN1Yktlcm5lbHMgPSBudWxsO1xuXG4gICAgdGhpcy52YWxpZGF0ZSA9IHRydWU7XG5cbiAgICB0aGlzLmltbXV0YWJsZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5waXBlbGluZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5wcmVjaXNpb24gPSBudWxsO1xuXG4gICAgdGhpcy50YWN0aWMgPSBudWxsO1xuXG4gICAgdGhpcy5wbHVnaW5zID0gbnVsbDtcblxuICAgIHRoaXMucmV0dXJuVHlwZSA9IG51bGw7XG4gICAgdGhpcy5sZWFkaW5nUmV0dXJuU3RhdGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmZvbGxvd2luZ1JldHVyblN0YXRlbWVudCA9IG51bGw7XG4gICAgdGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5ID0gbnVsbDtcbiAgICB0aGlzLnN0cmljdEludGVnZXJzID0gZmFsc2U7XG4gICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IG51bGw7XG4gICAgdGhpcy5vbklzdGFuYnVsQ292ZXJhZ2VWYXJpYWJsZSA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVJc3RhbmJ1bENvdmVyYWdlID0gZmFsc2U7XG4gICAgdGhpcy5idWlsdCA9IGZhbHNlO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gbnVsbDtcbiAgfVxuXG4gIG1lcmdlU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICBmb3IgKGxldCBwIGluIHNldHRpbmdzKSB7XG4gICAgICBpZiAoIXNldHRpbmdzLmhhc093blByb3BlcnR5KHApIHx8ICF0aGlzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgIHN3aXRjaCAocCkge1xuICAgICAgICBjYXNlICdvdXRwdXQnOlxuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzZXR0aW5ncy5vdXRwdXQpKSB7XG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dChzZXR0aW5ncy5vdXRwdXQpOyBcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnVuY3Rpb25zJzpcbiAgICAgICAgICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0dGluZ3MuZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZ1bmN0aW9uKHNldHRpbmdzLmZ1bmN0aW9uc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlICdncmFwaGljYWwnOlxuICAgICAgICAgIGlmIChzZXR0aW5nc1twXSAmJiAhc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ3ByZWNpc2lvbicpKSB7XG4gICAgICAgICAgICB0aGlzLnByZWNpc2lvbiA9ICd1bnNpZ25lZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXNbcF0gPSBzZXR0aW5nc1twXTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSAncmVtb3ZlSXN0YW5idWxDb3ZlcmFnZSc6XG4gICAgICAgICAgaWYgKHNldHRpbmdzW3BdICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzW3BdID0gc2V0dGluZ3NbcF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlICduYXRpdmVGdW5jdGlvbnMnOlxuICAgICAgICAgIGlmICghc2V0dGluZ3MubmF0aXZlRnVuY3Rpb25zKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLm5hdGl2ZUZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0dGluZ3MubmF0aXZlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzID0gc2V0dGluZ3MubmF0aXZlRnVuY3Rpb25zW2ldO1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBzb3VyY2UgfSA9IHM7XG4gICAgICAgICAgICB0aGlzLmFkZE5hdGl2ZUZ1bmN0aW9uKG5hbWUsIHNvdXJjZSwgcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpc1twXSA9IHNldHRpbmdzW3BdO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jYW52YXMpIHRoaXMuY2FudmFzID0gdGhpcy5pbml0Q2FudmFzKCk7XG4gICAgaWYgKCF0aGlzLmNvbnRleHQpIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdENvbnRleHQoKTtcbiAgICBpZiAoIXRoaXMucGx1Z2lucykgdGhpcy5wbHVnaW5zID0gdGhpcy5pbml0UGx1Z2lucyhzZXR0aW5ncyk7XG4gIH1cbiAgYnVpbGQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImJ1aWxkXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIHJ1bigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwicnVuXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKVxuICB9XG5cbiAgaW5pdENhbnZhcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiaW5pdENhbnZhc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBpbml0Q29udGV4dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiaW5pdENvbnRleHRcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgaW5pdFBsdWdpbnMoc2V0dGluZ3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiaW5pdFBsdWdpbnNcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgYWRkRnVuY3Rpb24oc291cmNlLCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgaWYgKHNvdXJjZS5uYW1lICYmIHNvdXJjZS5zb3VyY2UgJiYgc291cmNlLmFyZ3VtZW50VHlwZXMgJiYgJ3JldHVyblR5cGUnIGluIHNvdXJjZSkge1xuICAgICAgdGhpcy5mdW5jdGlvbnMucHVzaChzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAoJ3NldHRpbmdzJyBpbiBzb3VyY2UgJiYgJ3NvdXJjZScgaW4gc291cmNlKSB7XG4gICAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKHRoaXMuZnVuY3Rpb25Ub0lHUFVGdW5jdGlvbihzb3VyY2Uuc291cmNlLCBzb3VyY2Uuc2V0dGluZ3MpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuZnVuY3Rpb25zLnB1c2godGhpcy5mdW5jdGlvblRvSUdQVUZ1bmN0aW9uKHNvdXJjZSwgc2V0dGluZ3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBmdW5jdGlvbiBub3QgcHJvcGVybHkgZGVmaW5lZGApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZE5hdGl2ZUZ1bmN0aW9uKG5hbWUsIHNvdXJjZSwgc2V0dGluZ3MgPSB7fSkge1xuICAgIGNvbnN0IHsgYXJndW1lbnRUeXBlcywgYXJndW1lbnROYW1lcyB9ID0gc2V0dGluZ3MuYXJndW1lbnRUeXBlcyA/XG4gICAgICBzcGxpdEFyZ3VtZW50VHlwZXMoc2V0dGluZ3MuYXJndW1lbnRUeXBlcykgOlxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5uYXRpdmVGdW5jdGlvbkFyZ3VtZW50cyhzb3VyY2UpIHx8IHt9O1xuICAgIHRoaXMubmF0aXZlRnVuY3Rpb25zLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNldHRpbmdzLFxuICAgICAgYXJndW1lbnRUeXBlcyxcbiAgICAgIGFyZ3VtZW50TmFtZXMsXG4gICAgICByZXR1cm5UeXBlOiBzZXR0aW5ncy5yZXR1cm5UeXBlIHx8IHRoaXMuY29uc3RydWN0b3IubmF0aXZlRnVuY3Rpb25SZXR1cm5UeXBlKHNvdXJjZSlcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldHVwQXJndW1lbnRzKGFyZ3MpIHtcbiAgICB0aGlzLmtlcm5lbEFyZ3VtZW50cyA9IFtdO1xuICAgIGlmICghdGhpcy5hcmd1bWVudFR5cGVzKSB7XG4gICAgICBpZiAoIXRoaXMuYXJndW1lbnRUeXBlcykge1xuICAgICAgICB0aGlzLmFyZ3VtZW50VHlwZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgYXJnVHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZShhcmdzW2ldLCB0aGlzLnN0cmljdEludGVnZXJzKTtcbiAgICAgICAgICBjb25zdCB0eXBlID0gYXJnVHlwZSA9PT0gJ0ludGVnZXInID8gJ051bWJlcicgOiBhcmdUeXBlO1xuICAgICAgICAgIHRoaXMuYXJndW1lbnRUeXBlcy5wdXNoKHR5cGUpO1xuICAgICAgICAgIHRoaXMua2VybmVsQXJndW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hcmd1bWVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMua2VybmVsQXJndW1lbnRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IHRoaXMuYXJndW1lbnRUeXBlc1tpXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFyZ3VtZW50U2l6ZXMgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpO1xuICAgIHRoaXMuYXJndW1lbnRCaXRSYXRpb3MgPSBuZXcgSW50MzJBcnJheShhcmdzLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgICB0aGlzLmFyZ3VtZW50U2l6ZXNbaV0gPSBhcmcuY29uc3RydWN0b3IgPT09IElucHV0ID8gYXJnLnNpemUgOiBudWxsO1xuICAgICAgdGhpcy5hcmd1bWVudEJpdFJhdGlvc1tpXSA9IHRoaXMuZ2V0Qml0UmF0aW8oYXJnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYXJndW1lbnRzIGFyZSBtaXNzLWFsaWduZWRgKTtcbiAgICB9XG4gIH1cblxuICBzZXR1cENvbnN0YW50cygpIHtcbiAgICB0aGlzLmtlcm5lbENvbnN0YW50cyA9IFtdO1xuICAgIGxldCBuZWVkc0NvbnN0YW50VHlwZXMgPSB0aGlzLmNvbnN0YW50VHlwZXMgPT09IG51bGw7XG4gICAgaWYgKG5lZWRzQ29uc3RhbnRUeXBlcykge1xuICAgICAgdGhpcy5jb25zdGFudFR5cGVzID0ge307XG4gICAgfVxuICAgIHRoaXMuY29uc3RhbnRCaXRSYXRpb3MgPSB7fTtcbiAgICBpZiAodGhpcy5jb25zdGFudHMpIHtcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5jb25zdGFudHMpIHtcbiAgICAgICAgaWYgKG5lZWRzQ29uc3RhbnRUeXBlcykge1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSB1dGlscy5nZXRWYXJpYWJsZVR5cGUodGhpcy5jb25zdGFudHNbbmFtZV0sIHRoaXMuc3RyaWN0SW50ZWdlcnMpO1xuICAgICAgICAgIHRoaXMuY29uc3RhbnRUeXBlc1tuYW1lXSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5rZXJuZWxDb25zdGFudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMua2VybmVsQ29uc3RhbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuY29uc3RhbnRUeXBlc1tuYW1lXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uc3RhbnRCaXRSYXRpb3NbbmFtZV0gPSB0aGlzLmdldEJpdFJhdGlvKHRoaXMuY29uc3RhbnRzW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRPcHRpbWl6ZUZsb2F0TWVtb3J5KGZsYWcpIHtcbiAgICB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdG9LZXJuZWxPdXRwdXQob3V0cHV0KSB7XG4gICAgaWYgKG91dHB1dC5oYXNPd25Qcm9wZXJ0eSgneCcpKSB7XG4gICAgICBpZiAob3V0cHV0Lmhhc093blByb3BlcnR5KCd5JykpIHtcbiAgICAgICAgaWYgKG91dHB1dC5oYXNPd25Qcm9wZXJ0eSgneicpKSB7XG4gICAgICAgICAgcmV0dXJuIFtvdXRwdXQueCwgb3V0cHV0LnksIG91dHB1dC56XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW291dHB1dC54LCBvdXRwdXQueV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbb3V0cHV0LnhdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgfVxuXG4gIHNldE91dHB1dChvdXRwdXQpIHtcbiAgICB0aGlzLm91dHB1dCA9IHRoaXMudG9LZXJuZWxPdXRwdXQob3V0cHV0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldERlYnVnKGZsYWcpIHtcbiAgICB0aGlzLmRlYnVnID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEdyYXBoaWNhbChmbGFnKSB7XG4gICAgdGhpcy5ncmFwaGljYWwgPSBmbGFnO1xuICAgIHRoaXMucHJlY2lzaW9uID0gJ3Vuc2lnbmVkJztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldExvb3BNYXhJdGVyYXRpb25zKG1heCkge1xuICAgIHRoaXMubG9vcE1heEl0ZXJhdGlvbnMgPSBtYXg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRDb25zdGFudHMoY29uc3RhbnRzKSB7XG4gICAgdGhpcy5jb25zdGFudHMgPSBjb25zdGFudHM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRDb25zdGFudFR5cGVzKGNvbnN0YW50VHlwZXMpIHtcbiAgICB0aGlzLmNvbnN0YW50VHlwZXMgPSBjb25zdGFudFR5cGVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0RnVuY3Rpb25zKGZ1bmN0aW9ucykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFkZEZ1bmN0aW9uKGZ1bmN0aW9uc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0TmF0aXZlRnVuY3Rpb25zKG5hdGl2ZUZ1bmN0aW9ucykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmF0aXZlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzZXR0aW5ncyA9IG5hdGl2ZUZ1bmN0aW9uc1tpXTtcbiAgICAgIGNvbnN0IHsgbmFtZSwgc291cmNlIH0gPSBzZXR0aW5ncztcbiAgICAgIHRoaXMuYWRkTmF0aXZlRnVuY3Rpb24obmFtZSwgc291cmNlLCBzZXR0aW5ncyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0SW5qZWN0ZWROYXRpdmUoaW5qZWN0ZWROYXRpdmUpIHtcbiAgICB0aGlzLmluamVjdGVkTmF0aXZlID0gaW5qZWN0ZWROYXRpdmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRQaXBlbGluZShmbGFnKSB7XG4gICAgdGhpcy5waXBlbGluZSA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRQcmVjaXNpb24oZmxhZykge1xuICAgIHRoaXMucHJlY2lzaW9uID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldERpbWVuc2lvbnMoZmxhZykge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdtZXRob2QnLCAnc2V0RGltZW5zaW9ucycsICdzZXRPdXRwdXQnKTtcbiAgICB0aGlzLm91dHB1dCA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRPdXRwdXRUb1RleHR1cmUoZmxhZykge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdtZXRob2QnLCAnc2V0T3V0cHV0VG9UZXh0dXJlJywgJ3NldFBpcGVsaW5lJyk7XG4gICAgdGhpcy5waXBlbGluZSA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRJbW11dGFibGUoZmxhZykge1xuICAgIHRoaXMuaW1tdXRhYmxlID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldENhbnZhcyhjYW52YXMpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFN0cmljdEludGVnZXJzKGZsYWcpIHtcbiAgICB0aGlzLnN0cmljdEludGVnZXJzID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldER5bmFtaWNPdXRwdXQoZmxhZykge1xuICAgIHRoaXMuZHluYW1pY091dHB1dCA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRIYXJkY29kZUNvbnN0YW50cyhmbGFnKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ21ldGhvZCcsICdzZXRIYXJkY29kZUNvbnN0YW50cycpO1xuICAgIHRoaXMuc2V0RHluYW1pY091dHB1dChmbGFnKTtcbiAgICB0aGlzLnNldER5bmFtaWNBcmd1bWVudHMoZmxhZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXREeW5hbWljQXJndW1lbnRzKGZsYWcpIHtcbiAgICB0aGlzLmR5bmFtaWNBcmd1bWVudHMgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0VXNlTGVnYWN5RW5jb2RlcihmbGFnKSB7XG4gICAgdGhpcy51c2VMZWdhY3lFbmNvZGVyID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFdhcm5WYXJVc2FnZShmbGFnKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ21ldGhvZCcsICdzZXRXYXJuVmFyVXNhZ2UnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldENhbnZhcygpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnbWV0aG9kJywgJ2dldENhbnZhcycpO1xuICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgfVxuXG4gIGdldFdlYkdsKCkge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdtZXRob2QnLCAnZ2V0V2ViR2wnKTtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0O1xuICB9XG5cbiAgc2V0Q29udGV4dChjb250ZXh0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEFyZ3VtZW50VHlwZXMoYXJndW1lbnRUeXBlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50VHlwZXMpKSB7XG4gICAgICB0aGlzLmFyZ3VtZW50VHlwZXMgPSBhcmd1bWVudFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFyZ3VtZW50VHlwZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgcCBpbiBhcmd1bWVudFR5cGVzKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRUeXBlcy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50SW5kZXggPSB0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihwKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50SW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byBmaW5kIGFyZ3VtZW50ICR7IHAgfWApO1xuICAgICAgICB0aGlzLmFyZ3VtZW50VHlwZXNbYXJndW1lbnRJbmRleF0gPSBhcmd1bWVudFR5cGVzW3BdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFRhY3RpYyh0YWN0aWMpIHtcbiAgICB0aGlzLnRhY3RpYyA9IHRhY3RpYztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlcXVlc3RGYWxsYmFjayhhcmdzKSB7XG4gICAgaWYgKCF0aGlzLm9uUmVxdWVzdEZhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFwib25SZXF1ZXN0RmFsbGJhY2tcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICAgIH1cbiAgICB0aGlzLmZhbGxiYWNrUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5vblJlcXVlc3RGYWxsYmFjayhhcmdzKTtcbiAgfVxuXG4gIHZhbGlkYXRlU2V0dGluZ3MoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcInZhbGlkYXRlU2V0dGluZ3NcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgYWRkU3ViS2VybmVsKHN1Yktlcm5lbCkge1xuICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3ViS2VybmVscyA9IFtdO1xuICAgIH1cbiAgICBpZiAoIXN1Yktlcm5lbC5zb3VyY2UpIHRocm93IG5ldyBFcnJvcignc3ViS2VybmVsIG1pc3NpbmcgXCJzb3VyY2VcIiBwcm9wZXJ0eScpO1xuICAgIGlmICghc3ViS2VybmVsLnByb3BlcnR5ICYmIGlzTmFOKHN1Yktlcm5lbC5wcm9wZXJ0eSkpIHRocm93IG5ldyBFcnJvcignc3ViS2VybmVsIG1pc3NpbmcgXCJwcm9wZXJ0eVwiIHByb3BlcnR5Jyk7XG4gICAgaWYgKCFzdWJLZXJuZWwubmFtZSkgdGhyb3cgbmV3IEVycm9yKCdzdWJLZXJuZWwgbWlzc2luZyBcIm5hbWVcIiBwcm9wZXJ0eScpO1xuICAgIHRoaXMuc3ViS2VybmVscy5wdXNoKHN1Yktlcm5lbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZXN0cm95KHJlbW92ZUNhbnZhc1JlZmVyZW5jZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZGVzdHJveVwiIGNhbGxlZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgZ2V0Qml0UmF0aW8odmFsdWUpIHtcbiAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICByZXR1cm4gNDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbMF0pKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCaXRSYXRpbyh2YWx1ZVswXSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gSW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJpdFJhdGlvKHZhbHVlLnZhbHVlKTtcbiAgICB9XG4gICAgc3dpdGNoICh2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBVaW50OENsYW1wZWRBcnJheTpcbiAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gIH1cblxuICBnZXRQaXhlbHMoZmxpcCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJnZXRQaXhlbHNcIiBjYWxsZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIGNoZWNrT3V0cHV0KCkge1xuICAgIGlmICghdGhpcy5vdXRwdXQgfHwgIXV0aWxzLmlzQXJyYXkodGhpcy5vdXRwdXQpKSB0aHJvdyBuZXcgRXJyb3IoJ2tlcm5lbC5vdXRwdXQgbm90IGFuIGFycmF5Jyk7XG4gICAgaWYgKHRoaXMub3V0cHV0Lmxlbmd0aCA8IDEpIHRocm93IG5ldyBFcnJvcigna2VybmVsLm91dHB1dCBpcyBlbXB0eSwgbmVlZHMgYXQgbGVhc3QgMSB2YWx1ZScpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRwdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpc05hTih0aGlzLm91dHB1dFtpXSkgfHwgdGhpcy5vdXRwdXRbaV0gPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH0ub3V0cHV0WyR7IGkgfV0gaW5jb3JyZWN0bHkgZGVmaW5lZCBhcyBcXGAkeyB0aGlzLm91dHB1dFtpXSB9XFxgLCBuZWVkcyB0byBiZSBudW1lcmljLCBhbmQgZ3JlYXRlciB0aGFuIDBgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcmVwZW5kU3RyaW5nKHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcInByZXBlbmRTdHJpbmdcIiBjYWxsZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIGhhc1ByZXBlbmRTdHJpbmcodmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiaGFzUHJlcGVuZFN0cmluZ1wiIGNhbGxlZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXR0aW5nczoge1xuICAgICAgICBvdXRwdXQ6IHRoaXMub3V0cHV0LFxuICAgICAgICBwaXBlbGluZTogdGhpcy5waXBlbGluZSxcbiAgICAgICAgYXJndW1lbnROYW1lczogdGhpcy5hcmd1bWVudE5hbWVzLFxuICAgICAgICBhcmd1bWVudHNUeXBlczogdGhpcy5hcmd1bWVudFR5cGVzLFxuICAgICAgICBjb25zdGFudHM6IHRoaXMuY29uc3RhbnRzLFxuICAgICAgICBwbHVnaW5OYW1lczogdGhpcy5wbHVnaW5zID8gdGhpcy5wbHVnaW5zLm1hcChwbHVnaW4gPT4gcGx1Z2luLm5hbWUpIDogbnVsbCxcbiAgICAgICAgcmV0dXJuVHlwZTogdGhpcy5yZXR1cm5UeXBlLFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBidWlsZFNpZ25hdHVyZShhcmdzKSB7XG4gICAgY29uc3QgQ29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gQ29uc3RydWN0b3IuZ2V0U2lnbmF0dXJlKHRoaXMsIENvbnN0cnVjdG9yLmdldEFyZ3VtZW50VHlwZXModGhpcywgYXJncykpO1xuICB9XG5cbiAgc3RhdGljIGdldEFyZ3VtZW50VHlwZXMoa2VybmVsLCBhcmdzKSB7XG4gICAgY29uc3QgYXJndW1lbnRUeXBlcyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgICAgY29uc3QgdHlwZSA9IGtlcm5lbC5hcmd1bWVudFR5cGVzW2ldO1xuICAgICAgaWYgKGFyZy50eXBlKSB7XG4gICAgICAgIGFyZ3VtZW50VHlwZXNbaV0gPSBhcmcudHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICAgICAgICBhcmd1bWVudFR5cGVzW2ldID0gdXRpbHMuZ2V0VmFyaWFibGVUeXBlKGFyZyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYXJndW1lbnRUeXBlc1tpXSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZ3VtZW50VHlwZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0U2lnbmF0dXJlKGtlcm5lbCwgYXJndW1lbnRUeXBlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJnZXRTaWduYXR1cmVcIiBub3QgaW1wbGVtZW50ZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIGZ1bmN0aW9uVG9JR1BVRnVuY3Rpb24oc291cmNlLCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBzb3VyY2UgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignc291cmNlIG5vdCBhIHN0cmluZyBvciBmdW5jdGlvbicpO1xuICAgIGNvbnN0IHNvdXJjZVN0cmluZyA9IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gc291cmNlIDogc291cmNlLnRvU3RyaW5nKCk7XG4gICAgbGV0IGFyZ3VtZW50VHlwZXMgPSBbXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHNldHRpbmdzLmFyZ3VtZW50VHlwZXMpKSB7XG4gICAgICBhcmd1bWVudFR5cGVzID0gc2V0dGluZ3MuYXJndW1lbnRUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXR0aW5ncy5hcmd1bWVudFR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgYXJndW1lbnRUeXBlcyA9IHV0aWxzLmdldEFyZ3VtZW50TmFtZXNGcm9tU3RyaW5nKHNvdXJjZVN0cmluZylcbiAgICAgICAgLm1hcChuYW1lID0+IHNldHRpbmdzLmFyZ3VtZW50VHlwZXNbbmFtZV0pIHx8IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmd1bWVudFR5cGVzID0gc2V0dGluZ3MuYXJndW1lbnRUeXBlcyB8fCBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdXRpbHMuZ2V0RnVuY3Rpb25OYW1lRnJvbVN0cmluZyhzb3VyY2VTdHJpbmcpIHx8IG51bGwsXG4gICAgICBzb3VyY2U6IHNvdXJjZVN0cmluZyxcbiAgICAgIGFyZ3VtZW50VHlwZXMsXG4gICAgICByZXR1cm5UeXBlOiBzZXR0aW5ncy5yZXR1cm5UeXBlIHx8IG51bGwsXG4gICAgfTtcbiAgfVxuXG4gIG9uQWN0aXZhdGUocHJldmlvdXNLZXJuZWwpIHt9XG59XG5cbmZ1bmN0aW9uIHNwbGl0QXJndW1lbnRUeXBlcyhhcmd1bWVudFR5cGVzT2JqZWN0KSB7XG4gIGNvbnN0IGFyZ3VtZW50TmFtZXMgPSBPYmplY3Qua2V5cyhhcmd1bWVudFR5cGVzT2JqZWN0KTtcbiAgY29uc3QgYXJndW1lbnRUeXBlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmd1bWVudE5hbWUgPSBhcmd1bWVudE5hbWVzW2ldO1xuICAgIGFyZ3VtZW50VHlwZXMucHVzaChhcmd1bWVudFR5cGVzT2JqZWN0W2FyZ3VtZW50TmFtZV0pO1xuICB9XG4gIHJldHVybiB7IGFyZ3VtZW50VHlwZXMsIGFyZ3VtZW50TmFtZXMgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtlcm5lbFxufTtcbn0se1wiLi4vaW5wdXRcIjoxMTAsXCIuLi91dGlsc1wiOjExNH1dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IGZyYWdtZW50U2hhZGVyID0gYF9fSEVBREVSX187XG5fX0ZMT0FUX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuX19JTlRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX1NBTVBMRVJfMkRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5cbmNvbnN0IGludCBMT09QX01BWCA9IF9fTE9PUF9NQVhfXztcblxuX19QTFVHSU5TX187XG5fX0NPTlNUQU5UU19fO1xuXG52YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuXG5mbG9hdCBhY29zaChmbG9hdCB4KSB7XG4gIHJldHVybiBsb2coeCArIHNxcnQoeCAqIHggLSAxLjApKTtcbn1cblxuZmxvYXQgc2luaChmbG9hdCB4KSB7XG4gIHJldHVybiAocG93KCR7TWF0aC5FfSwgeCkgLSBwb3coJHtNYXRoLkV9LCAteCkpIC8gMi4wO1xufVxuXG5mbG9hdCBhc2luaChmbG9hdCB4KSB7XG4gIHJldHVybiBsb2coeCArIHNxcnQoeCAqIHggKyAxLjApKTtcbn1cblxuZmxvYXQgYXRhbjIoZmxvYXQgdjEsIGZsb2F0IHYyKSB7XG4gIGlmICh2MSA9PSAwLjAgfHwgdjIgPT0gMC4wKSByZXR1cm4gMC4wO1xuICByZXR1cm4gYXRhbih2MSAvIHYyKTtcbn1cblxuZmxvYXQgYXRhbmgoZmxvYXQgeCkge1xuICB4ID0gKHggKyAxLjApIC8gKHggLSAxLjApO1xuICBpZiAoeCA8IDAuMCkge1xuICAgIHJldHVybiAwLjUgKiBsb2coLXgpO1xuICB9XG4gIHJldHVybiAwLjUgKiBsb2coeCk7XG59XG5cbmZsb2F0IGNicnQoZmxvYXQgeCkge1xuICBpZiAoeCA+PSAwLjApIHtcbiAgICByZXR1cm4gcG93KHgsIDEuMCAvIDMuMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC1wb3coeCwgMS4wIC8gMy4wKTtcbiAgfVxufVxuXG5mbG9hdCBjb3NoKGZsb2F0IHgpIHtcbiAgcmV0dXJuIChwb3coJHtNYXRoLkV9LCB4KSArIHBvdygke01hdGguRX0sIC14KSkgLyAyLjA7IFxufVxuXG5mbG9hdCBleHBtMShmbG9hdCB4KSB7XG4gIHJldHVybiBwb3coJHtNYXRoLkV9LCB4KSAtIDEuMDsgXG59XG5cbmZsb2F0IGZyb3VuZChoaWdocCBmbG9hdCB4KSB7XG4gIHJldHVybiB4O1xufVxuXG5mbG9hdCBpbXVsKGZsb2F0IHYxLCBmbG9hdCB2Mikge1xuICByZXR1cm4gZmxvYXQoaW50KHYxKSAqIGludCh2MikpO1xufVxuXG5mbG9hdCBsb2cxMChmbG9hdCB4KSB7XG4gIHJldHVybiBsb2cyKHgpICogKDEuMCAvIGxvZzIoMTAuMCkpO1xufVxuXG5mbG9hdCBsb2cxcChmbG9hdCB4KSB7XG4gIHJldHVybiBsb2coMS4wICsgeCk7XG59XG5cbmZsb2F0IF9wb3coZmxvYXQgdjEsIGZsb2F0IHYyKSB7XG4gIGlmICh2MiA9PSAwLjApIHJldHVybiAxLjA7XG4gIHJldHVybiBwb3codjEsIHYyKTtcbn1cblxuZmxvYXQgdGFuaChmbG9hdCB4KSB7XG4gIGZsb2F0IGUgPSBleHAoMi4wICogeCk7XG4gIHJldHVybiAoZSAtIDEuMCkgLyAoZSArIDEuMCk7XG59XG5cbmZsb2F0IHRydW5jKGZsb2F0IHgpIHtcbiAgaWYgKHggPj0gMC4wKSB7XG4gICAgcmV0dXJuIGZsb29yKHgpOyBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2VpbCh4KTtcbiAgfVxufVxuXG52ZWM0IF9yb3VuZCh2ZWM0IHgpIHtcbiAgcmV0dXJuIGZsb29yKHggKyAwLjUpO1xufVxuXG5mbG9hdCBfcm91bmQoZmxvYXQgeCkge1xuICByZXR1cm4gZmxvb3IoeCArIDAuNSk7XG59XG5cbmNvbnN0IGludCBCSVRfQ09VTlQgPSAzMjtcbmludCBtb2RpKGludCB4LCBpbnQgeSkge1xuICByZXR1cm4geCAtIHkgKiAoeCAvIHkpO1xufVxuXG5pbnQgYml0d2lzZU9yKGludCBhLCBpbnQgYikge1xuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IG4gPSAxO1xuICBcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmICgobW9kaShhLCAyKSA9PSAxKSB8fCAobW9kaShiLCAyKSA9PSAxKSkge1xuICAgICAgcmVzdWx0ICs9IG47XG4gICAgfVxuICAgIGEgPSBhIC8gMjtcbiAgICBiID0gYiAvIDI7XG4gICAgbiA9IG4gKiAyO1xuICAgIGlmKCEoYSA+IDAgfHwgYiA+IDApKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmludCBiaXR3aXNlWE9SKGludCBhLCBpbnQgYikge1xuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IG4gPSAxO1xuICBcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmICgobW9kaShhLCAyKSA9PSAxKSAhPSAobW9kaShiLCAyKSA9PSAxKSkge1xuICAgICAgcmVzdWx0ICs9IG47XG4gICAgfVxuICAgIGEgPSBhIC8gMjtcbiAgICBiID0gYiAvIDI7XG4gICAgbiA9IG4gKiAyO1xuICAgIGlmKCEoYSA+IDAgfHwgYiA+IDApKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmludCBiaXR3aXNlQW5kKGludCBhLCBpbnQgYikge1xuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IG4gPSAxO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKChtb2RpKGEsIDIpID09IDEpICYmIChtb2RpKGIsIDIpID09IDEpKSB7XG4gICAgICByZXN1bHQgKz0gbjtcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIGIgPSBiIC8gMjtcbiAgICBuID0gbiAqIDI7XG4gICAgaWYoIShhID4gMCAmJiBiID4gMCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VOb3QoaW50IGEpIHtcbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBuID0gMTtcbiAgXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAobW9kaShhLCAyKSA9PSAwKSB7XG4gICAgICByZXN1bHQgKz0gbjsgICAgXG4gICAgfVxuICAgIGEgPSBhIC8gMjtcbiAgICBuID0gbiAqIDI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmludCBiaXR3aXNlWmVyb0ZpbGxMZWZ0U2hpZnQoaW50IG4sIGludCBzaGlmdCkge1xuICBpbnQgbWF4Qnl0ZXMgPSBCSVRfQ09VTlQ7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAobWF4Qnl0ZXMgPj0gbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG1heEJ5dGVzICo9IDI7XG4gIH1cbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChpID49IHNoaWZ0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbiAqPSAyO1xuICB9XG5cbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBieXRlVmFsID0gMTtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChpID49IG1heEJ5dGVzKSBicmVhaztcbiAgICBpZiAobW9kaShuLCAyKSA+IDApIHsgcmVzdWx0ICs9IGJ5dGVWYWw7IH1cbiAgICBuID0gaW50KG4gLyAyKTtcbiAgICBieXRlVmFsICo9IDI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuaW50IGJpdHdpc2VTaWduZWRSaWdodFNoaWZ0KGludCBudW0sIGludCBzaGlmdHMpIHtcbiAgcmV0dXJuIGludChmbG9vcihmbG9hdChudW0pIC8gcG93KDIuMCwgZmxvYXQoc2hpZnRzKSkpKTtcbn1cblxuaW50IGJpdHdpc2VaZXJvRmlsbFJpZ2h0U2hpZnQoaW50IG4sIGludCBzaGlmdCkge1xuICBpbnQgbWF4Qnl0ZXMgPSBCSVRfQ09VTlQ7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAobWF4Qnl0ZXMgPj0gbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG1heEJ5dGVzICo9IDI7XG4gIH1cbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChpID49IHNoaWZ0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbiAvPSAyO1xuICB9XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgYnl0ZVZhbCA9IDE7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoaSA+PSBtYXhCeXRlcykgYnJlYWs7XG4gICAgaWYgKG1vZGkobiwgMikgPiAwKSB7IHJlc3VsdCArPSBieXRlVmFsOyB9XG4gICAgbiA9IGludChuIC8gMik7XG4gICAgYnl0ZVZhbCAqPSAyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZlYzIgaW50ZWdlck1vZCh2ZWMyIHgsIGZsb2F0IHkpIHtcbiAgdmVjMiByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xuICByZXR1cm4gcmVzICogc3RlcCgxLjAgLSBmbG9vcih5KSwgLXJlcyk7XG59XG5cbnZlYzMgaW50ZWdlck1vZCh2ZWMzIHgsIGZsb2F0IHkpIHtcbiAgdmVjMyByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xuICByZXR1cm4gcmVzICogc3RlcCgxLjAgLSBmbG9vcih5KSwgLXJlcyk7XG59XG5cbnZlYzQgaW50ZWdlck1vZCh2ZWM0IHgsIHZlYzQgeSkge1xuICB2ZWM0IHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XG4gIHJldHVybiByZXMgKiBzdGVwKDEuMCAtIGZsb29yKHkpLCAtcmVzKTtcbn1cblxuZmxvYXQgaW50ZWdlck1vZChmbG9hdCB4LCBmbG9hdCB5KSB7XG4gIGZsb2F0IHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XG4gIHJldHVybiByZXMgKiAocmVzID4gZmxvb3IoeSkgLSAxLjAgPyAwLjAgOiAxLjApO1xufVxuXG5pbnQgaW50ZWdlck1vZChpbnQgeCwgaW50IHkpIHtcbiAgcmV0dXJuIHggLSAoeSAqIGludCh4IC8geSkpO1xufVxuXG5fX0RJVklERV9XSVRIX0lOVEVHRVJfQ0hFQ0tfXztcblxuLy8gSGVyZSBiZSBkcmFnb25zIVxuLy8gRE8gTk9UIE9QVElNSVpFIFRISVMgQ09ERVxuLy8gWU9VIFdJTEwgQlJFQUsgU09NRVRISU5HIE9OIFNPTUVCT0RZXFwnUyBNQUNISU5FXG4vLyBMRUFWRSBJVCBBUyBJVCBJUywgTEVTVCBZT1UgV0FTVEUgWU9VUiBPV04gVElNRVxuY29uc3QgdmVjMiBNQUdJQ19WRUMgPSB2ZWMyKDEuMCwgLTI1Ni4wKTtcbmNvbnN0IHZlYzQgU0NBTEVfRkFDVE9SID0gdmVjNCgxLjAsIDI1Ni4wLCA2NTUzNi4wLCAwLjApO1xuY29uc3QgdmVjNCBTQ0FMRV9GQUNUT1JfSU5WID0gdmVjNCgxLjAsIDAuMDAzOTA2MjUsIDAuMDAwMDE1MjU4Nzg5MDYyNSwgMC4wKTsgLy8gMSwgMS8yNTYsIDEvNjU1MzZcbmZsb2F0IGRlY29kZTMyKHZlYzQgdGV4ZWwpIHtcbiAgX19ERUNPREUzMl9FTkRJQU5ORVNTX187XG4gIHRleGVsICo9IDI1NS4wO1xuICB2ZWMyIGd0ZTEyODtcbiAgZ3RlMTI4LnggPSB0ZXhlbC5iID49IDEyOC4wID8gMS4wIDogMC4wO1xuICBndGUxMjgueSA9IHRleGVsLmEgPj0gMTI4LjAgPyAxLjAgOiAwLjA7XG4gIGZsb2F0IGV4cG9uZW50ID0gMi4wICogdGV4ZWwuYSAtIDEyNy4wICsgZG90KGd0ZTEyOCwgTUFHSUNfVkVDKTtcbiAgZmxvYXQgcmVzID0gZXhwMihfcm91bmQoZXhwb25lbnQpKTtcbiAgdGV4ZWwuYiA9IHRleGVsLmIgLSAxMjguMCAqIGd0ZTEyOC54O1xuICByZXMgPSBkb3QodGV4ZWwsIFNDQUxFX0ZBQ1RPUikgKiBleHAyKF9yb3VuZChleHBvbmVudC0yMy4wKSkgKyByZXM7XG4gIHJlcyAqPSBndGUxMjgueSAqIC0yLjAgKyAxLjA7XG4gIHJldHVybiByZXM7XG59XG5cbmZsb2F0IGRlY29kZTE2KHZlYzQgdGV4ZWwsIGludCBpbmRleCkge1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDIpO1xuICBpZiAoY2hhbm5lbCA9PSAwKSByZXR1cm4gdGV4ZWwuciAqIDI1NS4wICsgdGV4ZWwuZyAqIDY1MjgwLjA7XG4gIGlmIChjaGFubmVsID09IDEpIHJldHVybiB0ZXhlbC5iICogMjU1LjAgKyB0ZXhlbC5hICogNjUyODAuMDtcbiAgcmV0dXJuIDAuMDtcbn1cblxuZmxvYXQgZGVjb2RlOCh2ZWM0IHRleGVsLCBpbnQgaW5kZXgpIHtcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKGluZGV4LCA0KTtcbiAgaWYgKGNoYW5uZWwgPT0gMCkgcmV0dXJuIHRleGVsLnIgKiAyNTUuMDtcbiAgaWYgKGNoYW5uZWwgPT0gMSkgcmV0dXJuIHRleGVsLmcgKiAyNTUuMDtcbiAgaWYgKGNoYW5uZWwgPT0gMikgcmV0dXJuIHRleGVsLmIgKiAyNTUuMDtcbiAgaWYgKGNoYW5uZWwgPT0gMykgcmV0dXJuIHRleGVsLmEgKiAyNTUuMDtcbiAgcmV0dXJuIDAuMDtcbn1cblxudmVjNCBsZWdhY3lFbmNvZGUzMihmbG9hdCBmKSB7XG4gIGZsb2F0IEYgPSBhYnMoZik7XG4gIGZsb2F0IHNpZ24gPSBmIDwgMC4wID8gMS4wIDogMC4wO1xuICBmbG9hdCBleHBvbmVudCA9IGZsb29yKGxvZzIoRikpO1xuICBmbG9hdCBtYW50aXNzYSA9IChleHAyKC1leHBvbmVudCkgKiBGKTtcbiAgLy8gZXhwb25lbnQgKz0gZmxvb3IobG9nMihtYW50aXNzYSkpO1xuICB2ZWM0IHRleGVsID0gdmVjNChGICogZXhwMigyMy4wLWV4cG9uZW50KSkgKiBTQ0FMRV9GQUNUT1JfSU5WO1xuICB0ZXhlbC5yZyA9IGludGVnZXJNb2QodGV4ZWwucmcsIDI1Ni4wKTtcbiAgdGV4ZWwuYiA9IGludGVnZXJNb2QodGV4ZWwuYiwgMTI4LjApO1xuICB0ZXhlbC5hID0gZXhwb25lbnQqMC41ICsgNjMuNTtcbiAgdGV4ZWwuYmEgKz0gdmVjMihpbnRlZ2VyTW9kKGV4cG9uZW50KzEyNy4wLCAyLjApLCBzaWduKSAqIDEyOC4wO1xuICB0ZXhlbCA9IGZsb29yKHRleGVsKTtcbiAgdGV4ZWwgKj0gMC4wMDM5MjE1Njk7IC8vIDEvMjU1XG4gIF9fRU5DT0RFMzJfRU5ESUFOTkVTU19fO1xuICByZXR1cm4gdGV4ZWw7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ncHVqcy9ncHUuanMvd2lraS9FbmNvZGVyLWRldGFpbHNcbnZlYzQgZW5jb2RlMzIoZmxvYXQgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IDAuMCkgcmV0dXJuIHZlYzQoMCwgMCwgMCwgMCk7XG5cbiAgZmxvYXQgZXhwb25lbnQ7XG4gIGZsb2F0IG1hbnRpc3NhO1xuICB2ZWM0ICByZXN1bHQ7XG4gIGZsb2F0IHNnbjtcblxuICBzZ24gPSBzdGVwKDAuMCwgLXZhbHVlKTtcbiAgdmFsdWUgPSBhYnModmFsdWUpO1xuXG4gIGV4cG9uZW50ID0gZmxvb3IobG9nMih2YWx1ZSkpO1xuXG4gIG1hbnRpc3NhID0gdmFsdWUqcG93KDIuMCwgLWV4cG9uZW50KS0xLjA7XG4gIGV4cG9uZW50ID0gZXhwb25lbnQrMTI3LjA7XG4gIHJlc3VsdCAgID0gdmVjNCgwLDAsMCwwKTtcblxuICByZXN1bHQuYSA9IGZsb29yKGV4cG9uZW50LzIuMCk7XG4gIGV4cG9uZW50ID0gZXhwb25lbnQgLSByZXN1bHQuYSoyLjA7XG4gIHJlc3VsdC5hID0gcmVzdWx0LmEgKyAxMjguMCpzZ247XG5cbiAgcmVzdWx0LmIgPSBmbG9vcihtYW50aXNzYSAqIDEyOC4wKTtcbiAgbWFudGlzc2EgPSBtYW50aXNzYSAtIHJlc3VsdC5iIC8gMTI4LjA7XG4gIHJlc3VsdC5iID0gcmVzdWx0LmIgKyBleHBvbmVudCoxMjguMDtcblxuICByZXN1bHQuZyA9IGZsb29yKG1hbnRpc3NhKjMyNzY4LjApO1xuICBtYW50aXNzYSA9IG1hbnRpc3NhIC0gcmVzdWx0LmcvMzI3NjguMDtcblxuICByZXN1bHQuciA9IGZsb29yKG1hbnRpc3NhKjgzODg2MDguMCk7XG4gIHJldHVybiByZXN1bHQvMjU1LjA7XG59XG4vLyBEcmFnb25zIGVuZCBoZXJlXG5cbmludCBpbmRleDtcbml2ZWMzIHRocmVhZElkO1xuXG5pdmVjMyBpbmRleFRvM0QoaW50IGlkeCwgaXZlYzMgdGV4RGltKSB7XG4gIGludCB6ID0gaW50KGlkeCAvICh0ZXhEaW0ueCAqIHRleERpbS55KSk7XG4gIGlkeCAtPSB6ICogaW50KHRleERpbS54ICogdGV4RGltLnkpO1xuICBpbnQgeSA9IGludChpZHggLyB0ZXhEaW0ueCk7XG4gIGludCB4ID0gaW50KGludGVnZXJNb2QoaWR4LCB0ZXhEaW0ueCkpO1xuICByZXR1cm4gaXZlYzMoeCwgeSwgeik7XG59XG5cbmZsb2F0IGdldDMyKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbiAgcmV0dXJuIGRlY29kZTMyKHRleGVsKTtcbn1cblxuZmxvYXQgZ2V0MTYoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IHcgPSB0ZXhTaXplLnggKiAyO1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHRleCwgc3QgLyB2ZWMyKHRleFNpemUueCAqIDIsIHRleFNpemUueSkpO1xuICByZXR1cm4gZGVjb2RlMTYodGV4ZWwsIGluZGV4KTtcbn1cblxuZmxvYXQgZ2V0OChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgdyA9IHRleFNpemUueCAqIDQ7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodGV4LCBzdCAvIHZlYzIodGV4U2l6ZS54ICogNCwgdGV4U2l6ZS55KSk7XG4gIHJldHVybiBkZWNvZGU4KHRleGVsLCBpbmRleCk7XG59XG5cbmZsb2F0IGdldE1lbW9yeU9wdGltaXplZDMyKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgNCk7XG4gIGluZGV4ID0gaW5kZXggLyA0O1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIGlmIChjaGFubmVsID09IDApIHJldHVybiB0ZXhlbC5yO1xuICBpZiAoY2hhbm5lbCA9PSAxKSByZXR1cm4gdGV4ZWwuZztcbiAgaWYgKGNoYW5uZWwgPT0gMikgcmV0dXJuIHRleGVsLmI7XG4gIGlmIChjaGFubmVsID09IDMpIHJldHVybiB0ZXhlbC5hO1xuICByZXR1cm4gMC4wO1xufVxuXG52ZWM0IGdldEltYWdlMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHJldHVybiB0ZXh0dXJlMkQodGV4LCBzdCAvIHZlYzIodGV4U2l6ZSkpO1xufVxuXG5mbG9hdCBnZXRGbG9hdEZyb21TYW1wbGVyMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIHZlYzQgcmVzdWx0ID0gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgeiwgeSwgeCk7XG4gIHJldHVybiByZXN1bHRbMF07XG59XG5cbnZlYzIgZ2V0VmVjMkZyb21TYW1wbGVyMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIHZlYzQgcmVzdWx0ID0gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgeiwgeSwgeCk7XG4gIHJldHVybiB2ZWMyKHJlc3VsdFswXSwgcmVzdWx0WzFdKTtcbn1cblxudmVjMiBnZXRNZW1vcnlPcHRpbWl6ZWRWZWMyKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgKHRleERpbS54ICogKHkgKyAodGV4RGltLnkgKiB6KSkpO1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDIpO1xuICBpbmRleCA9IGluZGV4IC8gMjtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodGV4LCBzdCAvIHZlYzIodGV4U2l6ZSkpO1xuICBpZiAoY2hhbm5lbCA9PSAwKSByZXR1cm4gdmVjMih0ZXhlbC5yLCB0ZXhlbC5nKTtcbiAgaWYgKGNoYW5uZWwgPT0gMSkgcmV0dXJuIHZlYzIodGV4ZWwuYiwgdGV4ZWwuYSk7XG4gIHJldHVybiB2ZWMyKDAuMCwgMC4wKTtcbn1cblxudmVjMyBnZXRWZWMzRnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgdmVjNCByZXN1bHQgPSBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbiAgcmV0dXJuIHZlYzMocmVzdWx0WzBdLCByZXN1bHRbMV0sIHJlc3VsdFsyXSk7XG59XG5cbnZlYzMgZ2V0TWVtb3J5T3B0aW1pemVkVmVjMyhzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGZpZWxkSW5kZXggPSAzICogKHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KSk7XG4gIGludCB2ZWN0b3JJbmRleCA9IGZpZWxkSW5kZXggLyA0O1xuICBpbnQgdmVjdG9yT2Zmc2V0ID0gZmllbGRJbmRleCAtIHZlY3RvckluZGV4ICogNDtcbiAgaW50IHJlYWRZID0gdmVjdG9ySW5kZXggLyB0ZXhTaXplLng7XG4gIGludCByZWFkWCA9IHZlY3RvckluZGV4IC0gcmVhZFkgKiB0ZXhTaXplLng7XG4gIHZlYzQgdGV4MSA9IHRleHR1cmUyRCh0ZXgsICh2ZWMyKHJlYWRYLCByZWFkWSkgKyAwLjUpIC8gdmVjMih0ZXhTaXplKSk7XG4gIFxuICBpZiAodmVjdG9yT2Zmc2V0ID09IDApIHtcbiAgICByZXR1cm4gdGV4MS54eXo7XG4gIH0gZWxzZSBpZiAodmVjdG9yT2Zmc2V0ID09IDEpIHtcbiAgICByZXR1cm4gdGV4MS55enc7XG4gIH0gZWxzZSB7XG4gICAgcmVhZFgrKztcbiAgICBpZiAocmVhZFggPj0gdGV4U2l6ZS54KSB7XG4gICAgICByZWFkWCA9IDA7XG4gICAgICByZWFkWSsrO1xuICAgIH1cbiAgICB2ZWM0IHRleDIgPSB0ZXh0dXJlMkQodGV4LCB2ZWMyKHJlYWRYLCByZWFkWSkgLyB2ZWMyKHRleFNpemUpKTtcbiAgICBpZiAodmVjdG9yT2Zmc2V0ID09IDIpIHtcbiAgICAgIHJldHVybiB2ZWMzKHRleDEueiwgdGV4MS53LCB0ZXgyLngpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmVjMyh0ZXgxLncsIHRleDIueCwgdGV4Mi55KTtcbiAgICB9XG4gIH1cbn1cblxudmVjNCBnZXRWZWM0RnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgcmV0dXJuIGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xufVxuXG52ZWM0IGdldE1lbW9yeU9wdGltaXplZFZlYzQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKGluZGV4LCAyKTtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodGV4LCBzdCAvIHZlYzIodGV4U2l6ZSkpO1xuICByZXR1cm4gdmVjNCh0ZXhlbC5yLCB0ZXhlbC5nLCB0ZXhlbC5iLCB0ZXhlbC5hKTtcbn1cblxudmVjNCBhY3R1YWxDb2xvcjtcbnZvaWQgY29sb3IoZmxvYXQgciwgZmxvYXQgZywgZmxvYXQgYiwgZmxvYXQgYSkge1xuICBhY3R1YWxDb2xvciA9IHZlYzQocixnLGIsYSk7XG59XG5cbnZvaWQgY29sb3IoZmxvYXQgciwgZmxvYXQgZywgZmxvYXQgYikge1xuICBjb2xvcihyLGcsYiwxLjApO1xufVxuXG52b2lkIGNvbG9yKHNhbXBsZXIyRCBpbWFnZSkge1xuICBhY3R1YWxDb2xvciA9IHRleHR1cmUyRChpbWFnZSwgdlRleENvb3JkKTtcbn1cblxuZmxvYXQgbW9kdWxvKGZsb2F0IG51bWJlciwgZmxvYXQgZGl2aXNvcikge1xuICBpZiAobnVtYmVyIDwgMC4wKSB7XG4gICAgbnVtYmVyID0gYWJzKG51bWJlcik7XG4gICAgaWYgKGRpdmlzb3IgPCAwLjApIHtcbiAgICAgIGRpdmlzb3IgPSBhYnMoZGl2aXNvcik7XG4gICAgfVxuICAgIHJldHVybiAtbW9kKG51bWJlciwgZGl2aXNvcik7XG4gIH1cbiAgaWYgKGRpdmlzb3IgPCAwLjApIHtcbiAgICBkaXZpc29yID0gYWJzKGRpdmlzb3IpO1xuICB9XG4gIHJldHVybiBtb2QobnVtYmVyLCBkaXZpc29yKTtcbn1cblxuX19JTkpFQ1RFRF9OQVRJVkVfXztcbl9fTUFJTl9DT05TVEFOVFNfXztcbl9fTUFJTl9BUkdVTUVOVFNfXztcbl9fS0VSTkVMX187XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGluZGV4ID0gaW50KHZUZXhDb29yZC5zICogZmxvYXQodVRleFNpemUueCkpICsgaW50KHZUZXhDb29yZC50ICogZmxvYXQodVRleFNpemUueSkpICogdVRleFNpemUueDtcbiAgX19NQUlOX1JFU1VMVF9fO1xufWA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmcmFnbWVudFNoYWRlclxufTtcbn0se31dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tbm9kZScpO1xuXG5jbGFzcyBXZWJHTEZ1bmN0aW9uTm9kZSBleHRlbmRzIEZ1bmN0aW9uTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzb3VyY2UsIHNldHRpbmdzKTtcbiAgICBpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2ZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5JykpIHtcbiAgICAgIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBzZXR0aW5ncy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeTtcbiAgICB9XG4gIH1cblxuICBhc3RDb25kaXRpb25hbEV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICBpZiAoYXN0LnR5cGUgIT09ICdDb25kaXRpb25hbEV4cHJlc3Npb24nKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdOb3QgYSBjb25kaXRpb25hbCBleHByZXNzaW9uJywgYXN0KTtcbiAgICB9XG4gICAgY29uc3QgY29uc2VxdWVudFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LmNvbnNlcXVlbnQpO1xuICAgIGNvbnN0IGFsdGVybmF0ZVR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LmFsdGVybmF0ZSk7XG4gICAgaWYgKGNvbnNlcXVlbnRUeXBlID09PSBudWxsICYmIGFsdGVybmF0ZVR5cGUgPT09IG51bGwpIHtcbiAgICAgIHJldEFyci5wdXNoKCdpZiAoJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnRlc3QsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnKSB7Jyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmNvbnNlcXVlbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnOycpO1xuICAgICAgcmV0QXJyLnB1c2goJ30gZWxzZSB7Jyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFsdGVybmF0ZSwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc7Jyk7XG4gICAgICByZXRBcnIucHVzaCgnfScpO1xuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnRlc3QsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJz8nKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmNvbnNlcXVlbnQsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJzonKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFsdGVybmF0ZSwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RGdW5jdGlvbihhc3QsIHJldEFycikge1xuICAgIGlmICh0aGlzLmlzUm9vdEtlcm5lbCkge1xuICAgICAgcmV0QXJyLnB1c2goJ3ZvaWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgICAgY29uc3QgbGFzdFJldHVybiA9IHRoaXMuZmluZExhc3RSZXR1cm4oKTtcbiAgICAgICAgaWYgKGxhc3RSZXR1cm4pIHtcbiAgICAgICAgICB0aGlzLnJldHVyblR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LmJvZHkpO1xuICAgICAgICAgIGlmICh0aGlzLnJldHVyblR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicpIHtcbiAgICAgICAgICAgIHRoaXMucmV0dXJuVHlwZSA9ICdOdW1iZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHJldHVyblR5cGUgfSA9IHRoaXM7XG4gICAgICBpZiAoIXJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0QXJyLnB1c2goJ3ZvaWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlTWFwW3JldHVyblR5cGVdO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZSAke3JldHVyblR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0QXJyLnB1c2godHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcgJyk7XG4gICAgcmV0QXJyLnB1c2godGhpcy5uYW1lKTtcbiAgICByZXRBcnIucHVzaCgnKCcpO1xuXG4gICAgaWYgKCF0aGlzLmlzUm9vdEtlcm5lbCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgYXJndW1lbnROYW1lID0gdGhpcy5hcmd1bWVudE5hbWVzW2ldO1xuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHJldEFyci5wdXNoKCcsICcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhcmd1bWVudFR5cGUgPSB0aGlzLmFyZ3VtZW50VHlwZXNbdGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YoYXJndW1lbnROYW1lKV07XG4gICAgICAgIGlmICghYXJndW1lbnRUeXBlKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5rbm93biBhcmd1bWVudCAke2FyZ3VtZW50TmFtZX0gdHlwZWAsIGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50VHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuICAgICAgICAgIHRoaXMuYXJndW1lbnRUeXBlc1tpXSA9IGFyZ3VtZW50VHlwZSA9ICdOdW1iZXInO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlTWFwW2FyZ3VtZW50VHlwZV07XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHV0aWxzLnNhbml0aXplTmFtZShhcmd1bWVudE5hbWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3NhbXBsZXIyRCcgfHwgdHlwZSA9PT0gJ3NhbXBsZXIyREFycmF5Jykge1xuICAgICAgICAgIHJldEFyci5wdXNoKGAke3R5cGV9IHVzZXJfJHtuYW1lfSxpdmVjMiB1c2VyXyR7bmFtZX1TaXplLGl2ZWMzIHVzZXJfJHtuYW1lfURpbWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldEFyci5wdXNoKGAke3R5cGV9IHVzZXJfJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0QXJyLnB1c2goJykge1xcbicpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QuYm9keS5ib2R5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmJvZHkuYm9keVtpXSwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCdcXG4nKTtcbiAgICB9XG5cbiAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RSZXR1cm5TdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICBpZiAoIWFzdC5hcmd1bWVudCkgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCByZXR1cm4gc3RhdGVtZW50JywgYXN0KTtcbiAgICB0aGlzLnB1c2hTdGF0ZSgnc2tpcC1saXRlcmFsLWNvcnJlY3Rpb24nKTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGFzdC5hcmd1bWVudCk7XG4gICAgdGhpcy5wb3BTdGF0ZSgnc2tpcC1saXRlcmFsLWNvcnJlY3Rpb24nKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgaWYgKCF0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSAnTGl0ZXJhbEludGVnZXInIHx8IHR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICB0aGlzLnJldHVyblR5cGUgPSAnTnVtYmVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmV0dXJuVHlwZSA9IHR5cGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ2Zsb2F0KCcpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5hcmd1bWVudCwgcmVzdWx0KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhc3QuYXJndW1lbnQsIHJlc3VsdCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmdldFR5cGUoYXN0KSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KCdmbG9hdCgnKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0ludGVnZXIoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihhc3QuYXJndW1lbnQsIHJlc3VsdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5hcmd1bWVudCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgIGNhc2UgJ0lucHV0JzpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5hcmd1bWVudCwgcmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGB1bmhhbmRsZWQgcmV0dXJuIHR5cGUgJHt0aGlzLnJldHVyblR5cGV9YCwgYXN0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1Jvb3RLZXJuZWwpIHtcbiAgICAgIHJldEFyci5wdXNoKGBrZXJuZWxSZXN1bHQgPSAkeyByZXN1bHQuam9pbignJykgfTtgKTtcbiAgICAgIHJldEFyci5wdXNoKCdyZXR1cm47Jyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU3ViS2VybmVsKSB7XG4gICAgICByZXRBcnIucHVzaChgc3ViS2VybmVsUmVzdWx0XyR7IHRoaXMubmFtZSB9ID0gJHsgcmVzdWx0LmpvaW4oJycpIH07YCk7XG4gICAgICByZXRBcnIucHVzaChgcmV0dXJuIHN1Yktlcm5lbFJlc3VsdF8keyB0aGlzLm5hbWUgfTtgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goYHJldHVybiAkeyByZXN1bHQuam9pbignJykgfTtgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdExpdGVyYWwoYXN0LCByZXRBcnIpIHtcbiAgICBpZiAoaXNOYU4oYXN0LnZhbHVlKSkge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcbiAgICAgICAgJ05vbi1udW1lcmljIGxpdGVyYWwgbm90IHN1cHBvcnRlZCA6ICcgKyBhc3QudmFsdWUsXG4gICAgICAgIGFzdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSB0aGlzLmFzdEtleShhc3QpO1xuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFzdC52YWx1ZSkpIHtcbiAgICAgIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpIHx8IHRoaXMuaXNTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpKSB7XG4gICAgICAgIHRoaXMubGl0ZXJhbFR5cGVzW2tleV0gPSAnSW50ZWdlcic7XG4gICAgICAgIHJldEFyci5wdXNoKGAke2FzdC52YWx1ZX1gKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWZsb2F0JykgfHwgdGhpcy5pc1N0YXRlKCdidWlsZGluZy1mbG9hdCcpKSB7XG4gICAgICAgIHRoaXMubGl0ZXJhbFR5cGVzW2tleV0gPSAnTnVtYmVyJztcbiAgICAgICAgcmV0QXJyLnB1c2goYCR7YXN0LnZhbHVlfS4wYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpdGVyYWxUeXBlc1trZXldID0gJ051bWJlcic7XG4gICAgICAgIHJldEFyci5wdXNoKGAke2FzdC52YWx1ZX0uMGApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKSB8fCB0aGlzLmlzU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKSkge1xuICAgICAgdGhpcy5saXRlcmFsVHlwZXNba2V5XSA9ICdJbnRlZ2VyJztcbiAgICAgIHJldEFyci5wdXNoKE1hdGgucm91bmQoYXN0LnZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGl0ZXJhbFR5cGVzW2tleV0gPSAnTnVtYmVyJztcbiAgICAgIHJldEFyci5wdXNoKGAke2FzdC52YWx1ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEJpbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICBpZiAodGhpcy5jaGVja0FuZFVwY29udmVydE9wZXJhdG9yKGFzdCwgcmV0QXJyKSkge1xuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSAmJiBhc3Qub3BlcmF0b3IgPT09ICcvJykge1xuICAgICAgcmV0QXJyLnB1c2goJ2RpdldpdGhJbnRDaGVjaygnKTtcbiAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgc3dpdGNoICh0aGlzLmdldFR5cGUoYXN0LmxlZnQpKSB7XG4gICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgIHRoaXMuY2FzdFZhbHVlVG9GbG9hdChhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgIH1cbiAgICAgIHJldEFyci5wdXNoKCcsICcpO1xuICAgICAgc3dpdGNoICh0aGlzLmdldFR5cGUoYXN0LnJpZ2h0KSkge1xuICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvRmxvYXQoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfVxuXG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICBjb25zdCBsZWZ0VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QubGVmdCkgfHwgJ051bWJlcic7XG4gICAgY29uc3QgcmlnaHRUeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5yaWdodCkgfHwgJ051bWJlcic7XG4gICAgaWYgKCFsZWZ0VHlwZSB8fCAhcmlnaHRUeXBlKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgYmluYXJ5IGV4cHJlc3Npb25gLCBhc3QpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBsZWZ0VHlwZSArICcgJiAnICsgcmlnaHRUeXBlO1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlICdJbnRlZ2VyICYgSW50ZWdlcic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTnVtYmVyICYgRmxvYXQnOlxuICAgICAgY2FzZSAnRmxvYXQgJiBOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQgJiBGbG9hdCc6XG4gICAgICBjYXNlICdOdW1iZXIgJiBOdW1iZXInOlxuICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXIgJiBMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpIHx8IHRoaXMuaXNTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpKSB7XG4gICAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnSW50ZWdlciAmIEZsb2F0JzpcbiAgICAgIGNhc2UgJ0ludGVnZXIgJiBOdW1iZXInOlxuICAgICAgICBpZiAoYXN0Lm9wZXJhdG9yID09PSAnPicgfHwgYXN0Lm9wZXJhdG9yID09PSAnPCcgJiYgYXN0LnJpZ2h0LnR5cGUgPT09ICdMaXRlcmFsJykge1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihhc3QucmlnaHQudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgICAgIHRoaXMuY2FzdFZhbHVlVG9GbG9hdChhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG4gICAgICAgIGlmIChhc3QucmlnaHQudHlwZSA9PT0gJ0xpdGVyYWwnKSB7XG4gICAgICAgICAgY29uc3QgbGl0ZXJhbFJlc3VsdCA9IFtdO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIGxpdGVyYWxSZXN1bHQpO1xuICAgICAgICAgIGNvbnN0IGxpdGVyYWxUeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5yaWdodCk7XG4gICAgICAgICAgaWYgKGxpdGVyYWxUeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGxpdGVyYWxSZXN1bHQuam9pbignJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgYmluYXJ5IGV4cHJlc3Npb24gd2l0aCBsaXRlcmFsYCwgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ2ludCgnKTtcbiAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdJbnRlZ2VyICYgTGl0ZXJhbEludGVnZXInOlxuICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ051bWJlciAmIEludGVnZXInOlxuICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMuY2FzdFZhbHVlVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRmxvYXQgJiBMaXRlcmFsSW50ZWdlcic6XG4gICAgICBjYXNlICdOdW1iZXIgJiBMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyICYgRmxvYXQnOlxuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXIgJiBOdW1iZXInOlxuICAgICAgICBpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKSkge1xuICAgICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0ludGVnZXIoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICAgIHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgICB0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG4gICAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyICYgSW50ZWdlcic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0ludGVnZXIoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQm9vbGVhbiAmIEJvb2xlYW4nOlxuICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctYm9vbGVhbicpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctYm9vbGVhbicpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnRmxvYXQgJiBJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvRmxvYXQoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIGJpbmFyeSBleHByZXNzaW9uIGJldHdlZW4gJHtrZXl9YCwgYXN0KTtcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyknKTtcblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjaGVja0FuZFVwY29udmVydE9wZXJhdG9yKGFzdCwgcmV0QXJyKSB7XG4gICAgY29uc3QgYml0d2lzZVJlc3VsdCA9IHRoaXMuY2hlY2tBbmRVcGNvbnZlcnRCaXR3aXNlT3BlcmF0b3JzKGFzdCwgcmV0QXJyKTtcbiAgICBpZiAoYml0d2lzZVJlc3VsdCkge1xuICAgICAgcmV0dXJuIGJpdHdpc2VSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHVwY29udmVydGFibGVPcGVyYXRvcnMgPSB7XG4gICAgICAnJSc6IHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPyAnaW50ZWdlckNvcnJlY3Rpb25Nb2R1bG8nIDogJ21vZHVsbycsXG4gICAgICAnKionOiAncG93JyxcbiAgICB9O1xuICAgIGNvbnN0IGZvdW5kT3BlcmF0b3IgPSB1cGNvbnZlcnRhYmxlT3BlcmF0b3JzW2FzdC5vcGVyYXRvcl07XG4gICAgaWYgKCFmb3VuZE9wZXJhdG9yKSByZXR1cm4gbnVsbDtcbiAgICByZXRBcnIucHVzaChmb3VuZE9wZXJhdG9yKTtcbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIHN3aXRjaCAodGhpcy5nZXRUeXBlKGFzdC5sZWZ0KSkge1xuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgIHRoaXMuY2FzdFZhbHVlVG9GbG9hdChhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJywnKTtcbiAgICBzd2l0Y2ggKHRoaXMuZ2V0VHlwZShhc3QucmlnaHQpKSB7XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjaGVja0FuZFVwY29udmVydEJpdHdpc2VPcGVyYXRvcnMoYXN0LCByZXRBcnIpIHtcbiAgICBjb25zdCB1cGNvbnZlcnRhYmxlT3BlcmF0b3JzID0ge1xuICAgICAgJyYnOiAnYml0d2lzZUFuZCcsXG4gICAgICAnfCc6ICdiaXR3aXNlT3InLFxuICAgICAgJ14nOiAnYml0d2lzZVhPUicsXG4gICAgICAnPDwnOiAnYml0d2lzZVplcm9GaWxsTGVmdFNoaWZ0JyxcbiAgICAgICc+Pic6ICdiaXR3aXNlU2lnbmVkUmlnaHRTaGlmdCcsXG4gICAgICAnPj4+JzogJ2JpdHdpc2VaZXJvRmlsbFJpZ2h0U2hpZnQnLFxuICAgIH07XG4gICAgY29uc3QgZm91bmRPcGVyYXRvciA9IHVwY29udmVydGFibGVPcGVyYXRvcnNbYXN0Lm9wZXJhdG9yXTtcbiAgICBpZiAoIWZvdW5kT3BlcmF0b3IpIHJldHVybiBudWxsO1xuICAgIHJldEFyci5wdXNoKGZvdW5kT3BlcmF0b3IpO1xuICAgIHJldEFyci5wdXNoKCcoJyk7XG4gICAgY29uc3QgbGVmdFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LmxlZnQpO1xuICAgIHN3aXRjaCAobGVmdFR5cGUpIHtcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIHRoaXMuY2FzdFZhbHVlVG9JbnRlZ2VyKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcsJyk7XG4gICAgY29uc3QgcmlnaHRUeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5yaWdodCk7XG4gICAgc3dpdGNoIChyaWdodFR5cGUpIHtcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIHRoaXMuY2FzdFZhbHVlVG9JbnRlZ2VyKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0ludGVnZXIoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNoZWNrQW5kVXBjb252ZXJ0Qml0d2lzZVVuYXJ5KGFzdCwgcmV0QXJyKSB7XG4gICAgY29uc3QgdXBjb252ZXJ0YWJsZU9wZXJhdG9ycyA9IHtcbiAgICAgICd+JzogJ2JpdHdpc2VOb3QnLFxuICAgIH07XG4gICAgY29uc3QgZm91bmRPcGVyYXRvciA9IHVwY29udmVydGFibGVPcGVyYXRvcnNbYXN0Lm9wZXJhdG9yXTtcbiAgICBpZiAoIWZvdW5kT3BlcmF0b3IpIHJldHVybiBudWxsO1xuICAgIHJldEFyci5wdXNoKGZvdW5kT3BlcmF0b3IpO1xuICAgIHJldEFyci5wdXNoKCcoJyk7XG4gICAgc3dpdGNoICh0aGlzLmdldFR5cGUoYXN0LmFyZ3VtZW50KSkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0ludGVnZXIoYXN0LmFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihhc3QuYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5hcmd1bWVudCwgcmV0QXJyKTtcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgY2FzdExpdGVyYWxUb0ludGVnZXIoYXN0LCByZXRBcnIpIHtcbiAgICB0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdCwgcmV0QXJyKTtcbiAgICB0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgY2FzdExpdGVyYWxUb0Zsb2F0KGFzdCwgcmV0QXJyKSB7XG4gICAgdGhpcy5wdXNoU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LCByZXRBcnIpO1xuICAgIHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgY2FzdFZhbHVlVG9JbnRlZ2VyKGFzdCwgcmV0QXJyKSB7XG4gICAgdGhpcy5wdXNoU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuICAgIHJldEFyci5wdXNoKCdpbnQoJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjYXN0VmFsdWVUb0Zsb2F0KGFzdCwgcmV0QXJyKSB7XG4gICAgdGhpcy5wdXNoU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKTtcbiAgICByZXRBcnIucHVzaCgnZmxvYXQoJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0SWRlbnRpZmllckV4cHJlc3Npb24oaWR0Tm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKGlkdE5vZGUudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJZGVudGlmaWVyRXhwcmVzc2lvbiAtIG5vdCBhbiBJZGVudGlmaWVyJywgaWR0Tm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZShpZHROb2RlKTtcblxuICAgIGNvbnN0IG5hbWUgPSB1dGlscy5zYW5pdGl6ZU5hbWUoaWR0Tm9kZS5uYW1lKTtcbiAgICBpZiAoaWR0Tm9kZS5uYW1lID09PSAnSW5maW5pdHknKSB7XG4gICAgICByZXRBcnIucHVzaCgnMy40MDI4MjM0NjZlKzM4Jyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnQm9vbGVhbicpIHtcbiAgICAgIGlmICh0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgIHJldEFyci5wdXNoKGBib29sKHVzZXJfJHtuYW1lfSlgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7bmFtZX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHtuYW1lfWApO1xuICAgIH1cblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RGb3JTdGF0ZW1lbnQoZm9yTm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKGZvck5vZGUudHlwZSAhPT0gJ0ZvclN0YXRlbWVudCcpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0ludmFsaWQgZm9yIHN0YXRlbWVudCcsIGZvck5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRBcnIgPSBbXTtcbiAgICBjb25zdCB0ZXN0QXJyID0gW107XG4gICAgY29uc3QgdXBkYXRlQXJyID0gW107XG4gICAgY29uc3QgYm9keUFyciA9IFtdO1xuICAgIGxldCBpc1NhZmUgPSBudWxsO1xuXG4gICAgaWYgKGZvck5vZGUuaW5pdCkge1xuICAgICAgY29uc3QgeyBkZWNsYXJhdGlvbnMgfSA9IGZvck5vZGUuaW5pdDtcbiAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICBpc1NhZmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLmluaXQsIGluaXRBcnIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNsYXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uc1tpXS5pbml0ICYmIGRlY2xhcmF0aW9uc1tpXS5pbml0LnR5cGUgIT09ICdMaXRlcmFsJykge1xuICAgICAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmb3JOb2RlLnRlc3QpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLnRlc3QsIHRlc3RBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc1NhZmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZm9yTm9kZS51cGRhdGUpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLnVwZGF0ZSwgdXBkYXRlQXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZvck5vZGUuYm9keSkge1xuICAgICAgdGhpcy5wdXNoU3RhdGUoJ2xvb3AtYm9keScpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUuYm9keSwgYm9keUFycik7XG4gICAgICB0aGlzLnBvcFN0YXRlKCdsb29wLWJvZHknKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTYWZlID09PSBudWxsKSB7XG4gICAgICBpc1NhZmUgPSB0aGlzLmlzU2FmZShmb3JOb2RlLmluaXQpICYmIHRoaXMuaXNTYWZlKGZvck5vZGUudGVzdCk7XG4gICAgfVxuXG4gICAgaWYgKGlzU2FmZSkge1xuICAgICAgY29uc3QgaW5pdFN0cmluZyA9IGluaXRBcnIuam9pbignJyk7XG4gICAgICBjb25zdCBpbml0TmVlZHNTZW1pQ29sb24gPSBpbml0U3RyaW5nW2luaXRTdHJpbmcubGVuZ3RoIC0gMV0gIT09ICc7JztcbiAgICAgIHJldEFyci5wdXNoKGBmb3IgKCR7aW5pdFN0cmluZ30ke2luaXROZWVkc1NlbWlDb2xvbiA/ICc7JyA6ICcnfSR7dGVzdEFyci5qb2luKCcnKX07JHt1cGRhdGVBcnIuam9pbignJyl9KXtcXG5gKTtcbiAgICAgIHJldEFyci5wdXNoKGJvZHlBcnIuam9pbignJykpO1xuICAgICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaVZhcmlhYmxlTmFtZSA9IHRoaXMuZ2V0SW50ZXJuYWxWYXJpYWJsZU5hbWUoJ3NhZmVJJyk7XG4gICAgICBpZiAoaW5pdEFyci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldEFyci5wdXNoKGluaXRBcnIuam9pbignJyksICdcXG4nKTtcbiAgICAgIH1cbiAgICAgIHJldEFyci5wdXNoKGBmb3IgKGludCAke2lWYXJpYWJsZU5hbWV9PTA7JHtpVmFyaWFibGVOYW1lfTxMT09QX01BWDske2lWYXJpYWJsZU5hbWV9Kyspe1xcbmApO1xuICAgICAgaWYgKHRlc3RBcnIubGVuZ3RoID4gMCkge1xuICAgICAgICByZXRBcnIucHVzaChgaWYgKCEke3Rlc3RBcnIuam9pbignJyl9KSBicmVhaztcXG5gKTtcbiAgICAgIH1cbiAgICAgIHJldEFyci5wdXNoKGJvZHlBcnIuam9pbignJykpO1xuICAgICAgcmV0QXJyLnB1c2goYFxcbiR7dXBkYXRlQXJyLmpvaW4oJycpfTtgKTtcbiAgICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RXaGlsZVN0YXRlbWVudCh3aGlsZU5vZGUsIHJldEFycikge1xuICAgIGlmICh3aGlsZU5vZGUudHlwZSAhPT0gJ1doaWxlU3RhdGVtZW50Jykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnSW52YWxpZCB3aGlsZSBzdGF0ZW1lbnQnLCB3aGlsZU5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGlWYXJpYWJsZU5hbWUgPSB0aGlzLmdldEludGVybmFsVmFyaWFibGVOYW1lKCdzYWZlSScpO1xuICAgIHJldEFyci5wdXNoKGBmb3IgKGludCAke2lWYXJpYWJsZU5hbWV9PTA7JHtpVmFyaWFibGVOYW1lfTxMT09QX01BWDske2lWYXJpYWJsZU5hbWV9Kyspe1xcbmApO1xuICAgIHJldEFyci5wdXNoKCdpZiAoIScpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyh3aGlsZU5vZGUudGVzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKSBicmVhaztcXG4nKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMod2hpbGVOb2RlLmJvZHksIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3REb1doaWxlU3RhdGVtZW50KGRvV2hpbGVOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoZG9XaGlsZU5vZGUudHlwZSAhPT0gJ0RvV2hpbGVTdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIHdoaWxlIHN0YXRlbWVudCcsIGRvV2hpbGVOb2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpVmFyaWFibGVOYW1lID0gdGhpcy5nZXRJbnRlcm5hbFZhcmlhYmxlTmFtZSgnc2FmZUknKTtcbiAgICByZXRBcnIucHVzaChgZm9yIChpbnQgJHtpVmFyaWFibGVOYW1lfT0wOyR7aVZhcmlhYmxlTmFtZX08TE9PUF9NQVg7JHtpVmFyaWFibGVOYW1lfSsrKXtcXG5gKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoZG9XaGlsZU5vZGUuYm9keSwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnaWYgKCEnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoZG9XaGlsZU5vZGUudGVzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKSBicmVhaztcXG4nKTtcbiAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG5cbiAgYXN0QXNzaWdubWVudEV4cHJlc3Npb24oYXNzTm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKGFzc05vZGUub3BlcmF0b3IgPT09ICclPScpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLmxlZnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnPScpO1xuICAgICAgcmV0QXJyLnB1c2goJ21vZCgnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLmxlZnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnLCcpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUucmlnaHQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIH0gZWxzZSBpZiAoYXNzTm9kZS5vcGVyYXRvciA9PT0gJyoqPScpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLmxlZnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnPScpO1xuICAgICAgcmV0QXJyLnB1c2goJ3BvdygnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLmxlZnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnLCcpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUucmlnaHQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZWZ0VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3NOb2RlLmxlZnQpO1xuICAgICAgY29uc3QgcmlnaHRUeXBlID0gdGhpcy5nZXRUeXBlKGFzc05vZGUucmlnaHQpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKGFzc05vZGUub3BlcmF0b3IpO1xuICAgICAgaWYgKGxlZnRUeXBlICE9PSAnSW50ZWdlcicgJiYgcmlnaHRUeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgcmV0QXJyLnB1c2goJ2Zsb2F0KCcpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLnJpZ2h0LCByZXRBcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9XG4gIH1cblxuICBhc3RCbG9ja1N0YXRlbWVudChiTm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKHRoaXMuaXNTdGF0ZSgnbG9vcC1ib2R5JykpIHtcbiAgICAgIHRoaXMucHVzaFN0YXRlKCdibG9jay1ib2R5Jyk7IFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiTm9kZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhiTm9kZS5ib2R5W2ldLCByZXRBcnIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wb3BTdGF0ZSgnYmxvY2stYm9keScpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaCgne1xcbicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiTm9kZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhiTm9kZS5ib2R5W2ldLCByZXRBcnIpO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdFZhcmlhYmxlRGVjbGFyYXRpb24odmFyRGVjTm9kZSwgcmV0QXJyKSB7XG4gICAgY29uc3QgZGVjbGFyYXRpb25zID0gdmFyRGVjTm9kZS5kZWNsYXJhdGlvbnM7XG4gICAgaWYgKCFkZWNsYXJhdGlvbnMgfHwgIWRlY2xhcmF0aW9uc1swXSB8fCAhZGVjbGFyYXRpb25zWzBdLmluaXQpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIHZhckRlY05vZGUpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgbGFzdFR5cGUgPSBudWxsO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uU2V0cyA9IFtdO1xuICAgIGxldCBkZWNsYXJhdGlvblNldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uc1tpXTtcbiAgICAgIGNvbnN0IGluaXQgPSBkZWNsYXJhdGlvbi5pbml0O1xuICAgICAgY29uc3QgaW5mbyA9IHRoaXMuZ2V0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24uaWQpO1xuICAgICAgY29uc3QgYWN0dWFsVHlwZSA9IHRoaXMuZ2V0VHlwZShkZWNsYXJhdGlvbi5pbml0KTtcbiAgICAgIGxldCB0eXBlID0gYWN0dWFsVHlwZTtcbiAgICAgIGlmICh0eXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG4gICAgICAgIGlmIChpbmZvLnN1Z2dlc3RlZFR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgIHR5cGUgPSAnSW50ZWdlcic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZSA9ICdOdW1iZXInO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBtYXJrdXBUeXBlID0gdHlwZU1hcFt0eXBlXTtcbiAgICAgIGlmICghbWFya3VwVHlwZSkge1xuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBNYXJrdXAgdHlwZSAkeyBtYXJrdXBUeXBlIH0gbm90IGhhbmRsZWRgLCB2YXJEZWNOb2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uUmVzdWx0ID0gW107XG4gICAgICBpZiAoYWN0dWFsVHlwZSA9PT0gJ0ludGVnZXInICYmIHR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICBpbmZvLnZhbHVlVHlwZSA9ICdOdW1iZXInO1xuICAgICAgICBpZiAoaSA9PT0gMCB8fCBsYXN0VHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGRlY2xhcmF0aW9uUmVzdWx0LnB1c2goJ2Zsb2F0ICcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IGxhc3RUeXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmhhbmRsZWQgZGVjbGFyYXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0VHlwZSA9IHR5cGU7XG4gICAgICAgIGRlY2xhcmF0aW9uUmVzdWx0LnB1c2goYHVzZXJfJHt1dGlscy5zYW5pdGl6ZU5hbWUoZGVjbGFyYXRpb24uaWQubmFtZSl9PWApO1xuICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKCdmbG9hdCgnKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGluaXQsIGRlY2xhcmF0aW9uUmVzdWx0KTtcbiAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaCgnKScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mby52YWx1ZVR5cGUgPSB0eXBlO1xuICAgICAgICBpZiAoaSA9PT0gMCB8fCBsYXN0VHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGRlY2xhcmF0aW9uUmVzdWx0LnB1c2goYCR7bWFya3VwVHlwZX0gYCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gbGFzdFR5cGUpIHtcbiAgICAgICAgICBkZWNsYXJhdGlvblNldHMucHVzaChkZWNsYXJhdGlvblNldC5qb2luKCcsJykpO1xuICAgICAgICAgIGRlY2xhcmF0aW9uU2V0ID0gW107XG4gICAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaChgJHttYXJrdXBUeXBlfSBgKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0VHlwZSA9IHR5cGU7XG4gICAgICAgIGRlY2xhcmF0aW9uUmVzdWx0LnB1c2goYHVzZXJfJHt1dGlscy5zYW5pdGl6ZU5hbWUoZGVjbGFyYXRpb24uaWQubmFtZSl9PWApO1xuICAgICAgICBpZiAoYWN0dWFsVHlwZSA9PT0gJ051bWJlcicgJiYgdHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgaWYgKGluaXQubGVmdCAmJiBpbml0LmxlZnQudHlwZSA9PT0gJ0xpdGVyYWwnKSB7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoaW5pdCwgZGVjbGFyYXRpb25SZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKCdpbnQoJyk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoaW5pdCwgZGVjbGFyYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaCgnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhY3R1YWxUeXBlID09PSAnTGl0ZXJhbEludGVnZXInICYmIHR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0ludGVnZXIoaW5pdCwgZGVjbGFyYXRpb25SZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhpbml0LCBkZWNsYXJhdGlvblJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlY2xhcmF0aW9uU2V0LnB1c2goZGVjbGFyYXRpb25SZXN1bHQuam9pbignJykpO1xuICAgIH1cblxuICAgIGlmIChkZWNsYXJhdGlvblNldC5sZW5ndGggPiAwKSB7XG4gICAgICBkZWNsYXJhdGlvblNldHMucHVzaChkZWNsYXJhdGlvblNldC5qb2luKCcsJykpO1xuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKGRlY2xhcmF0aW9uU2V0cy5qb2luKCc7JykpO1xuXG4gICAgcmV0QXJyLnB1c2gocmVzdWx0LmpvaW4oJycpKTtcbiAgICByZXRBcnIucHVzaCgnOycpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RJZlN0YXRlbWVudChpZk5vZGUsIHJldEFycikge1xuICAgIHJldEFyci5wdXNoKCdpZiAoJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgaWYgKGlmTm9kZS5jb25zZXF1ZW50LnR5cGUgPT09ICdCbG9ja1N0YXRlbWVudCcpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goJyB7XFxuJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmNvbnNlcXVlbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnXFxufVxcbicpO1xuICAgIH1cblxuICAgIGlmIChpZk5vZGUuYWx0ZXJuYXRlKSB7XG4gICAgICByZXRBcnIucHVzaCgnZWxzZSAnKTtcbiAgICAgIGlmIChpZk5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09ICdCbG9ja1N0YXRlbWVudCcgfHwgaWZOb2RlLmFsdGVybmF0ZS50eXBlID09PSAnSWZTdGF0ZW1lbnQnKSB7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuYWx0ZXJuYXRlLCByZXRBcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0QXJyLnB1c2goJyB7XFxuJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuYWx0ZXJuYXRlLCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnXFxufVxcbicpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0U3dpdGNoU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnU3dpdGNoU3RhdGVtZW50Jykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnSW52YWxpZCBzd2l0Y2ggc3RhdGVtZW50JywgYXN0KTtcbiAgICB9XG4gICAgY29uc3QgeyBkaXNjcmltaW5hbnQsIGNhc2VzIH0gPSBhc3Q7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZShkaXNjcmltaW5hbnQpO1xuICAgIGNvbnN0IHZhck5hbWUgPSBgc3dpdGNoRGlzY3JpbWluYW50JHt0aGlzLmFzdEtleShhc3QsICdfJyl9YDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgIHJldEFyci5wdXNoKGBmbG9hdCAke3Zhck5hbWV9ID0gYCk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhkaXNjcmltaW5hbnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCc7XFxuJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgIHJldEFyci5wdXNoKGBpbnQgJHt2YXJOYW1lfSA9IGApO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoZGlzY3JpbWluYW50LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnO1xcbicpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGNhc2VzLmxlbmd0aCA9PT0gMSAmJiAhY2FzZXNbMF0udGVzdCkge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGNhc2VzWzBdLmNvbnNlcXVlbnQsIHJldEFycik7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cblxuICAgIGxldCBmYWxsaW5nVGhyb3VnaCA9IGZhbHNlO1xuICAgIGxldCBkZWZhdWx0UmVzdWx0ID0gW107XG4gICAgbGV0IG1vdmluZ0RlZmF1bHRUb0VuZCA9IGZhbHNlO1xuICAgIGxldCBwYXN0Rmlyc3RJZiA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghY2FzZXNbaV0udGVzdCkge1xuICAgICAgICBpZiAoY2FzZXMubGVuZ3RoID4gaSArIDEpIHtcbiAgICAgICAgICBtb3ZpbmdEZWZhdWx0VG9FbmQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhjYXNlc1tpXS5jb25zZXF1ZW50LCBkZWZhdWx0UmVzdWx0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnIGVsc2Uge1xcbicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaSA9PT0gMCB8fCAhcGFzdEZpcnN0SWYpIHtcbiAgICAgICAgICBwYXN0Rmlyc3RJZiA9IHRydWU7XG4gICAgICAgICAgcmV0QXJyLnB1c2goYGlmICgke3Zhck5hbWV9ID09IGApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmYWxsaW5nVGhyb3VnaCkge1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goYCR7dmFyTmFtZX0gPT0gYCk7XG4gICAgICAgICAgICBmYWxsaW5nVGhyb3VnaCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXRBcnIucHVzaChgIGVsc2UgaWYgKCR7dmFyTmFtZX0gPT0gYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICBjb25zdCB0ZXN0VHlwZSA9IHRoaXMuZ2V0VHlwZShjYXNlc1tpXS50ZXN0KTtcbiAgICAgICAgICBzd2l0Y2ggKHRlc3RUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvSW50ZWdlcihjYXNlc1tpXS50ZXN0LCByZXRBcnIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihjYXNlc1tpXS50ZXN0LCByZXRBcnIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0Zsb2F0Jykge1xuICAgICAgICAgIGNvbnN0IHRlc3RUeXBlID0gdGhpcy5nZXRUeXBlKGNhc2VzW2ldLnRlc3QpO1xuICAgICAgICAgIHN3aXRjaCAodGVzdFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoY2FzZXNbaV0udGVzdCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGNhc2VzW2ldLnRlc3QsIHJldEFycik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaGFubGRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FzZXNbaV0uY29uc2VxdWVudCB8fCBjYXNlc1tpXS5jb25zZXF1ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGZhbGxpbmdUaHJvdWdoID0gdHJ1ZTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnIHx8ICcpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldEFyci5wdXNoKGApIHtcXG5gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhjYXNlc1tpXS5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJ1xcbn0nKTtcbiAgICB9XG4gICAgaWYgKG1vdmluZ0RlZmF1bHRUb0VuZCkge1xuICAgICAgcmV0QXJyLnB1c2goJyBlbHNlIHsnKTtcbiAgICAgIHJldEFyci5wdXNoKGRlZmF1bHRSZXN1bHQuam9pbignJykpO1xuICAgICAgcmV0QXJyLnB1c2goJ30nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdFRoaXNFeHByZXNzaW9uKHROb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgndGhpcycpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RNZW1iZXJFeHByZXNzaW9uKG1Ob2RlLCByZXRBcnIpIHtcbiAgICBjb25zdCB7XG4gICAgICBwcm9wZXJ0eSxcbiAgICAgIG5hbWUsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBvcmlnaW4sXG4gICAgICB0eXBlLFxuICAgICAgeFByb3BlcnR5LFxuICAgICAgeVByb3BlcnR5LFxuICAgICAgelByb3BlcnR5XG4gICAgfSA9IHRoaXMuZ2V0TWVtYmVyRXhwcmVzc2lvbkRldGFpbHMobU5vZGUpO1xuICAgIHN3aXRjaCAoc2lnbmF0dXJlKSB7XG4gICAgICBjYXNlICd2YWx1ZS50aHJlYWQudmFsdWUnOlxuICAgICAgY2FzZSAndGhpcy50aHJlYWQudmFsdWUnOlxuICAgICAgICBpZiAobmFtZSAhPT0gJ3gnICYmIG5hbWUgIT09ICd5JyAmJiBuYW1lICE9PSAneicpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24sIGV4cGVjdGVkIGB0aGlzLnRocmVhZC54YCwgYHRoaXMudGhyZWFkLnlgLCBvciBgdGhpcy50aHJlYWQuemAnLCBtTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0QXJyLnB1c2goYHRocmVhZElkLiR7bmFtZX1gKTtcbiAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgIGNhc2UgJ3RoaXMub3V0cHV0LnZhbHVlJzpcbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY091dHB1dCkge1xuICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKSkge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKCdmbG9hdCh1T3V0cHV0RGltLngpJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ3VPdXRwdXREaW0ueCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKSkge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKCdmbG9hdCh1T3V0cHV0RGltLnkpJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ3VPdXRwdXREaW0ueScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKSkge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKCdmbG9hdCh1T3V0cHV0RGltLnopJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ3VPdXRwdXREaW0ueicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKSkge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMub3V0cHV0WzBdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm91dHB1dFswXSwgJy4wJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykpIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm91dHB1dFsxXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMV0sICcuMCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMl0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMub3V0cHV0WzJdLCAnLjAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIG1Ob2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuICAgICAgY2FzZSAndmFsdWVbXSc6XG4gICAgICBjYXNlICd2YWx1ZVtdW10nOlxuICAgICAgY2FzZSAndmFsdWVbXVtdW10nOlxuICAgICAgY2FzZSAndmFsdWVbXVtdW11bXSc6XG4gICAgICBjYXNlICd2YWx1ZS52YWx1ZSc6XG4gICAgICAgIGlmIChvcmlnaW4gPT09ICdNYXRoJykge1xuICAgICAgICAgIHJldEFyci5wdXNoKE1hdGhbbmFtZV0pO1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xlYW5OYW1lID0gdXRpbHMuc2FuaXRpemVOYW1lKG5hbWUpO1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8keyBjbGVhbk5hbWUgfS5yYCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHsgY2xlYW5OYW1lIH0uZ2ApO1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IGNsZWFuTmFtZSB9LmJgKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8keyBjbGVhbk5hbWUgfS5hYCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWUnOlxuICAgICAgICBpZiAodHlwZW9mIHhQcm9wZXJ0eSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgICAgICAgcmV0QXJyLnB1c2goYGNvbnN0YW50c18keyB1dGlscy5zYW5pdGl6ZU5hbWUobmFtZSkgfWApO1xuICAgICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdJzpcbiAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdJzpcbiAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW10nOlxuICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXVtdJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZm4oKVtdJzpcbiAgICAgICAgICB0aGlzLmFzdENhbGxFeHByZXNzaW9uKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHByb3BlcnR5KSk7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICBjYXNlICdbXVtdJzpcbiAgICAgICAgICB0aGlzLmFzdEFycmF5RXhwcmVzc2lvbihtTm9kZS5vYmplY3QsIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cChwcm9wZXJ0eSkpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgY2FzZSAndmFsdWUudmFsdWVbXSc6XG4gICAgICAgIGNhc2UgJ3ZhbHVlLnZhbHVlW11bXSc6XG4gICAgICAgICAgaWYgKHRoaXMucmVtb3ZlSXN0YW5idWxDb3ZlcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIG1Ob2RlKTtcbiAgICB9XG5cbiAgICBpZiAobU5vZGUuY29tcHV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgICAgcmV0QXJyLnB1c2goYCR7b3JpZ2lufV8ke3V0aWxzLnNhbml0aXplTmFtZShuYW1lKX1gKTtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1hcmt1cE5hbWUgPSBgJHtvcmlnaW59XyR7dXRpbHMuc2FuaXRpemVOYW1lKG5hbWUpfWA7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgcmV0QXJyLnB1c2godGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAoeFByb3BlcnR5KSk7XG4gICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSFRNTEltYWdlQXJyYXknOlxuICAgICAgICByZXRBcnIucHVzaChgZ2V0SW1hZ2UzRCgkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRGbG9hdEZyb21TYW1wbGVyMkQoJHsgbWFya3VwTmFtZSB9LCAkeyBtYXJrdXBOYW1lIH1TaXplLCAkeyBtYXJrdXBOYW1lIH1EaW0sIGApO1xuICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheTFEKDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5MkQoMiknOlxuICAgICAgY2FzZSAnQXJyYXkzRCgyKSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRNZW1vcnlPcHRpbWl6ZWRWZWMyKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDIpJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldFZlYzJGcm9tU2FtcGxlcjJEKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXkxRCgzKSc6XG4gICAgICBjYXNlICdBcnJheTJEKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5M0QoMyknOlxuICAgICAgICByZXRBcnIucHVzaChgZ2V0TWVtb3J5T3B0aW1pemVkVmVjMygkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRWZWMzRnJvbVNhbXBsZXIyRCgkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5MUQoNCknOlxuICAgICAgY2FzZSAnQXJyYXkyRCg0KSc6XG4gICAgICBjYXNlICdBcnJheTNEKDQpJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldE1lbW9yeU9wdGltaXplZFZlYzQoJHsgbWFya3VwTmFtZSB9LCAkeyBtYXJrdXBOYW1lIH1TaXplLCAkeyBtYXJrdXBOYW1lIH1EaW0sIGApO1xuICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoNCknOlxuICAgICAgY2FzZSAnSFRNTENhbnZhcyc6XG4gICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgY2FzZSAnSFRNTFZpZGVvJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldFZlYzRGcm9tU2FtcGxlcjJEKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTnVtYmVyVGV4dHVyZSc6XG4gICAgICBjYXNlICdBcnJheSc6XG4gICAgICBjYXNlICdBcnJheTJEJzpcbiAgICAgIGNhc2UgJ0FycmF5M0QnOlxuICAgICAgY2FzZSAnQXJyYXk0RCc6XG4gICAgICBjYXNlICdJbnB1dCc6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICByZXRBcnIucHVzaChgZ2V0TWVtb3J5T3B0aW1pemVkMzIoJHttYXJrdXBOYW1lfSwgJHttYXJrdXBOYW1lfVNpemUsICR7bWFya3VwTmFtZX1EaW0sIGApO1xuICAgICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYml0UmF0aW8gPSAob3JpZ2luID09PSAndXNlcicgP1xuICAgICAgICAgICAgdGhpcy5sb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8odGhpcy5uYW1lLCBuYW1lKSA6XG4gICAgICAgICAgICB0aGlzLmNvbnN0YW50Qml0UmF0aW9zW25hbWVdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzd2l0Y2ggKGJpdFJhdGlvKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKGBnZXQ4KCR7bWFya3VwTmFtZX0sICR7bWFya3VwTmFtZX1TaXplLCAke21hcmt1cE5hbWV9RGltLCBgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKGBnZXQxNigke21hcmt1cE5hbWV9LCAke21hcmt1cE5hbWV9U2l6ZSwgJHttYXJrdXBOYW1lfURpbSwgYCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXRBcnIucHVzaChgZ2V0MzIoJHttYXJrdXBOYW1lfSwgJHttYXJrdXBOYW1lfVNpemUsICR7bWFya3VwTmFtZX1EaW0sIGApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIGJpdCByYXRpbyBvZiAke2JpdFJhdGlvfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRNZW1vcnlPcHRpbWl6ZWQzMigkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIG1lbWJlciBleHByZXNzaW9uIFwiJHsgdHlwZSB9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdENhbGxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKCFhc3QuY2FsbGVlKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmtub3duIENhbGxFeHByZXNzaW9uJywgYXN0KTtcbiAgICB9XG5cbiAgICBsZXQgZnVuY3Rpb25OYW1lID0gbnVsbDtcbiAgICBjb25zdCBpc01hdGhGdW5jdGlvbiA9IHRoaXMuaXNBc3RNYXRoRnVuY3Rpb24oYXN0KTtcblxuICAgIGlmIChpc01hdGhGdW5jdGlvbiB8fCAoYXN0LmNhbGxlZS5vYmplY3QgJiYgYXN0LmNhbGxlZS5vYmplY3QudHlwZSA9PT0gJ1RoaXNFeHByZXNzaW9uJykpIHtcbiAgICAgIGZ1bmN0aW9uTmFtZSA9IGFzdC5jYWxsZWUucHJvcGVydHkubmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXN0LmNhbGxlZS50eXBlID09PSAnU2VxdWVuY2VFeHByZXNzaW9uJyAmJiBhc3QuY2FsbGVlLmV4cHJlc3Npb25zWzBdLnR5cGUgPT09ICdMaXRlcmFsJyAmJiAhaXNOYU4oYXN0LmNhbGxlZS5leHByZXNzaW9uc1swXS5yYXcpKSB7XG4gICAgICBmdW5jdGlvbk5hbWUgPSBhc3QuY2FsbGVlLmV4cHJlc3Npb25zWzFdLnByb3BlcnR5Lm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bmN0aW9uTmFtZSA9IGFzdC5jYWxsZWUubmFtZTtcbiAgICB9XG5cbiAgICBpZiAoIWZ1bmN0aW9uTmFtZSkge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIGZ1bmN0aW9uLCBjb3VsZG4ndCBmaW5kIG5hbWVgLCBhc3QpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICBjYXNlICdwb3cnOlxuICAgICAgICBmdW5jdGlvbk5hbWUgPSAnX3Bvdyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncm91bmQnOlxuICAgICAgICBmdW5jdGlvbk5hbWUgPSAnX3JvdW5kJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2FsbGVkRnVuY3Rpb25zLmluZGV4T2YoZnVuY3Rpb25OYW1lKSA8IDApIHtcbiAgICAgIHRoaXMuY2FsbGVkRnVuY3Rpb25zLnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZnVuY3Rpb25OYW1lID09PSAncmFuZG9tJyAmJiB0aGlzLnBsdWdpbnMgJiYgdGhpcy5wbHVnaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tpXTtcbiAgICAgICAgaWYgKHBsdWdpbi5mdW5jdGlvbk1hdGNoID09PSAnTWF0aC5yYW5kb20oKScgJiYgcGx1Z2luLmZ1bmN0aW9uUmVwbGFjZSkge1xuICAgICAgICAgIHJldEFyci5wdXNoKHBsdWdpbi5mdW5jdGlvblJlcGxhY2UpO1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgdGhpcy5vbkZ1bmN0aW9uQ2FsbCh0aGlzLm5hbWUsIGZ1bmN0aW9uTmFtZSwgYXN0LmFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0QXJyLnB1c2goZnVuY3Rpb25OYW1lKTtcblxuICAgIHJldEFyci5wdXNoKCcoJyk7XG5cbiAgICBpZiAoaXNNYXRoRnVuY3Rpb24pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LmFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBhcmd1bWVudCA9IGFzdC5hcmd1bWVudHNbaV07XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50VHlwZSA9IHRoaXMuZ2V0VHlwZShhcmd1bWVudCk7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHJldEFyci5wdXNoKCcsICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChhcmd1bWVudFR5cGUpIHtcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICAgIHRoaXMuY2FzdFZhbHVlVG9GbG9hdChhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXRUeXBlcyA9IHRoaXMubG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzKGZ1bmN0aW9uTmFtZSkgfHwgW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5hcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgYXJndW1lbnQgPSBhc3QuYXJndW1lbnRzW2ldO1xuICAgICAgICBsZXQgdGFyZ2V0VHlwZSA9IHRhcmdldFR5cGVzW2ldO1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnLCAnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmd1bWVudFR5cGUgPSB0aGlzLmdldFR5cGUoYXJndW1lbnQpO1xuICAgICAgICBpZiAoIXRhcmdldFR5cGUpIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJJbXBseUFyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGksIGFyZ3VtZW50VHlwZSwgdGhpcyk7XG4gICAgICAgICAgdGFyZ2V0VHlwZSA9IGFyZ3VtZW50VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50VHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKCdpbnQoJyk7XG4gICAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFR5cGUgPT09ICdOdW1iZXInIHx8IHRhcmdldFR5cGUgPT09ICdGbG9hdCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuICAgICAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICAgIGlmICh0YXJnZXRUeXBlID09PSAnTnVtYmVyJyB8fCB0YXJnZXRUeXBlID09PSAnRmxvYXQnKSB7XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcbiAgICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0ludGVnZXIoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRUeXBlID09PSAnTnVtYmVyJyB8fCB0YXJnZXRUeXBlID09PSAnRmxvYXQnKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuICAgICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gYXJndW1lbnRUeXBlKSB7XG4gICAgICAgICAgICAgIGlmIChhcmd1bWVudC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8ke3V0aWxzLnNhbml0aXplTmFtZShhcmd1bWVudC5uYW1lKX1gKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudC50eXBlID09PSAnQXJyYXlFeHByZXNzaW9uJyB8fCBhcmd1bWVudC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgfHwgYXJndW1lbnQudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgYXJndW1lbnQgdHlwZSAkeyBhcmd1bWVudC50eXBlIH1gLCBhc3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnSFRNTENhbnZhcyc6XG4gICAgICAgICAgY2FzZSAnSFRNTEltYWdlJzpcbiAgICAgICAgICBjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG4gICAgICAgICAgY2FzZSAnSFRNTFZpZGVvJzpcbiAgICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMSknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG4gICAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoNCknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICBjYXNlICdJbnB1dCc6XG4gICAgICAgICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gYXJndW1lbnRUeXBlKSB7XG4gICAgICAgICAgICAgIGlmIChhcmd1bWVudC50eXBlICE9PSAnSWRlbnRpZmllcicpIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBhcmd1bWVudCB0eXBlICR7IGFyZ3VtZW50LnR5cGUgfWAsIGFzdCk7XG4gICAgICAgICAgICAgIHRoaXMudHJpZ2dlckltcGx5QXJndW1lbnRCaXRSYXRpbyh0aGlzLm5hbWUsIGFyZ3VtZW50Lm5hbWUsIGZ1bmN0aW9uTmFtZSwgaSk7XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB1dGlscy5zYW5pdGl6ZU5hbWUoYXJndW1lbnQubmFtZSk7XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7bmFtZX0sdXNlcl8ke25hbWV9U2l6ZSx1c2VyXyR7bmFtZX1EaW1gKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgYXJndW1lbnQgY29tYmluYXRpb24gb2YgJHsgYXJndW1lbnRUeXBlIH0gYW5kICR7IHRhcmdldFR5cGUgfSBmb3IgYXJndW1lbnQgbmFtZWQgXCIkeyBhcmd1bWVudC5uYW1lIH1cImAsIGFzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcpJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0QXJyYXlFeHByZXNzaW9uKGFyck5vZGUsIHJldEFycikge1xuICAgIGNvbnN0IGFyckxlbiA9IGFyck5vZGUuZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgcmV0QXJyLnB1c2goJ3ZlYycgKyBhcnJMZW4gKyAnKCcpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyTGVuOyArK2kpIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICByZXRBcnIucHVzaCgnLCAnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1Yk5vZGUgPSBhcnJOb2RlLmVsZW1lbnRzW2ldO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKHN1Yk5vZGUsIHJldEFycilcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyknKTtcblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBtZW1iZXJFeHByZXNzaW9uWFlaKHgsIHksIHosIHJldEFycikge1xuICAgIGlmICh6KSB7XG4gICAgICByZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cCh6KSwgJywgJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKCcwLCAnKTtcbiAgICB9XG4gICAgaWYgKHkpIHtcbiAgICAgIHJldEFyci5wdXNoKHRoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHkpLCAnLCAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goJzAsICcpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cCh4KSk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIG1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cChwcm9wZXJ0eSkge1xuICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgbm90IHNldCcpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKHByb3BlcnR5KTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIHRoaXMuY2FzdFZhbHVlVG9JbnRlZ2VyKHByb3BlcnR5LCByZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihwcm9wZXJ0eSwgcmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMocHJvcGVydHksIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gIH1cbn1cblxuY29uc3QgdHlwZU1hcCA9IHtcbiAgJ0FycmF5JzogJ3NhbXBsZXIyRCcsXG4gICdBcnJheSgyKSc6ICd2ZWMyJyxcbiAgJ0FycmF5KDMpJzogJ3ZlYzMnLFxuICAnQXJyYXkoNCknOiAndmVjNCcsXG4gICdBcnJheTJEJzogJ3NhbXBsZXIyRCcsXG4gICdBcnJheTNEJzogJ3NhbXBsZXIyRCcsXG4gICdCb29sZWFuJzogJ2Jvb2wnLFxuICAnRmxvYXQnOiAnZmxvYXQnLFxuICAnSW5wdXQnOiAnc2FtcGxlcjJEJyxcbiAgJ0ludGVnZXInOiAnaW50JyxcbiAgJ051bWJlcic6ICdmbG9hdCcsXG4gICdMaXRlcmFsSW50ZWdlcic6ICdmbG9hdCcsXG4gICdOdW1iZXJUZXh0dXJlJzogJ3NhbXBsZXIyRCcsXG4gICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogJ3NhbXBsZXIyRCcsXG4gICdBcnJheVRleHR1cmUoMSknOiAnc2FtcGxlcjJEJyxcbiAgJ0FycmF5VGV4dHVyZSgyKSc6ICdzYW1wbGVyMkQnLFxuICAnQXJyYXlUZXh0dXJlKDMpJzogJ3NhbXBsZXIyRCcsXG4gICdBcnJheVRleHR1cmUoNCknOiAnc2FtcGxlcjJEJyxcbiAgJ0hUTUxWaWRlbyc6ICdzYW1wbGVyMkQnLFxuICAnSFRNTENhbnZhcyc6ICdzYW1wbGVyMkQnLFxuICAnSFRNTEltYWdlJzogJ3NhbXBsZXIyRCcsXG4gICdIVE1MSW1hZ2VBcnJheSc6ICdzYW1wbGVyMkRBcnJheScsXG59O1xuXG5jb25zdCBvcGVyYXRvck1hcCA9IHtcbiAgJz09PSc6ICc9PScsXG4gICchPT0nOiAnIT0nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xGdW5jdGlvbk5vZGVcbn07XG59LHtcIi4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vZnVuY3Rpb24tbm9kZVwiOjEwfV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbiB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvYm9vbGVhbicpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRmxvYXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2Zsb2F0Jyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9pbnRlZ2VyJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvaHRtbC1pbWFnZScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUhUTUxWaWRlbyB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvaHRtbC12aWRlbycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlbyB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLXZpZGVvJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUlucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtaW5wdXQnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtaW5wdXQnKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvdW5zaWduZWQtaW5wdXQnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWlucHV0Jyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLW1lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvbnVtYmVyLXRleHR1cmUnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLW51bWJlci10ZXh0dXJlJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXknKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXknKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWknKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkxZC1pJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyZC1pJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MmQtaScpO1xuXG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M2QtaScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTNkLWknKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTMgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5NCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5NCcpO1xuXG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1hcnJheScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtYXJyYXknKTtcblxuY29uc3Qga2VybmVsVmFsdWVNYXBzID0ge1xuICB1bnNpZ25lZDoge1xuICAgIGR5bmFtaWM6IHtcbiAgICAgICdCb29sZWFuJzogV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnSW50ZWdlcic6IFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0Zsb2F0JzogV2ViR0xLZXJuZWxWYWx1ZUZsb2F0LFxuICAgICAgJ0FycmF5JzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogZmFsc2UsXG4gICAgICAnQXJyYXkoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheSg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCg0KSc6IGZhbHNlLFxuICAgICAgJ0lucHV0JzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDEpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgyKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDQpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gICAgICAnSFRNTENhbnZhcyc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZUFycmF5JzogZmFsc2UsXG4gICAgICAnSFRNTFZpZGVvJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8sXG4gICAgfSxcbiAgICBzdGF0aWM6IHtcbiAgICAgICdCb29sZWFuJzogV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnRmxvYXQnOiBXZWJHTEtlcm5lbFZhbHVlRmxvYXQsXG4gICAgICAnSW50ZWdlcic6IFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0FycmF5JzogV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXksXG4gICAgICAnQXJyYXkoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheSgzKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5KDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDQpJzogZmFsc2UsXG4gICAgICAnSW5wdXQnOiBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDEpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDQpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZSc6IFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBmYWxzZSxcbiAgICAgICdIVE1MVmlkZW8nOiBXZWJHTEtlcm5lbFZhbHVlSFRNTFZpZGVvLFxuICAgIH1cbiAgfSxcbiAgc2luZ2xlOiB7XG4gICAgZHluYW1pYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbixcbiAgICAgICdJbnRlZ2VyJzogV2ViR0xLZXJuZWxWYWx1ZUludGVnZXIsXG4gICAgICAnRmxvYXQnOiBXZWJHTEtlcm5lbFZhbHVlRmxvYXQsXG4gICAgICAnQXJyYXknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MixcbiAgICAgICdBcnJheSgzKSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTMsXG4gICAgICAnQXJyYXkoNCknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXk0LFxuICAgICAgJ0FycmF5MUQoMiknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoMyknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoNCknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MkQoMiknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoMyknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoNCknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5M0QoMiknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoMyknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoNCknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJLFxuICAgICAgJ0lucHV0JzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgxKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMiknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSg0KSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2UnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IGZhbHNlLFxuICAgICAgJ0hUTUxWaWRlbyc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvLFxuICAgIH0sXG4gICAgc3RhdGljOiB7XG4gICAgICAnQm9vbGVhbic6IFdlYkdMS2VybmVsVmFsdWVCb29sZWFuLFxuICAgICAgJ0Zsb2F0JzogV2ViR0xLZXJuZWxWYWx1ZUZsb2F0LFxuICAgICAgJ0ludGVnZXInOiBXZWJHTEtlcm5lbFZhbHVlSW50ZWdlcixcbiAgICAgICdBcnJheSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheSxcbiAgICAgICdBcnJheSgyKSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTIsXG4gICAgICAnQXJyYXkoMyknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzLFxuICAgICAgJ0FycmF5KDQpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5NCxcbiAgICAgICdBcnJheTFEKDIpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoMyknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREksXG4gICAgICAnQXJyYXkxRCg0KSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTJEKDIpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoMyknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREksXG4gICAgICAnQXJyYXkyRCg0KSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTNEKDIpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoMyknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREksXG4gICAgICAnQXJyYXkzRCg0KSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSxcbiAgICAgICdJbnB1dCc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDEpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDQpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZSc6IFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBmYWxzZSxcbiAgICAgICdIVE1MVmlkZW8nOiBXZWJHTEtlcm5lbFZhbHVlSFRNTFZpZGVvLFxuICAgIH1cbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGxvb2t1cEtlcm5lbFZhbHVlVHlwZSh0eXBlLCBkeW5hbWljLCBwcmVjaXNpb24sIHZhbHVlKSB7XG4gIGlmICghdHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKCFkeW5hbWljKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkeW5hbWljIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoIXByZWNpc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJlY2lzaW9uIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAodmFsdWUudHlwZSkge1xuICAgIHR5cGUgPSB2YWx1ZS50eXBlO1xuICB9XG4gIGNvbnN0IHR5cGVzID0ga2VybmVsVmFsdWVNYXBzW3ByZWNpc2lvbl1bZHluYW1pY107XG4gIGlmICh0eXBlc1t0eXBlXSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhIEtlcm5lbFZhbHVlIGZvciAkeyB0eXBlIH1gKTtcbiAgfVxuICByZXR1cm4gdHlwZXNbdHlwZV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb29rdXBLZXJuZWxWYWx1ZVR5cGUsXG4gIGtlcm5lbFZhbHVlTWFwcyxcbn07XG59LHtcIi4va2VybmVsLXZhbHVlL2Jvb2xlYW5cIjo0MSxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtaHRtbC1pbWFnZVwiOjQyLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLXZpZGVvXCI6NDMsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLW1lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmVcIjo0NCxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtbnVtYmVyLXRleHR1cmVcIjo0NSxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5XCI6NDYsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTFkLWlcIjo0NyxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MmQtaVwiOjQ4LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkzZC1pXCI6NDksXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1pbnB1dFwiOjUwLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1hcnJheVwiOjUxLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1pbnB1dFwiOjUyLFwiLi9rZXJuZWwtdmFsdWUvZmxvYXRcIjo1MyxcIi4va2VybmVsLXZhbHVlL2h0bWwtaW1hZ2VcIjo1NCxcIi4va2VybmVsLXZhbHVlL2h0bWwtdmlkZW9cIjo1NSxcIi4va2VybmVsLXZhbHVlL2ludGVnZXJcIjo1NyxcIi4va2VybmVsLXZhbHVlL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmVcIjo1OCxcIi4va2VybmVsLXZhbHVlL251bWJlci10ZXh0dXJlXCI6NTksXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXlcIjo2MCxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWlcIjo2MSxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJcIjo2MixcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWlcIjo2MyxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNcIjo2NCxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWlcIjo2NSxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTRcIjo2NixcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dFwiOjY3LFwiLi9rZXJuZWwtdmFsdWUvdW5zaWduZWQtYXJyYXlcIjo2OCxcIi4va2VybmVsLXZhbHVlL3Vuc2lnbmVkLWlucHV0XCI6Njl9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcbmNvbnN0IHsgSW5wdXQgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL2lucHV0Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlIHtcbiAgY2hlY2tTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIXRoaXMua2VybmVsLnZhbGlkYXRlKSByZXR1cm47XG4gICAgY29uc3QgeyBtYXhUZXh0dXJlU2l6ZSB9ID0gdGhpcy5rZXJuZWwuY29uc3RydWN0b3IuZmVhdHVyZXM7XG4gICAgaWYgKHdpZHRoID4gbWF4VGV4dHVyZVNpemUgfHwgaGVpZ2h0ID4gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIGlmICh3aWR0aCA+IGhlaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50IHRleHR1cmUgd2lkdGggb2YgJHt3aWR0aH0gbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplIG9mICR7bWF4VGV4dHVyZVNpemV9IGZvciB5b3VyIEdQVWApO1xuICAgICAgfSBlbHNlIGlmICh3aWR0aCA8IGhlaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50IHRleHR1cmUgaGVpZ2h0IG9mICR7aGVpZ2h0fSBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemUgb2YgJHttYXhUZXh0dXJlU2l6ZX0gZm9yIHlvdXIgR1BVYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50IHRleHR1cmUgaGVpZ2h0IGFuZCB3aWR0aCBvZiAke2hlaWdodH0gbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplIG9mICR7bWF4VGV4dHVyZVNpemV9IGZvciB5b3VyIEdQVWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldHVwKCkge1xuICAgIHRoaXMucmVxdWVzdFRleHR1cmUoKTtcbiAgICB0aGlzLnNldHVwVGV4dHVyZSgpO1xuICAgIHRoaXMuZGVmaW5lVGV4dHVyZSgpO1xuICB9XG5cbiAgcmVxdWVzdFRleHR1cmUoKSB7XG4gICAgdGhpcy50ZXh0dXJlID0gdGhpcy5vblJlcXVlc3RUZXh0dXJlKCk7XG4gIH1cblxuICBkZWZpbmVUZXh0dXJlKCkge1xuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgfVxuXG4gIHNldHVwVGV4dHVyZSgpIHtcbiAgICB0aGlzLmNvbnRleHRIYW5kbGUgPSB0aGlzLm9uUmVxdWVzdENvbnRleHRIYW5kbGUoKTtcbiAgICB0aGlzLmluZGV4ID0gdGhpcy5vblJlcXVlc3RJbmRleCgpO1xuICAgIHRoaXMuZGltZW5zaW9uc0lkID0gdGhpcy5pZCArICdEaW0nO1xuICAgIHRoaXMuc2l6ZUlkID0gdGhpcy5pZCArICdTaXplJztcbiAgfVxuXG4gIGdldEJpdFJhdGlvKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbMF0pKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCaXRSYXRpbyh2YWx1ZVswXSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gSW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJpdFJhdGlvKHZhbHVlLnZhbHVlKTtcbiAgICB9XG4gICAgc3dpdGNoICh2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBVaW50OENsYW1wZWRBcnJheTpcbiAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnByZXZBcmcpIHtcbiAgICAgIHRoaXMucHJldkFyZy5kZWxldGUoKTtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0LmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxBcnJheVxufTtcbn0se1wiLi4vLi4vLi4vaW5wdXRcIjoxMTAsXCIuL2luZGV4XCI6NTZ9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVCb29sZWFuIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGdldFNvdXJjZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHtcbiAgICAgIHJldHVybiBgY29uc3QgYm9vbCAke3RoaXMuaWR9ID0gJHt2YWx1ZX07XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGB1bmlmb3JtIGJvb2wgJHt0aGlzLmlkfTtcXG5gO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybjtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW5cbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9pbmRleFwiOjU2fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdmFsdWU7XG4gICAgdGhpcy5jaGVja1NpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gW3dpZHRoLCBoZWlnaHQsIDFdO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSBbd2lkdGgsIGhlaWdodF07XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaHRtbC1pbWFnZVwiOjU0fV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9keW5hbWljLWh0bWwtaW1hZ2UnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8gZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW9cbn07XG59LHtcIi4vZHluYW1pYy1odG1sLWltYWdlXCI6NDJ9XSw0NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKGlucHV0VGV4dHVyZSkge1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IGlucHV0VGV4dHVyZS5kaW1lbnNpb25zO1xuICAgIHRoaXMuY2hlY2tTaXplKGlucHV0VGV4dHVyZS5zaXplWzBdLCBpbnB1dFRleHR1cmUuc2l6ZVsxXSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IGlucHV0VGV4dHVyZS5zaXplO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUoaW5wdXRUZXh0dXJlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZVwiOjU4fV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4vbnVtYmVyLXRleHR1cmUnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB2YWx1ZS5kaW1lbnNpb25zO1xuICAgIHRoaXMuY2hlY2tTaXplKHZhbHVlLnNpemVbMF0sIHZhbHVlLnNpemVbMV0pO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB2YWx1ZS5zaXplO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmVcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9udW1iZXItdGV4dHVyZVwiOjU5fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IH0gPSByZXF1aXJlKCcuL3NpbmdsZS1hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiB0aGlzLmJpdFJhdGlvO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vc2luZ2xlLWFycmF5XCI6NjB9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgfSA9IHJlcXVpcmUoJy4vc2luZ2xlLWFycmF5MWQtaScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9zaW5nbGUtYXJyYXkxZC1pXCI6NjF9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4vc2luZ2xlLWFycmF5MmQtaScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9zaW5nbGUtYXJyYXkyZC1pXCI6NjN9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkgfSA9IHJlcXVpcmUoJy4vc2luZ2xlLWFycmF5M2QtaScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9zaW5nbGUtYXJyYXkzZC1pXCI6NjV9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlSW5wdXQgfSA9IHJlcXVpcmUoJy4vc2luZ2xlLWlucHV0Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlSW5wdXQgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlSW5wdXQge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBsZXQgW3csIGgsIGRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdyB8fCAxLCBoIHx8IDEsIGQgfHwgMV0pO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL3NpbmdsZS1pbnB1dFwiOjY3fV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXkgfSA9IHJlcXVpcmUoJy4vdW5zaWduZWQtYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkUGFja2VkVGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiAoNCAvIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIGNvbnN0IFR5cGUgPSB0aGlzLmdldFRyYW5zZmVyQXJyYXlUeXBlKHZhbHVlKTtcbiAgICB0aGlzLnByZVVwbG9hZFZhbHVlID0gbmV3IFR5cGUodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBVaW50OEFycmF5KHRoaXMucHJlVXBsb2FkVmFsdWUuYnVmZmVyKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vdW5zaWduZWQtYXJyYXlcIjo2OH1dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuL3Vuc2lnbmVkLWlucHV0Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgbGV0IFt3LCBoLCBkXSA9IHZhbHVlLnNpemU7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IEludDMyQXJyYXkoW3cgfHwgMSwgaCB8fCAxLCBkIHx8IDFdKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkUGFja2VkVGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiAoNCAvIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIGNvbnN0IFR5cGUgPSB0aGlzLmdldFRyYW5zZmVyQXJyYXlUeXBlKHZhbHVlLnZhbHVlKTtcbiAgICB0aGlzLnByZVVwbG9hZFZhbHVlID0gbmV3IFR5cGUodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBVaW50OEFycmF5KHRoaXMucHJlVXBsb2FkVmFsdWUuYnVmZmVyKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vdW5zaWduZWQtaW5wdXRcIjo2OX1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUZsb2F0IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfTtcXG5gO1xuICB9XG4gIGdldFNvdXJjZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHtcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYGNvbnN0IGZsb2F0ICR7dGhpcy5pZH0gPSAke3ZhbHVlfS4wO1xcbmA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYGNvbnN0IGZsb2F0ICR7dGhpcy5pZH0gPSAke3ZhbHVlfTtcXG5gO1xuICAgIH1cbiAgICByZXR1cm4gYHVuaWZvcm0gZmxvYXQgJHt0aGlzLmlkfTtcXG5gO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm47XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFmKHRoaXMuaWQsIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVGbG9hdFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2luZGV4XCI6NTZ9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHZhbHVlO1xuICAgIHRoaXMuY2hlY2tTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IFt3aWR0aCwgaGVpZ2h0LCAxXTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gW3dpZHRoLCBoZWlnaHRdO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfTtcXG5gO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKGlucHV0SW1hZ2UpIHtcbiAgICBpZiAoaW5wdXRJbWFnZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2goaW5wdXRJbWFnZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnVwbG9hZFZhbHVlID0gaW5wdXRJbWFnZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MH1dLDU1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVIVE1MVmlkZW8gZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlSFRNTFZpZGVvXG59O1xufSx7XCIuL2h0bWwtaW1hZ2VcIjo1NH1dLDU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEtlcm5lbFZhbHVlIH0gPSByZXF1aXJlKCcuLi8uLi9rZXJuZWwtdmFsdWUnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZSBleHRlbmRzIEtlcm5lbFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmRpbWVuc2lvbnNJZCA9IG51bGw7XG4gICAgdGhpcy5zaXplSWQgPSBudWxsO1xuICAgIHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICB0aGlzLm9uUmVxdWVzdFRleHR1cmUgPSBzZXR0aW5ncy5vblJlcXVlc3RUZXh0dXJlO1xuICAgIHRoaXMub25SZXF1ZXN0SW5kZXggPSBzZXR0aW5ncy5vblJlcXVlc3RJbmRleDtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gbnVsbDtcbiAgICB0aGlzLmJpdFJhdGlvID0gbnVsbDtcbiAgICB0aGlzLnByZXZBcmcgPSBudWxsO1xuICB9XG5cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9yaWdpbn1fJHt1dGlscy5zYW5pdGl6ZU5hbWUodGhpcy5uYW1lKX1gO1xuICB9XG5cbiAgc2V0dXAoKSB7fVxuXG4gIGdldFRyYW5zZmVyQXJyYXlUeXBlKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbMF0pKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2ZlckFycmF5VHlwZSh2YWx1ZVswXSk7XG4gICAgfVxuICAgIHN3aXRjaCAodmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgQXJyYXk6XG4gICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICBjYXNlIEludDhBcnJheTpcbiAgICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheTtcbiAgICAgIGNhc2UgVWludDhDbGFtcGVkQXJyYXk6XG4gICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgY2FzZSBVaW50MzJBcnJheTpcbiAgICAgIGNhc2UgRmxvYXQzMkFycmF5OlxuICAgICAgY2FzZSBGbG9hdDY0QXJyYXk6XG4gICAgICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKCdVbmZhbWlsaWFyIGNvbnN0cnVjdG9yIHR5cGUuICBXaWxsIGdvIGFoZWFkIGFuZCB1c2UsIGJ1dCBsaWtsZXkgdGhpcyBtYXkgcmVzdWx0IGluIGEgdHJhbnNmZXIgb2YgemVyb3MnKTtcbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3I7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImdldFN0cmluZ1ZhbHVlSGFuZGxlclwiIG5vdCBpbXBsZW1lbnRlZCBvbiAke3RoaXMuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmtlcm5lbC5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZyh0aGlzLnRleHR1cmVTaXplIHx8IHVuZGVmaW5lZCwgdGhpcy50YWN0aWMgfHwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi9rZXJuZWwtdmFsdWVcIjozNX1dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUludGVnZXIgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cbiAgZ2V0U291cmNlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgcmV0dXJuIGBjb25zdCBpbnQgJHt0aGlzLmlkfSA9ICR7IHBhcnNlSW50KHZhbHVlKSB9O1xcbmA7XG4gICAgfVxuICAgIHJldHVybiBgdW5pZm9ybSBpbnQgJHt0aGlzLmlkfTtcXG5gO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm47XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaW5kZXhcIjo1Nn1dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY29uc3Qgc2FtZUVycm9yID0gYFNvdXJjZSBhbmQgZGVzdGluYXRpb24gdGV4dHVyZXMgYXJlIHRoZSBzYW1lLiAgVXNlIGltbXV0YWJsZSA9IHRydWUgYW5kIG1hbnVhbGx5IGNsZWFudXAga2VybmVsIG91dHB1dCB0ZXh0dXJlIG1lbW9yeSB3aXRoIHRleHR1cmUuZGVsZXRlKClgO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHZhbHVlLnNpemU7XG4gICAgdGhpcy5jaGVja1NpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gdmFsdWUuZGltZW5zaW9ucztcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUudGV4dHVyZTtcbiAgICB0aGlzLmZvcmNlVXBsb2FkRWFjaFJ1biA9IHRydWU7XG4gIH1cblxuICBzZXR1cCgpIHtcbiAgICB0aGlzLnNldHVwVGV4dHVyZSgpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9LnRleHR1cmU7XFxuYDtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbnB1dFRleHR1cmUpIHtcbiAgICBpZiAoaW5wdXRUZXh0dXJlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaChpbnB1dFRleHR1cmUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGVja0NvbnRleHQgJiYgaW5wdXRUZXh0dXJlLmNvbnRleHQgIT09IHRoaXMuY29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSAke3RoaXMubmFtZX0gKCR7dGhpcy50eXBlfSkgbXVzdCBiZSBmcm9tIHNhbWUgY29udGV4dGApO1xuICAgIH1cblxuICAgIGNvbnN0IHsga2VybmVsLCBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBpZiAoa2VybmVsLnBpcGVsaW5lKSB7XG4gICAgICBpZiAoa2VybmVsLmltbXV0YWJsZSkge1xuICAgICAgICBrZXJuZWwudXBkYXRlVGV4dHVyZUFyZ3VtZW50UmVmcyh0aGlzLCBpbnB1dFRleHR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGtlcm5lbC50ZXh0dXJlLnRleHR1cmUgPT09IGlucHV0VGV4dHVyZS50ZXh0dXJlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNhbWVFcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoa2VybmVsLm1hcHBlZFRleHR1cmVzKSB7XG4gICAgICAgICAgY29uc3QgeyBtYXBwZWRUZXh0dXJlcyB9ID0ga2VybmVsO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcGVkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChtYXBwZWRUZXh0dXJlc1tpXS50ZXh0dXJlID09PSBpbnB1dFRleHR1cmUudGV4dHVyZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2FtZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy51cGxvYWRWYWx1ZSA9IGlucHV0VGV4dHVyZS50ZXh0dXJlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICBzYW1lRXJyb3Jcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuY29uc3QgeyBzYW1lRXJyb3IgfSA9IHJlcXVpcmUoJy4vbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHZhbHVlLnNpemU7XG4gICAgdGhpcy5jaGVja1NpemUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgeyBzaXplOiB0ZXh0dXJlU2l6ZSwgZGltZW5zaW9ucyB9ID0gdmFsdWU7XG4gICAgdGhpcy5iaXRSYXRpbyA9IHRoaXMuZ2V0Qml0UmF0aW8odmFsdWUpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IGRpbWVuc2lvbnM7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHRleHR1cmVTaXplO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZS50ZXh0dXJlO1xuICAgIHRoaXMuZm9yY2VVcGxvYWRFYWNoUnVuID0gdHJ1ZTtcbiAgfVxuXG4gIHNldHVwKCkge1xuICAgIHRoaXMuc2V0dXBUZXh0dXJlKCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX0udGV4dHVyZTtcXG5gO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKGlucHV0VGV4dHVyZSkge1xuICAgIGlmIChpbnB1dFRleHR1cmUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKGlucHV0VGV4dHVyZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmNoZWNrQ29udGV4dCAmJiBpbnB1dFRleHR1cmUuY29udGV4dCAhPT0gdGhpcy5jb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlICR7dGhpcy5uYW1lfSAoJHt0aGlzLnR5cGV9KSBtdXN0IGJlIGZyb20gc2FtZSBjb250ZXh0YCk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBrZXJuZWwsIGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGlmIChrZXJuZWwucGlwZWxpbmUpIHtcbiAgICAgIGlmIChrZXJuZWwuaW1tdXRhYmxlKSB7XG4gICAgICAgIGtlcm5lbC51cGRhdGVUZXh0dXJlQXJndW1lbnRSZWZzKHRoaXMsIGlucHV0VGV4dHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2VybmVsLnRleHR1cmUudGV4dHVyZSA9PT0gaW5wdXRUZXh0dXJlLnRleHR1cmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2FtZUVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXJuZWwubWFwcGVkVGV4dHVyZXMpIHtcbiAgICAgICAgICBjb25zdCB7IG1hcHBlZFRleHR1cmVzIH0gPSBrZXJuZWw7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBwZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1hcHBlZFRleHR1cmVzW2ldLnRleHR1cmUgPT09IGlucHV0VGV4dHVyZS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzYW1lRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnVwbG9hZFZhbHVlID0gaW5wdXRUZXh0dXJlLnRleHR1cmUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmVcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwLFwiLi9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlXCI6NTh9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuYml0UmF0aW8gPSA0O1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IHV0aWxzLmdldERpbWVuc2lvbnModmFsdWUsIHRydWUpO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3IEZsb2F0MzJBcnJheSgke3RoaXMudXBsb2FkQXJyYXlMZW5ndGh9KWAsXG4gICAgICBgZmxhdHRlblRvKCR7dGhpcy52YXJOYW1lfSwgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9KWAsXG4gICAgXSk7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuVG8odmFsdWUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDB9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuYml0UmF0aW8gPSA0O1xuICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICB9XG5cbiAgc2V0U2hhcGUodmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZURpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh2YWx1ZURpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBJbnQzMkFycmF5KFt2YWx1ZURpbWVuc2lvbnNbMV0sIDEsIDFdKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiB0aGlzLmJpdFJhdGlvO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSBuZXcgRmxvYXQzMkFycmF5KCR7dGhpcy51cGxvYWRBcnJheUxlbmd0aH0pYCxcbiAgICAgIGBmbGF0dGVuVG8oJHt0aGlzLnZhck5hbWV9LCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW4yZEFycmF5VG8odmFsdWUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDB9XSw2MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTIgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZ2V0U291cmNlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgcmV0dXJuIGBjb25zdCB2ZWMyICR7dGhpcy5pZH0gPSB2ZWMyKCR7dmFsdWVbMF19LCR7dmFsdWVbMV19KTtcXG5gO1xuICAgIH1cbiAgICByZXR1cm4gYHVuaWZvcm0gdmVjMiAke3RoaXMuaWR9O1xcbmA7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuICcnO1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybjtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMmZ2KHRoaXMuaWQsIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9pbmRleFwiOjU2fV0sNjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmJpdFJhdGlvID0gNDtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgfVxuXG4gIHNldFNoYXBlKHZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVEaW1lbnNpb25zID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUodmFsdWVEaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdmFsdWVEaW1lbnNpb25zWzFdLCB2YWx1ZURpbWVuc2lvbnNbMl0sIDFdKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiB0aGlzLmJpdFJhdGlvO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSBuZXcgRmxvYXQzMkFycmF5KCR7dGhpcy51cGxvYWRBcnJheUxlbmd0aH0pYCxcbiAgICAgIGBmbGF0dGVuVG8oJHt0aGlzLnZhck5hbWV9LCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW4zZEFycmF5VG8odmFsdWUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDB9XSw2NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTMgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZ2V0U291cmNlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgcmV0dXJuIGBjb25zdCB2ZWMzICR7dGhpcy5pZH0gPSB2ZWMzKCR7dmFsdWVbMF19LCR7dmFsdWVbMV19LCR7dmFsdWVbMl19KTtcXG5gO1xuICAgIH1cbiAgICByZXR1cm4gYHVuaWZvcm0gdmVjMyAke3RoaXMuaWR9O1xcbmA7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuICcnO1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybjtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2Z2KHRoaXMuaWQsIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9pbmRleFwiOjU2fV0sNjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmJpdFJhdGlvID0gNDtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgfVxuXG4gIHNldFNoYXBlKHZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVEaW1lbnNpb25zID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUodmFsdWVEaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdmFsdWVEaW1lbnNpb25zWzFdLCB2YWx1ZURpbWVuc2lvbnNbMl0sIHZhbHVlRGltZW5zaW9uc1szXV0pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyBGbG9hdDMyQXJyYXkoJHt0aGlzLnVwbG9hZEFycmF5TGVuZ3RofSlgLFxuICAgICAgYGZsYXR0ZW5Ubygke3RoaXMudmFyTmFtZX0sIHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlbjRkQXJyYXlUbyh2YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MH1dLDY2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5NCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBnZXRTb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSB7XG4gICAgICByZXR1cm4gYGNvbnN0IHZlYzQgJHt0aGlzLmlkfSA9IHZlYzQoJHt2YWx1ZVswXX0sJHt2YWx1ZVsxXX0sJHt2YWx1ZVsyXX0sJHt2YWx1ZVszXX0pO1xcbmA7XG4gICAgfVxuICAgIHJldHVybiBgdW5pZm9ybSB2ZWM0ICR7dGhpcy5pZH07XFxuYDtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX07XFxuYDtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm00ZnYodGhpcy5pZCwgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5NFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2luZGV4XCI6NTZ9XSw2NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuYml0UmF0aW8gPSA0O1xuICAgIGxldCBbdywgaCwgZF0gPSB2YWx1ZS5zaXplO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBJbnQzMkFycmF5KFt3IHx8IDEsIGggfHwgMSwgZCB8fCAxXSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiB0aGlzLmJpdFJhdGlvO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSBuZXcgRmxvYXQzMkFycmF5KCR7dGhpcy51cGxvYWRBcnJheUxlbmd0aH0pYCxcbiAgICAgIGBmbGF0dGVuVG8oJHt0aGlzLnZhck5hbWV9LnZhbHVlLCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbnB1dCkge1xuICAgIGlmIChpbnB1dC5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2goaW5wdXQuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW5UbyhpbnB1dC52YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUlucHV0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MH1dLDY4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmJpdFJhdGlvID0gdGhpcy5nZXRCaXRSYXRpbyh2YWx1ZSk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZFBhY2tlZFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogKDQgLyB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLlRyYW5zZXJBcnJheVR5cGUgPSB0aGlzLmdldFRyYW5zZmVyQXJyYXlUeXBlKHZhbHVlKTtcbiAgICB0aGlzLnByZVVwbG9hZFZhbHVlID0gbmV3IHRoaXMuVHJhbnNlckFycmF5VHlwZSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5wcmVVcGxvYWRWYWx1ZS5idWZmZXIpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGBjb25zdCBwcmVVcGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSBuZXcgJHt0aGlzLlRyYW5zZXJBcnJheVR5cGUubmFtZX0oJHt0aGlzLnVwbG9hZEFycmF5TGVuZ3RofSlgLFxuICAgICAgYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyBVaW50OEFycmF5KHByZVVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfS5idWZmZXIpYCxcbiAgICAgIGBmbGF0dGVuVG8oJHt0aGlzLnZhck5hbWV9LCBwcmVVcGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW5Ubyh2YWx1ZSwgdGhpcy5wcmVVcGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRBcnJheVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDB9XSw2OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5iaXRSYXRpbyA9IHRoaXMuZ2V0Qml0UmF0aW8odmFsdWUpO1xuICAgIGNvbnN0IFt3LCBoLCBkXSA9IHZhbHVlLnNpemU7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IEludDMyQXJyYXkoW3cgfHwgMSwgaCB8fCAxLCBkIHx8IDFdKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkUGFja2VkVGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiAoNCAvIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMuVHJhbnNlckFycmF5VHlwZSA9IHRoaXMuZ2V0VHJhbnNmZXJBcnJheVR5cGUodmFsdWUudmFsdWUpO1xuICAgIHRoaXMucHJlVXBsb2FkVmFsdWUgPSBuZXcgdGhpcy5UcmFuc2VyQXJyYXlUeXBlKHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgVWludDhBcnJheSh0aGlzLnByZVVwbG9hZFZhbHVlLmJ1ZmZlcik7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYGNvbnN0IHByZVVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyAke3RoaXMuVHJhbnNlckFycmF5VHlwZS5uYW1lfSgke3RoaXMudXBsb2FkQXJyYXlMZW5ndGh9KWAsXG4gICAgICBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3IFVpbnQ4QXJyYXkocHJlVXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9LmJ1ZmZlcilgLFxuICAgICAgYGZsYXR0ZW5Ubygke3RoaXMudmFyTmFtZX0udmFsdWUsIHByZVVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKGlucHV0KSB7XG4gICAgaWYgKGlucHV0LmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKGlucHV0LnZhbHVlLCB0aGlzLnByZVVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MH1dLDcwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4uL2dsL2tlcm5lbCcpO1xuY29uc3QgeyBGdW5jdGlvbkJ1aWxkZXIgfSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uLWJ1aWxkZXInKTtcbmNvbnN0IHsgV2ViR0xGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tbm9kZScpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IG1ydWQgPSByZXF1aXJlKCcuLi8uLi9wbHVnaW5zL21hdGgtcmFuZG9tLXVuaWZvcm1seS1kaXN0cmlidXRlZCcpO1xuY29uc3QgeyBmcmFnbWVudFNoYWRlciB9ID0gcmVxdWlyZSgnLi9mcmFnbWVudC1zaGFkZXInKTtcbmNvbnN0IHsgdmVydGV4U2hhZGVyIH0gPSByZXF1aXJlKCcuL3ZlcnRleC1zaGFkZXInKTtcbmNvbnN0IHsgZ2xLZXJuZWxTdHJpbmcgfSA9IHJlcXVpcmUoJy4uL2dsL2tlcm5lbC1zdHJpbmcnKTtcbmNvbnN0IHsgbG9va3VwS2VybmVsVmFsdWVUeXBlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS1tYXBzJyk7XG5cbmxldCBpc1N1cHBvcnRlZCA9IG51bGw7XG5sZXQgdGVzdENhbnZhcyA9IG51bGw7XG5sZXQgdGVzdENvbnRleHQgPSBudWxsO1xubGV0IHRlc3RFeHRlbnNpb25zID0gbnVsbDtcbmxldCBmZWF0dXJlcyA9IG51bGw7XG5cbmNvbnN0IHBsdWdpbnMgPSBbbXJ1ZF07XG5jb25zdCBjYW52YXNlcyA9IFtdO1xuY29uc3QgbWF4VGV4U2l6ZXMgPSB7fTtcblxuXG5jbGFzcyBXZWJHTEtlcm5lbCBleHRlbmRzIEdMS2VybmVsIHtcbiAgc3RhdGljIGdldCBpc1N1cHBvcnRlZCgpIHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgICB9XG4gICAgdGhpcy5zZXR1cEZlYXR1cmVDaGVja3MoKTtcbiAgICBpc1N1cHBvcnRlZCA9IHRoaXMuaXNDb250ZXh0TWF0Y2godGVzdENvbnRleHQpO1xuICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHN0YXRpYyBzZXR1cEZlYXR1cmVDaGVja3MoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRlc3RDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0ZXN0Q2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygwLCAwKTtcbiAgICB9XG4gICAgaWYgKCF0ZXN0Q2FudmFzKSByZXR1cm47XG4gICAgdGVzdENvbnRleHQgPSB0ZXN0Q2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHwgdGVzdENhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKTtcbiAgICBpZiAoIXRlc3RDb250ZXh0IHx8ICF0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24pIHJldHVybjtcbiAgICB0ZXN0RXh0ZW5zaW9ucyA9IHtcbiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0OiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JyksXG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXI6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyksXG4gICAgICBPRVNfZWxlbWVudF9pbmRleF91aW50OiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSxcbiAgICAgIFdFQkdMX2RyYXdfYnVmZmVyczogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKSxcbiAgICB9O1xuICAgIGZlYXR1cmVzID0gdGhpcy5nZXRGZWF0dXJlcygpO1xuICB9XG5cbiAgc3RhdGljIGlzQ29udGV4dE1hdGNoKGNvbnRleHQpIHtcbiAgICBpZiAodHlwZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBjb250ZXh0IGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgZ2V0SXNUZXh0dXJlRmxvYXQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGVzdEV4dGVuc2lvbnMuT0VTX3RleHR1cmVfZmxvYXQpO1xuICB9XG5cbiAgc3RhdGljIGdldElzRHJhd0J1ZmZlcnMoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGVzdEV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRDaGFubmVsQ291bnQoKSB7XG4gICAgcmV0dXJuIHRlc3RFeHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycyA/XG4gICAgICB0ZXN0Q29udGV4dC5nZXRQYXJhbWV0ZXIodGVzdEV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzLk1BWF9EUkFXX0JVRkZFUlNfV0VCR0wpIDpcbiAgICAgIDE7XG4gIH1cblxuICBzdGF0aWMgZ2V0TWF4VGV4dHVyZVNpemUoKSB7XG4gICAgcmV0dXJuIHRlc3RDb250ZXh0LmdldFBhcmFtZXRlcih0ZXN0Q29udGV4dC5NQVhfVEVYVFVSRV9TSVpFKTtcbiAgfVxuXG4gIHN0YXRpYyBsb29rdXBLZXJuZWxWYWx1ZVR5cGUodHlwZSwgZHluYW1pYywgcHJlY2lzaW9uLCB2YWx1ZSkge1xuICAgIHJldHVybiBsb29rdXBLZXJuZWxWYWx1ZVR5cGUodHlwZSwgZHluYW1pYywgcHJlY2lzaW9uLCB2YWx1ZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlc3RDYW52YXMoKSB7XG4gICAgcmV0dXJuIHRlc3RDYW52YXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlc3RDb250ZXh0KCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgc3RhdGljIGdldCBmcmFnbWVudFNoYWRlcigpIHtcbiAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHZlcnRleFNoYWRlcigpIHtcbiAgICByZXR1cm4gdmVydGV4U2hhZGVyO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioc291cmNlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHNvdXJjZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgdGhpcy5waXBlbGluZSA9IHNldHRpbmdzLnBpcGVsaW5lO1xuICAgIHRoaXMuZW5kaWFubmVzcyA9IHV0aWxzLnN5c3RlbUVuZGlhbm5lc3MoKTtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLmFyZ3VtZW50VGV4dHVyZUNvdW50ID0gMDtcbiAgICB0aGlzLmNvbnN0YW50VGV4dHVyZUNvdW50ID0gMDtcbiAgICB0aGlzLmZyYWdTaGFkZXIgPSBudWxsO1xuICAgIHRoaXMudmVydFNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5kcmF3QnVmZmVyc01hcCA9IG51bGw7XG5cbiAgICB0aGlzLm1heFRleFNpemUgPSBudWxsO1xuICAgIHRoaXMub25SZXF1ZXN0U3dpdGNoS2VybmVsID0gbnVsbDtcbiAgICB0aGlzLnJlbW92ZUlzdGFuYnVsQ292ZXJhZ2UgPSB0cnVlO1xuXG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLm1hcHBlZFRleHR1cmVzID0gbnVsbDtcbiAgICB0aGlzLm1lcmdlU2V0dGluZ3Moc291cmNlLnNldHRpbmdzIHx8IHNldHRpbmdzKTtcblxuICAgIHRoaXMudGhyZWFkRGltID0gbnVsbDtcbiAgICB0aGlzLmZyYW1lYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG5cbiAgICB0aGlzLnRleHR1cmVDYWNoZSA9IFtdO1xuICAgIHRoaXMucHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtMWZDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTFpQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm0yZkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtMmZ2Q2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm0yaXZDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTNmdkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtM2l2Q2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm00ZnZDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTRpdkNhY2hlID0ge307XG4gIH1cblxuICBpbml0Q2FudmFzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IDI7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gMjtcbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMCwgMCk7XG4gICAgfVxuICB9XG5cbiAgaW5pdENvbnRleHQoKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICBhbHBoYTogZmFsc2UsXG4gICAgICBkZXB0aDogZmFsc2UsXG4gICAgICBhbnRpYWxpYXM6IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBzZXR0aW5ncykgfHwgdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgc2V0dGluZ3MpO1xuICB9XG5cbiAgaW5pdFBsdWdpbnMoc2V0dGluZ3MpIHtcbiAgICBjb25zdCBwbHVnaW5zVG9Vc2UgPSBbXTtcbiAgICBjb25zdCB7IHNvdXJjZSB9ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgICAgICBpZiAoc291cmNlLm1hdGNoKHBsdWdpbi5mdW5jdGlvbk1hdGNoKSkge1xuICAgICAgICAgIHBsdWdpbnNUb1VzZS5wdXNoKHBsdWdpbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoc2V0dGluZ3MucGx1Z2luTmFtZXMpIHsgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICAgICAgY29uc3QgdXNlUGx1Z2luID0gc2V0dGluZ3MucGx1Z2luTmFtZXMuc29tZShwbHVnaW5OYW1lID0+IHBsdWdpbk5hbWUgPT09IHBsdWdpbi5uYW1lKTtcbiAgICAgICAgICBpZiAodXNlUGx1Z2luKSB7XG4gICAgICAgICAgICBwbHVnaW5zVG9Vc2UucHVzaChwbHVnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGx1Z2luc1RvVXNlO1xuICB9XG5cbiAgaW5pdEV4dGVuc2lvbnMoKSB7XG4gICAgdGhpcy5leHRlbnNpb25zID0ge1xuICAgICAgT0VTX3RleHR1cmVfZmxvYXQ6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JyksXG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXI6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpLFxuICAgICAgT0VTX2VsZW1lbnRfaW5kZXhfdWludDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpLFxuICAgICAgV0VCR0xfZHJhd19idWZmZXJzOiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKSxcbiAgICAgIFdFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JyksXG4gICAgfTtcbiAgfVxuXG4gIHZhbGlkYXRlU2V0dGluZ3MoYXJncykge1xuICAgIGlmICghdGhpcy52YWxpZGF0ZSkge1xuICAgICAgdGhpcy50ZXhTaXplID0gdXRpbHMuZ2V0S2VybmVsVGV4dHVyZVNpemUoe1xuICAgICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICAgIHByZWNpc2lvbjogdGhpcy5wcmVjaXNpb24sXG4gICAgICB9LCB0aGlzLm91dHB1dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBmZWF0dXJlcyB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuICAgIGlmICh0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkgPT09IHRydWUgJiYgIWZlYXR1cmVzLmlzVGV4dHVyZUZsb2F0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zsb2F0IHRleHR1cmVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScgJiYgIWZlYXR1cmVzLmlzRmxvYXRSZWFkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpbmdsZSBwcmVjaXNpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZ3JhcGhpY2FsICYmIHRoaXMucHJlY2lzaW9uID09PSBudWxsICYmIGZlYXR1cmVzLmlzVGV4dHVyZUZsb2F0KSB7XG4gICAgICB0aGlzLnByZWNpc2lvbiA9IGZlYXR1cmVzLmlzRmxvYXRSZWFkID8gJ3NpbmdsZScgOiAndW5zaWduZWQnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgJiYgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aCA+IDAgJiYgIXRoaXMuZXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IGluc3RhbnRpYXRlIGRyYXcgYnVmZmVycyBleHRlbnNpb24nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9ICFmZWF0dXJlcy5pc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSAmJiBmZWF0dXJlcy5pc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlKSB7XG4gICAgICB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja091dHB1dCgpO1xuXG4gICAgaWYgKCF0aGlzLm91dHB1dCB8fCB0aGlzLm91dHB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dG8gb3V0cHV0IG9ubHkgc3VwcG9ydGVkIGZvciBrZXJuZWxzIHdpdGggb25seSBvbmUgaW5wdXQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXJnVHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZShhcmdzWzBdLCB0aGlzLnN0cmljdEludGVnZXJzKTtcbiAgICAgIHN3aXRjaCAoYXJnVHlwZSkge1xuICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgdGhpcy5vdXRwdXQgPSB1dGlscy5nZXREaW1lbnNpb25zKGFyZ1R5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdOdW1iZXJUZXh0dXJlJzpcbiAgICAgICAgY2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG4gICAgICAgICAgdGhpcy5vdXRwdXQgPSBhcmdzWzBdLm91dHB1dDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dG8gb3V0cHV0IG5vdCBzdXBwb3J0ZWQgZm9yIGlucHV0IHR5cGU6ICcgKyBhcmdUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcbiAgICAgIGlmICh0aGlzLm91dHB1dC5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdXRwdXQgbXVzdCBoYXZlIDIgZGltZW5zaW9ucyBvbiBncmFwaGljYWwgbW9kZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdwcmVjaXNpb24nKSB7XG4gICAgICAgIHRoaXMucHJlY2lzaW9uID0gJ3Vuc2lnbmVkJztcbiAgICAgICAgY29uc29sZS53YXJuKCdDYW5ub3QgdXNlIGdyYXBoaWNhbCBtb2RlIGFuZCBzaW5nbGUgcHJlY2lzaW9uIGF0IHRoZSBzYW1lIHRpbWUnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXhTaXplID0gdXRpbHMuY2xvbmUodGhpcy5vdXRwdXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcmVjaXNpb24gPT09IG51bGwgJiYgZmVhdHVyZXMuaXNUZXh0dXJlRmxvYXQpIHtcbiAgICAgIHRoaXMucHJlY2lzaW9uID0gJ3NpbmdsZSc7XG4gICAgfVxuXG4gICAgdGhpcy50ZXhTaXplID0gdXRpbHMuZ2V0S2VybmVsVGV4dHVyZVNpemUoe1xuICAgICAgb3B0aW1pemVGbG9hdE1lbW9yeTogdGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgICAgcHJlY2lzaW9uOiB0aGlzLnByZWNpc2lvbixcbiAgICB9LCB0aGlzLm91dHB1dCk7XG5cbiAgICB0aGlzLmNoZWNrVGV4dHVyZVNpemUoKTtcbiAgfVxuXG4gIHVwZGF0ZU1heFRleFNpemUoKSB7XG4gICAgY29uc3QgeyB0ZXhTaXplLCBjYW52YXMgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMubWF4VGV4U2l6ZSA9PT0gbnVsbCkge1xuICAgICAgbGV0IGNhbnZhc0luZGV4ID0gY2FudmFzZXMuaW5kZXhPZihjYW52YXMpO1xuICAgICAgaWYgKGNhbnZhc0luZGV4ID09PSAtMSkge1xuICAgICAgICBjYW52YXNJbmRleCA9IGNhbnZhc2VzLmxlbmd0aDtcbiAgICAgICAgY2FudmFzZXMucHVzaChjYW52YXMpO1xuICAgICAgICBtYXhUZXhTaXplc1tjYW52YXNJbmRleF0gPSBbdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXV07XG4gICAgICB9XG4gICAgICB0aGlzLm1heFRleFNpemUgPSBtYXhUZXhTaXplc1tjYW52YXNJbmRleF07XG4gICAgfVxuICAgIGlmICh0aGlzLm1heFRleFNpemVbMF0gPCB0ZXhTaXplWzBdKSB7XG4gICAgICB0aGlzLm1heFRleFNpemVbMF0gPSB0ZXhTaXplWzBdO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhUZXhTaXplWzFdIDwgdGV4U2l6ZVsxXSkge1xuICAgICAgdGhpcy5tYXhUZXhTaXplWzFdID0gdGV4U2l6ZVsxXTtcbiAgICB9XG4gIH1cblxuICBzZXR1cEFyZ3VtZW50cyhhcmdzKSB7XG4gICAgdGhpcy5rZXJuZWxBcmd1bWVudHMgPSBbXTtcbiAgICB0aGlzLmFyZ3VtZW50VGV4dHVyZUNvdW50ID0gMDtcbiAgICBjb25zdCBuZWVkc0FyZ3VtZW50VHlwZXMgPSB0aGlzLmFyZ3VtZW50VHlwZXMgPT09IG51bGw7XG4gICAgaWYgKG5lZWRzQXJndW1lbnRUeXBlcykge1xuICAgICAgdGhpcy5hcmd1bWVudFR5cGVzID0gW107XG4gICAgfVxuICAgIHRoaXMuYXJndW1lbnRTaXplcyA9IFtdO1xuICAgIHRoaXMuYXJndW1lbnRCaXRSYXRpb3MgPSBbXTtcblxuICAgIGlmIChhcmdzLmxlbmd0aCA8IHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGVub3VnaCBhcmd1bWVudHMgZm9yIGtlcm5lbCcpO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPiB0aGlzLmFyZ3VtZW50TmFtZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBtYW55IGFyZ3VtZW50cyBmb3Iga2VybmVsJyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBsZXQgdGV4dHVyZUluZGV4ZXMgPSAwO1xuXG4gICAgY29uc3Qgb25SZXF1ZXN0VGV4dHVyZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUmVxdWVzdEluZGV4ID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRleHR1cmVJbmRleGVzKys7XG4gICAgfTtcbiAgICBjb25zdCBvblVwZGF0ZVZhbHVlTWlzbWF0Y2ggPSAoY29uc3RydWN0b3IpID0+IHtcbiAgICAgIHRoaXMuc3dpdGNoS2VybmVscyh7XG4gICAgICAgIHR5cGU6ICdhcmd1bWVudE1pc21hdGNoJyxcbiAgICAgICAgbmVlZGVkOiBjb25zdHJ1Y3RvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvblJlcXVlc3RDb250ZXh0SGFuZGxlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudFRleHR1cmVDb3VudCArIHRoaXMuYXJndW1lbnRUZXh0dXJlQ291bnQrKztcbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFyZ3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgY29uc3QgbmFtZSA9IHRoaXMuYXJndW1lbnROYW1lc1tpbmRleF07XG4gICAgICBsZXQgdHlwZTtcbiAgICAgIGlmIChuZWVkc0FyZ3VtZW50VHlwZXMpIHtcbiAgICAgICAgdHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZSh2YWx1ZSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICAgIHRoaXMuYXJndW1lbnRUeXBlcy5wdXNoKHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHRoaXMuYXJndW1lbnRUeXBlc1tpbmRleF07XG4gICAgICB9XG4gICAgICBjb25zdCBLZXJuZWxWYWx1ZSA9IHRoaXMuY29uc3RydWN0b3IubG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIHRoaXMuZHluYW1pY0FyZ3VtZW50cyA/ICdkeW5hbWljJyA6ICdzdGF0aWMnLCB0aGlzLnByZWNpc2lvbiwgYXJnc1tpbmRleF0pO1xuICAgICAgaWYgKEtlcm5lbFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RGYWxsYmFjayhhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtlcm5lbEFyZ3VtZW50ID0gbmV3IEtlcm5lbFZhbHVlKHZhbHVlLCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRhY3RpYzogdGhpcy50YWN0aWMsXG4gICAgICAgIG9yaWdpbjogJ3VzZXInLFxuICAgICAgICBjb250ZXh0OiBnbCxcbiAgICAgICAgY2hlY2tDb250ZXh0OiB0aGlzLmNoZWNrQ29udGV4dCxcbiAgICAgICAga2VybmVsOiB0aGlzLFxuICAgICAgICBzdHJpY3RJbnRlZ2VyczogdGhpcy5zdHJpY3RJbnRlZ2VycyxcbiAgICAgICAgb25SZXF1ZXN0VGV4dHVyZSxcbiAgICAgICAgb25SZXF1ZXN0SW5kZXgsXG4gICAgICAgIG9uVXBkYXRlVmFsdWVNaXNtYXRjaCxcbiAgICAgICAgb25SZXF1ZXN0Q29udGV4dEhhbmRsZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5rZXJuZWxBcmd1bWVudHMucHVzaChrZXJuZWxBcmd1bWVudCk7XG4gICAgICBrZXJuZWxBcmd1bWVudC5zZXR1cCgpO1xuICAgICAgdGhpcy5hcmd1bWVudFNpemVzLnB1c2goa2VybmVsQXJndW1lbnQudGV4dHVyZVNpemUpO1xuICAgICAgdGhpcy5hcmd1bWVudEJpdFJhdGlvc1tpbmRleF0gPSBrZXJuZWxBcmd1bWVudC5iaXRSYXRpbztcbiAgICB9XG4gIH1cblxuICBjcmVhdGVUZXh0dXJlKCkge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmNvbnRleHQuY3JlYXRlVGV4dHVyZSgpO1xuICAgIHRoaXMudGV4dHVyZUNhY2hlLnB1c2godGV4dHVyZSk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cblxuICBzZXR1cENvbnN0YW50cyhhcmdzKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB0aGlzLmtlcm5lbENvbnN0YW50cyA9IFtdO1xuICAgIHRoaXMuZm9yY2VVcGxvYWRLZXJuZWxDb25zdGFudHMgPSBbXTtcbiAgICBsZXQgbmVlZHNDb25zdGFudFR5cGVzID0gdGhpcy5jb25zdGFudFR5cGVzID09PSBudWxsO1xuICAgIGlmIChuZWVkc0NvbnN0YW50VHlwZXMpIHtcbiAgICAgIHRoaXMuY29uc3RhbnRUeXBlcyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmNvbnN0YW50Qml0UmF0aW9zID0ge307XG4gICAgbGV0IHRleHR1cmVJbmRleGVzID0gMDtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5jb25zdGFudHMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jb25zdGFudHNbbmFtZV07XG4gICAgICBsZXQgdHlwZTtcbiAgICAgIGlmIChuZWVkc0NvbnN0YW50VHlwZXMpIHtcbiAgICAgICAgdHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZSh2YWx1ZSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICAgIHRoaXMuY29uc3RhbnRUeXBlc1tuYW1lXSA9IHR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gdGhpcy5jb25zdGFudFR5cGVzW25hbWVdO1xuICAgICAgfVxuICAgICAgY29uc3QgS2VybmVsVmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLmxvb2t1cEtlcm5lbFZhbHVlVHlwZSh0eXBlLCAnc3RhdGljJywgdGhpcy5wcmVjaXNpb24sIHZhbHVlKTtcbiAgICAgIGlmIChLZXJuZWxWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RmFsbGJhY2soYXJncyk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXJuZWxWYWx1ZSA9IG5ldyBLZXJuZWxWYWx1ZSh2YWx1ZSwge1xuICAgICAgICBuYW1lLFxuICAgICAgICB0eXBlLFxuICAgICAgICB0YWN0aWM6IHRoaXMudGFjdGljLFxuICAgICAgICBvcmlnaW46ICdjb25zdGFudHMnLFxuICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgIGNoZWNrQ29udGV4dDogdGhpcy5jaGVja0NvbnRleHQsXG4gICAgICAgIGtlcm5lbDogdGhpcyxcbiAgICAgICAgc3RyaWN0SW50ZWdlcnM6IHRoaXMuc3RyaWN0SW50ZWdlcnMsXG4gICAgICAgIG9uUmVxdWVzdFRleHR1cmU6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVxdWVzdEluZGV4OiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRleHR1cmVJbmRleGVzKys7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVxdWVzdENvbnRleHRIYW5kbGU6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50VGV4dHVyZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb25zdGFudEJpdFJhdGlvc1tuYW1lXSA9IGtlcm5lbFZhbHVlLmJpdFJhdGlvO1xuICAgICAgdGhpcy5rZXJuZWxDb25zdGFudHMucHVzaChrZXJuZWxWYWx1ZSk7XG4gICAgICBrZXJuZWxWYWx1ZS5zZXR1cCgpO1xuICAgICAgaWYgKGtlcm5lbFZhbHVlLmZvcmNlVXBsb2FkRWFjaFJ1bikge1xuICAgICAgICB0aGlzLmZvcmNlVXBsb2FkS2VybmVsQ29uc3RhbnRzLnB1c2goa2VybmVsVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGJ1aWxkKCkge1xuICAgIGlmICh0aGlzLmJ1aWx0KSByZXR1cm47XG4gICAgdGhpcy5pbml0RXh0ZW5zaW9ucygpO1xuICAgIHRoaXMudmFsaWRhdGVTZXR0aW5ncyhhcmd1bWVudHMpO1xuICAgIHRoaXMuc2V0dXBDb25zdGFudHMoYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5mYWxsYmFja1JlcXVlc3RlZCkgcmV0dXJuO1xuICAgIHRoaXMuc2V0dXBBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5mYWxsYmFja1JlcXVlc3RlZCkgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlTWF4VGV4U2l6ZSgpO1xuICAgIHRoaXMudHJhbnNsYXRlU291cmNlKCk7XG4gICAgY29uc3QgZmFpbHVyZVJlc3VsdCA9IHRoaXMucGlja1JlbmRlclN0cmF0ZWd5KGFyZ3VtZW50cyk7XG4gICAgaWYgKGZhaWx1cmVSZXN1bHQpIHtcbiAgICAgIHJldHVybiBmYWlsdXJlUmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCB7IHRleFNpemUsIGNvbnRleHQ6IGdsLCBjYW52YXMgfSA9IHRoaXM7XG4gICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgaWYgKHRoaXMucGlwZWxpbmUgJiYgdGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLm1heFRleFNpemVbMF0sIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG4gICAgICBjYW52YXMud2lkdGggPSB0aGlzLm1heFRleFNpemVbMF07XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5tYXhUZXhTaXplWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLm1heFRleFNpemVbMF0sIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG4gICAgICBjYW52YXMud2lkdGggPSB0aGlzLm1heFRleFNpemVbMF07XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5tYXhUZXhTaXplWzFdO1xuICAgIH1cbiAgICBjb25zdCB0aHJlYWREaW0gPSB0aGlzLnRocmVhZERpbSA9IEFycmF5LmZyb20odGhpcy5vdXRwdXQpO1xuICAgIHdoaWxlICh0aHJlYWREaW0ubGVuZ3RoIDwgMykge1xuICAgICAgdGhyZWFkRGltLnB1c2goMSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcGlsZWRWZXJ0ZXhTaGFkZXIgPSB0aGlzLmdldFZlcnRleFNoYWRlcihhcmd1bWVudHMpO1xuICAgIGNvbnN0IHZlcnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKHZlcnRTaGFkZXIsIGNvbXBpbGVkVmVydGV4U2hhZGVyKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKHZlcnRTaGFkZXIpO1xuICAgIHRoaXMudmVydFNoYWRlciA9IHZlcnRTaGFkZXI7XG5cbiAgICBjb25zdCBjb21waWxlZEZyYWdtZW50U2hhZGVyID0gdGhpcy5nZXRGcmFnbWVudFNoYWRlcihhcmd1bWVudHMpO1xuICAgIGNvbnN0IGZyYWdTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ1NoYWRlciwgY29tcGlsZWRGcmFnbWVudFNoYWRlcik7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnU2hhZGVyKTtcbiAgICB0aGlzLmZyYWdTaGFkZXIgPSBmcmFnU2hhZGVyO1xuXG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdHTFNMIFNoYWRlciBPdXRwdXQ6Jyk7XG4gICAgICBjb25zb2xlLmxvZyhjb21waWxlZEZyYWdtZW50U2hhZGVyKTtcbiAgICB9XG5cbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY29tcGlsaW5nIHZlcnRleCBzaGFkZXI6ICcgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRTaGFkZXIpKTtcbiAgICB9XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ1NoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNvbXBpbGluZyBmcmFnbWVudCBzaGFkZXI6ICcgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdTaGFkZXIpKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5wcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ1NoYWRlcik7XG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci53aWR0aCA9IHRleFNpemVbMF07XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci5oZWlnaHQgPSB0ZXhTaXplWzFdO1xuXG4gICAgY29uc3QgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFstMSwgLTEsXG4gICAgICAxLCAtMSwgLTEsIDEsXG4gICAgICAxLCAxXG4gICAgXSk7XG4gICAgY29uc3QgdGV4Q29vcmRzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAwLCAwLFxuICAgICAgMSwgMCxcbiAgICAgIDAsIDEsXG4gICAgICAxLCAxXG4gICAgXSk7XG5cbiAgICBjb25zdCB0ZXhDb29yZE9mZnNldCA9IHZlcnRpY2VzLmJ5dGVMZW5ndGg7XG5cbiAgICBsZXQgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIGJ1ZmZlciA9IHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcy5ieXRlTGVuZ3RoICsgdGV4Q29vcmRzLmJ5dGVMZW5ndGgsIGdsLlNUQVRJQ19EUkFXKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgfVxuXG4gICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHZlcnRpY2VzKTtcbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGV4Q29vcmRPZmZzZXQsIHRleENvb3Jkcyk7XG5cbiAgICBjb25zdCBhUG9zTG9jID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnYVBvcycpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFQb3NMb2MpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYVBvc0xvYywgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICBjb25zdCBhVGV4Q29vcmRMb2MgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sICdhVGV4Q29vcmQnKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhVGV4Q29vcmRMb2MpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYVRleENvb3JkTG9jLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIHRleENvb3JkT2Zmc2V0KTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICBmb3IgKGxldCBwIGluIHRoaXMuY29uc3RhbnRzKSB7XG4gICAgICB0aGlzLmtlcm5lbENvbnN0YW50c1tpKytdLnVwZGF0ZVZhbHVlKHRoaXMuY29uc3RhbnRzW3BdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXR1cE91dHB1dFRleHR1cmUoKTtcbiAgICBpZiAoXG4gICAgICB0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwgJiZcbiAgICAgIHRoaXMuc3ViS2VybmVscy5sZW5ndGggPiAwXG4gICAgKSB7XG4gICAgICB0aGlzLl9tYXBwZWRUZXh0dXJlU3dpdGNoZWQgPSB7fTtcbiAgICAgIHRoaXMuX3NldHVwU3ViT3V0cHV0VGV4dHVyZXMoKTtcbiAgICB9XG4gICAgdGhpcy5idWlsZFNpZ25hdHVyZShhcmd1bWVudHMpO1xuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICB9XG5cbiAgdHJhbnNsYXRlU291cmNlKCkge1xuICAgIGNvbnN0IGZ1bmN0aW9uQnVpbGRlciA9IEZ1bmN0aW9uQnVpbGRlci5mcm9tS2VybmVsKHRoaXMsIFdlYkdMRnVuY3Rpb25Ob2RlLCB7XG4gICAgICBmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeTogdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeVxuICAgIH0pO1xuICAgIHRoaXMudHJhbnNsYXRlZFNvdXJjZSA9IGZ1bmN0aW9uQnVpbGRlci5nZXRQcm90b3R5cGVTdHJpbmcoJ2tlcm5lbCcpO1xuICAgIHRoaXMuc2V0dXBSZXR1cm5UeXBlcyhmdW5jdGlvbkJ1aWxkZXIpO1xuICB9XG5cbiAgc2V0dXBSZXR1cm5UeXBlcyhmdW5jdGlvbkJ1aWxkZXIpIHtcbiAgICBpZiAoIXRoaXMuZ3JhcGhpY2FsICYmICF0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIHRoaXMucmV0dXJuVHlwZSA9IGZ1bmN0aW9uQnVpbGRlci5nZXRLZXJuZWxSZXN1bHRUeXBlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3ViS2VybmVscyAmJiB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgICBpZiAoIXN1Yktlcm5lbC5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgc3ViS2VybmVsLnJldHVyblR5cGUgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0U3ViS2VybmVsUmVzdWx0VHlwZShpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJ1bigpIHtcbiAgICBjb25zdCB7IGtlcm5lbEFyZ3VtZW50cywgdGV4U2l6ZSwgZm9yY2VVcGxvYWRLZXJuZWxDb25zdGFudHMsIGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuXG4gICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIGdsLnNjaXNzb3IoMCwgMCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSk7XG4gICAgaWYgKHRoaXMuZHluYW1pY091dHB1dCkge1xuICAgICAgdGhpcy5zZXRVbmlmb3JtM2l2KCd1T3V0cHV0RGltJywgbmV3IEludDMyQXJyYXkodGhpcy50aHJlYWREaW0pKTtcbiAgICAgIHRoaXMuc2V0VW5pZm9ybTJpdigndVRleFNpemUnLCB0ZXhTaXplKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFVuaWZvcm0yZigncmF0aW8nLCB0ZXhTaXplWzBdIC8gdGhpcy5tYXhUZXhTaXplWzBdLCB0ZXhTaXplWzFdIC8gdGhpcy5tYXhUZXhTaXplWzFdKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9yY2VVcGxvYWRLZXJuZWxDb25zdGFudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbnN0YW50ID0gZm9yY2VVcGxvYWRLZXJuZWxDb25zdGFudHNbaV07XG4gICAgICBjb25zdGFudC51cGRhdGVWYWx1ZSh0aGlzLmNvbnN0YW50c1tjb25zdGFudC5uYW1lXSk7XG4gICAgICBpZiAodGhpcy5zd2l0Y2hpbmdLZXJuZWxzKSByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsQXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXJuZWxBcmd1bWVudHNbaV0udXBkYXRlVmFsdWUoYXJndW1lbnRzW2ldKTtcbiAgICAgIGlmICh0aGlzLnN3aXRjaGluZ0tlcm5lbHMpIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbHVnaW5zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnBsdWdpbnNbaV07XG4gICAgICAgIGlmIChwbHVnaW4ub25CZWZvcmVSdW4pIHtcbiAgICAgICAgICBwbHVnaW4ub25CZWZvcmVSdW4odGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcbiAgICAgIGlmICh0aGlzLnBpcGVsaW5lKSB7XG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgaWYgKHRoaXMuaW1tdXRhYmxlKSB7XG4gICAgICAgICAgdGhpcy5fcmVwbGFjZU91dHB1dFRleHR1cmUoKTtcbiAgICAgICAgfVxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1tdXRhYmxlID8gdGhpcy50ZXh0dXJlLmNsb25lKCkgOiB0aGlzLnRleHR1cmU7XG4gICAgICB9XG4gICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICBpZiAodGhpcy5pbW11dGFibGUpIHtcbiAgICAgIHRoaXMuX3JlcGxhY2VPdXRwdXRUZXh0dXJlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuaW1tdXRhYmxlKSB7XG4gICAgICAgIHRoaXMuX3JlcGxhY2VTdWJPdXRwdXRUZXh0dXJlcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmF3QnVmZmVycygpO1xuICAgIH1cblxuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICB9XG5cbiAgZHJhd0J1ZmZlcnMoKSB7XG4gICAgdGhpcy5leHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycy5kcmF3QnVmZmVyc1dFQkdMKHRoaXMuZHJhd0J1ZmZlcnNNYXApO1xuICB9XG5cbiAgZ2V0SW50ZXJuYWxGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5SR0JBO1xuICB9XG4gIGdldFRleHR1cmVGb3JtYXQoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBzd2l0Y2ggKHRoaXMuZ2V0SW50ZXJuYWxGb3JtYXQoKSkge1xuICAgICAgY2FzZSBnbC5SR0JBOlxuICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbnRlcm5hbCBmb3JtYXQnKTtcbiAgICB9XG4gIH1cblxuICBfcmVwbGFjZU91dHB1dFRleHR1cmUoKSB7XG4gICAgaWYgKHRoaXMudGV4dHVyZS5iZWZvcmVNdXRhdGUoKSB8fCB0aGlzLl90ZXh0dXJlU3dpdGNoZWQpIHtcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUudGV4dHVyZSwgMCk7XG4gICAgICB0aGlzLl90ZXh0dXJlU3dpdGNoZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBfc2V0dXBPdXRwdXRUZXh0dXJlKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IHRleFNpemUgPSB0aGlzLnRleFNpemU7XG4gICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUudGV4dHVyZSwgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudFRleHR1cmVDb3VudCArIHRoaXMuYXJndW1lbnRUZXh0dXJlQ291bnQpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpO1xuICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBmb3JtYXQsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgIH1cbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgIHRoaXMudGV4dHVyZSA9IG5ldyB0aGlzLlRleHR1cmVDb25zdHJ1Y3Rvcih7XG4gICAgICB0ZXh0dXJlLFxuICAgICAgc2l6ZTogdGV4U2l6ZSxcbiAgICAgIGRpbWVuc2lvbnM6IHRoaXMudGhyZWFkRGltLFxuICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgIGludGVybmFsRm9ybWF0OiB0aGlzLmdldEludGVybmFsRm9ybWF0KCksXG4gICAgICB0ZXh0dXJlRm9ybWF0OiB0aGlzLmdldFRleHR1cmVGb3JtYXQoKSxcbiAgICAgIGtlcm5lbDogdGhpcyxcbiAgICB9KTtcbiAgfVxuXG4gIF9yZXBsYWNlU3ViT3V0cHV0VGV4dHVyZXMoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcHBlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBtYXBwZWRUZXh0dXJlID0gdGhpcy5tYXBwZWRUZXh0dXJlc1tpXTtcbiAgICAgIGlmIChtYXBwZWRUZXh0dXJlLmJlZm9yZU11dGF0ZSgpIHx8IHRoaXMuX21hcHBlZFRleHR1cmVTd2l0Y2hlZFtpXSkge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSwgZ2wuVEVYVFVSRV8yRCwgbWFwcGVkVGV4dHVyZS50ZXh0dXJlLCAwKTtcbiAgICAgICAgdGhpcy5fbWFwcGVkVGV4dHVyZVN3aXRjaGVkW2ldID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3NldHVwU3ViT3V0cHV0VGV4dHVyZXMoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgaWYgKHRoaXMubWFwcGVkVGV4dHVyZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkgKyAxLCBnbC5URVhUVVJFXzJELCB0aGlzLm1hcHBlZFRleHR1cmVzW2ldLnRleHR1cmUsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXhTaXplID0gdGhpcy50ZXhTaXplO1xuICAgIHRoaXMuZHJhd0J1ZmZlcnNNYXAgPSBbZ2wuQ09MT1JfQVRUQUNITUVOVDBdO1xuICAgIHRoaXMubWFwcGVkVGV4dHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgdGhpcy5kcmF3QnVmZmVyc01hcC5wdXNoKGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEpO1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRUZXh0dXJlQ291bnQgKyB0aGlzLmFyZ3VtZW50VGV4dHVyZUNvdW50ICsgaSk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkgKyAxLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcblxuICAgICAgdGhpcy5tYXBwZWRUZXh0dXJlcy5wdXNoKG5ldyB0aGlzLlRleHR1cmVDb25zdHJ1Y3Rvcih7XG4gICAgICAgIHRleHR1cmUsXG4gICAgICAgIHNpemU6IHRleFNpemUsXG4gICAgICAgIGRpbWVuc2lvbnM6IHRoaXMudGhyZWFkRGltLFxuICAgICAgICBvdXRwdXQ6IHRoaXMub3V0cHV0LFxuICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgIGludGVybmFsRm9ybWF0OiB0aGlzLmdldEludGVybmFsRm9ybWF0KCksXG4gICAgICAgIHRleHR1cmVGb3JtYXQ6IHRoaXMuZ2V0VGV4dHVyZUZvcm1hdCgpLFxuICAgICAgICBrZXJuZWw6IHRoaXMsXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG5cbiAgc2V0VW5pZm9ybTFmKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybTFmQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtMWZDYWNoZVtuYW1lXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gY2FjaGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm0xZkNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgY29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgdGhpcy5jb250ZXh0LnVuaWZvcm0xZihsb2MsIHZhbHVlKTtcbiAgfVxuXG4gIHNldFVuaWZvcm0xaShuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm0xaUNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTFpQ2FjaGVbbmFtZV07XG4gICAgICBpZiAodmFsdWUgPT09IGNhY2hlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtMWlDYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIHRoaXMuY29udGV4dC51bmlmb3JtMWkobG9jLCB2YWx1ZSk7XG4gIH1cblxuICBzZXRVbmlmb3JtMmYobmFtZSwgdmFsdWUxLCB2YWx1ZTIpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtMmZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm0yZkNhY2hlW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZTEgPT09IGNhY2hlWzBdICYmXG4gICAgICAgIHZhbHVlMiA9PT0gY2FjaGVbMV1cbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybTJmQ2FjaGVbbmFtZV0gPSBbdmFsdWUxLCB2YWx1ZTJdO1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIHRoaXMuY29udGV4dC51bmlmb3JtMmYobG9jLCB2YWx1ZTEsIHZhbHVlMik7XG4gIH1cblxuICBzZXRVbmlmb3JtMmZ2KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybTJmdkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTJmdkNhY2hlW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZVswXSA9PT0gY2FjaGVbMF0gJiZcbiAgICAgICAgdmFsdWVbMV0gPT09IGNhY2hlWzFdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm0yZnZDYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIHRoaXMuY29udGV4dC51bmlmb3JtMmZ2KGxvYywgdmFsdWUpO1xuICB9XG5cbiAgc2V0VW5pZm9ybTJpdihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm0yaXZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm0yaXZDYWNoZVtuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWVbMF0gPT09IGNhY2hlWzBdICYmXG4gICAgICAgIHZhbHVlWzFdID09PSBjYWNoZVsxXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtMml2Q2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTJpdihsb2MsIHZhbHVlKTtcbiAgfVxuXG4gIHNldFVuaWZvcm0zZnYobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtM2Z2Q2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtM2Z2Q2FjaGVbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlWzBdID09PSBjYWNoZVswXSAmJlxuICAgICAgICB2YWx1ZVsxXSA9PT0gY2FjaGVbMV0gJiZcbiAgICAgICAgdmFsdWVbMl0gPT09IGNhY2hlWzJdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm0zZnZDYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIHRoaXMuY29udGV4dC51bmlmb3JtM2Z2KGxvYywgdmFsdWUpO1xuICB9XG5cbiAgc2V0VW5pZm9ybTNpdihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm0zaXZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm0zaXZDYWNoZVtuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWVbMF0gPT09IGNhY2hlWzBdICYmXG4gICAgICAgIHZhbHVlWzFdID09PSBjYWNoZVsxXSAmJlxuICAgICAgICB2YWx1ZVsyXSA9PT0gY2FjaGVbMl1cbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybTNpdkNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgY29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgdGhpcy5jb250ZXh0LnVuaWZvcm0zaXYobG9jLCB2YWx1ZSk7XG4gIH1cblxuICBzZXRVbmlmb3JtNGZ2KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybTRmdkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTRmdkNhY2hlW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZVswXSA9PT0gY2FjaGVbMF0gJiZcbiAgICAgICAgdmFsdWVbMV0gPT09IGNhY2hlWzFdICYmXG4gICAgICAgIHZhbHVlWzJdID09PSBjYWNoZVsyXSAmJlxuICAgICAgICB2YWx1ZVszXSA9PT0gY2FjaGVbM11cbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybTRmdkNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgY29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgdGhpcy5jb250ZXh0LnVuaWZvcm00ZnYobG9jLCB2YWx1ZSk7XG4gIH1cblxuICBzZXRVbmlmb3JtNGl2KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybTRpdkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTRpdkNhY2hlW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZVswXSA9PT0gY2FjaGVbMF0gJiZcbiAgICAgICAgdmFsdWVbMV0gPT09IGNhY2hlWzFdICYmXG4gICAgICAgIHZhbHVlWzJdID09PSBjYWNoZVsyXSAmJlxuICAgICAgICB2YWx1ZVszXSA9PT0gY2FjaGVbM11cbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybTRpdkNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgY29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgdGhpcy5jb250ZXh0LnVuaWZvcm00aXYobG9jLCB2YWx1ZSk7XG4gIH1cblxuICBnZXRVbmlmb3JtTG9jYXRpb24obmFtZSkge1xuICAgIGlmICh0aGlzLnByb2dyYW1Vbmlmb3JtTG9jYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbkNhY2hlW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9ncmFtVW5pZm9ybUxvY2F0aW9uQ2FjaGVbbmFtZV0gPSB0aGlzLmNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSk7XG4gIH1cblxuICBfZ2V0RnJhZ1NoYWRlckFydGlmYWN0TWFwKGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSEVBREVSOiB0aGlzLl9nZXRIZWFkZXJTdHJpbmcoKSxcbiAgICAgIExPT1BfTUFYOiB0aGlzLl9nZXRMb29wTWF4U3RyaW5nKCksXG4gICAgICBQTFVHSU5TOiB0aGlzLl9nZXRQbHVnaW5zU3RyaW5nKCksXG4gICAgICBDT05TVEFOVFM6IHRoaXMuX2dldENvbnN0YW50c1N0cmluZygpLFxuICAgICAgREVDT0RFMzJfRU5ESUFOTkVTUzogdGhpcy5fZ2V0RGVjb2RlMzJFbmRpYW5uZXNzU3RyaW5nKCksXG4gICAgICBFTkNPREUzMl9FTkRJQU5ORVNTOiB0aGlzLl9nZXRFbmNvZGUzMkVuZGlhbm5lc3NTdHJpbmcoKSxcbiAgICAgIERJVklERV9XSVRIX0lOVEVHRVJfQ0hFQ0s6IHRoaXMuX2dldERpdmlkZVdpdGhJbnRlZ2VyQ2hlY2tTdHJpbmcoKSxcbiAgICAgIElOSkVDVEVEX05BVElWRTogdGhpcy5fZ2V0SW5qZWN0ZWROYXRpdmUoKSxcbiAgICAgIE1BSU5fQ09OU1RBTlRTOiB0aGlzLl9nZXRNYWluQ29uc3RhbnRzU3RyaW5nKCksXG4gICAgICBNQUlOX0FSR1VNRU5UUzogdGhpcy5fZ2V0TWFpbkFyZ3VtZW50c1N0cmluZyhhcmdzKSxcbiAgICAgIEtFUk5FTDogdGhpcy5nZXRLZXJuZWxTdHJpbmcoKSxcbiAgICAgIE1BSU5fUkVTVUxUOiB0aGlzLmdldE1haW5SZXN1bHRTdHJpbmcoKSxcbiAgICAgIEZMT0FUX1RBQ1RJQ19ERUNMQVJBVElPTjogdGhpcy5nZXRGbG9hdFRhY3RpY0RlY2xhcmF0aW9uKCksXG4gICAgICBJTlRfVEFDVElDX0RFQ0xBUkFUSU9OOiB0aGlzLmdldEludFRhY3RpY0RlY2xhcmF0aW9uKCksXG4gICAgICBTQU1QTEVSXzJEX1RBQ1RJQ19ERUNMQVJBVElPTjogdGhpcy5nZXRTYW1wbGVyMkRUYWN0aWNEZWNsYXJhdGlvbigpLFxuICAgICAgU0FNUExFUl8yRF9BUlJBWV9UQUNUSUNfREVDTEFSQVRJT046IHRoaXMuZ2V0U2FtcGxlcjJEQXJyYXlUYWN0aWNEZWNsYXJhdGlvbigpLFxuICAgIH07XG4gIH1cblxuICBfZ2V0VmVydFNoYWRlckFydGlmYWN0TWFwKGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgRkxPQVRfVEFDVElDX0RFQ0xBUkFUSU9OOiB0aGlzLmdldEZsb2F0VGFjdGljRGVjbGFyYXRpb24oKSxcbiAgICAgIElOVF9UQUNUSUNfREVDTEFSQVRJT046IHRoaXMuZ2V0SW50VGFjdGljRGVjbGFyYXRpb24oKSxcbiAgICAgIFNBTVBMRVJfMkRfVEFDVElDX0RFQ0xBUkFUSU9OOiB0aGlzLmdldFNhbXBsZXIyRFRhY3RpY0RlY2xhcmF0aW9uKCksXG4gICAgICBTQU1QTEVSXzJEX0FSUkFZX1RBQ1RJQ19ERUNMQVJBVElPTjogdGhpcy5nZXRTYW1wbGVyMkRBcnJheVRhY3RpY0RlY2xhcmF0aW9uKCksXG4gICAgfTtcbiAgfVxuXG4gIF9nZXRIZWFkZXJTdHJpbmcoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCA/XG4gICAgICAnI2V4dGVuc2lvbiBHTF9FWFRfZHJhd19idWZmZXJzIDogcmVxdWlyZVxcbicgOlxuICAgICAgJydcbiAgICApO1xuICB9XG5cbiAgX2dldExvb3BNYXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9vcE1heEl0ZXJhdGlvbnMgP1xuICAgICAgYCAke3BhcnNlSW50KHRoaXMubG9vcE1heEl0ZXJhdGlvbnMpfTtcXG5gIDpcbiAgICAgICcgMTAwMDtcXG4nXG4gICAgKTtcbiAgfVxuXG4gIF9nZXRQbHVnaW5zU3RyaW5nKCkge1xuICAgIGlmICghdGhpcy5wbHVnaW5zKSByZXR1cm4gJ1xcbic7XG4gICAgcmV0dXJuIHRoaXMucGx1Z2lucy5tYXAocGx1Z2luID0+IHBsdWdpbi5zb3VyY2UgJiYgdGhpcy5zb3VyY2UubWF0Y2gocGx1Z2luLmZ1bmN0aW9uTWF0Y2gpID8gcGx1Z2luLnNvdXJjZSA6ICcnKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIF9nZXRDb25zdGFudHNTdHJpbmcoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgeyB0aHJlYWREaW0sIHRleFNpemUgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMuZHluYW1pY091dHB1dCkge1xuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICd1bmlmb3JtIGl2ZWMzIHVPdXRwdXREaW0nLFxuICAgICAgICAndW5pZm9ybSBpdmVjMiB1VGV4U2l6ZSdcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICBgaXZlYzMgdU91dHB1dERpbSA9IGl2ZWMzKCR7dGhyZWFkRGltWzBdfSwgJHt0aHJlYWREaW1bMV19LCAke3RocmVhZERpbVsyXX0pYCxcbiAgICAgICAgYGl2ZWMyIHVUZXhTaXplID0gaXZlYzIoJHt0ZXhTaXplWzBdfSwgJHt0ZXhTaXplWzFdfSlgXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpO1xuICB9XG5cbiAgX2dldFRleHR1cmVDb29yZGluYXRlKCkge1xuICAgIGNvbnN0IHN1Yktlcm5lbHMgPSB0aGlzLnN1Yktlcm5lbHM7XG4gICAgaWYgKHN1Yktlcm5lbHMgPT09IG51bGwgfHwgc3ViS2VybmVscy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdvdXQgdmVjMiB2VGV4Q29vcmQ7XFxuJztcbiAgICB9XG4gIH1cblxuICBfZ2V0RGVjb2RlMzJFbmRpYW5uZXNzU3RyaW5nKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmVuZGlhbm5lc3MgPT09ICdMRScgP1xuICAgICAgJycgOlxuICAgICAgJyAgdGV4ZWwucmdiYSA9IHRleGVsLmFiZ3I7XFxuJ1xuICAgICk7XG4gIH1cblxuICBfZ2V0RW5jb2RlMzJFbmRpYW5uZXNzU3RyaW5nKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmVuZGlhbm5lc3MgPT09ICdMRScgP1xuICAgICAgJycgOlxuICAgICAgJyAgdGV4ZWwucmdiYSA9IHRleGVsLmFiZ3I7XFxuJ1xuICAgICk7XG4gIH1cblxuICBfZ2V0RGl2aWRlV2l0aEludGVnZXJDaGVja1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA/XG4gICAgICBgZmxvYXQgZGl2V2l0aEludENoZWNrKGZsb2F0IHgsIGZsb2F0IHkpIHtcbiAgaWYgKGZsb29yKHgpID09IHggJiYgZmxvb3IoeSkgPT0geSAmJiBpbnRlZ2VyTW9kKHgsIHkpID09IDAuMCkge1xuICAgIHJldHVybiBmbG9hdChpbnQoeCkgLyBpbnQoeSkpO1xuICB9XG4gIHJldHVybiB4IC8geTtcbn1cblxuZmxvYXQgaW50ZWdlckNvcnJlY3Rpb25Nb2R1bG8oZmxvYXQgbnVtYmVyLCBmbG9hdCBkaXZpc29yKSB7XG4gIGlmIChudW1iZXIgPCAwLjApIHtcbiAgICBudW1iZXIgPSBhYnMobnVtYmVyKTtcbiAgICBpZiAoZGl2aXNvciA8IDAuMCkge1xuICAgICAgZGl2aXNvciA9IGFicyhkaXZpc29yKTtcbiAgICB9XG4gICAgcmV0dXJuIC0obnVtYmVyIC0gKGRpdmlzb3IgKiBmbG9vcihkaXZXaXRoSW50Q2hlY2sobnVtYmVyLCBkaXZpc29yKSkpKTtcbiAgfVxuICBpZiAoZGl2aXNvciA8IDAuMCkge1xuICAgIGRpdmlzb3IgPSBhYnMoZGl2aXNvcik7XG4gIH1cbiAgcmV0dXJuIG51bWJlciAtIChkaXZpc29yICogZmxvb3IoZGl2V2l0aEludENoZWNrKG51bWJlciwgZGl2aXNvcikpKTtcbn1gIDpcbiAgICAgICcnO1xuICB9XG5cbiAgX2dldE1haW5Bcmd1bWVudHNTdHJpbmcoYXJncykge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBjb25zdCB7IGFyZ3VtZW50TmFtZXMgfSA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRzLnB1c2godGhpcy5rZXJuZWxBcmd1bWVudHNbaV0uZ2V0U291cmNlKGFyZ3NbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMuam9pbignJyk7XG4gIH1cblxuICBfZ2V0SW5qZWN0ZWROYXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5qZWN0ZWROYXRpdmUgfHwgJyc7XG4gIH1cblxuICBfZ2V0TWFpbkNvbnN0YW50c1N0cmluZygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCB7IGNvbnN0YW50cyB9ID0gdGhpcztcbiAgICBpZiAoY29uc3RhbnRzKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25zdGFudHMuaGFzT3duUHJvcGVydHkobmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmtlcm5lbENvbnN0YW50c1tpKytdLmdldFNvdXJjZSh0aGlzLmNvbnN0YW50c1tuYW1lXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICB9XG5cbiAgZ2V0S2VybmVsUmVzdWx0RGVjbGFyYXRpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgcmV0dXJuICd2ZWMyIGtlcm5lbFJlc3VsdCc7XG4gICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICAgIHJldHVybiAndmVjMyBrZXJuZWxSZXN1bHQnO1xuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICByZXR1cm4gJ3ZlYzQga2VybmVsUmVzdWx0JztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgcmV0dXJuICdmbG9hdCBrZXJuZWxSZXN1bHQnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICAgICAgcmV0dXJuICdmbG9hdCBrZXJuZWxSZXN1bHQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIG91dHB1dCB0eXBlIFwiJHsgdGhpcy5yZXR1cm5UeXBlIH1cImApO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGdldEtlcm5lbFN0cmluZygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbdGhpcy5nZXRLZXJuZWxSZXN1bHREZWNsYXJhdGlvbigpXTtcbiAgICBjb25zdCB7IHN1Yktlcm5lbHMgfSA9IHRoaXM7XG4gICAgaWYgKHN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJLZXJuZWwgPSBzdWJLZXJuZWxzW2ldO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIHN1Yktlcm5lbC5yZXR1cm5UeXBlID09PSAnSW50ZWdlcicgP1xuICAgICAgICAgICAgICBgaW50IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gMGAgOlxuICAgICAgICAgICAgICBgZmxvYXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH0gPSAwLjBgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIGB2ZWMyIHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWxzW2ldLm5hbWUgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYHZlYzMgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbHNbaV0ubmFtZSB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBgdmVjNCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsc1tpXS5uYW1lIH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpICsgdGhpcy50cmFuc2xhdGVkU291cmNlO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEdyYXBoaWNhbCgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZ2xfRnJhZ0NvbG9yID0gYWN0dWFsQ29sb3InLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFBhY2tlZFBpeGVscygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYWluUmVzdWx0S2VybmVsUGFja2VkUGl4ZWxzKCkgK1xuICAgICAgICAgIHRoaXMuZ2V0TWFpblJlc3VsdFN1Yktlcm5lbFBhY2tlZFBpeGVscygpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWNrZWQgb3V0cHV0IG9ubHkgdXNhYmxlIHdpdGggTnVtYmVycywgXCIke3RoaXMucmV0dXJuVHlwZX1cIiBzcGVjaWZpZWRgKTtcbiAgICB9XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsUGFja2VkUGl4ZWxzKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICBgICBnbF9GcmFnRGF0YVswXSA9ICR7dGhpcy51c2VMZWdhY3lFbmNvZGVyID8gJ2xlZ2FjeUVuY29kZTMyJyA6ICdlbmNvZGUzMid9KGtlcm5lbFJlc3VsdClgXG4gICAgXSk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsUGFja2VkUGl4ZWxzKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIGlmIChzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XSA9ICR7dGhpcy51c2VMZWdhY3lFbmNvZGVyID8gJ2xlZ2FjeUVuY29kZTMyJyA6ICdlbmNvZGUzMid9KGZsb2F0KHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfSkpYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dID0gJHt0aGlzLnVzZUxlZ2FjeUVuY29kZXIgPyAnbGVnYWN5RW5jb2RlMzInIDogJ2VuY29kZTMyJ30oc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9KWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcocmVzdWx0KTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRNZW1vcnlPcHRpbWl6ZWRGbG9hdHMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW1xuICAgICAgJyAgaW5kZXggKj0gNCcsXG4gICAgXTtcblxuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIGNvbnN0IGNoYW5uZWxzID0gWydyJywgJ2cnLCAnYicsICdhJ107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGFubmVsID0gY2hhbm5lbHNbaV07XG4gICAgICAgICAgdGhpcy5nZXRNYWluUmVzdWx0S2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCk7XG4gICAgICAgICAgdGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCk7XG4gICAgICAgICAgaWYgKGkgKyAxIDwgY2hhbm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnICBpbmRleCArPSAxJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvcHRpbWl6ZWQgb3V0cHV0IG9ubHkgdXNhYmxlIHdpdGggTnVtYmVycywgJHt0aGlzLnJldHVyblR5cGV9IHNwZWNpZmllZGApO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHJlc3VsdCk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCkge1xuICAgIHJlc3VsdC5wdXNoKFxuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgIGAgIGdsX0ZyYWdEYXRhWzBdLiR7Y2hhbm5lbH0gPSBrZXJuZWxSZXN1bHRgLFxuICAgICk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCkge1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJLZXJuZWwgPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICBpZiAoc3ViS2VybmVsLnJldHVyblR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV0uJHtjaGFubmVsfSA9IGZsb2F0KHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfSlgLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dLiR7Y2hhbm5lbH0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxOdW1iZXJUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZ2xfRnJhZ0RhdGFbMF1bMF0gPSBrZXJuZWxSZXN1bHQnLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsTnVtYmVyVGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgaWYgKHN1Yktlcm5lbC5yZXR1cm5UeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzBdID0gZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9KWAsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5MlRleHR1cmUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBnbF9GcmFnRGF0YVswXVswXSA9IGtlcm5lbFJlc3VsdFswXScsXG4gICAgICAnICBnbF9GcmFnRGF0YVswXVsxXSA9IGtlcm5lbFJlc3VsdFsxXScsXG4gICAgXTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTJUZXh0dXJlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzBdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzBdYCxcbiAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzFdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzFdYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkzVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdWzBdID0ga2VybmVsUmVzdWx0WzBdJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdWzFdID0ga2VybmVsUmVzdWx0WzFdJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdWzJdID0ga2VybmVsUmVzdWx0WzJdJyxcbiAgICBdO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5M1RleHR1cmUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMF1gLFxuICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMV1gLFxuICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMl0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMl1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZ2xfRnJhZ0RhdGFbMF0gPSBrZXJuZWxSZXN1bHQnLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXk0VGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgICAgICBpZiAoc3ViS2VybmVsLnJldHVyblR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XSA9IGZsb2F0KHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfSlgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVswXWAsXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMV1gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMF1gLFxuICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzFdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzFdYCxcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVsyXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsyXWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVswXWAsXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMV1gLFxuICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzJdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzJdYCxcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVszXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVszXWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVwbGFjZUFydGlmYWN0cyhzcmMsIG1hcCkge1xuICAgIHJldHVybiBzcmMucmVwbGFjZSgvWyBdKl9fKFtBLVpdK1swLTldKihbX10/W0EtWl0qWzAtOV0/KSopX187XFxuL2csIChtYXRjaCwgYXJ0aWZhY3QpID0+IHtcbiAgICAgIGlmIChtYXAuaGFzT3duUHJvcGVydHkoYXJ0aWZhY3QpKSB7XG4gICAgICAgIHJldHVybiBtYXBbYXJ0aWZhY3RdO1xuICAgICAgfVxuICAgICAgdGhyb3cgYHVuaGFuZGxlZCBhcnRpZmFjdCAke2FydGlmYWN0fWA7XG4gICAgfSk7XG4gIH1cblxuICBnZXRGcmFnbWVudFNoYWRlcihhcmdzKSB7XG4gICAgaWYgKHRoaXMuY29tcGlsZWRGcmFnbWVudFNoYWRlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRGcmFnbWVudFNoYWRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZWRGcmFnbWVudFNoYWRlciA9IHRoaXMucmVwbGFjZUFydGlmYWN0cyh0aGlzLmNvbnN0cnVjdG9yLmZyYWdtZW50U2hhZGVyLCB0aGlzLl9nZXRGcmFnU2hhZGVyQXJ0aWZhY3RNYXAoYXJncykpO1xuICB9XG5cbiAgZ2V0VmVydGV4U2hhZGVyKGFyZ3MpIHtcbiAgICBpZiAodGhpcy5jb21waWxlZFZlcnRleFNoYWRlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRWZXJ0ZXhTaGFkZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXBpbGVkVmVydGV4U2hhZGVyID0gdGhpcy5yZXBsYWNlQXJ0aWZhY3RzKHRoaXMuY29uc3RydWN0b3IudmVydGV4U2hhZGVyLCB0aGlzLl9nZXRWZXJ0U2hhZGVyQXJ0aWZhY3RNYXAoYXJncykpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3Qgc2V0dXBDb250ZXh0U3RyaW5nID0gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgZ2wgPSBjb250ZXh0YCxcbiAgICBdKTtcbiAgICByZXR1cm4gZ2xLZXJuZWxTdHJpbmcodGhpcy5jb25zdHJ1Y3RvciwgYXJndW1lbnRzLCB0aGlzLCBzZXR1cENvbnRleHRTdHJpbmcpO1xuICB9XG5cbiAgZGVzdHJveShyZW1vdmVDYW52YXNSZWZlcmVuY2VzKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRleHQpIHJldHVybjtcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIHRoaXMuY29udGV4dC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFtZWJ1ZmZlcikge1xuICAgICAgdGhpcy5jb250ZXh0LmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy52ZXJ0U2hhZGVyKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZGVsZXRlU2hhZGVyKHRoaXMudmVydFNoYWRlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdTaGFkZXIpIHtcbiAgICAgIHRoaXMuY29udGV4dC5kZWxldGVTaGFkZXIodGhpcy5mcmFnU2hhZGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvZ3JhbSkge1xuICAgICAgdGhpcy5jb250ZXh0LmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgdGhpcy50ZXh0dXJlLmRlbGV0ZSgpO1xuICAgICAgY29uc3QgdGV4dHVyZUNhY2hlSW5kZXggPSB0aGlzLnRleHR1cmVDYWNoZS5pbmRleE9mKHRoaXMudGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgIGlmICh0ZXh0dXJlQ2FjaGVJbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlLnNwbGljZSh0ZXh0dXJlQ2FjaGVJbmRleCwgMSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXBwZWRUZXh0dXJlcyAmJiB0aGlzLm1hcHBlZFRleHR1cmVzLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcHBlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlZFRleHR1cmUgPSB0aGlzLm1hcHBlZFRleHR1cmVzW2ldO1xuICAgICAgICBtYXBwZWRUZXh0dXJlLmRlbGV0ZSgpO1xuICAgICAgICBjb25zdCB0ZXh0dXJlQ2FjaGVJbmRleCA9IHRoaXMudGV4dHVyZUNhY2hlLmluZGV4T2YobWFwcGVkVGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgICAgaWYgKHRleHR1cmVDYWNoZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICB0aGlzLnRleHR1cmVDYWNoZS5zcGxpY2UodGV4dHVyZUNhY2hlSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm1hcHBlZFRleHR1cmVzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMua2VybmVsQXJndW1lbnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMua2VybmVsQXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMua2VybmVsQXJndW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMua2VybmVsQ29uc3RhbnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMua2VybmVsQ29uc3RhbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMua2VybmVsQ29uc3RhbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKHRoaXMudGV4dHVyZUNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmVDYWNoZS5wb3AoKTtcbiAgICAgIHRoaXMuY29udGV4dC5kZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICAgIH1cbiAgICBpZiAocmVtb3ZlQ2FudmFzUmVmZXJlbmNlcykge1xuICAgICAgY29uc3QgaWR4ID0gY2FudmFzZXMuaW5kZXhPZih0aGlzLmNhbnZhcyk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgY2FudmFzZXNbaWR4XSA9IG51bGw7XG4gICAgICAgIG1heFRleFNpemVzW2lkeF0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3lFeHRlbnNpb25zKCk7XG4gICAgZGVsZXRlIHRoaXMuY29udGV4dDtcbiAgICBkZWxldGUgdGhpcy5jYW52YXM7XG4gICAgaWYgKCF0aGlzLmdwdSkgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB0aGlzLmdwdS5rZXJuZWxzLmluZGV4T2YodGhpcyk7XG4gICAgaWYgKGkgPT09IC0xKSByZXR1cm47XG4gICAgdGhpcy5ncHUua2VybmVscy5zcGxpY2UoaSwgMSk7XG4gIH1cblxuICBkZXN0cm95RXh0ZW5zaW9ucygpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMuT0VTX3RleHR1cmVfZmxvYXQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5PRVNfZWxlbWVudF9pbmRleF91aW50ID0gbnVsbDtcbiAgICB0aGlzLmV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBkZXN0cm95Q29udGV4dChjb250ZXh0KSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gY29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpO1xuICAgIGlmIChleHRlbnNpb24pIHtcbiAgICAgIGV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBqc29uID0gc3VwZXIudG9KU09OKCk7XG4gICAganNvbi5mdW5jdGlvbk5vZGVzID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgV2ViR0xGdW5jdGlvbk5vZGUpLnRvSlNPTigpO1xuICAgIGpzb24uc2V0dGluZ3MudGhyZWFkRGltID0gdGhpcy50aHJlYWREaW07XG4gICAgcmV0dXJuIGpzb247XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsXG59O1xufSx7XCIuLi8uLi9wbHVnaW5zL21hdGgtcmFuZG9tLXVuaWZvcm1seS1kaXN0cmlidXRlZFwiOjExMixcIi4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vZnVuY3Rpb24tYnVpbGRlclwiOjksXCIuLi9nbC9rZXJuZWxcIjoxMyxcIi4uL2dsL2tlcm5lbC1zdHJpbmdcIjoxMixcIi4vZnJhZ21lbnQtc2hhZGVyXCI6MzcsXCIuL2Z1bmN0aW9uLW5vZGVcIjozOCxcIi4va2VybmVsLXZhbHVlLW1hcHNcIjozOSxcIi4vdmVydGV4LXNoYWRlclwiOjcxfV0sNzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgdmVydGV4U2hhZGVyID0gYF9fRkxPQVRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX0lOVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fU0FNUExFUl8yRF9UQUNUSUNfREVDTEFSQVRJT05fXztcblxuYXR0cmlidXRlIHZlYzIgYVBvcztcbmF0dHJpYnV0ZSB2ZWMyIGFUZXhDb29yZDtcblxudmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcbnVuaWZvcm0gdmVjMiByYXRpbztcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KChhUG9zICsgdmVjMigxKSkgKiByYXRpbyArIHZlYzIoLTEpLCAwLCAxKTtcbiAgdlRleENvb3JkID0gYVRleENvb3JkO1xufWA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2ZXJ0ZXhTaGFkZXJcbn07XG59LHt9XSw3MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCBmcmFnbWVudFNoYWRlciA9IGAjdmVyc2lvbiAzMDAgZXNcbl9fSEVBREVSX187XG5fX0ZMT0FUX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuX19JTlRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX1NBTVBMRVJfMkRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX1NBTVBMRVJfMkRfQVJSQVlfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5cbmNvbnN0IGludCBMT09QX01BWCA9IF9fTE9PUF9NQVhfXztcblxuX19QTFVHSU5TX187XG5fX0NPTlNUQU5UU19fO1xuXG5pbiB2ZWMyIHZUZXhDb29yZDtcblxuZmxvYXQgYXRhbjIoZmxvYXQgdjEsIGZsb2F0IHYyKSB7XG4gIGlmICh2MSA9PSAwLjAgfHwgdjIgPT0gMC4wKSByZXR1cm4gMC4wO1xuICByZXR1cm4gYXRhbih2MSAvIHYyKTtcbn1cblxuZmxvYXQgY2JydChmbG9hdCB4KSB7XG4gIGlmICh4ID49IDAuMCkge1xuICAgIHJldHVybiBwb3coeCwgMS4wIC8gMy4wKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLXBvdyh4LCAxLjAgLyAzLjApO1xuICB9XG59XG5cbmZsb2F0IGV4cG0xKGZsb2F0IHgpIHtcbiAgcmV0dXJuIHBvdygke01hdGguRX0sIHgpIC0gMS4wOyBcbn1cblxuZmxvYXQgZnJvdW5kKGhpZ2hwIGZsb2F0IHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZsb2F0IGltdWwoZmxvYXQgdjEsIGZsb2F0IHYyKSB7XG4gIHJldHVybiBmbG9hdChpbnQodjEpICogaW50KHYyKSk7XG59XG5cbmZsb2F0IGxvZzEwKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZzIoeCkgKiAoMS4wIC8gbG9nMigxMC4wKSk7XG59XG5cbmZsb2F0IGxvZzFwKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZygxLjAgKyB4KTtcbn1cblxuZmxvYXQgX3BvdyhmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgaWYgKHYyID09IDAuMCkgcmV0dXJuIDEuMDtcbiAgcmV0dXJuIHBvdyh2MSwgdjIpO1xufVxuXG5mbG9hdCBfcm91bmQoZmxvYXQgeCkge1xuICByZXR1cm4gZmxvb3IoeCArIDAuNSk7XG59XG5cblxuY29uc3QgaW50IEJJVF9DT1VOVCA9IDMyO1xuaW50IG1vZGkoaW50IHgsIGludCB5KSB7XG4gIHJldHVybiB4IC0geSAqICh4IC8geSk7XG59XG5cbmludCBiaXR3aXNlT3IoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIFxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKChtb2RpKGEsIDIpID09IDEpIHx8IChtb2RpKGIsIDIpID09IDEpKSB7XG4gICAgICByZXN1bHQgKz0gbjtcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIGIgPSBiIC8gMjtcbiAgICBuID0gbiAqIDI7XG4gICAgaWYoIShhID4gMCB8fCBiID4gMCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VYT1IoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIFxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKChtb2RpKGEsIDIpID09IDEpICE9IChtb2RpKGIsIDIpID09IDEpKSB7XG4gICAgICByZXN1bHQgKz0gbjtcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIGIgPSBiIC8gMjtcbiAgICBuID0gbiAqIDI7XG4gICAgaWYoIShhID4gMCB8fCBiID4gMCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VBbmQoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoKG1vZGkoYSwgMikgPT0gMSkgJiYgKG1vZGkoYiwgMikgPT0gMSkpIHtcbiAgICAgIHJlc3VsdCArPSBuO1xuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgYiA9IGIgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgICBpZighKGEgPiAwICYmIGIgPiAwKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZU5vdChpbnQgYSkge1xuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IG4gPSAxO1xuICBcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtb2RpKGEsIDIpID09IDApIHtcbiAgICAgIHJlc3VsdCArPSBuOyAgICBcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VaZXJvRmlsbExlZnRTaGlmdChpbnQgbiwgaW50IHNoaWZ0KSB7XG4gIGludCBtYXhCeXRlcyA9IEJJVF9DT1VOVDtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtYXhCeXRlcyA+PSBuKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbWF4Qnl0ZXMgKj0gMjtcbiAgfVxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gc2hpZnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuICo9IDI7XG4gIH1cblxuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IGJ5dGVWYWwgPSAxO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gbWF4Qnl0ZXMpIGJyZWFrO1xuICAgIGlmIChtb2RpKG4sIDIpID4gMCkgeyByZXN1bHQgKz0gYnl0ZVZhbDsgfVxuICAgIG4gPSBpbnQobiAvIDIpO1xuICAgIGJ5dGVWYWwgKj0gMjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5pbnQgYml0d2lzZVNpZ25lZFJpZ2h0U2hpZnQoaW50IG51bSwgaW50IHNoaWZ0cykge1xuICByZXR1cm4gaW50KGZsb29yKGZsb2F0KG51bSkgLyBwb3coMi4wLCBmbG9hdChzaGlmdHMpKSkpO1xufVxuXG5pbnQgYml0d2lzZVplcm9GaWxsUmlnaHRTaGlmdChpbnQgbiwgaW50IHNoaWZ0KSB7XG4gIGludCBtYXhCeXRlcyA9IEJJVF9DT1VOVDtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtYXhCeXRlcyA+PSBuKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbWF4Qnl0ZXMgKj0gMjtcbiAgfVxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gc2hpZnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuIC89IDI7XG4gIH1cbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBieXRlVmFsID0gMTtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChpID49IG1heEJ5dGVzKSBicmVhaztcbiAgICBpZiAobW9kaShuLCAyKSA+IDApIHsgcmVzdWx0ICs9IGJ5dGVWYWw7IH1cbiAgICBuID0gaW50KG4gLyAyKTtcbiAgICBieXRlVmFsICo9IDI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmVjMiBpbnRlZ2VyTW9kKHZlYzIgeCwgZmxvYXQgeSkge1xuICB2ZWMyIHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XG4gIHJldHVybiByZXMgKiBzdGVwKDEuMCAtIGZsb29yKHkpLCAtcmVzKTtcbn1cblxudmVjMyBpbnRlZ2VyTW9kKHZlYzMgeCwgZmxvYXQgeSkge1xuICB2ZWMzIHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XG4gIHJldHVybiByZXMgKiBzdGVwKDEuMCAtIGZsb29yKHkpLCAtcmVzKTtcbn1cblxudmVjNCBpbnRlZ2VyTW9kKHZlYzQgeCwgdmVjNCB5KSB7XG4gIHZlYzQgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG5mbG9hdCBpbnRlZ2VyTW9kKGZsb2F0IHgsIGZsb2F0IHkpIHtcbiAgZmxvYXQgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIChyZXMgPiBmbG9vcih5KSAtIDEuMCA/IDAuMCA6IDEuMCk7XG59XG5cbmludCBpbnRlZ2VyTW9kKGludCB4LCBpbnQgeSkge1xuICByZXR1cm4geCAtICh5ICogaW50KHgveSkpO1xufVxuXG5fX0RJVklERV9XSVRIX0lOVEVHRVJfQ0hFQ0tfXztcblxuLy8gSGVyZSBiZSBkcmFnb25zIVxuLy8gRE8gTk9UIE9QVElNSVpFIFRISVMgQ09ERVxuLy8gWU9VIFdJTEwgQlJFQUsgU09NRVRISU5HIE9OIFNPTUVCT0RZXFwnUyBNQUNISU5FXG4vLyBMRUFWRSBJVCBBUyBJVCBJUywgTEVTVCBZT1UgV0FTVEUgWU9VUiBPV04gVElNRVxuY29uc3QgdmVjMiBNQUdJQ19WRUMgPSB2ZWMyKDEuMCwgLTI1Ni4wKTtcbmNvbnN0IHZlYzQgU0NBTEVfRkFDVE9SID0gdmVjNCgxLjAsIDI1Ni4wLCA2NTUzNi4wLCAwLjApO1xuY29uc3QgdmVjNCBTQ0FMRV9GQUNUT1JfSU5WID0gdmVjNCgxLjAsIDAuMDAzOTA2MjUsIDAuMDAwMDE1MjU4Nzg5MDYyNSwgMC4wKTsgLy8gMSwgMS8yNTYsIDEvNjU1MzZcbmZsb2F0IGRlY29kZTMyKHZlYzQgdGV4ZWwpIHtcbiAgX19ERUNPREUzMl9FTkRJQU5ORVNTX187XG4gIHRleGVsICo9IDI1NS4wO1xuICB2ZWMyIGd0ZTEyODtcbiAgZ3RlMTI4LnggPSB0ZXhlbC5iID49IDEyOC4wID8gMS4wIDogMC4wO1xuICBndGUxMjgueSA9IHRleGVsLmEgPj0gMTI4LjAgPyAxLjAgOiAwLjA7XG4gIGZsb2F0IGV4cG9uZW50ID0gMi4wICogdGV4ZWwuYSAtIDEyNy4wICsgZG90KGd0ZTEyOCwgTUFHSUNfVkVDKTtcbiAgZmxvYXQgcmVzID0gZXhwMihyb3VuZChleHBvbmVudCkpO1xuICB0ZXhlbC5iID0gdGV4ZWwuYiAtIDEyOC4wICogZ3RlMTI4Lng7XG4gIHJlcyA9IGRvdCh0ZXhlbCwgU0NBTEVfRkFDVE9SKSAqIGV4cDIocm91bmQoZXhwb25lbnQtMjMuMCkpICsgcmVzO1xuICByZXMgKj0gZ3RlMTI4LnkgKiAtMi4wICsgMS4wO1xuICByZXR1cm4gcmVzO1xufVxuXG5mbG9hdCBkZWNvZGUxNih2ZWM0IHRleGVsLCBpbnQgaW5kZXgpIHtcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKGluZGV4LCAyKTtcbiAgcmV0dXJuIHRleGVsW2NoYW5uZWwqMl0gKiAyNTUuMCArIHRleGVsW2NoYW5uZWwqMiArIDFdICogNjUyODAuMDtcbn1cblxuZmxvYXQgZGVjb2RlOCh2ZWM0IHRleGVsLCBpbnQgaW5kZXgpIHtcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKGluZGV4LCA0KTtcbiAgcmV0dXJuIHRleGVsW2NoYW5uZWxdICogMjU1LjA7XG59XG5cbnZlYzQgbGVnYWN5RW5jb2RlMzIoZmxvYXQgZikge1xuICBmbG9hdCBGID0gYWJzKGYpO1xuICBmbG9hdCBzaWduID0gZiA8IDAuMCA/IDEuMCA6IDAuMDtcbiAgZmxvYXQgZXhwb25lbnQgPSBmbG9vcihsb2cyKEYpKTtcbiAgZmxvYXQgbWFudGlzc2EgPSAoZXhwMigtZXhwb25lbnQpICogRik7XG4gIC8vIGV4cG9uZW50ICs9IGZsb29yKGxvZzIobWFudGlzc2EpKTtcbiAgdmVjNCB0ZXhlbCA9IHZlYzQoRiAqIGV4cDIoMjMuMC1leHBvbmVudCkpICogU0NBTEVfRkFDVE9SX0lOVjtcbiAgdGV4ZWwucmcgPSBpbnRlZ2VyTW9kKHRleGVsLnJnLCAyNTYuMCk7XG4gIHRleGVsLmIgPSBpbnRlZ2VyTW9kKHRleGVsLmIsIDEyOC4wKTtcbiAgdGV4ZWwuYSA9IGV4cG9uZW50KjAuNSArIDYzLjU7XG4gIHRleGVsLmJhICs9IHZlYzIoaW50ZWdlck1vZChleHBvbmVudCsxMjcuMCwgMi4wKSwgc2lnbikgKiAxMjguMDtcbiAgdGV4ZWwgPSBmbG9vcih0ZXhlbCk7XG4gIHRleGVsICo9IDAuMDAzOTIxNTY5OyAvLyAxLzI1NVxuICBfX0VOQ09ERTMyX0VORElBTk5FU1NfXztcbiAgcmV0dXJuIHRleGVsO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ3B1anMvZ3B1LmpzL3dpa2kvRW5jb2Rlci1kZXRhaWxzXG52ZWM0IGVuY29kZTMyKGZsb2F0IHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSAwLjApIHJldHVybiB2ZWM0KDAsIDAsIDAsIDApO1xuXG4gIGZsb2F0IGV4cG9uZW50O1xuICBmbG9hdCBtYW50aXNzYTtcbiAgdmVjNCAgcmVzdWx0O1xuICBmbG9hdCBzZ247XG5cbiAgc2duID0gc3RlcCgwLjAsIC12YWx1ZSk7XG4gIHZhbHVlID0gYWJzKHZhbHVlKTtcblxuICBleHBvbmVudCA9IGZsb29yKGxvZzIodmFsdWUpKTtcblxuICBtYW50aXNzYSA9IHZhbHVlKnBvdygyLjAsIC1leHBvbmVudCktMS4wO1xuICBleHBvbmVudCA9IGV4cG9uZW50KzEyNy4wO1xuICByZXN1bHQgICA9IHZlYzQoMCwwLDAsMCk7XG5cbiAgcmVzdWx0LmEgPSBmbG9vcihleHBvbmVudC8yLjApO1xuICBleHBvbmVudCA9IGV4cG9uZW50IC0gcmVzdWx0LmEqMi4wO1xuICByZXN1bHQuYSA9IHJlc3VsdC5hICsgMTI4LjAqc2duO1xuXG4gIHJlc3VsdC5iID0gZmxvb3IobWFudGlzc2EgKiAxMjguMCk7XG4gIG1hbnRpc3NhID0gbWFudGlzc2EgLSByZXN1bHQuYiAvIDEyOC4wO1xuICByZXN1bHQuYiA9IHJlc3VsdC5iICsgZXhwb25lbnQqMTI4LjA7XG5cbiAgcmVzdWx0LmcgPSBmbG9vcihtYW50aXNzYSozMjc2OC4wKTtcbiAgbWFudGlzc2EgPSBtYW50aXNzYSAtIHJlc3VsdC5nLzMyNzY4LjA7XG5cbiAgcmVzdWx0LnIgPSBmbG9vcihtYW50aXNzYSo4Mzg4NjA4LjApO1xuICByZXR1cm4gcmVzdWx0LzI1NS4wO1xufVxuLy8gRHJhZ29ucyBlbmQgaGVyZVxuXG5pbnQgaW5kZXg7XG5pdmVjMyB0aHJlYWRJZDtcblxuaXZlYzMgaW5kZXhUbzNEKGludCBpZHgsIGl2ZWMzIHRleERpbSkge1xuICBpbnQgeiA9IGludChpZHggLyAodGV4RGltLnggKiB0ZXhEaW0ueSkpO1xuICBpZHggLT0geiAqIGludCh0ZXhEaW0ueCAqIHRleERpbS55KTtcbiAgaW50IHkgPSBpbnQoaWR4IC8gdGV4RGltLngpO1xuICBpbnQgeCA9IGludChpbnRlZ2VyTW9kKGlkeCwgdGV4RGltLngpKTtcbiAgcmV0dXJuIGl2ZWMzKHgsIHksIHopO1xufVxuXG5mbG9hdCBnZXQzMihzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUodGV4LCBzdCAvIHZlYzIodGV4U2l6ZSkpO1xuICByZXR1cm4gZGVjb2RlMzIodGV4ZWwpO1xufVxuXG5mbG9hdCBnZXQxNihzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArICh0ZXhEaW0ueCAqICh5ICsgKHRleERpbS55ICogeikpKTtcbiAgaW50IHcgPSB0ZXhTaXplLnggKiAyO1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplLnggKiAyLCB0ZXhTaXplLnkpKTtcbiAgcmV0dXJuIGRlY29kZTE2KHRleGVsLCBpbmRleCk7XG59XG5cbmZsb2F0IGdldDgoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyAodGV4RGltLnggKiAoeSArICh0ZXhEaW0ueSAqIHopKSk7XG4gIGludCB3ID0gdGV4U2l6ZS54ICogNDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUodGV4LCBzdCAvIHZlYzIodGV4U2l6ZS54ICogNCwgdGV4U2l6ZS55KSk7XG4gIHJldHVybiBkZWNvZGU4KHRleGVsLCBpbmRleCk7XG59XG5cbmZsb2F0IGdldE1lbW9yeU9wdGltaXplZDMyKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgKHRleERpbS54ICogKHkgKyAodGV4RGltLnkgKiB6KSkpO1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDQpO1xuICBpbmRleCA9IGluZGV4IC8gNDtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIGluZGV4ID0gaW5kZXggLyA0O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIHJldHVybiB0ZXhlbFtjaGFubmVsXTtcbn1cblxudmVjNCBnZXRJbWFnZTJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICByZXR1cm4gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG59XG5cbnZlYzQgZ2V0SW1hZ2UzRChzYW1wbGVyMkRBcnJheSB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICByZXR1cm4gdGV4dHVyZSh0ZXgsIHZlYzMoc3QgLyB2ZWMyKHRleFNpemUpLCB6KSk7XG59XG5cbmZsb2F0IGdldEZsb2F0RnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgdmVjNCByZXN1bHQgPSBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbiAgcmV0dXJuIHJlc3VsdFswXTtcbn1cblxudmVjMiBnZXRWZWMyRnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgdmVjNCByZXN1bHQgPSBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbiAgcmV0dXJuIHZlYzIocmVzdWx0WzBdLCByZXN1bHRbMV0pO1xufVxuXG52ZWMyIGdldE1lbW9yeU9wdGltaXplZFZlYzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKGluZGV4LCAyKTtcbiAgaW5kZXggPSBpbmRleCAvIDI7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIGlmIChjaGFubmVsID09IDApIHJldHVybiB2ZWMyKHRleGVsLnIsIHRleGVsLmcpO1xuICBpZiAoY2hhbm5lbCA9PSAxKSByZXR1cm4gdmVjMih0ZXhlbC5iLCB0ZXhlbC5hKTtcbiAgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xufVxuXG52ZWMzIGdldFZlYzNGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gdmVjMyhyZXN1bHRbMF0sIHJlc3VsdFsxXSwgcmVzdWx0WzJdKTtcbn1cblxudmVjMyBnZXRNZW1vcnlPcHRpbWl6ZWRWZWMzKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgZmllbGRJbmRleCA9IDMgKiAoeCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopKTtcbiAgaW50IHZlY3RvckluZGV4ID0gZmllbGRJbmRleCAvIDQ7XG4gIGludCB2ZWN0b3JPZmZzZXQgPSBmaWVsZEluZGV4IC0gdmVjdG9ySW5kZXggKiA0O1xuICBpbnQgcmVhZFkgPSB2ZWN0b3JJbmRleCAvIHRleFNpemUueDtcbiAgaW50IHJlYWRYID0gdmVjdG9ySW5kZXggLSByZWFkWSAqIHRleFNpemUueDtcbiAgdmVjNCB0ZXgxID0gdGV4dHVyZSh0ZXgsICh2ZWMyKHJlYWRYLCByZWFkWSkgKyAwLjUpIC8gdmVjMih0ZXhTaXplKSk7XG5cbiAgaWYgKHZlY3Rvck9mZnNldCA9PSAwKSB7XG4gICAgcmV0dXJuIHRleDEueHl6O1xuICB9IGVsc2UgaWYgKHZlY3Rvck9mZnNldCA9PSAxKSB7XG4gICAgcmV0dXJuIHRleDEueXp3O1xuICB9IGVsc2Uge1xuICAgIHJlYWRYKys7XG4gICAgaWYgKHJlYWRYID49IHRleFNpemUueCkge1xuICAgICAgcmVhZFggPSAwO1xuICAgICAgcmVhZFkrKztcbiAgICB9XG4gICAgdmVjNCB0ZXgyID0gdGV4dHVyZSh0ZXgsIHZlYzIocmVhZFgsIHJlYWRZKSAvIHZlYzIodGV4U2l6ZSkpO1xuICAgIGlmICh2ZWN0b3JPZmZzZXQgPT0gMikge1xuICAgICAgcmV0dXJuIHZlYzModGV4MS56LCB0ZXgxLncsIHRleDIueCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2ZWMzKHRleDEudywgdGV4Mi54LCB0ZXgyLnkpO1xuICAgIH1cbiAgfVxufVxuXG52ZWM0IGdldFZlYzRGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICByZXR1cm4gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgeiwgeSwgeCk7XG59XG5cbnZlYzQgZ2V0TWVtb3J5T3B0aW1pemVkVmVjNChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDIpO1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUodGV4LCBzdCAvIHZlYzIodGV4U2l6ZSkpO1xuICByZXR1cm4gdmVjNCh0ZXhlbC5yLCB0ZXhlbC5nLCB0ZXhlbC5iLCB0ZXhlbC5hKTtcbn1cblxudmVjNCBhY3R1YWxDb2xvcjtcbnZvaWQgY29sb3IoZmxvYXQgciwgZmxvYXQgZywgZmxvYXQgYiwgZmxvYXQgYSkge1xuICBhY3R1YWxDb2xvciA9IHZlYzQocixnLGIsYSk7XG59XG5cbnZvaWQgY29sb3IoZmxvYXQgciwgZmxvYXQgZywgZmxvYXQgYikge1xuICBjb2xvcihyLGcsYiwxLjApO1xufVxuXG5mbG9hdCBtb2R1bG8oZmxvYXQgbnVtYmVyLCBmbG9hdCBkaXZpc29yKSB7XG4gIGlmIChudW1iZXIgPCAwLjApIHtcbiAgICBudW1iZXIgPSBhYnMobnVtYmVyKTtcbiAgICBpZiAoZGl2aXNvciA8IDAuMCkge1xuICAgICAgZGl2aXNvciA9IGFicyhkaXZpc29yKTtcbiAgICB9XG4gICAgcmV0dXJuIC1tb2QobnVtYmVyLCBkaXZpc29yKTtcbiAgfVxuICBpZiAoZGl2aXNvciA8IDAuMCkge1xuICAgIGRpdmlzb3IgPSBhYnMoZGl2aXNvcik7XG4gIH1cbiAgcmV0dXJuIG1vZChudW1iZXIsIGRpdmlzb3IpO1xufVxuXG5fX0lOSkVDVEVEX05BVElWRV9fO1xuX19NQUlOX0NPTlNUQU5UU19fO1xuX19NQUlOX0FSR1VNRU5UU19fO1xuX19LRVJORUxfXztcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgaW5kZXggPSBpbnQodlRleENvb3JkLnMgKiBmbG9hdCh1VGV4U2l6ZS54KSkgKyBpbnQodlRleENvb3JkLnQgKiBmbG9hdCh1VGV4U2l6ZS55KSkgKiB1VGV4U2l6ZS54O1xuICBfX01BSU5fUkVTVUxUX187XG59YDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZyYWdtZW50U2hhZGVyXG59O1xufSx7fV0sNzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4uL3dlYi1nbC9mdW5jdGlvbi1ub2RlJyk7XG5cbmNsYXNzIFdlYkdMMkZ1bmN0aW9uTm9kZSBleHRlbmRzIFdlYkdMRnVuY3Rpb25Ob2RlIHtcblxuICBhc3RJZGVudGlmaWVyRXhwcmVzc2lvbihpZHROb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoaWR0Tm9kZS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG4gICAgICAgICdJZGVudGlmaWVyRXhwcmVzc2lvbiAtIG5vdCBhbiBJZGVudGlmaWVyJyxcbiAgICAgICAgaWR0Tm9kZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGlkdE5vZGUpO1xuXG4gICAgY29uc3QgbmFtZSA9IHV0aWxzLnNhbml0aXplTmFtZShpZHROb2RlLm5hbWUpO1xuICAgIGlmIChpZHROb2RlLm5hbWUgPT09ICdJbmZpbml0eScpIHtcbiAgICAgIHJldEFyci5wdXNoKCdpbnRCaXRzVG9GbG9hdCgyMTM5MDk1MDM5KScpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0Jvb2xlYW4nKSB7XG4gICAgICBpZiAodGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICByZXRBcnIucHVzaChgYm9vbCh1c2VyXyR7bmFtZX0pYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXRBcnIucHVzaChgdXNlcl8ke25hbWV9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7bmFtZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJGdW5jdGlvbk5vZGVcbn07XG59LHtcIi4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vd2ViLWdsL2Z1bmN0aW9uLW5vZGVcIjozOH1dLDc0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVCb29sZWFuIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9ib29sZWFuJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRmxvYXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2Zsb2F0Jyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlSW50ZWdlciB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvaW50ZWdlcicpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlJyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2VBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvaHRtbC1pbWFnZS1hcnJheScpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2VBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlLWFycmF5Jyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVIVE1MVmlkZW8gfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2h0bWwtdmlkZW8nKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtdmlkZW8nKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUlucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtaW5wdXQnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWlucHV0Jyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1pbnB1dCcpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWlucHV0Jyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvbnVtYmVyLXRleHR1cmUnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1udW1iZXItdGV4dHVyZScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheScpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXknKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkxZC1pJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTFkLWknKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyZC1pJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTJkLWknKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzZC1pJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTNkLWknKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MiB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MicpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MyB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5NCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5NCcpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlVW5zaWduZWRBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvdW5zaWduZWQtYXJyYXknKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1hcnJheScpO1xuXG5jb25zdCBrZXJuZWxWYWx1ZU1hcHMgPSB7XG4gIHVuc2lnbmVkOiB7XG4gICAgZHluYW1pYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnSW50ZWdlcic6IFdlYkdMMktlcm5lbFZhbHVlSW50ZWdlcixcbiAgICAgICdGbG9hdCc6IFdlYkdMMktlcm5lbFZhbHVlRmxvYXQsXG4gICAgICAnQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogZmFsc2UsXG4gICAgICAnQXJyYXkoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheSg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCg0KSc6IGZhbHNlLFxuICAgICAgJ0lucHV0JzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMSknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgyKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZUFycmF5JzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlQXJyYXksXG4gICAgICAnSFRNTFZpZGVvJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvLFxuICAgIH0sXG4gICAgc3RhdGljOiB7XG4gICAgICAnQm9vbGVhbic6IFdlYkdMMktlcm5lbFZhbHVlQm9vbGVhbixcbiAgICAgICdGbG9hdCc6IFdlYkdMMktlcm5lbFZhbHVlRmxvYXQsXG4gICAgICAnSW50ZWdlcic6IFdlYkdMMktlcm5lbFZhbHVlSW50ZWdlcixcbiAgICAgICdBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlVW5zaWduZWRBcnJheSxcbiAgICAgICdBcnJheSgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5KDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkoNCknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDIpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCgzKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoNCknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDIpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCgzKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoNCknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDIpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCgzKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoNCknOiBmYWxzZSxcbiAgICAgICdJbnB1dCc6IFdlYkdMMktlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgxKSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSxcbiAgICAgICdIVE1MQ2FudmFzJzogV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlJzogV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZUFycmF5LFxuICAgICAgJ0hUTUxWaWRlbyc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTFZpZGVvLFxuICAgIH1cbiAgfSxcbiAgc2luZ2xlOiB7XG4gICAgZHluYW1pYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnSW50ZWdlcic6IFdlYkdMMktlcm5lbFZhbHVlSW50ZWdlcixcbiAgICAgICdGbG9hdCc6IFdlYkdMMktlcm5lbFZhbHVlRmxvYXQsXG4gICAgICAnQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheSxcbiAgICAgICdBcnJheSgyKSc6IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyLFxuICAgICAgJ0FycmF5KDMpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTMsXG4gICAgICAnQXJyYXkoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5NCxcbiAgICAgICdBcnJheTFEKDIpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxREksXG4gICAgICAnQXJyYXkxRCgzKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTJEKDIpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREksXG4gICAgICAnQXJyYXkyRCgzKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTNEKDIpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREksXG4gICAgICAnQXJyYXkzRCgzKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTNESSxcbiAgICAgICdJbnB1dCc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUlucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgxKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gICAgICAnSFRNTENhbnZhcyc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2UnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2VBcnJheSxcbiAgICAgICdIVE1MVmlkZW8nOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8sXG4gICAgfSxcbiAgICBzdGF0aWM6IHtcbiAgICAgICdCb29sZWFuJzogV2ViR0wyS2VybmVsVmFsdWVCb29sZWFuLFxuICAgICAgJ0Zsb2F0JzogV2ViR0wyS2VybmVsVmFsdWVGbG9hdCxcbiAgICAgICdJbnRlZ2VyJzogV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0FycmF5JzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheSxcbiAgICAgICdBcnJheSgyKSc6IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyLFxuICAgICAgJ0FycmF5KDMpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTMsXG4gICAgICAnQXJyYXkoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5NCxcbiAgICAgICdBcnJheTFEKDIpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTFEKDMpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTFEKDQpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTJEKDIpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTJEKDMpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTJEKDQpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTNEKDIpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSxcbiAgICAgICdBcnJheTNEKDMpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSxcbiAgICAgICdBcnJheTNEKDQpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSxcbiAgICAgICdJbnB1dCc6IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlSW5wdXQsXG4gICAgICAnTnVtYmVyVGV4dHVyZSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMSknOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgzKSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMMktlcm5lbFZhbHVlTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSxcbiAgICAgICdIVE1MQ2FudmFzJzogV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlJzogV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZUFycmF5LFxuICAgICAgJ0hUTUxWaWRlbyc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTFZpZGVvLFxuICAgIH1cbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGxvb2t1cEtlcm5lbFZhbHVlVHlwZSh0eXBlLCBkeW5hbWljLCBwcmVjaXNpb24sIHZhbHVlKSB7XG4gIGlmICghdHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKCFkeW5hbWljKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkeW5hbWljIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoIXByZWNpc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJlY2lzaW9uIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAodmFsdWUudHlwZSkge1xuICAgIHR5cGUgPSB2YWx1ZS50eXBlO1xuICB9XG4gIGNvbnN0IHR5cGVzID0ga2VybmVsVmFsdWVNYXBzW3ByZWNpc2lvbl1bZHluYW1pY107XG4gIGlmICh0eXBlc1t0eXBlXSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhIEtlcm5lbFZhbHVlIGZvciAkeyB0eXBlIH1gKTtcbiAgfVxuICByZXR1cm4gdHlwZXNbdHlwZV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrZXJuZWxWYWx1ZU1hcHMsXG4gIGxvb2t1cEtlcm5lbFZhbHVlVHlwZVxufTtcbn0se1wiLi9rZXJuZWwtdmFsdWUvYm9vbGVhblwiOjc1LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlXCI6NzcsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2UtYXJyYXlcIjo3NixcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtaHRtbC12aWRlb1wiOjc4LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlXCI6NzksXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLW51bWJlci10ZXh0dXJlXCI6ODAsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheVwiOjgxLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkxZC1pXCI6ODIsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTJkLWlcIjo4MyxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5M2QtaVwiOjg0LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtaW5wdXRcIjo4NSxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtYXJyYXlcIjo4NixcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtaW5wdXRcIjo4NyxcIi4va2VybmVsLXZhbHVlL2Zsb2F0XCI6ODgsXCIuL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlXCI6OTAsXCIuL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlLWFycmF5XCI6ODksXCIuL2tlcm5lbC12YWx1ZS9odG1sLXZpZGVvXCI6OTEsXCIuL2tlcm5lbC12YWx1ZS9pbnRlZ2VyXCI6OTIsXCIuL2tlcm5lbC12YWx1ZS9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlXCI6OTMsXCIuL2tlcm5lbC12YWx1ZS9udW1iZXItdGV4dHVyZVwiOjk0LFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5XCI6OTUsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkxZC1pXCI6OTYsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyXCI6OTcsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyZC1pXCI6OTgsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzXCI6OTksXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzZC1pXCI6MTAwLFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5NFwiOjEwMSxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dFwiOjEwMixcIi4va2VybmVsLXZhbHVlL3Vuc2lnbmVkLWFycmF5XCI6MTAzLFwiLi9rZXJuZWwtdmFsdWUvdW5zaWduZWQtaW5wdXRcIjoxMDR9XSw3NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVCb29sZWFuIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2Jvb2xlYW4nKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVCb29sZWFuIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW4ge31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlQm9vbGVhblxufTtcbn0se1wiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9ib29sZWFuXCI6NDF9XSw3NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZUFycmF5IH0gPSByZXF1aXJlKCcuL2h0bWwtaW1hZ2UtYXJyYXknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlQXJyYXkgZXh0ZW5kcyBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZUFycmF5IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEQXJyYXkgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW1hZ2VzKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBpbWFnZXNbMF07XG4gICAgdGhpcy5jaGVja1NpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gW3dpZHRoLCBoZWlnaHQsIGltYWdlcy5sZW5ndGhdO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSBbd2lkdGgsIGhlaWdodF07XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZShpbWFnZXMpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2VBcnJheVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2h0bWwtaW1hZ2UtYXJyYXlcIjo4OX1dLDc3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtaHRtbC1pbWFnZScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtaHRtbC1pbWFnZVwiOjQyfV0sNzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2R5bmFtaWMtaHRtbC1pbWFnZScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8gZXh0ZW5kcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2Uge31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlb1xufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2R5bmFtaWMtaHRtbC1pbWFnZVwiOjc3fV0sNzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZVwiOjQ0fV0sODA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtbnVtYmVyLXRleHR1cmUnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmVcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9keW5hbWljLW51bWJlci10ZXh0dXJlXCI6NDV9XSw4MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wyL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkgZXh0ZW5kcyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiB0aGlzLmJpdFJhdGlvO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wyL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXlcIjo5NX1dLDgyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxREkgZXh0ZW5kcyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWlcIjo5Nn1dLDgzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREkgZXh0ZW5kcyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWlcIjo5OH1dLDg0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREkgZXh0ZW5kcyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWlcIjoxMDB9XSw4NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUlucHV0IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wyL2tlcm5lbC12YWx1ZS9zaW5nbGUtaW5wdXQnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlSW5wdXQgZXh0ZW5kcyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUlucHV0IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgbGV0IFt3LCBoLCBkXSA9IHZhbHVlLnNpemU7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IEludDMyQXJyYXkoW3cgfHwgMSwgaCB8fCAxLCBkIHx8IDFdKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUlucHV0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dFwiOjEwMn1dLDg2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRBcnJheSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWFycmF5Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1hcnJheVwiOjUxfV0sODc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtaW5wdXQnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRJbnB1dCB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWlucHV0XCI6NTJ9XSw4ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRmxvYXQgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZmxvYXQnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVGbG9hdCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVGbG9hdCB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVGbG9hdFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2Zsb2F0XCI6NTN9XSw4OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2FycmF5Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh2YWx1ZVswXS53aWR0aCwgdmFsdWVbMF0uaGVpZ2h0KTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBbdmFsdWVbMF0ud2lkdGgsIHZhbHVlWzBdLmhlaWdodCwgdmFsdWUubGVuZ3RoXTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gW3ZhbHVlWzBdLndpZHRoLCB2YWx1ZVswXS5oZWlnaHRdO1xuICB9XG4gIGRlZmluZVRleHR1cmUoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkRfQVJSQVksIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJEX0FSUkFZLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEQXJyYXkgJHt0aGlzLmlkfWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW1hZ2VzKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcbiAgICBnbC50ZXhJbWFnZTNEKFxuICAgICAgZ2wuVEVYVFVSRV8yRF9BUlJBWSxcbiAgICAgIDAsXG4gICAgICBnbC5SR0JBLFxuICAgICAgaW1hZ2VzWzBdLndpZHRoLFxuICAgICAgaW1hZ2VzWzBdLmhlaWdodCxcbiAgICAgIGltYWdlcy5sZW5ndGgsXG4gICAgICAwLFxuICAgICAgZ2wuUkdCQSxcbiAgICAgIGdsLlVOU0lHTkVEX0JZVEUsXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeE9mZnNldCA9IDA7XG4gICAgICBjb25zdCB5T2Zmc2V0ID0gMDtcbiAgICAgIGNvbnN0IGltYWdlRGVwdGggPSAxO1xuICAgICAgZ2wudGV4U3ViSW1hZ2UzRChcbiAgICAgICAgZ2wuVEVYVFVSRV8yRF9BUlJBWSxcbiAgICAgICAgMCxcbiAgICAgICAgeE9mZnNldCxcbiAgICAgICAgeU9mZnNldCxcbiAgICAgICAgaSxcbiAgICAgICAgaW1hZ2VzW2ldLndpZHRoLFxuICAgICAgICBpbWFnZXNbaV0uaGVpZ2h0LFxuICAgICAgICBpbWFnZURlcHRoLFxuICAgICAgICBnbC5SR0JBLFxuICAgICAgICBnbC5VTlNJR05FRF9CWVRFLFxuICAgICAgICB0aGlzLnVwbG9hZFZhbHVlID0gaW1hZ2VzW2ldXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9hcnJheVwiOjQwfV0sOTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvaHRtbC1pbWFnZVwiOjU0fV0sOTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UgfSA9IHJlcXVpcmUoJy4vaHRtbC1pbWFnZScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxWaWRlbyBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlIHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxWaWRlb1xufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2h0bWwtaW1hZ2VcIjo5MH1dLDkyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUludGVnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvaW50ZWdlcicpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUludGVnZXIgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlSW50ZWdlciB7XG4gIGdldFNvdXJjZSh2YWx1ZSkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHtcbiAgICAgIHJldHVybiBgY29uc3QgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpbnQgJHt0aGlzLmlkfSA9ICR7IHBhcnNlSW50KHZhbHVlKSB9O1xcbmA7XG4gICAgfVxuICAgIHJldHVybiBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGludCAke3RoaXMuaWR9O1xcbmA7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybjtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyXG59O1xufSx7XCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2ludGVnZXJcIjo1N31dLDkzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgeyBpZCwgc2l6ZUlkLCB0ZXh0dXJlU2l6ZSwgZGltZW5zaW9uc0lkLCBkaW1lbnNpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke2lkfWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3NpemVJZH0gPSBpdmVjMigke3RleHR1cmVTaXplWzBdfSwgJHt0ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7ZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7ZGltZW5zaW9uc1swXX0sICR7ZGltZW5zaW9uc1sxXX0sICR7ZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZVwiOjU4fV0sOTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvbnVtYmVyLXRleHR1cmUnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgeyBpZCwgc2l6ZUlkLCB0ZXh0dXJlU2l6ZSwgZGltZW5zaW9uc0lkLCBkaW1lbnNpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7aWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7c2l6ZUlkfSA9IGl2ZWMyKCR7dGV4dHVyZVNpemVbMF19LCAke3RleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHtkaW1lbnNpb25zSWR9ID0gaXZlYzMoJHtkaW1lbnNpb25zWzBdfSwgJHtkaW1lbnNpb25zWzFdfSwgJHtkaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmVcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9udW1iZXItdGV4dHVyZVwiOjU5fV0sOTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5XCI6NjB9XSw5NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MWQtaScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJIHtcbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuVG8odmFsdWUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEzMkYsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkxRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkxZC1pXCI6NjF9XSw5NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTIgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MicpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MiBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTIge31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyXG59O1xufSx7XCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJcIjo2Mn1dLDk4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyZC1pJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkge1xuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW5Ubyh2YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQTMyRiwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWlcIjo2M31dLDk5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MyB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkzIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MyB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNcbn07XG59LHtcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M1wiOjY0fV0sMTAwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzZC1pJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkge1xuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW5Ubyh2YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQTMyRiwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWlcIjo2NX1dLDEwMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTQgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5NCcpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5NCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTQge31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXk0XG59O1xufSx7XCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTRcIjo2Nn1dLDEwMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlSW5wdXQgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWlucHV0Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlSW5wdXQgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlSW5wdXQge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW5wdXQpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW5UbyhpbnB1dC52YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQTMyRiwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVJbnB1dFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dFwiOjY3fV0sMTAzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3Vuc2lnbmVkLWFycmF5Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlVW5zaWduZWRBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvdW5zaWduZWQtYXJyYXlcIjo2OH1dLDEwNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1pbnB1dCcpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXQgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlVW5zaWduZWRJbnB1dFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3Vuc2lnbmVkLWlucHV0XCI6Njl9XSwxMDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbCB9ID0gcmVxdWlyZSgnLi4vd2ViLWdsL2tlcm5lbCcpO1xuY29uc3QgeyBXZWJHTDJGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tbm9kZScpO1xuY29uc3QgeyBGdW5jdGlvbkJ1aWxkZXIgfSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uLWJ1aWxkZXInKTtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IGZyYWdtZW50U2hhZGVyIH0gPSByZXF1aXJlKCcuL2ZyYWdtZW50LXNoYWRlcicpO1xuY29uc3QgeyB2ZXJ0ZXhTaGFkZXIgfSA9IHJlcXVpcmUoJy4vdmVydGV4LXNoYWRlcicpO1xuY29uc3QgeyBsb29rdXBLZXJuZWxWYWx1ZVR5cGUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlLW1hcHMnKTtcblxubGV0IGlzU3VwcG9ydGVkID0gbnVsbDtcbmxldCB0ZXN0Q2FudmFzID0gbnVsbDtcbmxldCB0ZXN0Q29udGV4dCA9IG51bGw7XG5sZXQgdGVzdEV4dGVuc2lvbnMgPSBudWxsO1xuXG5sZXQgZmVhdHVyZXMgPSBudWxsO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWwgZXh0ZW5kcyBXZWJHTEtlcm5lbCB7XG4gIHN0YXRpYyBnZXQgaXNTdXBwb3J0ZWQoKSB7XG4gICAgaWYgKGlzU3VwcG9ydGVkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gICAgfVxuICAgIHRoaXMuc2V0dXBGZWF0dXJlQ2hlY2tzKCk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0aGlzLmlzQ29udGV4dE1hdGNoKHRlc3RDb250ZXh0KTtcbiAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgc2V0dXBGZWF0dXJlQ2hlY2tzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0ZXN0Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGVzdENhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMCwgMCk7XG4gICAgfVxuICAgIGlmICghdGVzdENhbnZhcykgcmV0dXJuO1xuICAgIHRlc3RDb250ZXh0ID0gdGVzdENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInKTtcbiAgICBpZiAoIXRlc3RDb250ZXh0IHx8ICF0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24pIHJldHVybjtcbiAgICB0ZXN0RXh0ZW5zaW9ucyA9IHtcbiAgICAgIEVYVF9jb2xvcl9idWZmZXJfZmxvYXQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpLFxuICAgICAgT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpLFxuICAgIH07XG4gICAgZmVhdHVyZXMgPSB0aGlzLmdldEZlYXR1cmVzKCk7XG4gIH1cblxuICBzdGF0aWMgaXNDb250ZXh0TWF0Y2goY29udGV4dCkge1xuICAgIGlmICh0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBjb250ZXh0IGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGdldEZlYXR1cmVzKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy50ZXN0Q29udGV4dDtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBpc0Zsb2F0UmVhZDogdGhpcy5nZXRJc0Zsb2F0UmVhZCgpLFxuICAgICAgaXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZTogdGhpcy5nZXRJc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlKCksXG4gICAgICBpc1NwZWVkVGFjdGljU3VwcG9ydGVkOiB0aGlzLmdldElzU3BlZWRUYWN0aWNTdXBwb3J0ZWQoKSxcbiAgICAgIGtlcm5lbE1hcDogdHJ1ZSxcbiAgICAgIGlzVGV4dHVyZUZsb2F0OiB0cnVlLFxuICAgICAgaXNEcmF3QnVmZmVyczogdHJ1ZSxcbiAgICAgIGNoYW5uZWxDb3VudDogdGhpcy5nZXRDaGFubmVsQ291bnQoKSxcbiAgICAgIG1heFRleHR1cmVTaXplOiB0aGlzLmdldE1heFRleHR1cmVTaXplKCksXG4gICAgICBsb3dJbnRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkxPV19JTlQpLFxuICAgICAgbG93RmxvYXRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkxPV19GTE9BVCksXG4gICAgICBtZWRpdW1JbnRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9JTlQpLFxuICAgICAgbWVkaXVtRmxvYXRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCksXG4gICAgICBoaWdoSW50UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0lOVCksXG4gICAgICBoaWdoRmxvYXRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQpLFxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldElzVGV4dHVyZUZsb2F0KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGljIGdldENoYW5uZWxDb3VudCgpIHtcbiAgICByZXR1cm4gdGVzdENvbnRleHQuZ2V0UGFyYW1ldGVyKHRlc3RDb250ZXh0Lk1BWF9EUkFXX0JVRkZFUlMpO1xuICB9XG5cbiAgc3RhdGljIGdldE1heFRleHR1cmVTaXplKCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dC5nZXRQYXJhbWV0ZXIodGVzdENvbnRleHQuTUFYX1RFWFRVUkVfU0laRSk7XG4gIH1cblxuICBzdGF0aWMgbG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIGR5bmFtaWMsIHByZWNpc2lvbiwgdmFsdWUpIHtcbiAgICByZXR1cm4gbG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIGR5bmFtaWMsIHByZWNpc2lvbiwgdmFsdWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q2FudmFzKCkge1xuICAgIHJldHVybiB0ZXN0Q2FudmFzO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGVzdENvbnRleHQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGZlYXR1cmVzKCkge1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZnJhZ21lbnRTaGFkZXIoKSB7XG4gICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICB9XG4gIHN0YXRpYyBnZXQgdmVydGV4U2hhZGVyKCkge1xuICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG4gIH1cblxuICBpbml0Q29udGV4dCgpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgIGRlcHRoOiBmYWxzZSxcbiAgICAgIGFudGlhbGlhczogZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBzZXR0aW5ncyk7XG4gIH1cblxuICBpbml0RXh0ZW5zaW9ucygpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7XG4gICAgICBFWFRfY29sb3JfYnVmZmVyX2Zsb2F0OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JyksXG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXI6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpLFxuICAgIH07XG4gIH1cblxuICB2YWxpZGF0ZVNldHRpbmdzKGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMudmFsaWRhdGUpIHtcbiAgICAgIHRoaXMudGV4U2l6ZSA9IHV0aWxzLmdldEtlcm5lbFRleHR1cmVTaXplKHtcbiAgICAgICAgb3B0aW1pemVGbG9hdE1lbW9yeTogdGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgICAgICBwcmVjaXNpb246IHRoaXMucHJlY2lzaW9uLFxuICAgICAgfSwgdGhpcy5vdXRwdXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgZmVhdHVyZXMgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJyAmJiAhZmVhdHVyZXMuaXNGbG9hdFJlYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmxvYXQgdGV4dHVyZSBvdXRwdXRzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5ncmFwaGljYWwgJiYgdGhpcy5wcmVjaXNpb24gPT09IG51bGwpIHtcbiAgICAgIHRoaXMucHJlY2lzaW9uID0gZmVhdHVyZXMuaXNGbG9hdFJlYWQgPyAnc2luZ2xlJyA6ICd1bnNpZ25lZCc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSAhZmVhdHVyZXMuaXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgJiYgZmVhdHVyZXMuaXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZSkge1xuICAgICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tPdXRwdXQoKTtcblxuICAgIGlmICghdGhpcy5vdXRwdXQgfHwgdGhpcy5vdXRwdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRvIG91dHB1dCBvbmx5IHN1cHBvcnRlZCBmb3Iga2VybmVscyB3aXRoIG9ubHkgb25lIGlucHV0Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFyZ1R5cGUgPSB1dGlscy5nZXRWYXJpYWJsZVR5cGUoYXJnc1swXSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICBzd2l0Y2ggKGFyZ1R5cGUpIHtcbiAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgIHRoaXMub3V0cHV0ID0gdXRpbHMuZ2V0RGltZW5zaW9ucyhhcmdUeXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTnVtYmVyVGV4dHVyZSc6XG4gICAgICAgIGNhc2UgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOlxuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMSknOlxuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMiknOlxuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMyknOlxuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoNCknOlxuICAgICAgICAgIHRoaXMub3V0cHV0ID0gYXJnc1swXS5vdXRwdXQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRvIG91dHB1dCBub3Qgc3VwcG9ydGVkIGZvciBpbnB1dCB0eXBlOiAnICsgYXJnVHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICBpZiAodGhpcy5vdXRwdXQubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3V0cHV0IG11c3QgaGF2ZSAyIGRpbWVuc2lvbnMgb24gZ3JhcGhpY2FsIG1vZGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Nhbm5vdCB1c2UgZ3JhcGhpY2FsIG1vZGUgYW5kIHNpbmdsZSBwcmVjaXNpb24gYXQgdGhlIHNhbWUgdGltZScpO1xuICAgICAgICB0aGlzLnByZWNpc2lvbiA9ICd1bnNpZ25lZCc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGV4U2l6ZSA9IHV0aWxzLmNsb25lKHRoaXMub3V0cHV0KTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmdyYXBoaWNhbCAmJiB0aGlzLnByZWNpc2lvbiA9PT0gbnVsbCAmJiBmZWF0dXJlcy5pc1RleHR1cmVGbG9hdCkge1xuICAgICAgdGhpcy5wcmVjaXNpb24gPSAnc2luZ2xlJztcbiAgICB9XG5cbiAgICB0aGlzLnRleFNpemUgPSB1dGlscy5nZXRLZXJuZWxUZXh0dXJlU2l6ZSh7XG4gICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICBwcmVjaXNpb246IHRoaXMucHJlY2lzaW9uLFxuICAgIH0sIHRoaXMub3V0cHV0KTtcblxuICAgIHRoaXMuY2hlY2tUZXh0dXJlU2l6ZSgpO1xuICB9XG5cbiAgdHJhbnNsYXRlU291cmNlKCkge1xuICAgIGNvbnN0IGZ1bmN0aW9uQnVpbGRlciA9IEZ1bmN0aW9uQnVpbGRlci5mcm9tS2VybmVsKHRoaXMsIFdlYkdMMkZ1bmN0aW9uTm9kZSwge1xuICAgICAgZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3k6IHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3lcbiAgICB9KTtcbiAgICB0aGlzLnRyYW5zbGF0ZWRTb3VyY2UgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0UHJvdG90eXBlU3RyaW5nKCdrZXJuZWwnKTtcbiAgICB0aGlzLnNldHVwUmV0dXJuVHlwZXMoZnVuY3Rpb25CdWlsZGVyKTtcbiAgfVxuXG4gIGRyYXdCdWZmZXJzKCkge1xuICAgIHRoaXMuY29udGV4dC5kcmF3QnVmZmVycyh0aGlzLmRyYXdCdWZmZXJzTWFwKTtcbiAgfVxuXG4gIGdldFRleHR1cmVGb3JtYXQoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBzd2l0Y2ggKHRoaXMuZ2V0SW50ZXJuYWxGb3JtYXQoKSkge1xuICAgICAgY2FzZSBnbC5SMzJGOlxuICAgICAgICByZXR1cm4gZ2wuUkVEO1xuICAgICAgY2FzZSBnbC5SRzMyRjpcbiAgICAgICAgcmV0dXJuIGdsLlJHO1xuICAgICAgY2FzZSBnbC5SR0JBMzJGOlxuICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICAgIGNhc2UgZ2wuUkdCQTpcbiAgICAgICAgcmV0dXJuIGdsLlJHQkE7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaW50ZXJuYWwgZm9ybWF0Jyk7XG4gICAgfVxuICB9XG4gIGdldEludGVybmFsRm9ybWF0KCkge1xuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICBpZiAodGhpcy5waXBlbGluZSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2wuUkdCQTMyRjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBnbC5SMzJGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgICAgICByZXR1cm4gZ2wuUkczMkY7XG4gICAgICAgICAgICBjYXNlICdBcnJheSgzKSc6IFxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgICAgICByZXR1cm4gZ2wuUkdCQTMyRjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5oYW5kbGVkIHJldHVybiB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBnbC5SR0JBMzJGO1xuICAgIH1cbiAgICByZXR1cm4gZ2wuUkdCQTtcbiAgfVxuXG4gIF9zZXR1cE91dHB1dFRleHR1cmUoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUudGV4dHVyZSwgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBjb25zdCB0ZXhTaXplID0gdGhpcy50ZXhTaXplO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50VGV4dHVyZUNvdW50ICsgdGhpcy5hcmd1bWVudFRleHR1cmVDb3VudCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuUkVQRUFUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5SRVBFQVQpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpO1xuICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIGdsLnRleFN0b3JhZ2UyRChnbC5URVhUVVJFXzJELCAxLCBmb3JtYXQsIHRleFNpemVbMF0sIHRleFNpemVbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZm9ybWF0LCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICB9XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcbiAgICB0aGlzLnRleHR1cmUgPSBuZXcgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3Ioe1xuICAgICAgdGV4dHVyZSxcbiAgICAgIHNpemU6IHRleFNpemUsXG4gICAgICBkaW1lbnNpb25zOiB0aGlzLnRocmVhZERpbSxcbiAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICBpbnRlcm5hbEZvcm1hdDogdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpLFxuICAgICAgdGV4dHVyZUZvcm1hdDogdGhpcy5nZXRUZXh0dXJlRm9ybWF0KCksXG4gICAgICBrZXJuZWw6IHRoaXMsXG4gICAgfSk7XG4gIH1cblxuICBfc2V0dXBTdWJPdXRwdXRUZXh0dXJlcygpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICBpZiAodGhpcy5tYXBwZWRUZXh0dXJlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEsIGdsLlRFWFRVUkVfMkQsIHRoaXMubWFwcGVkVGV4dHVyZXNbaV0udGV4dHVyZSwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleFNpemUgPSB0aGlzLnRleFNpemU7XG4gICAgdGhpcy5kcmF3QnVmZmVyc01hcCA9IFtnbC5DT0xPUl9BVFRBQ0hNRU5UMF07XG4gICAgdGhpcy5tYXBwZWRUZXh0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICB0aGlzLmRyYXdCdWZmZXJzTWFwLnB1c2goZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSk7XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudFRleHR1cmVDb3VudCArIHRoaXMuYXJndW1lbnRUZXh0dXJlQ291bnQgKyBpKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0SW50ZXJuYWxGb3JtYXQoKTtcbiAgICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgZ2wudGV4U3RvcmFnZTJEKGdsLlRFWFRVUkVfMkQsIDEsIGZvcm1hdCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgICAgfVxuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuXG4gICAgICB0aGlzLm1hcHBlZFRleHR1cmVzLnB1c2gobmV3IHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yKHtcbiAgICAgICAgdGV4dHVyZSxcbiAgICAgICAgc2l6ZTogdGV4U2l6ZSxcbiAgICAgICAgZGltZW5zaW9uczogdGhpcy50aHJlYWREaW0sXG4gICAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgaW50ZXJuYWxGb3JtYXQ6IHRoaXMuZ2V0SW50ZXJuYWxGb3JtYXQoKSxcbiAgICAgICAgdGV4dHVyZUZvcm1hdDogdGhpcy5nZXRUZXh0dXJlRm9ybWF0KCksXG4gICAgICAgIGtlcm5lbDogdGhpcyxcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0SGVhZGVyU3RyaW5nKCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIF9nZXRUZXh0dXJlQ29vcmRpbmF0ZSgpIHtcbiAgICBjb25zdCBzdWJLZXJuZWxzID0gdGhpcy5zdWJLZXJuZWxzO1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZyh0aGlzLnRleFNpemUsIHRoaXMudGFjdGljKTtcbiAgICBpZiAoc3ViS2VybmVscyA9PT0gbnVsbCB8fCBzdWJLZXJuZWxzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBgaW4gJHsgdmFyaWFibGVQcmVjaXNpb24gfSB2ZWMyIHZUZXhDb29yZDtcXG5gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYG91dCAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHZlYzIgdlRleENvb3JkO1xcbmA7XG4gICAgfVxuICB9XG5cbiAgX2dldE1haW5Bcmd1bWVudHNTdHJpbmcoYXJncykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IGFyZ3VtZW50TmFtZXMgPSB0aGlzLmFyZ3VtZW50TmFtZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaCh0aGlzLmtlcm5lbEFyZ3VtZW50c1tpXS5nZXRTb3VyY2UoYXJnc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICB9XG5cbiAgZ2V0S2VybmVsU3RyaW5nKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFt0aGlzLmdldEtlcm5lbFJlc3VsdERlY2xhcmF0aW9uKCldO1xuICAgIGNvbnN0IHN1Yktlcm5lbHMgPSB0aGlzLnN1Yktlcm5lbHM7XG4gICAgaWYgKHN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAnbGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzQgZGF0YTAnXG4gICAgICApO1xuICAgICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHN1Yktlcm5lbHNbaV07XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgc3ViS2VybmVsLnJldHVyblR5cGUgPT09ICdJbnRlZ2VyJyA/XG4gICAgICAgICAgICAgIGBpbnQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH0gPSAwYCA6XG4gICAgICAgICAgICAgIGBmbG9hdCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IDAuMGAsXG4gICAgICAgICAgICAgIGBsYXlvdXQobG9jYXRpb24gPSAkeyBpICsgMSB9KSBvdXQgdmVjNCBkYXRhJHsgaSArIDEgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYHZlYzIgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbHNbaV0ubmFtZSB9YCxcbiAgICAgICAgICAgICAgYGxheW91dChsb2NhdGlvbiA9ICR7IGkgKyAxIH0pIG91dCB2ZWM0IGRhdGEkeyBpICsgMSB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBgdmVjMyBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsc1tpXS5uYW1lIH1gLFxuICAgICAgICAgICAgICBgbGF5b3V0KGxvY2F0aW9uID0gJHsgaSArIDEgfSkgb3V0IHZlYzQgZGF0YSR7IGkgKyAxIH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIGB2ZWM0IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWxzW2ldLm5hbWUgfWAsXG4gICAgICAgICAgICAgIGBsYXlvdXQobG9jYXRpb24gPSAkeyBpICsgMSB9KSBvdXQgdmVjNCBkYXRhJHsgaSArIDEgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgJ291dCB2ZWM0IGRhdGEwJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpICsgdGhpcy50cmFuc2xhdGVkU291cmNlO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEdyYXBoaWNhbCgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZGF0YTAgPSBhY3R1YWxDb2xvcicsXG4gICAgXSk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0UGFja2VkUGl4ZWxzKCkge1xuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxQYWNrZWRQaXhlbHMoKSArXG4gICAgICAgICAgdGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsUGFja2VkUGl4ZWxzKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhY2tlZCBvdXRwdXQgb25seSB1c2FibGUgd2l0aCBOdW1iZXJzLCBcIiR7dGhpcy5yZXR1cm5UeXBlfVwiIHNwZWNpZmllZGApO1xuICAgIH1cbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxQYWNrZWRQaXhlbHMoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgIGAgIGRhdGEwID0gJHt0aGlzLnVzZUxlZ2FjeUVuY29kZXIgPyAnbGVnYWN5RW5jb2RlMzInIDogJ2VuY29kZTMyJ30oa2VybmVsUmVzdWx0KWBcbiAgICBdKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxQYWNrZWRQaXhlbHMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgaWYgKHN1Yktlcm5lbC5yZXR1cm5UeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZGF0YSR7aSArIDF9ID0gJHt0aGlzLnVzZUxlZ2FjeUVuY29kZXIgPyAnbGVnYWN5RW5jb2RlMzInIDogJ2VuY29kZTMyJ30oZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9KSlgXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBkYXRhJHtpICsgMX0gPSAke3RoaXMudXNlTGVnYWN5RW5jb2RlciA/ICdsZWdhY3lFbmNvZGUzMicgOiAnZW5jb2RlMzInfShzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX0pYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbE1lbW9yeU9wdGltaXplZEZsb2F0cyhyZXN1bHQsIGNoYW5uZWwpIHtcbiAgICByZXN1bHQucHVzaChcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICBgICBkYXRhMC4ke2NoYW5uZWx9ID0ga2VybmVsUmVzdWx0YCxcbiAgICApO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbE1lbW9yeU9wdGltaXplZEZsb2F0cyhyZXN1bHQsIGNoYW5uZWwpIHtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgaWYgKHN1Yktlcm5lbC5yZXR1cm5UeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZGF0YSR7aSArIDF9LiR7Y2hhbm5lbH0gPSBmbG9hdChzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX0pYCxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGRhdGEke2kgKyAxfS4ke2NoYW5uZWx9ID0gc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsTnVtYmVyVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgICcgIGRhdGEwWzBdID0ga2VybmVsUmVzdWx0JyxcbiAgICBdO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbE51bWJlclRleHR1cmUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIGlmIChzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGRhdGEke2kgKyAxfVswXSA9IGZsb2F0KHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfSlgLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZGF0YSR7aSArIDF9WzBdID0gc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTJUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZGF0YTBbMF0gPSBrZXJuZWxSZXN1bHRbMF0nLFxuICAgICAgJyAgZGF0YTBbMV0gPSBrZXJuZWxSZXN1bHRbMV0nLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXkyVGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgIGAgIGRhdGEke2kgKyAxfVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVswXWAsXG4gICAgICAgIGAgIGRhdGEke2kgKyAxfVsxXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVsxXWAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5M1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBkYXRhMFswXSA9IGtlcm5lbFJlc3VsdFswXScsXG4gICAgICAnICBkYXRhMFsxXSA9IGtlcm5lbFJlc3VsdFsxXScsXG4gICAgICAnICBkYXRhMFsyXSA9IGtlcm5lbFJlc3VsdFsyXScsXG4gICAgXTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTNUZXh0dXJlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBzdWJLZXJuZWwgPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgYCAgZGF0YSR7aSArIDF9WzBdID0gc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9WzBdYCxcbiAgICAgICAgYCAgZGF0YSR7aSArIDF9WzFdID0gc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9WzFdYCxcbiAgICAgICAgYCAgZGF0YSR7aSArIDF9WzJdID0gc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9WzJdYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXk0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgICcgIGRhdGEwID0ga2VybmVsUmVzdWx0JyxcbiAgICBdO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5NFRleHR1cmUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICBgICBkYXRhJHtpICsgMX0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGRlc3Ryb3lFeHRlbnNpb25zKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5FWFRfY29sb3JfYnVmZmVyX2Zsb2F0ID0gbnVsbDtcbiAgICB0aGlzLmV4dGVuc2lvbnMuT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyID0gbnVsbDtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBqc29uID0gc3VwZXIudG9KU09OKCk7XG4gICAganNvbi5mdW5jdGlvbk5vZGVzID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgV2ViR0wyRnVuY3Rpb25Ob2RlKS50b0pTT04oKTtcbiAgICBqc29uLnNldHRpbmdzLnRocmVhZERpbSA9IHRoaXMudGhyZWFkRGltO1xuICAgIHJldHVybiBqc29uO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxcbn07XG59LHtcIi4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vZnVuY3Rpb24tYnVpbGRlclwiOjksXCIuLi93ZWItZ2wva2VybmVsXCI6NzAsXCIuL2ZyYWdtZW50LXNoYWRlclwiOjcyLFwiLi9mdW5jdGlvbi1ub2RlXCI6NzMsXCIuL2tlcm5lbC12YWx1ZS1tYXBzXCI6NzQsXCIuL3ZlcnRleC1zaGFkZXJcIjoxMDZ9XSwxMDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgdmVydGV4U2hhZGVyID0gYCN2ZXJzaW9uIDMwMCBlc1xuX19GTE9BVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fSU5UX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuX19TQU1QTEVSXzJEX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuXG5pbiB2ZWMyIGFQb3M7XG5pbiB2ZWMyIGFUZXhDb29yZDtcblxub3V0IHZlYzIgdlRleENvb3JkO1xudW5pZm9ybSB2ZWMyIHJhdGlvO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnbF9Qb3NpdGlvbiA9IHZlYzQoKGFQb3MgKyB2ZWMyKDEpKSAqIHJhdGlvICsgdmVjMigtMSksIDAsIDEpO1xuICB2VGV4Q29vcmQgPSBhVGV4Q29vcmQ7XG59YDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZlcnRleFNoYWRlclxufTtcbn0se31dLDEwNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCBsaWIgPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5jb25zdCBHUFUgPSBsaWIuR1BVO1xuZm9yIChjb25zdCBwIGluIGxpYikge1xuICBpZiAoIWxpYi5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gIGlmIChwID09PSAnR1BVJykgY29udGludWU7IFxuICBHUFVbcF0gPSBsaWJbcF07XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBiaW5kVG8od2luZG93KTtcbn1cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgYmluZFRvKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBiaW5kVG8odGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQuR1BVKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdHUFUnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEdQVTtcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpYjtcbn0se1wiLi9pbmRleFwiOjEwOX1dLDEwODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IGdwdU1vY2sgfSA9IHJlcXVpcmUoJ2dwdS1tb2NrLmpzJyk7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB7IEtlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2tlcm5lbCcpO1xuY29uc3QgeyBDUFVLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9jcHUva2VybmVsJyk7XG5jb25zdCB7IEhlYWRsZXNzR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9oZWFkbGVzcy1nbC9rZXJuZWwnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsMi9rZXJuZWwnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wva2VybmVsJyk7XG5jb25zdCB7IGtlcm5lbFJ1blNob3J0Y3V0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC1ydW4tc2hvcnRjdXQnKTtcblxuXG5jb25zdCBrZXJuZWxPcmRlciA9IFtIZWFkbGVzc0dMS2VybmVsLCBXZWJHTDJLZXJuZWwsIFdlYkdMS2VybmVsXTtcblxuY29uc3Qga2VybmVsVHlwZXMgPSBbJ2dwdScsICdjcHUnXTtcblxuY29uc3QgaW50ZXJuYWxLZXJuZWxzID0ge1xuICAnaGVhZGxlc3NnbCc6IEhlYWRsZXNzR0xLZXJuZWwsXG4gICd3ZWJnbDInOiBXZWJHTDJLZXJuZWwsXG4gICd3ZWJnbCc6IFdlYkdMS2VybmVsLFxufTtcblxubGV0IHZhbGlkYXRlID0gdHJ1ZTtcblxuY2xhc3MgR1BVIHtcbiAgc3RhdGljIGRpc2FibGVWYWxpZGF0aW9uKCkge1xuICAgIHZhbGlkYXRlID0gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgZW5hYmxlVmFsaWRhdGlvbigpIHtcbiAgICB2YWxpZGF0ZSA9IHRydWU7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzR1BVU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBrZXJuZWxPcmRlci5zb21lKEtlcm5lbCA9PiBLZXJuZWwuaXNTdXBwb3J0ZWQpO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc0tlcm5lbE1hcFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4ga2VybmVsT3JkZXIuc29tZShLZXJuZWwgPT4gS2VybmVsLmlzU3VwcG9ydGVkICYmIEtlcm5lbC5mZWF0dXJlcy5rZXJuZWxNYXApO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB8fCB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzV2ViR0xTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIFdlYkdMS2VybmVsLmlzU3VwcG9ydGVkO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc1dlYkdMMlN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gV2ViR0wyS2VybmVsLmlzU3VwcG9ydGVkO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc0hlYWRsZXNzR0xTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIEhlYWRsZXNzR0xLZXJuZWwuaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzQ2FudmFzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc0dQVUhUTUxJbWFnZUFycmF5U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBXZWJHTDJLZXJuZWwuaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzU2luZ2xlUHJlY2lzaW9uU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBrZXJuZWxPcmRlci5zb21lKEtlcm5lbCA9PiBLZXJuZWwuaXNTdXBwb3J0ZWQgJiYgS2VybmVsLmZlYXR1cmVzLmlzRmxvYXRSZWFkICYmIEtlcm5lbC5mZWF0dXJlcy5pc1RleHR1cmVGbG9hdCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgdGhpcy5jYW52YXMgPSBzZXR0aW5ncy5jYW52YXMgfHwgbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0IHx8IG51bGw7XG4gICAgdGhpcy5tb2RlID0gc2V0dGluZ3MubW9kZTtcbiAgICB0aGlzLktlcm5lbCA9IG51bGw7XG4gICAgdGhpcy5rZXJuZWxzID0gW107XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbiAgICB0aGlzLm5hdGl2ZUZ1bmN0aW9ucyA9IFtdO1xuICAgIHRoaXMuaW5qZWN0ZWROYXRpdmUgPSBudWxsO1xuICAgIHRoaXMub25Jc3RhbmJ1bENvdmVyYWdlVmFyaWFibGUgPSBzZXR0aW5ncy5vbklzdGFuYnVsQ292ZXJhZ2VWYXJpYWJsZSB8fCBudWxsO1xuICAgIHRoaXMucmVtb3ZlSXN0YW5idWxDb3ZlcmFnZSA9IHNldHRpbmdzLmhhc093blByb3BlcnR5KCdyZW1vdmVJc3RhbmJ1bENvdmVyYWdlJykgPyBzZXR0aW5ncy5yZW1vdmVJc3RhbmJ1bENvdmVyYWdlIDogbnVsbDtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnZGV2JykgcmV0dXJuO1xuICAgIHRoaXMuY2hvb3NlS2VybmVsKCk7XG4gICAgaWYgKHNldHRpbmdzLmZ1bmN0aW9ucykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5mdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGRGdW5jdGlvbihzZXR0aW5ncy5mdW5jdGlvbnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3QgcCBpbiBzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKCFzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBzID0gc2V0dGluZ3MubmF0aXZlRnVuY3Rpb25zW3BdO1xuICAgICAgICBjb25zdCB7IG5hbWUsIHNvdXJjZSB9ID0gcztcbiAgICAgICAgdGhpcy5hZGROYXRpdmVGdW5jdGlvbihuYW1lLCBzb3VyY2UsIHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNob29zZUtlcm5lbCgpIHtcbiAgICBpZiAodGhpcy5LZXJuZWwpIHJldHVybjtcblxuICAgIGxldCBLZXJuZWwgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBFeHRlcm5hbEtlcm5lbCA9IGtlcm5lbE9yZGVyW2ldO1xuICAgICAgICBpZiAoRXh0ZXJuYWxLZXJuZWwuaXNDb250ZXh0TWF0Y2godGhpcy5jb250ZXh0KSkge1xuICAgICAgICAgIGlmICghRXh0ZXJuYWxLZXJuZWwuaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsIHR5cGUgJHtFeHRlcm5hbEtlcm5lbC5uYW1lfSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEtlcm5lbCA9IEV4dGVybmFsS2VybmVsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoS2VybmVsID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBDb250ZXh0Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGUpIHtcbiAgICAgIGlmICh0aGlzLm1vZGUgaW4gaW50ZXJuYWxLZXJuZWxzKSB7XG4gICAgICAgIGlmICghdmFsaWRhdGUgfHwgaW50ZXJuYWxLZXJuZWxzW3RoaXMubW9kZV0uaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICBLZXJuZWwgPSBpbnRlcm5hbEtlcm5lbHNbdGhpcy5tb2RlXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09ICdncHUnKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoa2VybmVsT3JkZXJbaV0uaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIEtlcm5lbCA9IGtlcm5lbE9yZGVyW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2NwdScpIHtcbiAgICAgICAgS2VybmVsID0gQ1BVS2VybmVsO1xuICAgICAgfVxuICAgICAgaWYgKCFLZXJuZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIHJlcXVlc3RlZCBtb2RlIG9mIFwiJHt0aGlzLm1vZGV9XCIgYW5kIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoa2VybmVsT3JkZXJbaV0uaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICBLZXJuZWwgPSBrZXJuZWxPcmRlcltpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFLZXJuZWwpIHtcbiAgICAgICAgS2VybmVsID0gQ1BVS2VybmVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5tb2RlKSB7XG4gICAgICB0aGlzLm1vZGUgPSBLZXJuZWwubW9kZTtcbiAgICB9XG4gICAgdGhpcy5LZXJuZWwgPSBLZXJuZWw7XG4gIH1cblxuICBjcmVhdGVLZXJuZWwoc291cmNlLCBzZXR0aW5ncykge1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNvdXJjZSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnICYmICF1dGlscy5pc0Z1bmN0aW9uKHNvdXJjZSkgJiYgdHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIHBhcmFtZXRlciBub3QgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IGtlcm5lbHMgPSB0aGlzLmtlcm5lbHM7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ2RldicpIHtcbiAgICAgIGNvbnN0IGRldktlcm5lbCA9IGdwdU1vY2soc291cmNlLCB1cGdyYWRlRGVwcmVjYXRlZENyZWF0ZUtlcm5lbFNldHRpbmdzKHNldHRpbmdzKSk7XG4gICAgICBrZXJuZWxzLnB1c2goZGV2S2VybmVsKTtcbiAgICAgIHJldHVybiBkZXZLZXJuZWw7XG4gICAgfVxuXG4gICAgc291cmNlID0gdHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZS50b1N0cmluZygpIDogc291cmNlO1xuICAgIGNvbnN0IHN3aXRjaGFibGVLZXJuZWxzID0ge307XG4gICAgY29uc3Qgc2V0dGluZ3NDb3B5ID0gdXBncmFkZURlcHJlY2F0ZWRDcmVhdGVLZXJuZWxTZXR0aW5ncyhzZXR0aW5ncykgfHwge307XG4gICAgaWYgKHNldHRpbmdzICYmIHR5cGVvZiBzZXR0aW5ncy5hcmd1bWVudFR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgc2V0dGluZ3NDb3B5LmFyZ3VtZW50VHlwZXMgPSBPYmplY3Qua2V5cyhzZXR0aW5ncy5hcmd1bWVudFR5cGVzKS5tYXAoYXJndW1lbnROYW1lID0+IHNldHRpbmdzLmFyZ3VtZW50VHlwZXNbYXJndW1lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25SZXF1ZXN0RmFsbGJhY2soYXJncykge1xuICAgICAgY29uc29sZS53YXJuKCdGYWxsaW5nIGJhY2sgdG8gQ1BVJyk7XG4gICAgICBjb25zdCBmYWxsYmFja0tlcm5lbCA9IG5ldyBDUFVLZXJuZWwoc291cmNlLCB7XG4gICAgICAgIGFyZ3VtZW50VHlwZXM6IGtlcm5lbFJ1bi5hcmd1bWVudFR5cGVzLFxuICAgICAgICBjb25zdGFudFR5cGVzOiBrZXJuZWxSdW4uY29uc3RhbnRUeXBlcyxcbiAgICAgICAgZ3JhcGhpY2FsOiBrZXJuZWxSdW4uZ3JhcGhpY2FsLFxuICAgICAgICBsb29wTWF4SXRlcmF0aW9uczoga2VybmVsUnVuLmxvb3BNYXhJdGVyYXRpb25zLFxuICAgICAgICBjb25zdGFudHM6IGtlcm5lbFJ1bi5jb25zdGFudHMsXG4gICAgICAgIGR5bmFtaWNPdXRwdXQ6IGtlcm5lbFJ1bi5keW5hbWljT3V0cHV0LFxuICAgICAgICBkeW5hbWljQXJndW1lbnQ6IGtlcm5lbFJ1bi5keW5hbWljQXJndW1lbnRzLFxuICAgICAgICBvdXRwdXQ6IGtlcm5lbFJ1bi5vdXRwdXQsXG4gICAgICAgIHByZWNpc2lvbjoga2VybmVsUnVuLnByZWNpc2lvbixcbiAgICAgICAgcGlwZWxpbmU6IGtlcm5lbFJ1bi5waXBlbGluZSxcbiAgICAgICAgaW1tdXRhYmxlOiBrZXJuZWxSdW4uaW1tdXRhYmxlLFxuICAgICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiBrZXJuZWxSdW4ub3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgICAgZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3k6IGtlcm5lbFJ1bi5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSxcbiAgICAgICAgZnVuY3Rpb25zOiBrZXJuZWxSdW4uZnVuY3Rpb25zLFxuICAgICAgICBuYXRpdmVGdW5jdGlvbnM6IGtlcm5lbFJ1bi5uYXRpdmVGdW5jdGlvbnMsXG4gICAgICAgIGluamVjdGVkTmF0aXZlOiBrZXJuZWxSdW4uaW5qZWN0ZWROYXRpdmUsXG4gICAgICAgIHN1Yktlcm5lbHM6IGtlcm5lbFJ1bi5zdWJLZXJuZWxzLFxuICAgICAgICBzdHJpY3RJbnRlZ2Vyczoga2VybmVsUnVuLnN0cmljdEludGVnZXJzLFxuICAgICAgICBkZWJ1Zzoga2VybmVsUnVuLmRlYnVnLFxuICAgICAgfSk7XG4gICAgICBmYWxsYmFja0tlcm5lbC5idWlsZC5hcHBseShmYWxsYmFja0tlcm5lbCwgYXJncyk7XG4gICAgICBjb25zdCByZXN1bHQgPSBmYWxsYmFja0tlcm5lbC5ydW4uYXBwbHkoZmFsbGJhY2tLZXJuZWwsIGFyZ3MpO1xuICAgICAga2VybmVsUnVuLnJlcGxhY2VLZXJuZWwoZmFsbGJhY2tLZXJuZWwpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblJlcXVlc3RTd2l0Y2hLZXJuZWwocmVhc29ucywgYXJncywgX2tlcm5lbCkge1xuICAgICAgaWYgKF9rZXJuZWwuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTd2l0Y2hpbmcga2VybmVscycpO1xuICAgICAgfVxuICAgICAgbGV0IG5ld091dHB1dCA9IG51bGw7XG4gICAgICBpZiAoX2tlcm5lbC5zaWduYXR1cmUgJiYgIXN3aXRjaGFibGVLZXJuZWxzW19rZXJuZWwuc2lnbmF0dXJlXSkge1xuICAgICAgICBzd2l0Y2hhYmxlS2VybmVsc1tfa2VybmVsLnNpZ25hdHVyZV0gPSBfa2VybmVsO1xuICAgICAgfVxuICAgICAgaWYgKF9rZXJuZWwuZHluYW1pY091dHB1dCkge1xuICAgICAgICBmb3IgKGxldCBpID0gcmVhc29ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IHJlYXNvbnNbaV07XG4gICAgICAgICAgaWYgKHJlYXNvbi50eXBlID09PSAnb3V0cHV0UHJlY2lzaW9uTWlzbWF0Y2gnKSB7XG4gICAgICAgICAgICBuZXdPdXRwdXQgPSByZWFzb24ubmVlZGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBDb25zdHJ1Y3RvciA9IF9rZXJuZWwuY29uc3RydWN0b3I7XG4gICAgICBjb25zdCBhcmd1bWVudFR5cGVzID0gQ29uc3RydWN0b3IuZ2V0QXJndW1lbnRUeXBlcyhfa2VybmVsLCBhcmdzKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IENvbnN0cnVjdG9yLmdldFNpZ25hdHVyZShfa2VybmVsLCBhcmd1bWVudFR5cGVzKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nS2VybmVsID0gc3dpdGNoYWJsZUtlcm5lbHNbc2lnbmF0dXJlXTtcbiAgICAgIGlmIChleGlzdGluZ0tlcm5lbCkge1xuICAgICAgICBleGlzdGluZ0tlcm5lbC5vbkFjdGl2YXRlKF9rZXJuZWwpO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdLZXJuZWw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0tlcm5lbCA9IHN3aXRjaGFibGVLZXJuZWxzW3NpZ25hdHVyZV0gPSBuZXcgQ29uc3RydWN0b3Ioc291cmNlLCB7XG4gICAgICAgIGFyZ3VtZW50VHlwZXMsXG4gICAgICAgIGNvbnN0YW50VHlwZXM6IF9rZXJuZWwuY29uc3RhbnRUeXBlcyxcbiAgICAgICAgZ3JhcGhpY2FsOiBfa2VybmVsLmdyYXBoaWNhbCxcbiAgICAgICAgbG9vcE1heEl0ZXJhdGlvbnM6IF9rZXJuZWwubG9vcE1heEl0ZXJhdGlvbnMsXG4gICAgICAgIGNvbnN0YW50czogX2tlcm5lbC5jb25zdGFudHMsXG4gICAgICAgIGR5bmFtaWNPdXRwdXQ6IF9rZXJuZWwuZHluYW1pY091dHB1dCxcbiAgICAgICAgZHluYW1pY0FyZ3VtZW50OiBfa2VybmVsLmR5bmFtaWNBcmd1bWVudHMsXG4gICAgICAgIGNvbnRleHQ6IF9rZXJuZWwuY29udGV4dCxcbiAgICAgICAgY2FudmFzOiBfa2VybmVsLmNhbnZhcyxcbiAgICAgICAgb3V0cHV0OiBuZXdPdXRwdXQgfHwgX2tlcm5lbC5vdXRwdXQsXG4gICAgICAgIHByZWNpc2lvbjogX2tlcm5lbC5wcmVjaXNpb24sXG4gICAgICAgIHBpcGVsaW5lOiBfa2VybmVsLnBpcGVsaW5lLFxuICAgICAgICBpbW11dGFibGU6IF9rZXJuZWwuaW1tdXRhYmxlLFxuICAgICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiBfa2VybmVsLm9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICAgIGZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5OiBfa2VybmVsLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5LFxuICAgICAgICBmdW5jdGlvbnM6IF9rZXJuZWwuZnVuY3Rpb25zLFxuICAgICAgICBuYXRpdmVGdW5jdGlvbnM6IF9rZXJuZWwubmF0aXZlRnVuY3Rpb25zLFxuICAgICAgICBpbmplY3RlZE5hdGl2ZTogX2tlcm5lbC5pbmplY3RlZE5hdGl2ZSxcbiAgICAgICAgc3ViS2VybmVsczogX2tlcm5lbC5zdWJLZXJuZWxzLFxuICAgICAgICBzdHJpY3RJbnRlZ2VyczogX2tlcm5lbC5zdHJpY3RJbnRlZ2VycyxcbiAgICAgICAgZGVidWc6IF9rZXJuZWwuZGVidWcsXG4gICAgICAgIGdwdTogX2tlcm5lbC5ncHUsXG4gICAgICAgIHZhbGlkYXRlLFxuICAgICAgICByZXR1cm5UeXBlOiBfa2VybmVsLnJldHVyblR5cGUsXG4gICAgICAgIG9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlOiBfa2VybmVsLm9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlLFxuICAgICAgICByZW1vdmVJc3RhbmJ1bENvdmVyYWdlOiBfa2VybmVsLnJlbW92ZUlzdGFuYnVsQ292ZXJhZ2UsXG4gICAgICAgIHRhY3RpYzogX2tlcm5lbC50YWN0aWMsXG4gICAgICAgIG9uUmVxdWVzdEZhbGxiYWNrLFxuICAgICAgICBvblJlcXVlc3RTd2l0Y2hLZXJuZWwsXG4gICAgICAgIHRleHR1cmU6IF9rZXJuZWwudGV4dHVyZSxcbiAgICAgICAgbWFwcGVkVGV4dHVyZXM6IF9rZXJuZWwubWFwcGVkVGV4dHVyZXMsXG4gICAgICAgIGRyYXdCdWZmZXJzTWFwOiBfa2VybmVsLmRyYXdCdWZmZXJzTWFwLFxuICAgICAgfSk7XG4gICAgICBuZXdLZXJuZWwuYnVpbGQuYXBwbHkobmV3S2VybmVsLCBhcmdzKTtcbiAgICAgIGtlcm5lbFJ1bi5yZXBsYWNlS2VybmVsKG5ld0tlcm5lbCk7XG4gICAgICBrZXJuZWxzLnB1c2gobmV3S2VybmVsKTtcbiAgICAgIHJldHVybiBuZXdLZXJuZWw7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZFNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICBjYW52YXM6IHRoaXMuY2FudmFzLFxuICAgICAgZnVuY3Rpb25zOiB0aGlzLmZ1bmN0aW9ucyxcbiAgICAgIG5hdGl2ZUZ1bmN0aW9uczogdGhpcy5uYXRpdmVGdW5jdGlvbnMsXG4gICAgICBpbmplY3RlZE5hdGl2ZTogdGhpcy5pbmplY3RlZE5hdGl2ZSxcbiAgICAgIG9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlOiB0aGlzLm9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlLFxuICAgICAgcmVtb3ZlSXN0YW5idWxDb3ZlcmFnZTogdGhpcy5yZW1vdmVJc3RhbmJ1bENvdmVyYWdlLFxuICAgICAgZ3B1OiB0aGlzLFxuICAgICAgdmFsaWRhdGUsXG4gICAgICBvblJlcXVlc3RGYWxsYmFjayxcbiAgICAgIG9uUmVxdWVzdFN3aXRjaEtlcm5lbFxuICAgIH0sIHNldHRpbmdzQ29weSk7XG5cbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgdGhpcy5LZXJuZWwoc291cmNlLCBtZXJnZWRTZXR0aW5ncyk7XG4gICAgY29uc3Qga2VybmVsUnVuID0ga2VybmVsUnVuU2hvcnRjdXQoa2VybmVsKTtcblxuICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzID0ga2VybmVsLmNhbnZhcztcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgdGhpcy5jb250ZXh0ID0ga2VybmVsLmNvbnRleHQ7XG4gICAgfVxuXG4gICAga2VybmVscy5wdXNoKGtlcm5lbCk7XG5cbiAgICByZXR1cm4ga2VybmVsUnVuO1xuICB9XG5cbiAgY3JlYXRlS2VybmVsTWFwKCkge1xuICAgIGxldCBmbjtcbiAgICBsZXQgc2V0dGluZ3M7XG4gICAgY29uc3QgYXJndW1lbnQyVHlwZSA9IHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDJdO1xuICAgIGlmIChhcmd1bWVudDJUeXBlID09PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50MlR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmbiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMl07XG4gICAgICBzZXR0aW5ncyA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tb2RlICE9PSAnZGV2Jykge1xuICAgICAgaWYgKCF0aGlzLktlcm5lbC5pc1N1cHBvcnRlZCB8fCAhdGhpcy5LZXJuZWwuZmVhdHVyZXMua2VybmVsTWFwKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgJiYga2VybmVsVHlwZXMuaW5kZXhPZih0aGlzLm1vZGUpIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihga2VybmVsTWFwIG5vdCBzdXBwb3J0ZWQgb24gJHt0aGlzLktlcm5lbC5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2V0dGluZ3NDb3B5ID0gdXBncmFkZURlcHJlY2F0ZWRDcmVhdGVLZXJuZWxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgaWYgKHNldHRpbmdzICYmIHR5cGVvZiBzZXR0aW5ncy5hcmd1bWVudFR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgc2V0dGluZ3NDb3B5LmFyZ3VtZW50VHlwZXMgPSBPYmplY3Qua2V5cyhzZXR0aW5ncy5hcmd1bWVudFR5cGVzKS5tYXAoYXJndW1lbnROYW1lID0+IHNldHRpbmdzLmFyZ3VtZW50VHlwZXNbYXJndW1lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgc2V0dGluZ3NDb3B5LnN1Yktlcm5lbHMgPSBbXTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGZ1bmN0aW9uc1tpXS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBuYW1lID0gdXRpbHMuZ2V0RnVuY3Rpb25OYW1lRnJvbVN0cmluZyhzb3VyY2UpO1xuICAgICAgICBzZXR0aW5nc0NvcHkuc3ViS2VybmVscy5wdXNoKHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBwcm9wZXJ0eTogaSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldHRpbmdzQ29weS5zdWJLZXJuZWxzID0gW107XG4gICAgICBjb25zdCBmdW5jdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IgKGxldCBwIGluIGZ1bmN0aW9ucykge1xuICAgICAgICBpZiAoIWZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGZ1bmN0aW9uc1twXS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBuYW1lID0gdXRpbHMuZ2V0RnVuY3Rpb25OYW1lRnJvbVN0cmluZyhzb3VyY2UpO1xuICAgICAgICBzZXR0aW5nc0NvcHkuc3ViS2VybmVscy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBuYW1lIHx8IHAsXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHByb3BlcnR5OiBwLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlS2VybmVsKGZuLCBzZXR0aW5nc0NvcHkpO1xuICB9XG5cbiAgY29tYmluZUtlcm5lbHMoKSB7XG4gICAgY29uc3QgZmlyc3RLZXJuZWwgPSBhcmd1bWVudHNbMF07XG4gICAgY29uc3QgY29tYmluZWRLZXJuZWwgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChmaXJzdEtlcm5lbC5rZXJuZWwuY29uc3RydWN0b3IubW9kZSA9PT0gJ2NwdScpIHJldHVybiBjb21iaW5lZEtlcm5lbDtcbiAgICBjb25zdCBjYW52YXMgPSBhcmd1bWVudHNbMF0uY2FudmFzO1xuICAgIGNvbnN0IGNvbnRleHQgPSBhcmd1bWVudHNbMF0uY29udGV4dDtcbiAgICBjb25zdCBtYXggPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICBhcmd1bWVudHNbaV1cbiAgICAgICAgLnNldENhbnZhcyhjYW52YXMpXG4gICAgICAgIC5zZXRDb250ZXh0KGNvbnRleHQpXG4gICAgICAgIC5zZXRQaXBlbGluZSh0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gY29tYmluZWRLZXJuZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0ZXh0dXJlLnRvQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRleHR1cmUudG9BcnJheSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfTtcbiAgfVxuXG4gIHNldEZ1bmN0aW9ucyhmdW5jdGlvbnMpIHtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldE5hdGl2ZUZ1bmN0aW9ucyhuYXRpdmVGdW5jdGlvbnMpIHtcbiAgICB0aGlzLm5hdGl2ZUZ1bmN0aW9ucyA9IG5hdGl2ZUZ1bmN0aW9ucztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZEZ1bmN0aW9uKHNvdXJjZSwgc2V0dGluZ3MpIHtcbiAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKHsgc291cmNlLCBzZXR0aW5ncyB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZE5hdGl2ZUZ1bmN0aW9uKG5hbWUsIHNvdXJjZSwgc2V0dGluZ3MpIHtcbiAgICBpZiAodGhpcy5rZXJuZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgXCJhZGROYXRpdmVGdW5jdGlvblwiIGFmdGVyIFwiY3JlYXRlS2VybmVsc1wiIGhhcyBiZWVuIGNhbGxlZC4nKTtcbiAgICB9XG4gICAgdGhpcy5uYXRpdmVGdW5jdGlvbnMucHVzaChPYmplY3QuYXNzaWduKHsgbmFtZSwgc291cmNlIH0sIHNldHRpbmdzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpbmplY3ROYXRpdmUoc291cmNlKSB7XG4gICAgdGhpcy5pbmplY3RlZE5hdGl2ZSA9IHNvdXJjZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5rZXJuZWxzKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5rZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmtlcm5lbHNbaV0uZGVzdHJveSh0cnVlKTsgXG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBmaXJzdEtlcm5lbCA9IHRoaXMua2VybmVsc1swXTtcbiAgICAgICAgICBpZiAoZmlyc3RLZXJuZWwpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdEtlcm5lbC5rZXJuZWwpIHtcbiAgICAgICAgICAgICAgZmlyc3RLZXJuZWwgPSBmaXJzdEtlcm5lbC5rZXJuZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RLZXJuZWwuY29uc3RydWN0b3IuZGVzdHJveUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgZmlyc3RLZXJuZWwuY29uc3RydWN0b3IuZGVzdHJveUNvbnRleHQodGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSwgMCk7XG4gICAgfSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiB1cGdyYWRlRGVwcmVjYXRlZENyZWF0ZUtlcm5lbFNldHRpbmdzKHNldHRpbmdzKSB7XG4gIGlmICghc2V0dGluZ3MpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgdXBncmFkZWRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzKTtcblxuICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2Zsb2F0T3V0cHV0JykpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnc2V0dGluZycsICdmbG9hdE91dHB1dCcsICdwcmVjaXNpb24nKTtcbiAgICB1cGdyYWRlZFNldHRpbmdzLnByZWNpc2lvbiA9IHNldHRpbmdzLmZsb2F0T3V0cHV0ID8gJ3NpbmdsZScgOiAndW5zaWduZWQnO1xuICB9XG4gIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnb3V0cHV0VG9UZXh0dXJlJykpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnc2V0dGluZycsICdvdXRwdXRUb1RleHR1cmUnLCAncGlwZWxpbmUnKTtcbiAgICB1cGdyYWRlZFNldHRpbmdzLnBpcGVsaW5lID0gQm9vbGVhbihzZXR0aW5ncy5vdXRwdXRUb1RleHR1cmUpO1xuICB9XG4gIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnb3V0cHV0SW1tdXRhYmxlJykpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnc2V0dGluZycsICdvdXRwdXRJbW11dGFibGUnLCAnaW1tdXRhYmxlJyk7XG4gICAgdXBncmFkZWRTZXR0aW5ncy5pbW11dGFibGUgPSBCb29sZWFuKHNldHRpbmdzLm91dHB1dEltbXV0YWJsZSk7XG4gIH1cbiAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdmbG9hdFRleHR1cmVzJykpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnc2V0dGluZycsICdmbG9hdFRleHR1cmVzJywgJ29wdGltaXplRmxvYXRNZW1vcnknKTtcbiAgICB1cGdyYWRlZFNldHRpbmdzLm9wdGltaXplRmxvYXRNZW1vcnkgPSBCb29sZWFuKHNldHRpbmdzLmZsb2F0VGV4dHVyZXMpO1xuICB9XG4gIHJldHVybiB1cGdyYWRlZFNldHRpbmdzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR1BVLFxuICBrZXJuZWxPcmRlcixcbiAga2VybmVsVHlwZXNcbn07XG59LHtcIi4vYmFja2VuZC9jcHUva2VybmVsXCI6OCxcIi4vYmFja2VuZC9oZWFkbGVzcy1nbC9rZXJuZWxcIjozNCxcIi4vYmFja2VuZC9rZXJuZWxcIjozNixcIi4vYmFja2VuZC93ZWItZ2wva2VybmVsXCI6NzAsXCIuL2JhY2tlbmQvd2ViLWdsMi9rZXJuZWxcIjoxMDUsXCIuL2tlcm5lbC1ydW4tc2hvcnRjdXRcIjoxMTEsXCIuL3V0aWxzXCI6MTE0LFwiZ3B1LW1vY2suanNcIjo0fV0sMTA5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgR1BVIH0gPSByZXF1aXJlKCcuL2dwdScpO1xuY29uc3QgeyBhbGlhcyB9ID0gcmVxdWlyZSgnLi9hbGlhcycpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgeyBJbnB1dCwgaW5wdXQgfSA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcbmNvbnN0IHsgVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlJyk7XG5jb25zdCB7IEZ1bmN0aW9uQnVpbGRlciB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2Z1bmN0aW9uLWJ1aWxkZXInKTtcbmNvbnN0IHsgRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvZnVuY3Rpb24tbm9kZScpO1xuY29uc3QgeyBDUFVGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9jcHUvZnVuY3Rpb24tbm9kZScpO1xuY29uc3QgeyBDUFVLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9jcHUva2VybmVsJyk7XG5cbmNvbnN0IHsgSGVhZGxlc3NHTEtlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2hlYWRsZXNzLWdsL2tlcm5lbCcpO1xuXG5jb25zdCB7IFdlYkdMRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsL2Z1bmN0aW9uLW5vZGUnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wva2VybmVsJyk7XG5jb25zdCB7IGtlcm5lbFZhbHVlTWFwczogd2ViR0xLZXJuZWxWYWx1ZU1hcHMgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wva2VybmVsLXZhbHVlLW1hcHMnKTtcblxuY29uc3QgeyBXZWJHTDJGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wyL2Z1bmN0aW9uLW5vZGUnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsMi9rZXJuZWwnKTtcbmNvbnN0IHsga2VybmVsVmFsdWVNYXBzOiB3ZWJHTDJLZXJuZWxWYWx1ZU1hcHMgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wyL2tlcm5lbC12YWx1ZS1tYXBzJyk7XG5cbmNvbnN0IHsgR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9nbC9rZXJuZWwnKTtcblxuY29uc3QgeyBLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9rZXJuZWwnKTtcblxuY29uc3QgeyBGdW5jdGlvblRyYWNlciB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2Z1bmN0aW9uLXRyYWNlcicpO1xuXG5jb25zdCBtYXRoUmFuZG9tID0gcmVxdWlyZSgnLi9wbHVnaW5zL21hdGgtcmFuZG9tLXVuaWZvcm1seS1kaXN0cmlidXRlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWxpYXMsXG4gIENQVUZ1bmN0aW9uTm9kZSxcbiAgQ1BVS2VybmVsLFxuICBHUFUsXG4gIEZ1bmN0aW9uQnVpbGRlcixcbiAgRnVuY3Rpb25Ob2RlLFxuICBIZWFkbGVzc0dMS2VybmVsLFxuICBJbnB1dCxcbiAgaW5wdXQsXG4gIFRleHR1cmUsXG4gIHV0aWxzLFxuXG4gIFdlYkdMMkZ1bmN0aW9uTm9kZSxcbiAgV2ViR0wyS2VybmVsLFxuICB3ZWJHTDJLZXJuZWxWYWx1ZU1hcHMsXG5cbiAgV2ViR0xGdW5jdGlvbk5vZGUsXG4gIFdlYkdMS2VybmVsLFxuICB3ZWJHTEtlcm5lbFZhbHVlTWFwcyxcblxuICBHTEtlcm5lbCxcbiAgS2VybmVsLFxuICBGdW5jdGlvblRyYWNlcixcblxuICBwbHVnaW5zOiB7XG4gICAgbWF0aFJhbmRvbVxuICB9XG59O1xufSx7XCIuL2FsaWFzXCI6NSxcIi4vYmFja2VuZC9jcHUvZnVuY3Rpb24tbm9kZVwiOjYsXCIuL2JhY2tlbmQvY3B1L2tlcm5lbFwiOjgsXCIuL2JhY2tlbmQvZnVuY3Rpb24tYnVpbGRlclwiOjksXCIuL2JhY2tlbmQvZnVuY3Rpb24tbm9kZVwiOjEwLFwiLi9iYWNrZW5kL2Z1bmN0aW9uLXRyYWNlclwiOjExLFwiLi9iYWNrZW5kL2dsL2tlcm5lbFwiOjEzLFwiLi9iYWNrZW5kL2hlYWRsZXNzLWdsL2tlcm5lbFwiOjM0LFwiLi9iYWNrZW5kL2tlcm5lbFwiOjM2LFwiLi9iYWNrZW5kL3dlYi1nbC9mdW5jdGlvbi1ub2RlXCI6MzgsXCIuL2JhY2tlbmQvd2ViLWdsL2tlcm5lbFwiOjcwLFwiLi9iYWNrZW5kL3dlYi1nbC9rZXJuZWwtdmFsdWUtbWFwc1wiOjM5LFwiLi9iYWNrZW5kL3dlYi1nbDIvZnVuY3Rpb24tbm9kZVwiOjczLFwiLi9iYWNrZW5kL3dlYi1nbDIva2VybmVsXCI6MTA1LFwiLi9iYWNrZW5kL3dlYi1nbDIva2VybmVsLXZhbHVlLW1hcHNcIjo3NCxcIi4vZ3B1XCI6MTA4LFwiLi9pbnB1dFwiOjExMCxcIi4vcGx1Z2lucy9tYXRoLXJhbmRvbS11bmlmb3JtbHktZGlzdHJpYnV0ZWRcIjoxMTIsXCIuL3RleHR1cmVcIjoxMTMsXCIuL3V0aWxzXCI6MTE0fV0sMTEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNsYXNzIElucHV0IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNpemUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2l6ZSkpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2l6ZSA9IG5ldyBJbnQzMkFycmF5KDMpO1xuICAgICAgaWYgKHNpemUueikge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXcgSW50MzJBcnJheShbc2l6ZS54LCBzaXplLnksIHNpemUuel0pO1xuICAgICAgfSBlbHNlIGlmIChzaXplLnkpIHtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3IEludDMyQXJyYXkoW3NpemUueCwgc2l6ZS55XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXcgSW50MzJBcnJheShbc2l6ZS54XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW3csIGgsIGRdID0gdGhpcy5zaXplO1xuICAgIGlmIChkKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggIT09ICh3ICogaCAqIGQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgc2l6ZSAke3RoaXMudmFsdWUubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCAke3d9ICogJHtofSAqICR7ZH0gPSAkeyhoICogdyAqIGQpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoICE9PSAodyAqIGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgc2l6ZSAke3RoaXMudmFsdWUubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCAke3d9ICogJHtofSA9ICR7KGggKiB3KX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoICE9PSB3KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgc2l6ZSAke3RoaXMudmFsdWUubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCAke3d9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICB0b0FycmF5KCkge1xuICAgIGNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICBjb25zdCBbdywgaCwgZF0gPSB0aGlzLnNpemU7XG4gICAgaWYgKGQpIHtcbiAgICAgIHJldHVybiB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZDNERmxvYXQodGhpcy52YWx1ZS5zdWJhcnJheSA/IHRoaXMudmFsdWUgOiBuZXcgRmxvYXQzMkFycmF5KHRoaXMudmFsdWUpLCB3LCBoLCBkKTtcbiAgICB9IGVsc2UgaWYgKGgpIHtcbiAgICAgIHJldHVybiB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZDJERmxvYXQodGhpcy52YWx1ZS5zdWJhcnJheSA/IHRoaXMudmFsdWUgOiBuZXcgRmxvYXQzMkFycmF5KHRoaXMudmFsdWUpLCB3LCBoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlucHV0KHZhbHVlLCBzaXplKSB7XG4gIHJldHVybiBuZXcgSW5wdXQodmFsdWUsIHNpemUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSW5wdXQsXG4gIGlucHV0XG59O1xufSx7XCIuL3V0aWxzXCI6MTE0fV0sMTExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuZnVuY3Rpb24ga2VybmVsUnVuU2hvcnRjdXQoa2VybmVsKSB7XG4gIGxldCBydW4gPSBmdW5jdGlvbigpIHtcbiAgICBrZXJuZWwuYnVpbGQuYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuICAgIHJ1biA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IHJlc3VsdCA9IGtlcm5lbC5ydW4uYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKGtlcm5lbC5zd2l0Y2hpbmdLZXJuZWxzKSB7XG4gICAgICAgIGNvbnN0IHJlYXNvbnMgPSBrZXJuZWwucmVzZXRTd2l0Y2hpbmdLZXJuZWxzKCk7XG4gICAgICAgIGNvbnN0IG5ld0tlcm5lbCA9IGtlcm5lbC5vblJlcXVlc3RTd2l0Y2hLZXJuZWwocmVhc29ucywgYXJndW1lbnRzLCBrZXJuZWwpO1xuICAgICAgICBzaG9ydGN1dC5rZXJuZWwgPSBrZXJuZWwgPSBuZXdLZXJuZWw7XG4gICAgICAgIHJlc3VsdCA9IG5ld0tlcm5lbC5ydW4uYXBwbHkobmV3S2VybmVsLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKGtlcm5lbC5yZW5kZXJLZXJuZWxzKSB7XG4gICAgICAgIHJldHVybiBrZXJuZWwucmVuZGVyS2VybmVscygpO1xuICAgICAgfSBlbHNlIGlmIChrZXJuZWwucmVuZGVyT3V0cHV0KSB7XG4gICAgICAgIHJldHVybiBrZXJuZWwucmVuZGVyT3V0cHV0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJ1bi5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gIH07XG4gIGNvbnN0IHNob3J0Y3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHJ1bi5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gIH07XG4gIHNob3J0Y3V0LmV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhY2NlcHQocnVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHNob3J0Y3V0LnJlcGxhY2VLZXJuZWwgPSBmdW5jdGlvbihyZXBsYWNlbWVudEtlcm5lbCkge1xuICAgIGtlcm5lbCA9IHJlcGxhY2VtZW50S2VybmVsO1xuICAgIGJpbmRLZXJuZWxUb1Nob3J0Y3V0KGtlcm5lbCwgc2hvcnRjdXQpO1xuICB9O1xuXG4gIGJpbmRLZXJuZWxUb1Nob3J0Y3V0KGtlcm5lbCwgc2hvcnRjdXQpO1xuICByZXR1cm4gc2hvcnRjdXQ7XG59XG5cbmZ1bmN0aW9uIGJpbmRLZXJuZWxUb1Nob3J0Y3V0KGtlcm5lbCwgc2hvcnRjdXQpIHtcbiAgaWYgKHNob3J0Y3V0Lmtlcm5lbCkge1xuICAgIHNob3J0Y3V0Lmtlcm5lbCA9IGtlcm5lbDtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvcGVydGllcyA9IHV0aWxzLmFsbFByb3BlcnRpZXNPZihrZXJuZWwpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgaWYgKHByb3BlcnR5WzBdID09PSAnXycgJiYgcHJvcGVydHlbMV0gPT09ICdfJykgY29udGludWU7XG4gICAgaWYgKHR5cGVvZiBrZXJuZWxbcHJvcGVydHldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAocHJvcGVydHkuc3Vic3RyaW5nKDAsIDMpID09PSAnYWRkJyB8fCBwcm9wZXJ0eS5zdWJzdHJpbmcoMCwgMykgPT09ICdzZXQnKSB7XG4gICAgICAgIHNob3J0Y3V0W3Byb3BlcnR5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNob3J0Y3V0Lmtlcm5lbFtwcm9wZXJ0eV0uYXBwbHkoc2hvcnRjdXQua2VybmVsLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHJldHVybiBzaG9ydGN1dDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3J0Y3V0W3Byb3BlcnR5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzaG9ydGN1dC5rZXJuZWxbcHJvcGVydHldLmFwcGx5KHNob3J0Y3V0Lmtlcm5lbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvcnRjdXQuX19kZWZpbmVHZXR0ZXJfXyhwcm9wZXJ0eSwgKCkgPT4gc2hvcnRjdXQua2VybmVsW3Byb3BlcnR5XSk7XG4gICAgICBzaG9ydGN1dC5fX2RlZmluZVNldHRlcl9fKHByb3BlcnR5LCAodmFsdWUpID0+IHtcbiAgICAgICAgc2hvcnRjdXQua2VybmVsW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHNob3J0Y3V0Lmtlcm5lbCA9IGtlcm5lbDtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrZXJuZWxSdW5TaG9ydGN1dFxufTtcbn0se1wiLi91dGlsc1wiOjExNH1dLDExMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCBzb3VyY2UgPSBgLy8gaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3LzR0MlNEaFxuLy9ub3RlOiB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQsIG5vcm1hbGl6ZWQgcmFuZCwgWzAsMV1cbmhpZ2hwIGZsb2F0IHJhbmRvbVNlZWRTaGlmdCA9IDEuMDtcbmhpZ2hwIGZsb2F0IHNsaWRlID0gMS4wO1xudW5pZm9ybSBoaWdocCBmbG9hdCByYW5kb21TZWVkMTtcbnVuaWZvcm0gaGlnaHAgZmxvYXQgcmFuZG9tU2VlZDI7XG5cbmhpZ2hwIGZsb2F0IG5yYW5kKGhpZ2hwIHZlYzIgbikge1xuICBoaWdocCBmbG9hdCByZXN1bHQgPSBmcmFjdChzaW4oZG90KChuLnh5ICsgMS4wKSAqIHZlYzIocmFuZG9tU2VlZDEgKiBzbGlkZSwgcmFuZG9tU2VlZDIgKiByYW5kb21TZWVkU2hpZnQpLCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMpO1xuICByYW5kb21TZWVkU2hpZnQgPSByZXN1bHQ7XG4gIGlmIChyYW5kb21TZWVkU2hpZnQgPiAwLjUpIHtcbiAgICBzbGlkZSArPSAwLjAwMDA5OyBcbiAgfSBlbHNlIHtcbiAgICBzbGlkZSArPSAwLjAwMDk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1gO1xuXG5jb25zdCBuYW1lID0gJ21hdGgtcmFuZG9tLXVuaWZvcm1seS1kaXN0cmlidXRlZCc7XG5cbmNvbnN0IGZ1bmN0aW9uTWF0Y2ggPSBgTWF0aC5yYW5kb20oKWA7XG5cbmNvbnN0IGZ1bmN0aW9uUmVwbGFjZSA9IGBucmFuZCh2VGV4Q29vcmQpYDtcblxuY29uc3QgZnVuY3Rpb25SZXR1cm5UeXBlID0gJ051bWJlcic7XG5jb25zdCBvbkJlZm9yZVJ1biA9IChrZXJuZWwpID0+IHtcbiAga2VybmVsLnNldFVuaWZvcm0xZigncmFuZG9tU2VlZDEnLCBNYXRoLnJhbmRvbSgpKTtcbiAga2VybmVsLnNldFVuaWZvcm0xZigncmFuZG9tU2VlZDInLCBNYXRoLnJhbmRvbSgpKTtcbn07XG5cbmNvbnN0IHBsdWdpbiA9IHtcbiAgbmFtZSxcbiAgb25CZWZvcmVSdW4sXG4gIGZ1bmN0aW9uTWF0Y2gsXG4gIGZ1bmN0aW9uUmVwbGFjZSxcbiAgZnVuY3Rpb25SZXR1cm5UeXBlLFxuICBzb3VyY2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGx1Z2luO1xufSx7fV0sMTEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNsYXNzIFRleHR1cmUge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIGNvbnN0IHtcbiAgICAgIHRleHR1cmUsXG4gICAgICBzaXplLFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIG91dHB1dCxcbiAgICAgIGNvbnRleHQsXG4gICAgICB0eXBlID0gJ051bWJlclRleHR1cmUnLFxuICAgICAga2VybmVsLFxuICAgICAgaW50ZXJuYWxGb3JtYXQsXG4gICAgICB0ZXh0dXJlRm9ybWF0XG4gICAgfSA9IHNldHRpbmdzO1xuICAgIGlmICghb3V0cHV0KSB0aHJvdyBuZXcgRXJyb3IoJ3NldHRpbmdzIHByb3BlcnR5IFwib3V0cHV0XCIgcmVxdWlyZWQuJyk7XG4gICAgaWYgKCFjb250ZXh0KSB0aHJvdyBuZXcgRXJyb3IoJ3NldHRpbmdzIHByb3BlcnR5IFwiY29udGV4dFwiIHJlcXVpcmVkLicpO1xuICAgIGlmICghdGV4dHVyZSkgdGhyb3cgbmV3IEVycm9yKCdzZXR0aW5ncyBwcm9wZXJ0eSBcInRleHR1cmVcIiByZXF1aXJlZC4nKTtcbiAgICBpZiAoIWtlcm5lbCkgdGhyb3cgbmV3IEVycm9yKCdzZXR0aW5ncyBwcm9wZXJ0eSBcImtlcm5lbFwiIHJlcXVpcmVkLicpO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgaWYgKHRleHR1cmUuX3JlZnMpIHtcbiAgICAgIHRleHR1cmUuX3JlZnMrKztcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dHVyZS5fcmVmcyA9IDE7XG4gICAgfVxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMua2VybmVsID0ga2VybmVsO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fZGVsZXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBpbnRlcm5hbEZvcm1hdDtcbiAgICB0aGlzLnRleHR1cmVGb3JtYXQgPSB0ZXh0dXJlRm9ybWF0O1xuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBpbXBsZW1lbnRlZCBvbiAke3RoaXMuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm90IGltcGxlbWVudGVkIG9uICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICB9XG5cbiAgZGVsZXRlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm90IGltcGxlbWVudGVkIG9uICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgaW1wbGVtZW50ZWQgb24gJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRleHR1cmVcbn07XG59LHt9XSwxMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgYWNvcm4gPSByZXF1aXJlKCdhY29ybicpO1xuY29uc3QgeyBJbnB1dCB9ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xuY29uc3QgeyBUZXh0dXJlIH0gPSByZXF1aXJlKCcuL3RleHR1cmUnKTtcblxuY29uc3QgRlVOQ1RJT05fTkFNRSA9IC9mdW5jdGlvbiAoW14oXSopLztcbmNvbnN0IFNUUklQX0NPTU1FTlRTID0gLygoXFwvXFwvLiokKXwoXFwvXFwqW1xcc1xcU10qP1xcKlxcLykpL21nO1xuY29uc3QgQVJHVU1FTlRfTkFNRVMgPSAvKFteXFxzLF0rKS9nO1xuXG5jb25zdCB1dGlscyA9IHtcbiAgc3lzdGVtRW5kaWFubmVzcygpIHtcbiAgICByZXR1cm4gX3N5c3RlbUVuZGlhbm5lc3M7XG4gIH0sXG4gIGdldFN5c3RlbUVuZGlhbm5lc3MoKSB7XG4gICAgY29uc3QgYiA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgICBjb25zdCBhID0gbmV3IFVpbnQzMkFycmF5KGIpO1xuICAgIGNvbnN0IGMgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICBhWzBdID0gMHhkZWFkYmVlZjtcbiAgICBpZiAoY1swXSA9PT0gMHhlZikgcmV0dXJuICdMRSc7XG4gICAgaWYgKGNbMF0gPT09IDB4ZGUpIHJldHVybiAnQkUnO1xuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBlbmRpYW5uZXNzJyk7XG4gIH0sXG5cbiAgaXNGdW5jdGlvbihmdW5jT2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZihmdW5jT2JqKSA9PT0gJ2Z1bmN0aW9uJztcbiAgfSxcblxuICBpc0Z1bmN0aW9uU3RyaW5nKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAoZm5cbiAgICAgICAgLnNsaWNlKDAsICdmdW5jdGlvbicubGVuZ3RoKVxuICAgICAgICAudG9Mb3dlckNhc2UoKSA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBnZXRGdW5jdGlvbk5hbWVGcm9tU3RyaW5nKGZ1bmNTdHIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBGVU5DVElPTl9OQU1FLmV4ZWMoZnVuY1N0cik7XG4gICAgaWYgKCFyZXN1bHQgfHwgcmVzdWx0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdFsxXS50cmltKCk7XG4gIH0sXG5cbiAgZ2V0RnVuY3Rpb25Cb2R5RnJvbVN0cmluZyhmdW5jU3RyKSB7XG4gICAgcmV0dXJuIGZ1bmNTdHIuc3Vic3RyaW5nKGZ1bmNTdHIuaW5kZXhPZigneycpICsgMSwgZnVuY1N0ci5sYXN0SW5kZXhPZignfScpKTtcbiAgfSxcblxuICBnZXRBcmd1bWVudE5hbWVzRnJvbVN0cmluZyhmbikge1xuICAgIGNvbnN0IGZuU3RyID0gZm4ucmVwbGFjZShTVFJJUF9DT01NRU5UUywgJycpO1xuICAgIGxldCByZXN1bHQgPSBmblN0ci5zbGljZShmblN0ci5pbmRleE9mKCcoJykgKyAxLCBmblN0ci5pbmRleE9mKCcpJykpLm1hdGNoKEFSR1VNRU5UX05BTUVTKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBjbG9uZShvYmopIHtcbiAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iai5oYXNPd25Qcm9wZXJ0eSgnaXNBY3RpdmVDbG9uZScpKSByZXR1cm4gb2JqO1xuXG4gICAgY29uc3QgdGVtcCA9IG9iai5jb25zdHJ1Y3RvcigpOyBcblxuICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIG9iai5pc0FjdGl2ZUNsb25lID0gbnVsbDtcbiAgICAgICAgdGVtcFtrZXldID0gdXRpbHMuY2xvbmUob2JqW2tleV0pO1xuICAgICAgICBkZWxldGUgb2JqLmlzQWN0aXZlQ2xvbmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXA7XG4gIH0sXG5cbiAgaXNBcnJheShhcnJheSkge1xuICAgIHJldHVybiAhaXNOYU4oYXJyYXkubGVuZ3RoKTtcbiAgfSxcblxuICBnZXRWYXJpYWJsZVR5cGUodmFsdWUsIHN0cmljdEludGVnZXJzKSB7XG4gICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCAmJiB2YWx1ZVswXS5ub2RlTmFtZSA9PT0gJ0lNRycpIHtcbiAgICAgICAgcmV0dXJuICdIVE1MSW1hZ2VBcnJheSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ0FycmF5JztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgIHJldHVybiAnQm9vbGVhbic7XG4gICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgaWYgKHN0cmljdEludGVnZXJzICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0Zsb2F0JztcbiAgICAgIGNhc2UgVGV4dHVyZTpcbiAgICAgICAgcmV0dXJuIHZhbHVlLnR5cGU7XG4gICAgICBjYXNlIElucHV0OlxuICAgICAgICByZXR1cm4gJ0lucHV0JztcbiAgICB9XG4gICAgc3dpdGNoICh2YWx1ZS5ub2RlTmFtZSkge1xuICAgICAgY2FzZSAnSU1HJzpcbiAgICAgICAgcmV0dXJuICdIVE1MSW1hZ2UnO1xuICAgICAgY2FzZSAnQ0FOVkFTJzpcbiAgICAgICAgcmV0dXJuICdIVE1MSW1hZ2UnO1xuICAgICAgY2FzZSAnVklERU8nOlxuICAgICAgICByZXR1cm4gJ0hUTUxWaWRlbyc7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHlwZTtcbiAgICB9XG4gICAgcmV0dXJuICdVbmtub3duJztcbiAgfSxcblxuICBnZXRLZXJuZWxUZXh0dXJlU2l6ZShzZXR0aW5ncywgZGltZW5zaW9ucykge1xuICAgIGxldCBbdywgaCwgZF0gPSBkaW1lbnNpb25zO1xuICAgIGxldCB0ZXhlbENvdW50ID0gKHcgfHwgMSkgKiAoaCB8fCAxKSAqIChkIHx8IDEpO1xuXG4gICAgaWYgKHNldHRpbmdzLm9wdGltaXplRmxvYXRNZW1vcnkgJiYgc2V0dGluZ3MucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgdyA9IHRleGVsQ291bnQgPSBNYXRoLmNlaWwodGV4ZWxDb3VudCAvIDQpO1xuICAgIH1cbiAgICBpZiAoaCA+IDEgJiYgdyAqIGggPT09IHRleGVsQ291bnQpIHtcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShbdywgaF0pO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuY2xvc2VzdFNxdWFyZURpbWVuc2lvbnModGV4ZWxDb3VudCk7XG4gIH0sXG5cbiAgY2xvc2VzdFNxdWFyZURpbWVuc2lvbnMobGVuZ3RoKSB7XG4gICAgY29uc3Qgc3FydCA9IE1hdGguc3FydChsZW5ndGgpO1xuICAgIGxldCBoaWdoID0gTWF0aC5jZWlsKHNxcnQpO1xuICAgIGxldCBsb3cgPSBNYXRoLmZsb29yKHNxcnQpO1xuICAgIHdoaWxlIChoaWdoICogbG93IDwgbGVuZ3RoKSB7XG4gICAgICBoaWdoLS07XG4gICAgICBsb3cgPSBNYXRoLmNlaWwobGVuZ3RoIC8gaGlnaCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSW50MzJBcnJheShbbG93LCBNYXRoLmNlaWwobGVuZ3RoIC8gbG93KV0pO1xuICB9LFxuXG4gIGdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUoZGltZW5zaW9ucywgYml0UmF0aW8pIHtcbiAgICBjb25zdCB0b3RhbEFyZWEgPSB1dGlscy5yb3VuZFRvKChkaW1lbnNpb25zWzBdIHx8IDEpICogKGRpbWVuc2lvbnNbMV0gfHwgMSkgKiAoZGltZW5zaW9uc1syXSB8fCAxKSAqIChkaW1lbnNpb25zWzNdIHx8IDEpLCA0KTtcbiAgICBjb25zdCB0ZXhlbENvdW50ID0gdG90YWxBcmVhIC8gYml0UmF0aW87XG4gICAgcmV0dXJuIHV0aWxzLmNsb3Nlc3RTcXVhcmVEaW1lbnNpb25zKHRleGVsQ291bnQpO1xuICB9LFxuXG4gIGdldE1lbW9yeU9wdGltaXplZFBhY2tlZFRleHR1cmVTaXplKGRpbWVuc2lvbnMsIGJpdFJhdGlvKSB7XG4gICAgY29uc3QgW3csIGgsIGRdID0gZGltZW5zaW9ucztcbiAgICBjb25zdCB0b3RhbEFyZWEgPSB1dGlscy5yb3VuZFRvKCh3IHx8IDEpICogKGggfHwgMSkgKiAoZCB8fCAxKSwgNCk7XG4gICAgY29uc3QgdGV4ZWxDb3VudCA9IHRvdGFsQXJlYSAvICg0IC8gYml0UmF0aW8pO1xuICAgIHJldHVybiB1dGlscy5jbG9zZXN0U3F1YXJlRGltZW5zaW9ucyh0ZXhlbENvdW50KTtcbiAgfSxcblxuICByb3VuZFRvKG4sIGQpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigobiArIGQgLSAxKSAvIGQpICogZDtcbiAgfSxcbiAgZ2V0RGltZW5zaW9ucyh4LCBwYWQpIHtcbiAgICBsZXQgcmV0O1xuICAgIGlmICh1dGlscy5pc0FycmF5KHgpKSB7XG4gICAgICBjb25zdCBkaW0gPSBbXTtcbiAgICAgIGxldCB0ZW1wID0geDtcbiAgICAgIHdoaWxlICh1dGlscy5pc0FycmF5KHRlbXApKSB7XG4gICAgICAgIGRpbS5wdXNoKHRlbXAubGVuZ3RoKTtcbiAgICAgICAgdGVtcCA9IHRlbXBbMF07XG4gICAgICB9XG4gICAgICByZXQgPSBkaW0ucmV2ZXJzZSgpO1xuICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgIHJldCA9IHgub3V0cHV0O1xuICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIElucHV0KSB7XG4gICAgICByZXQgPSB4LnNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkaW1lbnNpb25zIG9mICR7eH1gKTtcbiAgICB9XG5cbiAgICBpZiAocGFkKSB7XG4gICAgICByZXQgPSBBcnJheS5mcm9tKHJldCk7XG4gICAgICB3aGlsZSAocmV0Lmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0LnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KHJldCk7XG4gIH0sXG5cbiAgZmxhdHRlbjJkQXJyYXlUbyhhcnJheSwgdGFyZ2V0KSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBhcnJheS5sZW5ndGg7IHkrKykge1xuICAgICAgdGFyZ2V0LnNldChhcnJheVt5XSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBhcnJheVt5XS5sZW5ndGg7XG4gICAgfVxuICB9LFxuXG4gIGZsYXR0ZW4zZEFycmF5VG8oYXJyYXksIHRhcmdldCkge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgYXJyYXkubGVuZ3RoOyB6KyspIHtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgYXJyYXlbel0ubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgdGFyZ2V0LnNldChhcnJheVt6XVt5XSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGFycmF5W3pdW3ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZmxhdHRlbjRkQXJyYXlUbyhhcnJheSwgdGFyZ2V0KSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgbCA9IDA7IGwgPCBhcnJheS5sZW5ndGg7IGwrKykge1xuICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCBhcnJheVtsXS5sZW5ndGg7IHorKykge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGFycmF5W2xdW3pdLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgdGFyZ2V0LnNldChhcnJheVtsXVt6XVt5XSwgb2Zmc2V0KTtcbiAgICAgICAgICBvZmZzZXQgKz0gYXJyYXlbbF1bel1beV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGZsYXR0ZW5UbyhhcnJheSwgdGFyZ2V0KSB7XG4gICAgaWYgKHV0aWxzLmlzQXJyYXkoYXJyYXlbMF0pKSB7XG4gICAgICBpZiAodXRpbHMuaXNBcnJheShhcnJheVswXVswXSkpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzQXJyYXkoYXJyYXlbMF1bMF1bMF0pKSB7XG4gICAgICAgICAgdXRpbHMuZmxhdHRlbjRkQXJyYXlUbyhhcnJheSwgdGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1dGlscy5mbGF0dGVuM2RBcnJheVRvKGFycmF5LCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlscy5mbGF0dGVuMmRBcnJheVRvKGFycmF5LCB0YXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuc2V0KGFycmF5KTtcbiAgICB9XG4gIH0sXG5cbiAgc3BsaXRBcnJheShhcnJheSwgcGFydCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IHBhcnQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBhcnJheS5jb25zdHJ1Y3RvcihhcnJheS5idWZmZXIsIGkgKiA0ICsgYXJyYXkuYnl0ZU9mZnNldCwgcGFydCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIGdldEFzdFN0cmluZyhzb3VyY2UsIGFzdCkge1xuICAgIGNvbnN0IGxpbmVzID0gQXJyYXkuaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogc291cmNlLnNwbGl0KC9cXHI/XFxuL2cpO1xuICAgIGNvbnN0IHN0YXJ0ID0gYXN0LmxvYy5zdGFydDtcbiAgICBjb25zdCBlbmQgPSBhc3QubG9jLmVuZDtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoc3RhcnQubGluZSA9PT0gZW5kLmxpbmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmVzW3N0YXJ0LmxpbmUgLSAxXS5zdWJzdHJpbmcoc3RhcnQuY29sdW1uLCBlbmQuY29sdW1uKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmVzW3N0YXJ0LmxpbmUgLSAxXS5zbGljZShzdGFydC5jb2x1bW4pKTtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydC5saW5lOyBpIDwgZW5kLmxpbmU7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChsaW5lc1tpXSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChsaW5lc1tlbmQubGluZSAtIDFdLnNsaWNlKDAsIGVuZC5jb2x1bW4pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCdcXG4nKTtcbiAgfSxcblxuICBhbGxQcm9wZXJ0aWVzT2Yob2JqKSB7XG4gICAgY29uc3QgcHJvcHMgPSBbXTtcblxuICAgIGRvIHtcbiAgICAgIHByb3BzLnB1c2guYXBwbHkocHJvcHMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikpO1xuICAgIH0gd2hpbGUgKG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblxuICAgIHJldHVybiBwcm9wcztcbiAgfSxcblxuICBsaW5lc1RvU3RyaW5nKGxpbmVzKSB7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBsaW5lcy5qb2luKCc7XFxuJykgKyAnO1xcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnXFxuJztcbiAgICB9XG4gIH0sXG4gIHdhcm5EZXByZWNhdGVkKHR5cGUsIG9sZE5hbWUsIG5ld05hbWUpIHtcbiAgICBpZiAobmV3TmFtZSkge1xuICAgICAgY29uc29sZS53YXJuKGBZb3UgYXJlIHVzaW5nIGEgZGVwcmVjYXRlZCAkeyB0eXBlIH0gXCIkeyBvbGROYW1lIH1cIi4gSXQgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBcIiR7IG5ld05hbWUgfVwiLiBGaXhpbmcsIGJ1dCBwbGVhc2UgdXBncmFkZSBhcyBpdCB3aWxsIHNvb24gYmUgcmVtb3ZlZC5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGBZb3UgYXJlIHVzaW5nIGEgZGVwcmVjYXRlZCAkeyB0eXBlIH0gXCIkeyBvbGROYW1lIH1cIi4gSXQgaGFzIGJlZW4gcmVtb3ZlZC4gRml4aW5nLCBidXQgcGxlYXNlIHVwZ3JhZGUgYXMgaXQgd2lsbCBzb29uIGJlIHJlbW92ZWQuYCk7XG4gICAgfVxuICB9LFxuICBmbGlwUGl4ZWxzOiAocGl4ZWxzLCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDIgfCAwOyBcbiAgICBjb25zdCBieXRlc1BlclJvdyA9IHdpZHRoICogNDtcbiAgICBjb25zdCB0ZW1wID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogNCk7XG4gICAgY29uc3QgcmVzdWx0ID0gcGl4ZWxzLnNsaWNlKDApO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGFsZkhlaWdodDsgKyt5KSB7XG4gICAgICBjb25zdCB0b3BPZmZzZXQgPSB5ICogYnl0ZXNQZXJSb3c7XG4gICAgICBjb25zdCBib3R0b21PZmZzZXQgPSAoaGVpZ2h0IC0geSAtIDEpICogYnl0ZXNQZXJSb3c7XG5cbiAgICAgIHRlbXAuc2V0KHJlc3VsdC5zdWJhcnJheSh0b3BPZmZzZXQsIHRvcE9mZnNldCArIGJ5dGVzUGVyUm93KSk7XG5cbiAgICAgIHJlc3VsdC5jb3B5V2l0aGluKHRvcE9mZnNldCwgYm90dG9tT2Zmc2V0LCBib3R0b21PZmZzZXQgKyBieXRlc1BlclJvdyk7XG5cbiAgICAgIHJlc3VsdC5zZXQodGVtcCwgYm90dG9tT2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgZXJlY3RQYWNrZWRGbG9hdDogKGFycmF5LCB3aWR0aCkgPT4ge1xuICAgIHJldHVybiBhcnJheS5zdWJhcnJheSgwLCB3aWR0aCk7XG4gIH0sXG4gIGVyZWN0MkRQYWNrZWRGbG9hdDogKGFycmF5LCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICBjb25zdCB4U3RhcnQgPSB5ICogd2lkdGg7XG4gICAgICBjb25zdCB4RW5kID0geFN0YXJ0ICsgd2lkdGg7XG4gICAgICB5UmVzdWx0c1t5XSA9IGFycmF5LnN1YmFycmF5KHhTdGFydCwgeEVuZCk7XG4gICAgfVxuICAgIHJldHVybiB5UmVzdWx0cztcbiAgfSxcbiAgZXJlY3QzRFBhY2tlZEZsb2F0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFN0YXJ0ID0gKHogKiBoZWlnaHQgKiB3aWR0aCkgKyB5ICogd2lkdGg7XG4gICAgICAgIGNvbnN0IHhFbmQgPSB4U3RhcnQgKyB3aWR0aDtcbiAgICAgICAgeVJlc3VsdHNbeV0gPSBhcnJheS5zdWJhcnJheSh4U3RhcnQsIHhFbmQpO1xuICAgICAgfVxuICAgICAgelJlc3VsdHNbel0gPSB5UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHpSZXN1bHRzO1xuICB9LFxuICBlcmVjdE1lbW9yeU9wdGltaXplZEZsb2F0OiAoYXJyYXksIHdpZHRoKSA9PiB7XG4gICAgcmV0dXJuIGFycmF5LnN1YmFycmF5KDAsIHdpZHRoKTtcbiAgfSxcbiAgZXJlY3RNZW1vcnlPcHRpbWl6ZWQyREZsb2F0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiB3aWR0aDtcbiAgICAgIHlSZXN1bHRzW3ldID0gYXJyYXkuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyB3aWR0aCk7XG4gICAgfVxuICAgIHJldHVybiB5UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RNZW1vcnlPcHRpbWl6ZWQzREZsb2F0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKHogKiBoZWlnaHQgKiB3aWR0aCkgKyAoeSAqIHdpZHRoKTtcbiAgICAgICAgeVJlc3VsdHNbeV0gPSBhcnJheS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHdpZHRoKTtcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RGbG9hdDogKGFycmF5LCB3aWR0aCkgPT4ge1xuICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgeFJlc3VsdHNbeF0gPSBhcnJheVtpXTtcbiAgICAgIGkgKz0gNDtcbiAgICB9XG4gICAgcmV0dXJuIHhSZXN1bHRzO1xuICB9LFxuICBlcmVjdDJERmxvYXQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgeFJlc3VsdHNbeF0gPSBhcnJheVtpXTtcbiAgICAgICAgaSArPSA0O1xuICAgICAgfVxuICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdDNERmxvYXQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpID0+IHtcbiAgICBjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoKTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgeFJlc3VsdHNbeF0gPSBhcnJheVtpXTtcbiAgICAgICAgICBpICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RBcnJheTI6IChhcnJheSwgd2lkdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHgsIHggKyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHhSZXN1bHRzO1xuICB9LFxuICBlcmVjdDJEQXJyYXkyOiAoYXJyYXksIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGNvbnN0IFhSZXN1bHRzTWF4ID0gd2lkdGggKiA0O1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiBYUmVzdWx0c01heDtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgWFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCArIG9mZnNldCwgeCArIG9mZnNldCArIDIpO1xuICAgICAgfVxuICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdDNEQXJyYXkyOiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoeiAqIHhSZXN1bHRzTWF4ICogaGVpZ2h0KSArICh5ICogeFJlc3VsdHNNYXgpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RBcnJheTM6IChhcnJheSwgd2lkdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHgsIHggKyAzKTtcbiAgICB9XG4gICAgcmV0dXJuIHhSZXN1bHRzO1xuICB9LFxuICBlcmVjdDJEQXJyYXkzOiAoYXJyYXksIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiB4UmVzdWx0c01heDtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCArIG9mZnNldCwgeCArIG9mZnNldCArIDMpO1xuICAgICAgfVxuICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdDNEQXJyYXkzOiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoeiAqIHhSZXN1bHRzTWF4ICogaGVpZ2h0KSArICh5ICogeFJlc3VsdHNNYXgpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgMyk7XG4gICAgICAgIH1cbiAgICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RBcnJheTQ6IChhcnJheSwgd2lkdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheShhcnJheSk7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHgsIHggKyA0KTtcbiAgICB9XG4gICAgcmV0dXJuIHhSZXN1bHRzO1xuICB9LFxuICBlcmVjdDJEQXJyYXk0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiB4UmVzdWx0c01heDtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCArIG9mZnNldCwgeCArIG9mZnNldCArIDQpO1xuICAgICAgfVxuICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdDNEQXJyYXk0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoeiAqIHhSZXN1bHRzTWF4ICogaGVpZ2h0KSArICh5ICogeFJlc3VsdHNNYXgpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgNCk7XG4gICAgICAgIH1cbiAgICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcblxuICBmbGF0dGVuRnVuY3Rpb25Ub1N0cmluZzogKHNvdXJjZSwgc2V0dGluZ3MpID0+IHtcbiAgICBjb25zdCB7IGZpbmREZXBlbmRlbmN5LCB0aGlzTG9va3VwLCBkb05vdERlZmluZSB9ID0gc2V0dGluZ3M7XG4gICAgbGV0IGZsYXR0ZW5lZCA9IHNldHRpbmdzLmZsYXR0ZW5lZDtcbiAgICBpZiAoIWZsYXR0ZW5lZCkge1xuICAgICAgZmxhdHRlbmVkID0gc2V0dGluZ3MuZmxhdHRlbmVkID0ge307XG4gICAgfVxuICAgIGNvbnN0IGFzdCA9IGFjb3JuLnBhcnNlKHNvdXJjZSk7XG4gICAgY29uc3QgZnVuY3Rpb25EZXBlbmRlbmNpZXMgPSBbXTtcbiAgICBsZXQgaW5kZW50ID0gMDtcblxuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXN0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhc3QpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goZmxhdHRlbihhc3RbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cy5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnUHJvZ3JhbSc6XG4gICAgICAgICAgcmV0dXJuIGZsYXR0ZW4oYXN0LmJvZHkpICsgKGFzdC5ib2R5WzBdLnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJyA/ICc7JyA6ICcnKTtcbiAgICAgICAgY2FzZSAnRnVuY3Rpb25EZWNsYXJhdGlvbic6XG4gICAgICAgICAgcmV0dXJuIGBmdW5jdGlvbiAke2FzdC5pZC5uYW1lfSgke2FzdC5wYXJhbXMubWFwKGZsYXR0ZW4pLmpvaW4oJywgJyl9KSAkeyBmbGF0dGVuKGFzdC5ib2R5KSB9YDtcbiAgICAgICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgaW5kZW50ICs9IDI7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZmxhdCA9IGZsYXR0ZW4oYXN0LmJvZHlbaV0pO1xuICAgICAgICAgICAgaWYgKGZsYXQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyAnLnJlcGVhdChpbmRlbnQpICsgZmxhdCwgJztcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaW5kZW50IC09IDI7XG4gICAgICAgICAgcmV0dXJuIGB7XFxuJHtyZXN1bHQuam9pbignJyl9fWA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdGlvbic6XG4gICAgICAgICAgY29uc3QgZGVjbGFyYXRpb25zID0gdXRpbHMubm9ybWFsaXplRGVjbGFyYXRpb25zKGFzdClcbiAgICAgICAgICAgIC5tYXAoZmxhdHRlbilcbiAgICAgICAgICAgIC5maWx0ZXIociA9PiByICE9PSBudWxsKTtcbiAgICAgICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAke2FzdC5raW5kfSAke2RlY2xhcmF0aW9ucy5qb2luKCcsJyl9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzpcbiAgICAgICAgICAgIGlmIChhc3QuaW5pdC5vYmplY3QgJiYgYXN0LmluaXQub2JqZWN0LnR5cGUgPT09ICdUaGlzRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgY29uc3QgbG9va3VwID0gdGhpc0xvb2t1cChhc3QuaW5pdC5wcm9wZXJ0eS5uYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgaWYgKGxvb2t1cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHthc3QuaWQubmFtZX0gPSAke2ZsYXR0ZW4oYXN0LmluaXQpfWA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBgJHthc3QuaWQubmFtZX0gPSAke2ZsYXR0ZW4oYXN0LmluaXQpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6IHtcbiAgICAgICAgICAgICAgaWYgKGFzdC5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gJ3N1YmFycmF5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5jYWxsZWUub2JqZWN0KX0uJHtmbGF0dGVuKGFzdC5jYWxsZWUucHJvcGVydHkpfSgke2FzdC5hcmd1bWVudHMubWFwKHZhbHVlID0+IGZsYXR0ZW4odmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhc3QuY2FsbGVlLm9iamVjdC5uYW1lID09PSAnZ2wnIHx8IGFzdC5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdjb250ZXh0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5jYWxsZWUub2JqZWN0KX0uJHtmbGF0dGVuKGFzdC5jYWxsZWUucHJvcGVydHkpfSgke2FzdC5hcmd1bWVudHMubWFwKHZhbHVlID0+IGZsYXR0ZW4odmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhc3QuY2FsbGVlLm9iamVjdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25EZXBlbmRlbmNpZXMucHVzaChmaW5kRGVwZW5kZW5jeSgndGhpcycsIGFzdC5jYWxsZWUucHJvcGVydHkubmFtZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHthc3QuY2FsbGVlLnByb3BlcnR5Lm5hbWV9KCR7YXN0LmFyZ3VtZW50cy5tYXAodmFsdWUgPT4gZmxhdHRlbih2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXN0LmNhbGxlZS5vYmplY3QubmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kU291cmNlID0gZmluZERlcGVuZGVuY3koYXN0LmNhbGxlZS5vYmplY3QubmFtZSwgYXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRTb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHthc3QuY2FsbGVlLm9iamVjdC5uYW1lfS4ke2FzdC5jYWxsZWUucHJvcGVydHkubmFtZX0oJHthc3QuYXJndW1lbnRzLm1hcCh2YWx1ZSA9PiBmbGF0dGVuKHZhbHVlKSkuam9pbignLCAnKX0pYDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZXBlbmRlbmNpZXMucHVzaChmb3VuZFNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYCR7YXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lfSgke2FzdC5hcmd1bWVudHMubWFwKHZhbHVlID0+IGZsYXR0ZW4odmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhc3QuY2FsbGVlLm9iamVjdC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZmxhdHRlbihhc3QuY2FsbGVlLm9iamVjdCl9LiR7YXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lfSgke2FzdC5hcmd1bWVudHMubWFwKHZhbHVlID0+IGZsYXR0ZW4odmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBhc3QuY2FsbGVlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgICAgICAgIHJldHVybiBgcmV0dXJuICR7ZmxhdHRlbihhc3QuYXJndW1lbnQpfWA7XG4gICAgICAgICAgICBjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGAoJHtmbGF0dGVuKGFzdC5sZWZ0KX0ke2FzdC5vcGVyYXRvcn0ke2ZsYXR0ZW4oYXN0LnJpZ2h0KX0pYDtcbiAgICAgICAgICAgIGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgIGlmIChhc3QucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2FzdC5vcGVyYXRvcn0gJHtmbGF0dGVuKGFzdC5hcmd1bWVudCl9YDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZmxhdHRlbihhc3QuYXJndW1lbnQpfSAke2FzdC5vcGVyYXRvcn1gO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5leHByZXNzaW9uKX1gO1xuICAgICAgICAgICAgICBjYXNlICdTZXF1ZW5jZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBgKCR7ZmxhdHRlbihhc3QuZXhwcmVzc2lvbnMpfSlgO1xuICAgICAgICAgICAgICBjYXNlICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAoJHthc3QucGFyYW1zLm1hcChmbGF0dGVuKS5qb2luKCcsICcpfSkgPT4gJHtmbGF0dGVuKGFzdC5ib2R5KX1gO1xuICAgICAgICAgICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN0LnJhdztcbiAgICAgICAgICAgICAgY2FzZSAnSWRlbnRpZmllcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzdC5uYW1lO1xuICAgICAgICAgICAgICBjYXNlICdNZW1iZXJFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICBpZiAoYXN0Lm9iamVjdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0xvb2t1cChhc3QucHJvcGVydHkubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhc3QuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5vYmplY3QpfVske2ZsYXR0ZW4oYXN0LnByb3BlcnR5KX1dYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW4oYXN0Lm9iamVjdCkgKyAnLicgKyBmbGF0dGVuKGFzdC5wcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIGNhc2UgJ1RoaXNFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RoaXMnO1xuICAgICAgICAgICAgICBjYXNlICdOZXdFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYG5ldyAke2ZsYXR0ZW4oYXN0LmNhbGxlZSl9KCR7YXN0LmFyZ3VtZW50cy5tYXAodmFsdWUgPT4gZmxhdHRlbih2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBmb3IgKCR7ZmxhdHRlbihhc3QuaW5pdCl9OyR7ZmxhdHRlbihhc3QudGVzdCl9OyR7ZmxhdHRlbihhc3QudXBkYXRlKX0pICR7ZmxhdHRlbihhc3QuYm9keSl9YDtcbiAgICAgICAgICAgICAgY2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5sZWZ0KX0ke2FzdC5vcGVyYXRvcn0ke2ZsYXR0ZW4oYXN0LnJpZ2h0KX1gO1xuICAgICAgICAgICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZmxhdHRlbihhc3QuYXJndW1lbnQpfSR7YXN0Lm9wZXJhdG9yfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ0lmU3RhdGVtZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYGlmICgke2ZsYXR0ZW4oYXN0LnRlc3QpfSkgJHtmbGF0dGVuKGFzdC5jb25zZXF1ZW50KX1gO1xuICAgICAgICAgICAgICBjYXNlICdUaHJvd1N0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGB0aHJvdyAke2ZsYXR0ZW4oYXN0LmFyZ3VtZW50KX1gO1xuICAgICAgICAgICAgICBjYXNlICdPYmplY3RQYXR0ZXJuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN0LnByb3BlcnRpZXMubWFwKGZsYXR0ZW4pLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgIGNhc2UgJ0FycmF5UGF0dGVybic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzdC5lbGVtZW50cy5tYXAoZmxhdHRlbikuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgY2FzZSAnRGVidWdnZXJTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZGVidWdnZXI7JztcbiAgICAgICAgICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZmxhdHRlbihhc3QudGVzdCl9PyR7ZmxhdHRlbihhc3QuY29uc2VxdWVudCl9OiR7ZmxhdHRlbihhc3QuYWx0ZXJuYXRlKX1gO1xuICAgICAgICAgICAgICBjYXNlICdQcm9wZXJ0eSc6XG4gICAgICAgICAgICAgICAgaWYgKGFzdC5raW5kID09PSAnaW5pdCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuKGFzdC5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIGFzdC50eXBlIG9mICR7IGFzdC50eXBlIH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZmxhdHRlbihhc3QpO1xuICAgIGlmIChmdW5jdGlvbkRlcGVuZGVuY2llcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBmbGF0dGVuZWRGdW5jdGlvbkRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdW5jdGlvbkRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmdW5jdGlvbkRlcGVuZGVuY3kgPSBmdW5jdGlvbkRlcGVuZGVuY2llc1tpXTtcbiAgICAgICAgaWYgKCFmbGF0dGVuZWRbZnVuY3Rpb25EZXBlbmRlbmN5XSkge1xuICAgICAgICAgIGZsYXR0ZW5lZFtmdW5jdGlvbkRlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmbGF0dGVuZWRGdW5jdGlvbkRlcGVuZGVuY2llcy5wdXNoKHV0aWxzLmZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nKGZ1bmN0aW9uRGVwZW5kZW5jeSwgc2V0dGluZ3MpICsgJ1xcbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZsYXR0ZW5lZEZ1bmN0aW9uRGVwZW5kZW5jaWVzLmpvaW4oJycpICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIG5vcm1hbGl6ZURlY2xhcmF0aW9uczogKGFzdCkgPT4ge1xuICAgIGlmIChhc3QudHlwZSAhPT0gJ1ZhcmlhYmxlRGVjbGFyYXRpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ0FzdCBpcyBub3Qgb2YgdHlwZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIicpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWREZWNsYXJhdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBkZWNsYXJhdGlvbkluZGV4ID0gMDsgZGVjbGFyYXRpb25JbmRleCA8IGFzdC5kZWNsYXJhdGlvbnMubGVuZ3RoOyBkZWNsYXJhdGlvbkluZGV4KyspIHtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gYXN0LmRlY2xhcmF0aW9uc1tkZWNsYXJhdGlvbkluZGV4XTtcbiAgICAgIGlmIChkZWNsYXJhdGlvbi5pZCAmJiBkZWNsYXJhdGlvbi5pZC50eXBlID09PSAnT2JqZWN0UGF0dGVybicgJiYgZGVjbGFyYXRpb24uaWQucHJvcGVydGllcykge1xuICAgICAgICBjb25zdCB7IHByb3BlcnRpZXMgfSA9IGRlY2xhcmF0aW9uLmlkO1xuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eUluZGV4ID0gMDsgcHJvcGVydHlJbmRleCA8IHByb3BlcnRpZXMubGVuZ3RoOyBwcm9wZXJ0eUluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbcHJvcGVydHlJbmRleF07XG4gICAgICAgICAgaWYgKHByb3BlcnR5LnZhbHVlLnR5cGUgPT09ICdPYmplY3RQYXR0ZXJuJyAmJiBwcm9wZXJ0eS52YWx1ZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzdWJQcm9wZXJ0eUluZGV4ID0gMDsgc3ViUHJvcGVydHlJbmRleCA8IHByb3BlcnR5LnZhbHVlLnByb3BlcnRpZXMubGVuZ3RoOyBzdWJQcm9wZXJ0eUluZGV4KyspIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3ViUHJvcGVydHkgPSBwcm9wZXJ0eS52YWx1ZS5wcm9wZXJ0aWVzW3N1YlByb3BlcnR5SW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoc3ViUHJvcGVydHkudHlwZSA9PT0gJ1Byb3BlcnR5Jykge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWREZWNsYXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnVmFyaWFibGVEZWNsYXJhdG9yJyxcbiAgICAgICAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc3ViUHJvcGVydHkua2V5Lm5hbWVcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogZGVjbGFyYXRpb24uaW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJvcGVydHkua2V5Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdWJQcm9wZXJ0eS5rZXkubmFtZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgc3RhdGUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHkudmFsdWUudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkRGVjbGFyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiAnVmFyaWFibGVEZWNsYXJhdG9yJyxcbiAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgbmFtZTogcHJvcGVydHkudmFsdWUgJiYgcHJvcGVydHkudmFsdWUubmFtZSA/IHByb3BlcnR5LnZhbHVlLm5hbWUgOiBwcm9wZXJ0eS5rZXkubmFtZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgIG9iamVjdDogZGVjbGFyYXRpb24uaW5pdCxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eToge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgbmFtZTogcHJvcGVydHkua2V5Lm5hbWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHN0YXRlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRlY2xhcmF0aW9uLmlkICYmIGRlY2xhcmF0aW9uLmlkLnR5cGUgPT09ICdBcnJheVBhdHRlcm4nICYmIGRlY2xhcmF0aW9uLmlkLmVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudHMgfSA9IGRlY2xhcmF0aW9uLmlkO1xuICAgICAgICBmb3IgKGxldCBlbGVtZW50SW5kZXggPSAwOyBlbGVtZW50SW5kZXggPCBlbGVtZW50cy5sZW5ndGg7IGVsZW1lbnRJbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2VsZW1lbnRJbmRleF07XG4gICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkRGVjbGFyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiAnVmFyaWFibGVEZWNsYXJhdG9yJyxcbiAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgbmFtZTogZWxlbWVudC5uYW1lXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBkZWNsYXJhdGlvbi5pbml0LFxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnTGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZWxlbWVudEluZGV4LFxuICAgICAgICAgICAgICAgICAgcmF3OiBlbGVtZW50SW5kZXgudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBlbGVtZW50LnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgZW5kOiBlbGVtZW50LmVuZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQ6IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBzdGF0ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFsaXplZERlY2xhcmF0aW9ucy5wdXNoKGRlY2xhcmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWREZWNsYXJhdGlvbnM7XG4gIH0sXG5cbiAgc3BsaXRIVE1MSW1hZ2VUb1JHQjogKGdwdSwgaW1hZ2UpID0+IHtcbiAgICBjb25zdCByS2VybmVsID0gZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihhKSB7XG4gICAgICBjb25zdCBwaXhlbCA9IGFbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICByZXR1cm4gcGl4ZWwuciAqIDI1NTtcbiAgICB9LCB7XG4gICAgICBvdXRwdXQ6IFtpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0XSxcbiAgICAgIHByZWNpc2lvbjogJ3Vuc2lnbmVkJyxcbiAgICAgIGFyZ3VtZW50VHlwZXM6IHsgYTogJ0hUTUxJbWFnZScgfSxcbiAgICB9KTtcbiAgICBjb25zdCBnS2VybmVsID0gZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihhKSB7XG4gICAgICBjb25zdCBwaXhlbCA9IGFbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICByZXR1cm4gcGl4ZWwuZyAqIDI1NTtcbiAgICB9LCB7XG4gICAgICBvdXRwdXQ6IFtpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0XSxcbiAgICAgIHByZWNpc2lvbjogJ3Vuc2lnbmVkJyxcbiAgICAgIGFyZ3VtZW50VHlwZXM6IHsgYTogJ0hUTUxJbWFnZScgfSxcbiAgICB9KTtcbiAgICBjb25zdCBiS2VybmVsID0gZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihhKSB7XG4gICAgICBjb25zdCBwaXhlbCA9IGFbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICByZXR1cm4gcGl4ZWwuYiAqIDI1NTtcbiAgICB9LCB7XG4gICAgICBvdXRwdXQ6IFtpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0XSxcbiAgICAgIHByZWNpc2lvbjogJ3Vuc2lnbmVkJyxcbiAgICAgIGFyZ3VtZW50VHlwZXM6IHsgYTogJ0hUTUxJbWFnZScgfSxcbiAgICB9KTtcbiAgICBjb25zdCBhS2VybmVsID0gZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihhKSB7XG4gICAgICBjb25zdCBwaXhlbCA9IGFbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICByZXR1cm4gcGl4ZWwuYSAqIDI1NTtcbiAgICB9LCB7XG4gICAgICBvdXRwdXQ6IFtpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0XSxcbiAgICAgIHByZWNpc2lvbjogJ3Vuc2lnbmVkJyxcbiAgICAgIGFyZ3VtZW50VHlwZXM6IHsgYTogJ0hUTUxJbWFnZScgfSxcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBbXG4gICAgICByS2VybmVsKGltYWdlKSxcbiAgICAgIGdLZXJuZWwoaW1hZ2UpLFxuICAgICAgYktlcm5lbChpbWFnZSksXG4gICAgICBhS2VybmVsKGltYWdlKSxcbiAgICBdO1xuICAgIHJlc3VsdC5yS2VybmVsID0gcktlcm5lbDtcbiAgICByZXN1bHQuZ0tlcm5lbCA9IGdLZXJuZWw7XG4gICAgcmVzdWx0LmJLZXJuZWwgPSBiS2VybmVsO1xuICAgIHJlc3VsdC5hS2VybmVsID0gYUtlcm5lbDtcbiAgICByZXN1bHQuZ3B1ID0gZ3B1O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgc3BsaXRSR0JBVG9DYW52YXNlczogKGdwdSwgcmdiYSwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHZpc3VhbEtlcm5lbFIgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKHYpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gdlt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHRoaXMuY29sb3IocGl4ZWwuciAvIDI1NSwgMCwgMCwgMjU1KTtcbiAgICB9LCB7XG4gICAgICBvdXRwdXQ6IFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgIGdyYXBoaWNhbDogdHJ1ZSxcbiAgICAgIGFyZ3VtZW50VHlwZXM6IHsgdjogJ0FycmF5MkQoNCknIH1cbiAgICB9KTtcbiAgICB2aXN1YWxLZXJuZWxSKHJnYmEpO1xuXG4gICAgY29uc3QgdmlzdWFsS2VybmVsRyA9IGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24odikge1xuICAgICAgY29uc3QgcGl4ZWwgPSB2W3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgdGhpcy5jb2xvcigwLCBwaXhlbC5nIC8gMjU1LCAwLCAyNTUpO1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgZ3JhcGhpY2FsOiB0cnVlLFxuICAgICAgYXJndW1lbnRUeXBlczogeyB2OiAnQXJyYXkyRCg0KScgfVxuICAgIH0pO1xuICAgIHZpc3VhbEtlcm5lbEcocmdiYSk7XG5cbiAgICBjb25zdCB2aXN1YWxLZXJuZWxCID0gZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbih2KSB7XG4gICAgICBjb25zdCBwaXhlbCA9IHZbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICB0aGlzLmNvbG9yKDAsIDAsIHBpeGVsLmIgLyAyNTUsIDI1NSk7XG4gICAgfSwge1xuICAgICAgb3V0cHV0OiBbd2lkdGgsIGhlaWdodF0sXG4gICAgICBncmFwaGljYWw6IHRydWUsXG4gICAgICBhcmd1bWVudFR5cGVzOiB7IHY6ICdBcnJheTJEKDQpJyB9XG4gICAgfSk7XG4gICAgdmlzdWFsS2VybmVsQihyZ2JhKTtcblxuICAgIGNvbnN0IHZpc3VhbEtlcm5lbEEgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKHYpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gdlt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHRoaXMuY29sb3IoMjU1LCAyNTUsIDI1NSwgcGl4ZWwuYSAvIDI1NSk7XG4gICAgfSwge1xuICAgICAgb3V0cHV0OiBbd2lkdGgsIGhlaWdodF0sXG4gICAgICBncmFwaGljYWw6IHRydWUsXG4gICAgICBhcmd1bWVudFR5cGVzOiB7IHY6ICdBcnJheTJEKDQpJyB9XG4gICAgfSk7XG4gICAgdmlzdWFsS2VybmVsQShyZ2JhKTtcbiAgICByZXR1cm4gW1xuICAgICAgdmlzdWFsS2VybmVsUi5jYW52YXMsXG4gICAgICB2aXN1YWxLZXJuZWxHLmNhbnZhcyxcbiAgICAgIHZpc3VhbEtlcm5lbEIuY2FudmFzLFxuICAgICAgdmlzdWFsS2VybmVsQS5jYW52YXMsXG4gICAgXTtcbiAgfSxcblxuICBnZXRNaW5pZnlTYWZlTmFtZTogKGZuKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFzdCA9IGFjb3JuLnBhcnNlKGBjb25zdCB2YWx1ZSA9ICR7Zm4udG9TdHJpbmcoKX1gKTtcbiAgICAgIGNvbnN0IHsgaW5pdCB9ID0gYXN0LmJvZHlbMF0uZGVjbGFyYXRpb25zWzBdO1xuICAgICAgcmV0dXJuIGluaXQuYm9keS5uYW1lIHx8IGluaXQuYm9keS5ib2R5WzBdLmFyZ3VtZW50Lm5hbWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgZnVuY3Rpb24gdHlwZS4gIFBsZWFzZSB1c2UgYCgpID0+IHlvdXJGdW5jdGlvblZhcmlhYmxlSGVyZWAgb3IgZnVuY3Rpb24oKSB7IHJldHVybiB5b3VyRnVuY3Rpb25WYXJpYWJsZUhlcmU7IH0nKTtcbiAgICB9XG4gIH0sXG4gIHNhbml0aXplTmFtZTogZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChkb2xsYXJTaWduLnRlc3QobmFtZSkpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZG9sbGFyU2lnbiwgJ1NfUycpO1xuICAgIH1cbiAgICBpZiAoZG91YmxlVW5kZXJzY29yZS50ZXN0KG5hbWUpKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRvdWJsZVVuZGVyc2NvcmUsICdVX1UnKTtcbiAgICB9IGVsc2UgaWYgKHNpbmdsZVVuZGVyc2NvcmUudGVzdChuYW1lKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShzaW5nbGVVbmRlcnNjb3JlLCAndV91Jyk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xuICB9XG59O1xuXG5jb25zdCBkb2xsYXJTaWduID0gL1xcJC87XG5jb25zdCBkb3VibGVVbmRlcnNjb3JlID0gL19fLztcbmNvbnN0IHNpbmdsZVVuZGVyc2NvcmUgPSAvXy87XG5cbmNvbnN0IF9zeXN0ZW1FbmRpYW5uZXNzID0gdXRpbHMuZ2V0U3lzdGVtRW5kaWFubmVzcygpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdXRpbHNcbn07XG59LHtcIi4vaW5wdXRcIjoxMTAsXCIuL3RleHR1cmVcIjoxMTMsXCJhY29yblwiOjF9XX0se30sWzEwN10pKDEwNylcbn0pO1xuIiwiY29uc3Qge2V4dHJhY3R9ID0gcmVxdWlyZSgnLi9pbWFnZS10YXJnZXQvdHJhY2tpbmcvZXh0cmFjdG9yLmpzJyk7XG5jb25zdCB7RGV0ZWN0b3J9ID0gcmVxdWlyZSgnLi9pbWFnZS10YXJnZXQvZGV0ZWN0b3JHUFUvZGV0ZWN0b3IuanMnKTtcbmNvbnN0IHtidWlsZDogaGllcmFyY2hpY2FsQ2x1c3RlcmluZ0J1aWxkfSA9IHJlcXVpcmUoJy4vaW1hZ2UtdGFyZ2V0L21hdGNoaW5nL2hpZXJhcmNoaWNhbC1jbHVzdGVyaW5nLmpzJyk7XG5jb25zdCB7YnVpbGRJbWFnZUxpc3R9ID0gcmVxdWlyZSgnLi9pbWFnZS10YXJnZXQvaW1hZ2UtbGlzdC5qcycpO1xuXG5vbm1lc3NhZ2UgPSAobXNnKSA9PiB7XG4gIGNvbnN0IHtkYXRhfSA9IG1zZztcbiAgaWYgKGRhdGEudHlwZSA9PT0gJ2NvbXBpbGUnKSB7XG4gICAgY29uc3Qge3RhcmdldEltYWdlc30gPSBkYXRhO1xuICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldEltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGFyZ2V0SW1hZ2UgPSB0YXJnZXRJbWFnZXNbaV07XG4gICAgICBjb25zdCBpbWFnZUxpc3QgPSBidWlsZEltYWdlTGlzdCh0YXJnZXRJbWFnZSk7XG4gICAgICBjb25zb2xlLmxvZyhcImNvbXBpbGluZyB0cmFja2luZy4uLlwiLCBpKTtcbiAgICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IF9leHRyYWN0VHJhY2tpbmdGZWF0dXJlcyhpbWFnZUxpc3QpO1xuICAgICAgY29uc29sZS5sb2coXCJjb21waWxpbmcgbWF0Y2hpbmcuLi5cIiwgaSk7XG4gICAgICBjb25zdCBtYXRjaGluZ0RhdGEgPSBfZXh0cmFjdE1hdGNoaW5nRmVhdHVyZXMoaW1hZ2VMaXN0KTtcbiAgICAgIGxpc3QucHVzaCh7XG4gICAgICAgIHRhcmdldEltYWdlLFxuICAgICAgICBpbWFnZUxpc3QsXG4gICAgICAgIHRyYWNraW5nRGF0YSxcbiAgICAgICAgbWF0Y2hpbmdEYXRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogJ2NvbXBpbGVEb25lJyxcbiAgICAgIGxpc3QsXG4gICAgfSk7XG4gIH1cbn07XG5cbmNvbnN0IF9leHRyYWN0TWF0Y2hpbmdGZWF0dXJlcyA9IChpbWFnZUxpc3QpID0+IHtcbiAgY29uc3Qga2V5ZnJhbWVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW1hZ2VMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaW1hZ2UgPSBpbWFnZUxpc3RbaV07XG4gICAgY29uc3QgZGV0ZWN0b3IgPSBuZXcgRGV0ZWN0b3IoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgY29uc3QgcHMgPSBkZXRlY3Rvci5kZXRlY3RJbWFnZURhdGEoaW1hZ2UuZGF0YSk7XG4gICAgY29uc3QgcG9pbnRzQ2x1c3RlciA9IGhpZXJhcmNoaWNhbENsdXN0ZXJpbmdCdWlsZCh7cG9pbnRzOiBwc30pO1xuICAgIGtleWZyYW1lcy5wdXNoKHtwb2ludHM6IHBzLCBwb2ludHNDbHVzdGVyLCB3aWR0aDogaW1hZ2Uud2lkdGgsIGhlaWdodDogaW1hZ2UuaGVpZ2h0LCBzY2FsZTogaW1hZ2UuZHBpfSk7XG4gIH1cbiAgcmV0dXJuIGtleWZyYW1lcztcbn1cblxuY29uc3QgX2V4dHJhY3RUcmFja2luZ0ZlYXR1cmVzID0gKGltYWdlTGlzdCkgPT4ge1xuICBjb25zdCBmZWF0dXJlU2V0cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGltYWdlID0gaW1hZ2VMaXN0W2ldO1xuICAgIGNvbnN0IGNvb3JkcyA9IGV4dHJhY3QoaW1hZ2UpO1xuXG4gICAgY29uc3QgZmVhdHVyZVNldCA9IHt9O1xuICAgIGZlYXR1cmVTZXQuc2NhbGUgPSBpO1xuICAgIGZlYXR1cmVTZXQubWluZHBpID0gKGkgPT09IGltYWdlTGlzdC5sZW5ndGgtMSk/IGltYWdlTGlzdFtpXS5kcGkgKiAwLjU6IGltYWdlTGlzdFtpKzFdLmRwaTtcbiAgICBmZWF0dXJlU2V0Lm1heGRwaSA9IChpID09PSAwKT8gaW1hZ2VMaXN0W2ldLmRwaSAqIDI6IChpbWFnZUxpc3RbaV0uZHBpICogMC44ICsgaW1hZ2VMaXN0W2ktMV0uZHBpICogMC4yKTtcbiAgICBmZWF0dXJlU2V0LmNvb3JkcyA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBmZWF0dXJlU2V0LmNvb3Jkcy5wdXNoKHtcbiAgICAgICAgbXg6IGNvb3Jkc1tqXS5teCxcbiAgICAgICAgbXk6IGNvb3Jkc1tqXS5teSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmZWF0dXJlU2V0cy5wdXNoKGZlYXR1cmVTZXQpO1xuICB9XG4gIHJldHVybiBmZWF0dXJlU2V0cztcbn1cbiIsImNvbnN0IHtHUFV9ID0gcmVxdWlyZSgnZ3B1LmpzJyk7XG5cbmNvbnN0IFBZUkFNSURfTlVNX1NDQUxFU19QRVJfT0NUQVZFUyA9IDM7XG5jb25zdCBQWVJBTUlEX01JTl9TSVpFID0gODtcblxuY29uc3QgTEFQTEFDSUFOX1NRUl9USFJFU0hPTEQgPSAzICogMztcbmNvbnN0IE1BWF9TVUJQSVhFTF9ESVNUQU5DRV9TUVIgPSAzICogMztcbmNvbnN0IEVER0VfVEhSRVNIT0xEID0gNC4wO1xuY29uc3QgRURHRV9IRVNTSUFOX1RIUkVTSE9MRCA9ICgoRURHRV9USFJFU0hPTEQrMSkgKiAoRURHRV9USFJFU0hPTEQrMSkgLyBFREdFX1RIUkVTSE9MRCk7XG5cbmNvbnN0IE5VTV9CVUNLRVRTX1BFUl9ESU1FTlNJT04gPSAxMDtcbmNvbnN0IE1BWF9GRUFUVVJFU19QRVJfQlVDS0VUID0gNTtcbi8vY29uc3QgTlVNX0JVQ0tFVFNfUEVSX0RJTUVOU0lPTiA9IDIwO1xuLy9jb25zdCBNQVhfRkVBVFVSRVNfUEVSX0JVQ0tFVCA9IDE7XG5jb25zdCBOVU1fQlVDS0VUUyA9IE5VTV9CVUNLRVRTX1BFUl9ESU1FTlNJT04gKiBOVU1fQlVDS0VUU19QRVJfRElNRU5TSU9OO1xuLy8gdG90YWwgbWF4IGZlYXR1cmUgcG9pbnRzID0gTlVNX0JVQ0tFVFMgKiBNQVhfRkVBVFVSRVNfUEVSX0JVQ0tFVFxuXG5jb25zdCBPUklFTlRBVElPTl9OVU1fQklOUyA9IDM2O1xuY29uc3QgT1JJRU5UQVRJT05fU01PT1RISU5HX0lURVJBVElPTlMgPSA1O1xuXG5jb25zdCBPUklFTlRBVElPTl9HQVVTU0lBTl9FWFBBTlNJT05fRkFDVE9SID0gMy4wO1xuY29uc3QgT1JJRU5UQVRJT05fUkVHSU9OX0VYUEFOU0lPTl9GQUNUT1IgPSAxLjU7XG5jb25zdCBGUkVBS19FWFBBTlNJT05fRkFDVE9SID0gNy4wO1xuXG4vLyAzNyBwb2ludHMgPSA2IHJpbmdzIHggNiBwb2ludHMgcGVyIHJpbmcgKyAxIGNlbnRlclxuY29uc3QgRlJFQUtfUklOR1MgPSBbXG4gIC8vIHJpbmcgNVxuICB7XG4gICAgc2lnbWE6IDAuNTUwMDAwLFxuICAgIHBvaW50czogW1xuICAgICAgWy0xLjAwMDAwMCwgMC4wMDAwMDBdLFxuICAgICAgWy0wLjUwMDAwMCwgLTAuODY2MDI1XSxcbiAgICAgIFswLjUwMDAwMCwgLTAuODY2MDI1XSxcbiAgICAgIFsxLjAwMDAwMCwgLTAuMDAwMDAwXSxcbiAgICAgIFswLjUwMDAwMCwgMC44NjYwMjVdLFxuICAgICAgWy0wLjUwMDAwMCwgMC44NjYwMjVdXG4gICAgXVxuICB9LFxuICAvLyByaW5nIDRcbiAge1xuICAgIHNpZ21hOiAwLjQ3NTAwMCxcbiAgICBwb2ludHM6IFtcbiAgICAgIFswLjAwMDAwMCwgMC45MzA5NjldLFxuICAgICAgWy0wLjgwNjI0MywgMC40NjU0ODVdLFxuICAgICAgWy0wLjgwNjI0MywgLTAuNDY1NDg1XSxcbiAgICAgIFstMC4wMDAwMDAsIC0wLjkzMDk2OV0sXG4gICAgICBbMC44MDYyNDMsIC0wLjQ2NTQ4NV0sXG4gICAgICBbMC44MDYyNDMsIDAuNDY1NDg1XVxuICAgIF1cbiAgfSxcbiAgLy8gcmluZyAzXG4gIHtcbiAgICBzaWdtYTogMC40MDAwMDAsXG4gICAgcG9pbnRzOiBbXG4gICAgICBbMC44NDczMDYsIC0wLjAwMDAwMF0sXG4gICAgICBbMC40MjM2NTMsIDAuNzMzNzg5XSxcbiAgICAgIFstMC40MjM2NTMsIDAuNzMzNzg5XSxcbiAgICAgIFstMC44NDczMDYsIDAuMDAwMDAwXSxcbiAgICAgIFstMC40MjM2NTMsIC0wLjczMzc4OV0sXG4gICAgICBbMC40MjM2NTMsIC0wLjczMzc4OV1cbiAgICBdXG4gIH0sXG4gIC8vIHJpbmcgMlxuICB7XG4gICAgc2lnbWE6IDAuMzI1MDAwLFxuICAgIHBvaW50czogW1xuICAgICAgWy0wLjAwMDAwMCwgLTAuNzQxMDk0XSxcbiAgICAgIFswLjY0MTgwNiwgLTAuMzcwNTQ3XSxcbiAgICAgIFswLjY0MTgwNiwgMC4zNzA1NDddLFxuICAgICAgWzAuMDAwMDAwLCAwLjc0MTA5NF0sXG4gICAgICBbLTAuNjQxODA2LCAwLjM3MDU0N10sXG4gICAgICBbLTAuNjQxODA2LCAtMC4zNzA1NDddXG4gICAgXVxuICB9LFxuICAvLyByaW5nIDFcbiAge1xuICAgIHNpZ21hOiAwLjI1MDAwMCxcbiAgICBwb2ludHM6IFtcbiAgICAgIFstMC41OTU1MDIsIDAuMDAwMDAwXSxcbiAgICAgIFstMC4yOTc3NTEsIC0wLjUxNTcyMF0sXG4gICAgICBbMC4yOTc3NTEsIC0wLjUxNTcyMF0sXG4gICAgICBbMC41OTU1MDIsIC0wLjAwMDAwMF0sXG4gICAgICBbMC4yOTc3NTEsIDAuNTE1NzIwXSxcbiAgICAgIFstMC4yOTc3NTEsIDAuNTE1NzIwXVxuICAgIF1cbiAgfSxcbiAgLy8gcmluZyAwXG4gIHtcbiAgICBzaWdtYTogMC4xNzUwMDAsXG4gICAgcG9pbnRzOiBbXG4gICAgICBbMC4wMDAwMDAsIDAuMzYyNzgzXSxcbiAgICAgIFstMC4zMTQxNzksIDAuMTgxMzkxXSxcbiAgICAgIFstMC4zMTQxNzksIC0wLjE4MTM5MV0sXG4gICAgICBbLTAuMDAwMDAwLCAtMC4zNjI3ODNdLFxuICAgICAgWzAuMzE0MTc5LCAtMC4xODEzOTFdLFxuICAgICAgWzAuMzE0MTc5LCAwLjE4MTM5MV1cbiAgICBdXG4gIH0sXG4gIC8vIGNlbnRlclxuICB7XG4gICAgc2lnbWE6IDAuMTAwMDAwLFxuICAgIHBvaW50czogW1xuICAgICAgWzAsIDBdXG4gICAgXVxuICB9XG5dO1xuXG5jb25zdCBGUkVBS1BPSU5UUyA9IFtdO1xuZm9yIChsZXQgciA9IDA7IHIgPCBGUkVBS19SSU5HUy5sZW5ndGg7IHIrKykge1xuICBjb25zdCBzaWdtYSA9IEZSRUFLX1JJTkdTW3JdLnNpZ21hO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IEZSRUFLX1JJTkdTW3JdLnBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBvaW50ID0gRlJFQUtfUklOR1Nbcl0ucG9pbnRzW2ldO1xuICAgIEZSRUFLUE9JTlRTLnB1c2goW3NpZ21hLCBwb2ludFswXSwgcG9pbnRbMV1dKTtcbiAgfVxufVxuXG5jb25zdCBGUkVBS19DT05QQVJJU09OX0NPVU5UID0gKEZSRUFLUE9JTlRTLmxlbmd0aC0xKSAqIChGUkVBS1BPSU5UUy5sZW5ndGgpIC8gMjsgLy8gNjY2XG5cbi8vIGdwdS5qcyB1c2UgMzItYml0IGZsb2F0IG51bWJlci4gaXQgaGFzIDI0IHNpZ25pZmljYW50IGJpdCBhbmQgOCBiaXQgZXhwb25lbnQgKGNhbiBjb25maXJtZWQ/KVxuLy8gICB0aGVyZWZvcmUsIGl0IGNhbiBvbmx5IHB1dCAyNCBiaXRzIG9mIGluZm9ybWF0aW9uIHdpdGggZnVsbCBhY2N1cmFjeVxuLy8gICBhbnkgYmV0dGVyIHdheSB0byB1dGlsaXplIGFsbCAzMiBiaXRzP1xuY29uc3QgRlJFQUtfMjRCSVRfREVTQ1JJUFRPUl9DT1VOVCA9IE1hdGguY2VpbChGUkVBS19DT05QQVJJU09OX0NPVU5UIC8gMjQpOyAvLyBjZWlsKDY2Ni8yNCkgPSAyOCBudW1iZXJzXG5cbmNsYXNzIERldGVjdG9yIHtcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIGxldCBudW1PY3RhdmVzID0gMDtcbiAgICB3aGlsZSAod2lkdGggPj0gUFlSQU1JRF9NSU5fU0laRSAmJiBoZWlnaHQgPj0gUFlSQU1JRF9NSU5fU0laRSkge1xuICAgICAgd2lkdGggLz0gMjtcbiAgICAgIGhlaWdodCAvPSAyO1xuICAgICAgbnVtT2N0YXZlcysrO1xuICAgIH1cbiAgICB0aGlzLm51bU9jdGF2ZXMgPSBudW1PY3RhdmVzO1xuICAgIHRoaXMua2VybmVscyA9IFtdO1xuICAgIHRoaXMuZ3B1ID0gbmV3IEdQVSgpO1xuICAgIHRoaXMuaW5wdXRLZXJuZWwgPSBudWxsO1xuICB9XG5cbiAgZGV0ZWN0KGlucHV0KSB7XG4gICAgaWYgKHRoaXMuaW5wdXRLZXJuZWwgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuaW5wdXRLZXJuZWwgPSB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oaW5wdXRGcmFtZSkge1xuICAgICAgICBjb25zdCBwaXhlbCA9IGlucHV0RnJhbWVbdGhpcy5jb25zdGFudHMuaGVpZ2h0LTEtTWF0aC5mbG9vcih0aGlzLnRocmVhZC54IC8gdGhpcy5jb25zdGFudHMud2lkdGgpXVt0aGlzLnRocmVhZC54ICUgdGhpcy5jb25zdGFudHMud2lkdGhdO1xuICAgICAgICAvL3JldHVybiAocGl4ZWxbMF0gKyBwaXhlbFsxXSArIHBpeGVsWzJdKSAqIDI1NSAvIDM7XG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU5NjIxNi9mb3JtdWxhLXRvLWRldGVybWluZS1icmlnaHRuZXNzLW9mLXJnYi1jb2xvci81OTYyNDEjNTk2MjQxXG4gICAgICAgIHJldHVybiAyNTUgKiAoMC4yMTI2ICogcGl4ZWxbMF0gKyAwLjcxNTIgKiBwaXhlbFsxXSArIDAuMDcyMiAqIHBpeGVsWzJdKTtcbiAgICAgIH0sIHtcbiAgICAgICAgY29uc3RhbnRzOiB7d2lkdGg6IHRoaXMud2lkdGgsIGhlaWdodDogdGhpcy5oZWlnaHR9LFxuICAgICAgICBvdXRwdXQ6IFt0aGlzLndpZHRoICogdGhpcy5oZWlnaHRdLFxuICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaW5wdXRLZXJuZWwoaW5wdXQpO1xuICAgIHJldHVybiB0aGlzLmRldGVjdEltYWdlRGF0YShyZXN1bHQpO1xuICB9XG5cbiAgZGV0ZWN0SW1hZ2VEYXRhKGltYWdlZGF0YSkge1xuICAgIHRoaXMua2VybmVsSW5kZXggPSAwOyAvLyByZXNldCBrZXJuZWxJbmRleFxuXG4gICAgY29uc3QgaW5wdXRJbWFnZSA9IHt3aWR0aDogdGhpcy53aWR0aCwgaGVpZ2h0OiB0aGlzLmhlaWdodCwgZGF0YTogaW1hZ2VkYXRhfTtcblxuICAgIGNvbnN0IG9yaWdpbmFsV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IG9yaWdpbmFsSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbnVtT2N0YXZlcyA9IHRoaXMubnVtT2N0YXZlcztcblxuICAgIC8vIEJ1aWxkIGdhdXNzaWFuIHB5cmFtaWQgaW1hZ2VzXG4gICAgY29uc3QgcHlyYW1pZEltYWdlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT2N0YXZlczsgaSsrKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBweXJhbWlkSW1hZ2VzLnB1c2godGhpcy5fYXBwbHlGaWx0ZXIoaW5wdXRJbWFnZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmlyc3QgaW1hZ2Ugb2YgZWFjaCBvY3RhdmUsIGRvd25zYW1wbGUgZnJvbSBwcmV2aW91c1xuICAgICAgICBweXJhbWlkSW1hZ2VzLnB1c2godGhpcy5fZG93bnNhbXBsZUJpbGluZWFyKHB5cmFtaWRJbWFnZXNbcHlyYW1pZEltYWdlcy5sZW5ndGgtMV0pKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtYWluaW5nIGltYWdlcyBvZiBvY3RhdmUsIDR0aCBvcmRlciBiaW5vbWFpbCBmcm9tIHByZXZpb3VzXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IFBZUkFNSURfTlVNX1NDQUxFU19QRVJfT0NUQVZFUyAtIDE7IGorKykge1xuICAgICAgICBweXJhbWlkSW1hZ2VzLnB1c2godGhpcy5fYXBwbHlGaWx0ZXIocHlyYW1pZEltYWdlc1tweXJhbWlkSW1hZ2VzLmxlbmd0aC0xXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIGRpZmZlcmVuY2Ugb2YgZ2F1c3NpYW4gcHlyYW1pZFxuICAgIGNvbnN0IGRvZ1B5cmFtaWRJbWFnZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU9jdGF2ZXM7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBQWVJBTUlEX05VTV9TQ0FMRVNfUEVSX09DVEFWRVMgLSAxOyBqKyspIHtcbiAgICAgICAgY29uc3QgaW1hZ2UxID0gcHlyYW1pZEltYWdlc1tpICogUFlSQU1JRF9OVU1fU0NBTEVTX1BFUl9PQ1RBVkVTICsgal07XG4gICAgICAgIGNvbnN0IGltYWdlMiA9IHB5cmFtaWRJbWFnZXNbaSAqIFBZUkFNSURfTlVNX1NDQUxFU19QRVJfT0NUQVZFUyArIGogKyAxXTtcbiAgICAgICAgZG9nUHlyYW1pZEltYWdlcy5wdXNoKHRoaXMuX2RpZmZlcmVuY2VJbWFnZUJpbm9taWFsKGltYWdlMSwgaW1hZ2UyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHBydW5lZEV4dHJlbWFzID0gdGhpcy5faW5pdGlhbGl6ZVBydW5lKCk7XG5cbiAgICAvLyBGaW5kIGZlYXR1cmUgcG9pbnRzIChpLmUuIGV4dHJlbWFzIGluIGRvZyBpbWFnZXMpXG4gICAgZm9yIChsZXQgayA9IDE7IGsgPCBkb2dQeXJhbWlkSW1hZ2VzLmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgLy8gRXhwZXJpbWVudGFsIHJlc3VsdCBzaG93cyB0aGF0IG5vIGV4dHJlbWEgaXMgcG9zc2libGUgZm9yIG9kZCBudW1iZXIgb2Yga1xuICAgICAgLy8gSSBiZWxpZXZlIGl0IGhhcyBzb21ldGhpbmcgdG8gZG8gd2l0aCBob3cgdGhlIGdhdXNzaWFuIHB5cmFtaWQgYmVpbmcgY29uc3RydWN0ZWRcbiAgICAgIGlmIChrICUgMiA9PT0gMSkgY29udGludWU7XG5cbiAgICAgIGxldCBpbWFnZTAgPSBkb2dQeXJhbWlkSW1hZ2VzW2stMV07XG4gICAgICBsZXQgaW1hZ2UxID0gZG9nUHlyYW1pZEltYWdlc1trXTtcbiAgICAgIGxldCBpbWFnZTIgPSBkb2dQeXJhbWlkSW1hZ2VzW2srMV07XG5cbiAgICAgIGNvbnN0IG9jdGF2ZSA9IE1hdGguZmxvb3IoayAvIChQWVJBTUlEX05VTV9TQ0FMRVNfUEVSX09DVEFWRVMtMSkpO1xuICAgICAgY29uc3Qgc2NhbGUgPSBrICUgKFBZUkFNSURfTlVNX1NDQUxFU19QRVJfT0NUQVZFUy0xKTtcblxuICAgICAgbGV0IGhhc1Vwc2FtcGxlID0gZmFsc2U7XG4gICAgICBsZXQgaGFzUGFkT25lV2lkdGggPSBmYWxzZTtcbiAgICAgIGxldCBoYXNQYWRPbmVIZWlnaHQgPSBmYWxzZTtcblxuICAgICAgaWYgKCBNYXRoLmZsb29yKGltYWdlMC53aWR0aC8yKSA9PSBpbWFnZTEud2lkdGgpIHtcbiAgICAgICAgaW1hZ2UwID0gdGhpcy5fZG93bnNhbXBsZUJpbGluZWFyKGltYWdlMCk7XG4gICAgICB9XG4gICAgICBpZiAoIE1hdGguZmxvb3IoaW1hZ2UxLndpZHRoLzIpID09IGltYWdlMi53aWR0aCkge1xuICAgICAgICBoYXNVcHNhbXBsZSA9IHRydWU7XG4gICAgICAgIGhhc1BhZE9uZVdpZHRoID0gaW1hZ2UxLndpZHRoICUgMiA9PT0gMTtcbiAgICAgICAgaGFzUGFkT25lSGVpZ2h0ID0gaW1hZ2UxLmhlaWdodCAlIDIgPT09IDE7XG4gICAgICAgIGltYWdlMiA9IHRoaXMuX3Vwc2FtcGxlQmlsaW5lYXIoaW1hZ2UyLCBoYXNQYWRPbmVXaWR0aCwgaGFzUGFkT25lSGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgLy8gSW4gdXBzYW1wbGUgaW1hZ2UsIGlnbm9yZSB0aGUgYm9yZGVyXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRvIGZ1cnRoZXIgcGFkIG9uZSBtb3JlIGxpbmUgKGkuZS4gdXBzYWNhbGUgMngyIC0+IDV4NSksIHNvIGlnbm9yZSBvbmUgbW9yZSBsaW5lXG4gICAgICBsZXQgc3RhcnRJID0gaGFzVXBzYW1wbGU/IDI6IDE7XG4gICAgICBsZXQgc3RhcnRKID0gc3RhcnRJO1xuXG4gICAgICAvLyBzaG91bGQgaXQgYmUgXCJpbWFnZTEud2lkdGggLTJcIiA/IGJ1dCB0aGlzIHlpZWxkIGNvbnNpc3RlbnQgcmVzdWx0IHdpdGggYXJ0b29sa2l0XG4gICAgICBsZXQgZW5kSSA9IGhhc1Vwc2FtcGxlPyBpbWFnZTEud2lkdGggLSAzOiBpbWFnZTEud2lkdGggLSAxO1xuICAgICAgbGV0IGVuZEogPSBoYXNVcHNhbXBsZT8gaW1hZ2UxLmhlaWdodCAtIDM6IGltYWdlMS5oZWlnaHQgLSAxO1xuICAgICAgaWYgKGhhc1BhZE9uZVdpZHRoKSBlbmRJIC09IDE7XG4gICAgICBpZiAoaGFzUGFkT25lSGVpZ2h0KSBlbmRKIC09IDE7XG5cbiAgICAgIC8vIGZpbmQgYWxsIGV4dHJlbWEgZm9yIGltYWdlMVxuICAgICAgY29uc3QgZXh0cmVtYXNSZXN1bHQgPSB0aGlzLl9idWlsZEV4dHJlbWFzKGltYWdlMCwgaW1hZ2UxLCBpbWFnZTIsIG9jdGF2ZSwgc2NhbGUsIHN0YXJ0SSwgc3RhcnRKLCBlbmRJLCBlbmRKKTtcblxuICAgICAgLy8gY29tYmluZSB0aGlzIGV4dHJlbWEgd2l0aCB0aGUgZXhpc3RpbmdcbiAgICAgIHBydW5lZEV4dHJlbWFzID0gdGhpcy5fYXBwbHlQcnVuZShrLCBwcnVuZWRFeHRyZW1hcywgZXh0cmVtYXNSZXN1bHQsIGltYWdlMS53aWR0aCwgaW1hZ2UxLmhlaWdodCk7XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSB0aGUgb3JpZW50YXRpb24gYW5nbGUgb2YgdGhlIGV4dHJlbWFcbiAgICAvLyAgYXJ0b29sa2l0IHBpY2tzIG11dGlwbGUgYW5nbGVzICh1c3VhbGx5IDEtMyksIGJ1dCB3ZSBwaWNrIG9uZSBvbmx5IGZvciBzaW1wbGljaXR5XG4gICAgbGV0IGV4dHJlbWFIaXN0b2dyYW1zID0gdGhpcy5faW5pdGlhbGl6ZUhpc3RvZ3JhbXMoKTtcbiAgICBmb3IgKGxldCBrID0gMTsgayA8IGRvZ1B5cmFtaWRJbWFnZXMubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgICBjb25zdCBvY3RhdmUgPSBNYXRoLmZsb29yKGsgLyAoUFlSQU1JRF9OVU1fU0NBTEVTX1BFUl9PQ1RBVkVTLTEpKTtcbiAgICAgIGNvbnN0IHNjYWxlID0gayAlIChQWVJBTUlEX05VTV9TQ0FMRVNfUEVSX09DVEFWRVMtMSk7XG4gICAgICBjb25zdCBnYXVzc2lhbkluZGV4ID0gb2N0YXZlICogUFlSQU1JRF9OVU1fU0NBTEVTX1BFUl9PQ1RBVkVTICsgc2NhbGU7XG4gICAgICBjb25zdCBnYXVzc2lhbkltYWdlID0gcHlyYW1pZEltYWdlc1tnYXVzc2lhbkluZGV4XVxuICAgICAgY29uc3QgZ3JhZGllbnRSZXN1bHQgPSB0aGlzLl9jb21wdXRlR3JhZGllbnRzKGdhdXNzaWFuSW1hZ2UpO1xuXG4gICAgICBleHRyZW1hSGlzdG9ncmFtcyA9IHRoaXMuX2NvbXB1dGVPcmllbnRhdGlvbkhpc3RvZ3JhbXMoZXh0cmVtYUhpc3RvZ3JhbXMsIGdyYWRpZW50UmVzdWx0LCBwcnVuZWRFeHRyZW1hcywgaywgZ2F1c3NpYW5JbWFnZS53aWR0aCwgZ2F1c3NpYW5JbWFnZS5oZWlnaHQpO1xuICAgIH1cbiAgICBleHRyZW1hSGlzdG9ncmFtcyA9IHRoaXMuX3Ntb290aEhpc3RvZ3JhbXMoZXh0cmVtYUhpc3RvZ3JhbXMpO1xuICAgIGNvbnN0IGV4dHJlbWFBbmdsZXMgPSB0aGlzLl9jb21wdXRlRXh0cmVtYUFuZ2xlcyhleHRyZW1hSGlzdG9ncmFtcyk7XG5cbiAgICAvLyBjb21wdXRlIHRoZSBGUkVBSyBkZXNjcmlwdG9ycyBmb3IgZXh0cmVtYXNcbiAgICBjb25zdCBleHRyZW1hRnJlYWtzID0gdGhpcy5fY29tcHV0ZUV4dHJlbWFGcmVhayhweXJhbWlkSW1hZ2VzLCBudW1PY3RhdmVzLCBwcnVuZWRFeHRyZW1hcywgZXh0cmVtYUFuZ2xlcyk7XG4gICAgY29uc3QgZnJlYWtEZXNjcmlwdG9ycyA9IHRoaXMuX2NvbXB1dGVGcmVha0Rlc2NyaXB0b3JzKGV4dHJlbWFGcmVha3MpO1xuXG4gICAgLy8gY29tYmluZSBhbGwgbmVlZGVkIGRhdGEgYW5kIHJldHVybiB0byBDUFUgdG9nZXRoZXJcbiAgICBjb25zdCBjb21iaW5lZEV4dHJlbWFzID0gdGhpcy5fY29tYmluZShwcnVuZWRFeHRyZW1hcywgZnJlYWtEZXNjcmlwdG9ycyk7XG5cbiAgICBjb25zdCBjb21iaW5lZEV4dHJlbWFzQXJyID0gY29tYmluZWRFeHRyZW1hcy50b0FycmF5KCk7XG5cbiAgICBjb25zdCBmZWF0dXJlUG9pbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21iaW5lZEV4dHJlbWFzQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbWJpbmVkRXh0cmVtYXNBcnJbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGNvbWJpbmVkRXh0cmVtYXNBcnJbaV1bal1bMF0gIT09IDApIHtcbiAgICAgICAgICBjb25zdCBleHQgPSBjb21iaW5lZEV4dHJlbWFzQXJyW2ldW2pdO1xuXG4gICAgICAgICAgY29uc3QgZGVzY0JpdDI0ID0gZXh0LnNsaWNlKDMpO1xuICAgICAgICAgIC8vIGNvbnZlcnQgMjQtYml0cyBlbmNvZGVkIHRvIDMyLWJpdHMgZW5jb2RlZC4gaS5lLiBldmVyeSA0IG51bWJlcnMgdG8gMyBudW1iZXJzXG4gICAgICAgICAgLy8gIFsyNCArIDhdIFsxNiArIDE2XSBbOCArIDI0XVxuICAgICAgICAgIC8vIGFsdG9nZXRoZXIgMjggbnVtYmVycywgc28gcGVyZmVjdGx5IGNvbnZlcnQgdG8gMjEgbnVtYmVyc1xuICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkZXNjQml0MjQubGVuZ3RoOyBrICs9IDQpIHtcbiAgICAgICAgICAgIGNvbnN0IHYxID0gZGVzY0JpdDI0W2tdICogMjU2ICsgKGRlc2NCaXQyNFtrKzFdID4+IDE2KTtcbiAgICAgICAgICAgIGNvbnN0IHYyID0gKGRlc2NCaXQyNFtrKzFdICYgNjU1MzUpICogNjU1MzYgKyAoZGVzY0JpdDI0W2srMl0gPj4gOCk7XG4gICAgICAgICAgICBjb25zdCB2MyA9IChkZXNjQml0MjRbaysyXSAmIDI1NSkgKiAxNjc3NzIxNiArIGRlc2NCaXQyNFtrKzNdO1xuICAgICAgICAgICAgZGVzY3JpcHRvcnMucHVzaCh2MSk7XG4gICAgICAgICAgICBkZXNjcmlwdG9ycy5wdXNoKHYyKTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3JzLnB1c2godjMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB0aGVyZSBhcmUgNjY2IGZyZWFrIGJpdHMgdG8gZW5jb2RlLCBzbyB0aGUgbGFzdCBkZXNjcmlwdG9ycyBvbmx5IHVzZSAyNiBiaXRzLiAoNjY2ICUgMzIpXG4gICAgICAgICAgLy8gZm9yIGhpc3RvcmljYWxseSByZWFzb24sIGl0IHN0YXJ0ZWQgZnJvbSB0aGUgMm5kIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgKGJ1dCBub3QgbmVjZXNzYXJ5KTsgc28gbm93IHdlIHNoaWZ0IGJ5ICgzMi0yNi0xKSBiaXRzXG4gICAgICAgICAgZGVzY3JpcHRvcnNbZGVzY3JpcHRvcnMubGVuZ3RoLTFdID0gKGRlc2NyaXB0b3JzW2Rlc2NyaXB0b3JzLmxlbmd0aC0xXSA+Pj4gNSk7XG5cbiAgICAgICAgICBmZWF0dXJlUG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgbWF4aW1hOiBleHRbMF0gPiAwLFxuICAgICAgICAgICAgeDogZXh0WzFdLFxuICAgICAgICAgICAgeTogZXh0WzJdLFxuICAgICAgICAgICAgZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmVhdHVyZVBvaW50cztcbiAgfVxuXG4gIF9pbml0aWFsaXplUHJ1bmUoKSB7XG4gICAgaWYgKHRoaXMua2VybmVsSW5kZXggPT09IHRoaXMua2VybmVscy5sZW5ndGgpIHtcbiAgICAgIHRoaXMua2VybmVscy5wdXNoKFxuICAgICAgICB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvdXRwdXQ6IFs1LCBNQVhfRkVBVFVSRVNfUEVSX0JVQ0tFVCwgTlVNX0JVQ0tFVFNdLCAvLyBmaXJzdCBkaW1lbnNpb246IFtzY29yZSwgc2lnbWEsIHgsIHksIGRvZ0luZGV4XVxuICAgICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cbiAgICBjb25zdCBrZXJuZWwgPSB0aGlzLmtlcm5lbHNbdGhpcy5rZXJuZWxJbmRleCsrXTtcbiAgICBjb25zdCByZXN1bHQgPSBrZXJuZWwoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gY29tYmluZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gdG8gcmV0dXJuIHRvIGNwdVxuICAvLyBmaXJzdCBkaW1lbnNpb246IFtzY29yZSwgeCwgeSwgZnJlYWsxLCBmcmVhazIsIC4uLiwgZnJlYWszN11cbiAgX2NvbWJpbmUocHJ1bmVkRXh0cmVtYXMsIGZyZWFrRGVzY3JpcHRvcnMpIHtcbiAgICBpZiAodGhpcy5rZXJuZWxJbmRleCA9PT0gdGhpcy5rZXJuZWxzLmxlbmd0aCkge1xuICAgICAgdGhpcy5rZXJuZWxzLnB1c2goXG4gICAgICAgIHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihwcnVuZWRFeHRyZW1hcywgZnJlYWtEZXNjcmlwdG9ycykge1xuICAgICAgICAgIGlmICh0aGlzLnRocmVhZC54ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJ1bmVkRXh0cmVtYXNbdGhpcy50aHJlYWQuel1bdGhpcy50aHJlYWQueV1bMF07XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRocmVhZC54IDw9IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBwcnVuZWRFeHRyZW1hc1t0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54ICsgMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmcmVha0Rlc2NyaXB0b3JzW3RoaXMudGhyZWFkLnpdW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLngtM107XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvdXRwdXQ6IFszICsgRlJFQUtfMjRCSVRfREVTQ1JJUFRPUl9DT1VOVCwgTUFYX0ZFQVRVUkVTX1BFUl9CVUNLRVQsIE5VTV9CVUNLRVRTXSxcbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG4gICAgY29uc3Qga2VybmVsID0gdGhpcy5rZXJuZWxzW3RoaXMua2VybmVsSW5kZXgrK107XG4gICAgY29uc3QgcmVzdWx0ID0ga2VybmVsKHBydW5lZEV4dHJlbWFzLCBmcmVha0Rlc2NyaXB0b3JzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX2luaXRpYWxpemVIaXN0b2dyYW1zKCkge1xuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmtlcm5lbHMucHVzaChcbiAgICAgICAgdGhpcy5ncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgb3V0cHV0OiBbT1JJRU5UQVRJT05fTlVNX0JJTlMsIE1BWF9GRUFUVVJFU19QRVJfQlVDS0VULCBOVU1fQlVDS0VUU10sXG4gICAgICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVsc1t0aGlzLmtlcm5lbEluZGV4KytdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfY29tcHV0ZU9yaWVudGF0aW9uSGlzdG9ncmFtcyhleHRyZW1hSGlzdG9ncmFtcywgZ3JhZGllbnRSZXN1bHQsIHBydW5lZEV4dHJlbWFzLCBkb2dJbmRleCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmtlcm5lbHMucHVzaChcbiAgICAgICAgdGhpcy5ncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGV4dHJlbWFIaXN0b2dyYW1zLCBncmFkaWVudE1hZ3MsIGdyYWRpZW50QW5nbGVzLCBwcnVuZWRFeHRyZW1hcykge1xuICAgICAgICAgIGNvbnN0IGRvZ0luZGV4ID0gdGhpcy5jb25zdGFudHMuZG9nSW5kZXg7XG4gICAgICAgICAgY29uc3QgYnVja2V0UG9pbnRJbmRleCA9IHRoaXMudGhyZWFkLnk7XG4gICAgICAgICAgY29uc3QgYnVja2V0SW5kZXggPSB0aGlzLnRocmVhZC56O1xuXG4gICAgICAgICAgY29uc3QgdGhpc0RvZ0luZGV4ID0gcHJ1bmVkRXh0cmVtYXNbYnVja2V0SW5kZXhdW2J1Y2tldFBvaW50SW5kZXhdWzRdO1xuICAgICAgICAgIGlmIChkb2dJbmRleCAhPT0gdGhpc0RvZ0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0cmVtYUhpc3RvZ3JhbXNbdGhpcy50aHJlYWQuel1bdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgb2N0YXZlID0gdGhpcy5jb25zdGFudHMub2N0YXZlO1xuICAgICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5jb25zdGFudHMuc2NhbGU7XG4gICAgICAgICAgY29uc3QgbnVtQmlucyA9IHRoaXMuY29uc3RhbnRzLm51bUJpbnM7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmNvbnN0YW50cy53aWR0aDtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmNvbnN0YW50cy5oZWlnaHQ7XG4gICAgICAgICAgY29uc3Qgb25lT3ZlcjJQSSA9IDAuMTU5MTU0OTQzMDkxODk1O1xuICAgICAgICAgIGNvbnN0IGdhdXNzaWFuRXhwYW5zaW9uRmFjdG9yID0gdGhpcy5jb25zdGFudHMuZ2F1c3NpYW5FeHBhbnNpb25GYWN0b3I7XG4gICAgICAgICAgY29uc3QgcmVnaW9uRXhwYW5zaW9uRmFjdG9yID0gdGhpcy5jb25zdGFudHMucmVnaW9uRXhwYW5zaW9uRmFjdG9yO1xuXG4gICAgICAgICAgY29uc3QgaGlzdG9ncmFtSW5kZXggPSB0aGlzLnRocmVhZC54O1xuXG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxTaWdtYSA9IHBydW5lZEV4dHJlbWFzW2J1Y2tldEluZGV4XVtidWNrZXRQb2ludEluZGV4XVsxXTtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbFggPSBwcnVuZWRFeHRyZW1hc1tidWNrZXRJbmRleF1bYnVja2V0UG9pbnRJbmRleF1bMl07XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxZID0gcHJ1bmVkRXh0cmVtYXNbYnVja2V0SW5kZXhdW2J1Y2tldFBvaW50SW5kZXhdWzNdO1xuXG4gICAgICAgICAgLy8geCwgeSwgc2lnbWEgaW4gY3VycmVudCBvY3RhdmVcbiAgICAgICAgICBjb25zdCBvY3RhdmVGYWN0b3IgPSAxLjAgLyBNYXRoLnBvdygyLCBvY3RhdmUpO1xuICAgICAgICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKG9yaWdpbmFsWCAqIG9jdGF2ZUZhY3RvciArIDAuNSAqIG9jdGF2ZUZhY3Rvcik7XG4gICAgICAgICAgY29uc3QgeSA9IE1hdGguZmxvb3Iob3JpZ2luYWxZICogb2N0YXZlRmFjdG9yICsgMC41ICogb2N0YXZlRmFjdG9yKTtcbiAgICAgICAgICBjb25zdCBzaWdtYSA9IG9yaWdpbmFsU2lnbWEgKiBvY3RhdmVGYWN0b3I7XG5cbiAgICAgICAgICBjb25zdCBnd1NpZ21hID0gTWF0aC5tYXgoMS4wLCBnYXVzc2lhbkV4cGFuc2lvbkZhY3RvciAqIHNpZ21hKTtcbiAgICAgICAgICBjb25zdCBnd1NjYWxlID0gLTEuMCAvICgyICogZ3dTaWdtYSAqIGd3U2lnbWEpO1xuXG4gICAgICAgICAgY29uc3QgcmFkaXVzID0gcmVnaW9uRXhwYW5zaW9uRmFjdG9yICogZ3dTaWdtYTtcbiAgICAgICAgICBjb25zdCByYWRpdXMyID0gTWF0aC5jZWlsKHJhZGl1cyAqIHJhZGl1cyAtIDAuNSk7XG5cbiAgICAgICAgICBjb25zdCB4MCA9IE1hdGgubWF4KDAsIHggLSBNYXRoLmZsb29yKHJhZGl1cyArIDAuNSkpO1xuICAgICAgICAgIGNvbnN0IHgxID0gTWF0aC5taW4od2lkdGgtMSwgeCArIE1hdGguZmxvb3IocmFkaXVzICsgMC41KSk7XG4gICAgICAgICAgY29uc3QgeTAgPSBNYXRoLm1heCgwLCB5IC0gTWF0aC5mbG9vcihyYWRpdXMgKyAwLjUpKTtcbiAgICAgICAgICBjb25zdCB5MSA9IE1hdGgubWluKGhlaWdodC0xLCB5ICsgTWF0aC5mbG9vcihyYWRpdXMgKyAwLjUpKTtcblxuICAgICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgICAgZm9yIChsZXQgeXAgPSB5MDsgeXAgPD0geTE7IHlwKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGR5ID0geXAgLSB5O1xuICAgICAgICAgICAgY29uc3QgZHkyID0gZHkgKiBkeTtcbiAgICAgICAgICAgIGZvciAobGV0IHhwID0geDA7IHhwIDw9IHgxOyB4cCsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGR4ID0geHAgLSB4O1xuICAgICAgICAgICAgICBjb25zdCBkeDIgPSBkeCAqIGR4O1xuICAgICAgICAgICAgICBjb25zdCByMiA9IGR4MiArIGR5MjtcblxuICAgICAgICAgICAgICBpZiAocjIgPD0gcmFkaXVzMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hZyA9IGdyYWRpZW50TWFnc1t5cCAqIHdpZHRoICsgeHBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gZ3JhZGllbnRBbmdsZXNbeXAgKiB3aWR0aCArIHhwXTtcbiAgICAgICAgICAgICAgICBjb25zdCBfeCA9IHIyICogZ3dTY2FsZTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIGZhc3QgRXhwNlxuICAgICAgICAgICAgICAgICAqIDAuMDElIGVycm9yIGF0IDEuMDMwXG4gICAgICAgICAgICAgICAgICogMC4xMCUgZXJyb3IgYXQgMS41MjBcbiAgICAgICAgICAgICAgICAgKiAxLjAwJSBlcnJvciBhdCAyLjMzMFxuICAgICAgICAgICAgICAgICAqIDUuMDAlIGVycm9yIGF0IDMuMjg1XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3QgdyA9ICg3MjArX3gqKDcyMCtfeCooMzYwK194KigxMjArX3gqKDMwK194Kig2K194KSkpKSkpKjAuMDAxMzg4ODg4ODtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZiaW4gID0gbnVtQmlucyAqIGFuZ2xlICogb25lT3ZlcjJQSTtcbiAgICAgICAgICAgICAgICBjb25zdCBiaW4gPSBNYXRoLmZsb29yKGZiaW4gLSAwLjUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHcyID0gZmJpbiAtIGJpbiAtIDAuNTtcbiAgICAgICAgICAgICAgICBjb25zdCB3MSA9ICgxLjAgLSB3Mik7XG4gICAgICAgICAgICAgICAgY29uc3QgYjEgPSAoYmluICsgbnVtQmlucykgJSBudW1CaW5zO1xuICAgICAgICAgICAgICAgIGNvbnN0IGIyID0gKGJpbiArIDEpICUgbnVtQmlucztcbiAgICAgICAgICAgICAgICBjb25zdCBtYWduaXR1ZGUgPSB3ICogbWFnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGIxID09PSB0aGlzLnRocmVhZC54KSBzdW0gKz0gdzEgKiBtYWduaXR1ZGU7XG4gICAgICAgICAgICAgICAgaWYgKGIyID09PSB0aGlzLnRocmVhZC54KSBzdW0gKz0gdzIgKiBtYWduaXR1ZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNvbnN0YW50czoge1xuICAgICAgICAgICAgZG9nSW5kZXg6IGRvZ0luZGV4LFxuICAgICAgICAgICAgb2N0YXZlOiBNYXRoLmZsb29yKGRvZ0luZGV4IC8gKFBZUkFNSURfTlVNX1NDQUxFU19QRVJfT0NUQVZFUy0xKSksXG4gICAgICAgICAgICBzY2FsZTogZG9nSW5kZXggJSAoUFlSQU1JRF9OVU1fU0NBTEVTX1BFUl9PQ1RBVkVTLTEpLFxuICAgICAgICAgICAgbnVtQmluczogT1JJRU5UQVRJT05fTlVNX0JJTlMsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIGdhdXNzaWFuRXhwYW5zaW9uRmFjdG9yOiBPUklFTlRBVElPTl9HQVVTU0lBTl9FWFBBTlNJT05fRkFDVE9SLFxuICAgICAgICAgICAgcmVnaW9uRXhwYW5zaW9uRmFjdG9yOiBPUklFTlRBVElPTl9SRUdJT05fRVhQQU5TSU9OX0ZBQ1RPUlxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3V0cHV0OiBbT1JJRU5UQVRJT05fTlVNX0JJTlMsIE1BWF9GRUFUVVJFU19QRVJfQlVDS0VULCBOVU1fQlVDS0VUU10sXG4gICAgICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVsc1t0aGlzLmtlcm5lbEluZGV4KytdO1xuICAgIGNvbnN0IGdyYWRpZW50TWFncyA9IGdyYWRpZW50UmVzdWx0LnNhdmVNYWc7XG4gICAgY29uc3QgZ3JhZGllbnRBbmdsZXMgPSBncmFkaWVudFJlc3VsdC5yZXN1bHQ7XG4gICAgY29uc3QgcmVzdWx0ID0ga2VybmVsKGV4dHJlbWFIaXN0b2dyYW1zLCBncmFkaWVudE1hZ3MsIGdyYWRpZW50QW5nbGVzLCBwcnVuZWRFeHRyZW1hcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF9zbW9vdGhIaXN0b2dyYW1zKGhpc3RvZ3JhbXMpIHtcbiAgICBpZiAodGhpcy5rZXJuZWxJbmRleCA9PT0gdGhpcy5rZXJuZWxzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3Via2VybmVscyA9IFtdO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBPUklFTlRBVElPTl9TTU9PVEhJTkdfSVRFUkFUSU9OUzsgaysrKSB7XG4gICAgICAgIHN1Ymtlcm5lbHMucHVzaChcbiAgICAgICAgICB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oaGlzdG9ncmFtcykge1xuICAgICAgICAgICAgY29uc3QgbnVtQmlucyA9IHRoaXMuY29uc3RhbnRzLm51bUJpbnM7XG4gICAgICAgICAgICAvLyBUaGUgaGlzdG9ncmFtIGlzIHNtb290aGVkIHdpdGggYSBHYXVzc2lhbiwgd2l0aCBzaWdtYSA9IDFcbiAgICAgICAgICAgIHJldHVybiAwLjI3NDA2ODYxOTA2MTE5NyAqIGhpc3RvZ3JhbXNbdGhpcy50aHJlYWQuel1bdGhpcy50aHJlYWQueV1bKHRoaXMudGhyZWFkLnggLSAxICsgbnVtQmlucykgJSBudW1CaW5zXVxuICAgICAgICAgICAgICAgICArIDAuNDUxODYyNzYxODc3NjA2ICogaGlzdG9ncmFtc1t0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XVxuICAgICAgICAgICAgICAgICArIDAuMjc0MDY4NjE5MDYxMTk3ICogaGlzdG9ncmFtc1t0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVsodGhpcy50aHJlYWQueCArIDEpICUgbnVtQmluc107XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY29uc3RhbnRzOiB7bnVtQmluczogT1JJRU5UQVRJT05fTlVNX0JJTlN9LFxuICAgICAgICAgICAgb3V0cHV0OiBbT1JJRU5UQVRJT05fTlVNX0JJTlMsIE1BWF9GRUFUVVJFU19QRVJfQlVDS0VULCBOVU1fQlVDS0VUU10sXG4gICAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXJuZWxzLnB1c2goc3Via2VybmVscyk7XG4gICAgfVxuICAgIGNvbnN0IHN1Ymtlcm5lbHMgPSB0aGlzLmtlcm5lbHNbdGhpcy5rZXJuZWxJbmRleCsrXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IE9SSUVOVEFUSU9OX1NNT09USElOR19JVEVSQVRJT05TOyBrKyspIHtcbiAgICAgIGhpc3RvZ3JhbXMgPSBzdWJrZXJuZWxzW2tdKGhpc3RvZ3JhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gaGlzdG9ncmFtcztcbiAgfVxuXG4gIF9jb21wdXRlRXh0cmVtYUFuZ2xlcyhoaXN0b2dyYW1zKSB7XG4gICAgaWYgKHRoaXMua2VybmVsSW5kZXggPT09IHRoaXMua2VybmVscy5sZW5ndGgpIHtcbiAgICAgIHRoaXMua2VybmVscy5wdXNoKFxuICAgICAgICB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oaGlzdG9ncmFtcykge1xuICAgICAgICAgIGNvbnN0IG51bUJpbnMgPSB0aGlzLmNvbnN0YW50cy5udW1CaW5zO1xuXG4gICAgICAgICAgbGV0IG1heEluZGV4ID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bUJpbnM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGhpc3RvZ3JhbXNbdGhpcy50aHJlYWQuel1bdGhpcy50aHJlYWQueV1baV0gPiBoaXN0b2dyYW1zW3RoaXMudGhyZWFkLnpdW3RoaXMudGhyZWFkLnldW21heEluZGV4XSkge1xuICAgICAgICAgICAgICBtYXhJbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHByZXYgPSAobWF4SW5kZXggLSAxICsgbnVtQmlucykgJSBudW1CaW5zO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSAobWF4SW5kZXggKyAxKSAlIG51bUJpbnM7XG5cbiAgICAgICAgICBsZXQgZmJpbiA9IG1heEluZGV4OyAvLyBkZWZhdWx0IGlmIG5vIHF1YWRyYXRpYyBmaXRcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBGaXQgYSBxdWF0cmF0aWMgdG8gMyBwb2ludHMuIFRoZSBzeXN0ZW0gb2YgZXF1YXRpb25zIGlzOlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogeTAgPSBBKngwXjIgKyBCKngwICsgQ1xuICAgICAgICAgICAqIHkxID0gQSp4MV4yICsgQip4MSArIENcbiAgICAgICAgICAgKiB5MiA9IEEqeDJeMiArIEIqeDIgKyBDXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGlzIHN5c3RlbSBvZiBlcXVhdGlvbnMgaXMgc29sdmVkIGZvciBBLEIsQy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBwMTAgPSBtYXhJbmRleC0xO1xuICAgICAgICAgIGNvbnN0IHAxMSA9IGhpc3RvZ3JhbXNbdGhpcy50aHJlYWQuel1bdGhpcy50aHJlYWQueV1bcHJldl07XG4gICAgICAgICAgY29uc3QgcDIwID0gbWF4SW5kZXg7XG4gICAgICAgICAgY29uc3QgcDIxID0gaGlzdG9ncmFtc1t0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVttYXhJbmRleF07XG4gICAgICAgICAgY29uc3QgcDMwID0gbWF4SW5kZXgrMTtcbiAgICAgICAgICBjb25zdCBwMzEgPSBoaXN0b2dyYW1zW3RoaXMudGhyZWFkLnpdW3RoaXMudGhyZWFkLnldW25leHRdO1xuXG4gICAgICAgICAgY29uc3QgZDEgPSAocDMwLXAyMCkqKHAzMC1wMTApO1xuICAgICAgICAgIGNvbnN0IGQyID0gKHAxMC1wMjApKihwMzAtcDEwKTtcbiAgICAgICAgICBjb25zdCBkMyA9IHAxMC1wMjA7XG5cbiAgICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIGRlbm9taW5hdG9ycyBhcmUgemVybyB0aGVuIHJldHVybiBGQUxTRS5cbiAgICAgICAgICBpZiAoZDEgIT0gMCAmJiBkMiAhPSAwICYmIGQzICE9IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwMTAqcDEwO1xuICAgICAgICAgICAgY29uc3QgYiA9IHAyMCpwMjA7XG5cbiAgICAgICAgICAgIC8vIFNvbHZlIGZvciB0aGUgY29lZmZpY2llbnRzIEEsQixDXG4gICAgICAgICAgICBjb25zdCBBID0gKChwMzEtcDIxKS9kMSktKChwMTEtcDIxKS9kMik7XG4gICAgICAgICAgICBjb25zdCBCID0gKChwMTEtcDIxKSsoQSooYi1hKSkpL2QzO1xuICAgICAgICAgICAgY29uc3QgQyA9IHAxMS0oQSphKS0oQipwMTApO1xuICAgICAgICAgICAgZmJpbiA9IC1CIC8gKDIgKiBBKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgYW4gPSAgMi4wICogTWF0aC5QSSAqICgoZmJpbiArIDAuNSArIG51bUJpbnMpIC8gbnVtQmlucyk7XG4gICAgICAgICAgd2hpbGUgKGFuID4gMi4wICogTWF0aC5QSSkgeyAvLyBtb2R1bGFcbiAgICAgICAgICAgIGFuIC09IDIuMCAqIE1hdGguUEk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhbjtcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNvbnN0YW50czoge251bUJpbnM6IE9SSUVOVEFUSU9OX05VTV9CSU5TfSxcbiAgICAgICAgICBvdXRwdXQ6IFsxLCBNQVhfRkVBVFVSRVNfUEVSX0JVQ0tFVCwgTlVNX0JVQ0tFVFNdLFxuICAgICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsID0gdGhpcy5rZXJuZWxzW3RoaXMua2VybmVsSW5kZXgrK107XG4gICAgY29uc3QgcmVzdWx0ID0ga2VybmVsKGhpc3RvZ3JhbXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfYXBwbHlQcnVuZShkb2dJbmRleCwgcHJ1bmVkRXh0cmVtYXMsIGV4dHJlbWFzUmVzdWx0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgZXh0cmVtYVNjb3JlcyA9IGV4dHJlbWFzUmVzdWx0LnJlc3VsdDtcbiAgICBjb25zdCBleHRyZW1hU2lnbWFzID0gZXh0cmVtYXNSZXN1bHQuc2F2ZVNpZ21hO1xuICAgIGNvbnN0IGV4dHJlbWFYcyA9IGV4dHJlbWFzUmVzdWx0LnNhdmVYO1xuICAgIGNvbnN0IGV4dHJlbWFZcyA9IGV4dHJlbWFzUmVzdWx0LnNhdmVZO1xuXG4gICAgaWYgKHRoaXMua2VybmVsSW5kZXggPT09IHRoaXMua2VybmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN1Ymtlcm5lbHMgPSBbXTtcblxuICAgICAgc3Via2VybmVscy5wdXNoKCAvL2R1bW15XG4gICAgICAgIHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvdXRwdXQ6IFsxLCBOVU1fQlVDS0VUU10sXG4gICAgICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICAvLyBjb21wdXRlIHRoZSBvcmRlcnMgb25lIGJ5IG9uZSwgYW5kIHN0b3JlIHRoZSBpbmRleCBhczpcbiAgICAgIC8vICBpZiBtYXhJbmRleCA8IDA6IGl0IG1lYW5zIGNvbWluZyBmcm9tIHRoZSBleGlzdGluZyBwcnVuZWRFeHRyZW1hcy4gdGhlIHBvc2l0aW9uIGlzICgtbWF4SW5kZXgtMSk7XG4gICAgICAvLyAgICAgICAgZS5nLiAtMSAtPiAwLCAtMiAtPiAxLCAtMyAtPiAyXG4gICAgICAvLyAgaWYgbWF4SW5kZXggPj0gMDogaXQgbWVhbnMgY29taW5nIGZyb20gdGhlIG5ldyBleHRyZW1hcy4gdGhlIHBvc2l0aW9uIGlzIHRoZSBwaXhlbCBpbmRleFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfRkVBVFVSRVNfUEVSX0JVQ0tFVDsgaSsrKSB7XG4gICAgICAgIHN1Ymtlcm5lbHMucHVzaChcbiAgICAgICAgICB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24ob3JkZXJzLCBwcnVuZWRFeHRyZW1hcywgZXh0cmVtYVNjb3Jlcykge1xuICAgICAgICAgICAgY29uc3QgYnVja2V0UG9pbnRJbmRleCA9IHRoaXMudGhyZWFkLng7XG4gICAgICAgICAgICBjb25zdCBidWNrZXRJbmRleCA9IHRoaXMudGhyZWFkLnk7XG4gICAgICAgICAgICBjb25zdCBvcmRlckluZGV4ID0gdGhpcy5jb25zdGFudHMub3JkZXJJbmRleDtcbiAgICAgICAgICAgIGlmIChidWNrZXRQb2ludEluZGV4IDwgb3JkZXJJbmRleCkgcmV0dXJuIG9yZGVyc1t0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcblxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmNvbnN0YW50cy53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodD0gdGhpcy5jb25zdGFudHMuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbnVtQnVja2V0c1BlckRpbWVuc2lvbiA9IHRoaXMuY29uc3RhbnRzLm51bUJ1Y2tldHNQZXJEaW1lbnNpb247XG4gICAgICAgICAgICBjb25zdCBkeCA9IHRoaXMuY29uc3RhbnRzLmJ1Y2tldFdpZHRoO1xuICAgICAgICAgICAgY29uc3QgZHkgPSB0aGlzLmNvbnN0YW50cy5idWNrZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1Y2tldFggPSBidWNrZXRJbmRleCAlIG51bUJ1Y2tldHNQZXJEaW1lbnNpb247XG4gICAgICAgICAgICBjb25zdCBidWNrZXRZID0gTWF0aC5mbG9vcihidWNrZXRJbmRleCAvIG51bUJ1Y2tldHNQZXJEaW1lbnNpb24pO1xuXG4gICAgICAgICAgICBsZXQgY3VycmVudFBydW5lZE1heEluZGV4ID0gLTE7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVySW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAob3JkZXJzW2J1Y2tldEluZGV4XVtpXSA8IDApIGN1cnJlbnRQcnVuZWRNYXhJbmRleCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1heEluZGV4ID0gY3VycmVudFBydW5lZE1heEluZGV4O1xuICAgICAgICAgICAgbGV0IG1heFNjb3JlID0gTWF0aC5hYnMocHJ1bmVkRXh0cmVtYXNbYnVja2V0SW5kZXhdWy0xICogY3VycmVudFBydW5lZE1heEluZGV4IC0gMV1bMF0pOyAvLyBzY29yZSBhdCBwcm9wZXJ0eUluZGV4IDBcbiAgICAgICAgICAgIG1heFNjb3JlID0gTWF0aC5tYXgobWF4U2NvcmUsIDAuMDAwMSk7IC8vIHNhZmVndWFyZCwgYnV0IHByb2JhYmx5IG5vdCBuZWVkZWRcblxuICAgICAgICAgICAgbGV0IHN0YXJ0WCA9IE1hdGguZmxvb3IoYnVja2V0WCAqIGR4KTtcbiAgICAgICAgICAgIGxldCBlbmRYID0gTWF0aC5mbG9vcigoYnVja2V0WCArIDEpICogZHgpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0WSA9IE1hdGguZmxvb3IoYnVja2V0WSAqIGR5KTtcbiAgICAgICAgICAgIGxldCBlbmRZID0gTWF0aC5mbG9vcigoYnVja2V0WSArIDEpICogZHkpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRYOyBpIDwgZW5kWDsgaSsrKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSBzdGFydFk7IGogPCBlbmRZOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludEluZGV4ID0gaiAqIHdpZHRoICsgaTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludFNjb3JlID0gTWF0aC5hYnMoZXh0cmVtYVNjb3Jlc1twb2ludEluZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50U2NvcmUgPiBtYXhTY29yZSkge1xuICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG9yZGVySW5kZXg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXJzW2J1Y2tldEluZGV4XVtrXSA9PT0gcG9pbnRJbmRleCkgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhTY29yZSA9IHBvaW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIG1heEluZGV4ID0gcG9pbnRJbmRleDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXhJbmRleDtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjb25zdGFudHM6IHtcbiAgICAgICAgICAgICAgYnVja2V0V2lkdGg6IHdpZHRoIC8gTlVNX0JVQ0tFVFNfUEVSX0RJTUVOU0lPTixcbiAgICAgICAgICAgICAgYnVja2V0SGVpZ2h0OiBoZWlnaHQgLyBOVU1fQlVDS0VUU19QRVJfRElNRU5TSU9OLFxuICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICBudW1CdWNrZXRzUGVyRGltZW5zaW9uOiBOVU1fQlVDS0VUU19QRVJfRElNRU5TSU9OLFxuICAgICAgICAgICAgICBvcmRlckluZGV4OiBpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3V0cHV0OiBbaSsxLCBOVU1fQlVDS0VUU10sXG4gICAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9XG4gICAgICBzdWJrZXJuZWxzLnB1c2goXG4gICAgICAgIHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihvcmRlcnMsIHBydW5lZEV4dHJlbWFzLCBleHRyZW1hU2NvcmVzLCBleHRyZW1hU2lnbWFzLCBleHRyZW1hWHMsIGV4dHJlbWFZcykge1xuICAgICAgICAgIGNvbnN0IGRvZ0luZGV4ID0gdGhpcy5jb25zdGFudHMuZG9nSW5kZXg7XG4gICAgICAgICAgY29uc3QgcHJvcGVydHlJbmRleCA9IHRoaXMudGhyZWFkLng7XG4gICAgICAgICAgY29uc3QgYnVja2V0UG9pbnRJbmRleCA9IHRoaXMudGhyZWFkLnk7XG4gICAgICAgICAgY29uc3QgYnVja2V0SW5kZXggPSB0aGlzLnRocmVhZC56O1xuICAgICAgICAgIGNvbnN0IG1heEluZGV4ID0gb3JkZXJzW2J1Y2tldEluZGV4XVtidWNrZXRQb2ludEluZGV4XTtcbiAgICAgICAgICBpZiAobWF4SW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJ1bmVkRXh0cmVtYXNbYnVja2V0SW5kZXhdWy0xICogbWF4SW5kZXggLTFdW3Byb3BlcnR5SW5kZXhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHlJbmRleCA9PT0gMCkgcmV0dXJuIGV4dHJlbWFTY29yZXNbbWF4SW5kZXhdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5SW5kZXggPT09IDEpIHJldHVybiBleHRyZW1hU2lnbWFzW21heEluZGV4XTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUluZGV4ID09PSAyKSByZXR1cm4gZXh0cmVtYVhzW21heEluZGV4XTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUluZGV4ID09PSAzKSByZXR1cm4gZXh0cmVtYVlzW21heEluZGV4XTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUluZGV4ID09PSA0KSByZXR1cm4gZG9nSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgY29uc3RhbnRzOiB7XG4gICAgICAgICAgICBkb2dJbmRleDogZG9nSW5kZXgsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvdXRwdXQ6IFs1LCBNQVhfRkVBVFVSRVNfUEVSX0JVQ0tFVCwgTlVNX0JVQ0tFVFNdLCAvLyBmaXJzdCBkaW1lbnNpb246IFtzY29yZSwgc2lnbWEsIHgsIHksIGRvZ0luZGV4XVxuICAgICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHRoaXMua2VybmVscy5wdXNoKHN1Ymtlcm5lbHMpO1xuICAgIH1cblxuICAgIGNvbnN0IHN1Ymtlcm5lbHMgPSB0aGlzLmtlcm5lbHNbdGhpcy5rZXJuZWxJbmRleCsrXTtcbiAgICBsZXQgYyA9IDA7XG4gICAgbGV0IG9yZGVycyA9IHN1Ymtlcm5lbHNbYysrXSgpOyAvLyBkdW1teVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0ZFQVRVUkVTX1BFUl9CVUNLRVQ7IGkrKykge1xuICAgICAgb3JkZXJzID0gc3Via2VybmVsc1tjKytdKG9yZGVycywgcHJ1bmVkRXh0cmVtYXMsIGV4dHJlbWFTY29yZXMpOyAvLyBidWlsZCBtYXggaW5kZXggb25lIGJ5IG9uZVxuICAgIH1cbiAgICAvLyBwYWNrIHRoZSByZXN1bHRcbiAgICBjb25zdCByZXN1bHQgPSBzdWJrZXJuZWxzW2MrK10ob3JkZXJzLCBwcnVuZWRFeHRyZW1hcywgZXh0cmVtYVNjb3JlcywgZXh0cmVtYVNpZ21hcywgZXh0cmVtYVhzLCBleHRyZW1hWXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfY29tcHV0ZUdyYWRpZW50cyhpbWFnZSkge1xuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmtlcm5lbHMucHVzaChcbiAgICAgICAgdGhpcy5ncHUuY3JlYXRlS2VybmVsTWFwKHtcbiAgICAgICAgICBzYXZlTWFnOiBmdW5jdGlvbihhKSB7cmV0dXJuIGF9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuY29uc3RhbnRzLndpZHRoO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY29uc3RhbnRzLmhlaWdodDtcblxuICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLnRocmVhZC54ICUgd2lkdGg7XG4gICAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IodGhpcy50aHJlYWQueCAvIHdpZHRoKTtcbiAgICAgICAgICBjb25zdCBwcmV2SiA9IGogPiAwPyBqIC0gMTogajtcbiAgICAgICAgICBjb25zdCBuZXh0SiA9IGogPCBoZWlnaHQgLSAxPyBqICsgMTogajtcbiAgICAgICAgICBjb25zdCBwcmV2SSA9IGkgPiAwPyBpIC0gMTogaTtcbiAgICAgICAgICBjb25zdCBuZXh0SSA9IGkgPCB3aWR0aCAtIDE/IGkgKyAxOiBpO1xuICAgICAgICAgIGNvbnN0IGR4ID0gZGF0YVtqICogd2lkdGggKyBuZXh0SV0gLSBkYXRhW2ogKiB3aWR0aCArIHByZXZJXTtcbiAgICAgICAgICBjb25zdCBkeSA9IGRhdGFbbmV4dEogKiB3aWR0aCArIGldIC0gZGF0YVtwcmV2SiAqIHdpZHRoICsgaV07XG5cbiAgICAgICAgICAvLyBzZWVtcyBsaWtlIGdwdSBhdGFuMiBkb2Vzbid0IGhhbmRsZSBkeCA9PT0gMCB3ZWxsXG4gICAgICAgICAgLy8gYW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7IGNhbiBzb21lb25lIHZlcmlmeSBjb3JyZWN0bmVzcz9cbiAgICAgICAgICBsZXQgYW5nbGUgPSAwO1xuICAgICAgICAgIGlmIChkeCA9PT0gMCAmJiBkeSA9PT0gMCkgYW5nbGUgPSAwO1xuICAgICAgICAgIGVsc2UgaWYgKGR5ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoZHggPCAwKSBhbmdsZSA9IE1hdGguUEk7XG4gICAgICAgICAgICBlbHNlIGFuZ2xlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoZHggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChkeSA8IDApIGFuZ2xlID0gLU1hdGguUEkgLyAyO1xuICAgICAgICAgICAgZWxzZSBhbmdsZSA9IE1hdGguUEkgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihNYXRoLmFicyhkeSksIE1hdGguYWJzKGR4KSk7XG4gICAgICAgICAgICBpZiAoZHggPCAwICYmIGR5ID4gMCkgYW5nbGUgPSBNYXRoLlBJIC0gYW5nbGU7XG4gICAgICAgICAgICBlbHNlIGlmIChkeCA8IDAgJiYgZHkgPCAwKSBhbmdsZSA9IC0oTWF0aC5QSSAtIGFuZ2xlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGR4ID4gMCAmJiBkeSA8IDApIGFuZ2xlID0gLWFuZ2xlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhbmdsZSArPSBNYXRoLlBJO1xuXG4gICAgICAgICAgY29uc3QgbWFnID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICBzYXZlTWFnKG1hZyk7XG4gICAgICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgY29uc3RhbnRzOiB7d2lkdGg6IGltYWdlLndpZHRoLCBoZWlnaHQ6IGltYWdlLmhlaWdodH0sXG4gICAgICAgICAgb3V0cHV0OiBbaW1hZ2Uud2lkdGggKiBpbWFnZS5oZWlnaHRdLFxuICAgICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cbiAgICBjb25zdCBrZXJuZWwgPSB0aGlzLmtlcm5lbHNbdGhpcy5rZXJuZWxJbmRleCsrXTtcbiAgICBjb25zdCByZXN1bHQgPSBrZXJuZWwoaW1hZ2UuZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF9jb21wdXRlRnJlYWtEZXNjcmlwdG9ycyhmcmVha1Jlc3VsdCkge1xuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdWJrZXJuZWxzID0gW107XG4gICAgICBzdWJrZXJuZWxzLnB1c2goXG4gICAgICAgIHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihmcmVha1Jlc3VsdCkge1xuICAgICAgICAgIGNvbnN0IG51bUZyZWFrUG9pbnRzID0gdGhpcy5jb25zdGFudHMubnVtRnJlYWtQb2ludHM7XG4gICAgICAgICAgY29uc3QgeCA9IHRoaXMudGhyZWFkLng7XG5cbiAgICAgICAgICAvLyBiaW5hcnkgc2VhcmNoIGZpcnN0IHBvaW50IGluZGV4XG4gICAgICAgICAgbGV0IGwgPSAwO1xuICAgICAgICAgIGxldCByID0gbnVtRnJlYWtQb2ludHMgLSAxO1xuICAgICAgICAgIGxldCBzdGFydEF0ID0gMDtcbiAgICAgICAgICBjb25zdCBtYXhsb29wID0gNzsgLy8gbD0wLCByPTM2LiBtYXggbnVtIG9mIGxvb3BzID0gbSA9IDE4LDksNSwzLDIsMSxcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heGxvb3A7IGkrKykge1xuICAgICAgICAgICAgaWYgKGwgIT09IHIpIHtcbiAgICAgICAgICAgICAgbGV0IG0gPSBNYXRoLmNlaWwoKGwgKyByKSAvIDIpO1xuICAgICAgICAgICAgICBzdGFydEF0ID0gKG51bUZyZWFrUG9pbnRzLW0gKyBudW1GcmVha1BvaW50cy0xKSAqIG0gLyAyO1xuICAgICAgICAgICAgICBpZiAoeCA8IHN0YXJ0QXQpIHtcbiAgICAgICAgICAgICAgICByID0gbSAtIDE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbCA9IG07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhcnRBdCA9IChudW1GcmVha1BvaW50cy1sICsgbnVtRnJlYWtQb2ludHMtMSkgKiBsIC8gMjtcbiAgICAgICAgICBjb25zdCBwMSA9IGw7XG4gICAgICAgICAgY29uc3QgcDIgPSB4IC0gc3RhcnRBdCArIChwMSsxKTtcblxuICAgICAgICAgIGlmIChmcmVha1Jlc3VsdFt0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVtwMV0gPCBmcmVha1Jlc3VsdFt0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVtwMl0gKyAwLjAwMDEpIHJldHVybiAxO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgY29uc3RhbnRzOiB7XG4gICAgICAgICAgICBudW1GcmVha1BvaW50czogRlJFQUtQT0lOVFMubGVuZ3RoXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvdXRwdXQ6IFtGUkVBS19DT05QQVJJU09OX0NPVU5ULCBNQVhfRkVBVFVSRVNfUEVSX0JVQ0tFVCwgTlVNX0JVQ0tFVFNdLFxuICAgICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgKVxuXG4gICAgICBzdWJrZXJuZWxzLnB1c2goXG4gICAgICAgIHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihmcmVha1ZhbHVlcykge1xuICAgICAgICAgIGNvbnN0IGNvbXBhcmlzb25Db3VudCA9IHRoaXMuY29uc3RhbnRzLmNvbXBhcmlzb25Db3VudDtcbiAgICAgICAgICBjb25zdCB4ID0gdGhpcy50aHJlYWQueDtcbiAgICAgICAgICBjb25zdCBzdGFydCA9IDI0ICogeDtcbiAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIDI0O1xuICAgICAgICAgIGxldCB0ZW1wID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCBjb21wYXJpc29uQ291bnQgJiYgZnJlYWtWYWx1ZXNbdGhpcy50aHJlYWQuel1bdGhpcy50aHJlYWQueV1baV0gPT09IDEpIHtcbiAgICAgICAgICAgICAgdGVtcCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcCA9IHRlbXAgKiAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZW1wIC89IDI7XG5cbiAgICAgICAgICByZXR1cm4gdGVtcDtcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNvbnN0YW50czoge1xuICAgICAgICAgICAgY29tcGFyaXNvbkNvdW50OiBGUkVBS19DT05QQVJJU09OX0NPVU5ULFxuICAgICAgICAgICAgbnVtRnJlYWtQb2ludHM6IEZSRUFLUE9JTlRTLmxlbmd0aFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3V0cHV0OiBbRlJFQUtfMjRCSVRfREVTQ1JJUFRPUl9DT1VOVCwgTUFYX0ZFQVRVUkVTX1BFUl9CVUNLRVQsIE5VTV9CVUNLRVRTXSxcbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHRoaXMua2VybmVscy5wdXNoKHN1Ymtlcm5lbHMpO1xuICAgIH1cbiAgICBjb25zdCBzdWJrZXJuZWxzID0gdGhpcy5rZXJuZWxzW3RoaXMua2VybmVsSW5kZXgrK107XG4gICAgY29uc3QgcmVzdWx0ID0gc3Via2VybmVsc1swXShmcmVha1Jlc3VsdCk7XG4gICAgY29uc3QgcmVzdWx0MiA9IHN1Ymtlcm5lbHNbMV0ocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfVxuXG4gIF9jb21wdXRlRXh0cmVtYUZyZWFrKHB5cmFtaWRJbWFnZXMsIGdhdXNzaWFuTnVtT2N0YXZlcywgcHJ1bmVkRXh0cmVtYXMsIHBydW5lZEV4dHJlbWFzQW5nbGVzKSB7XG4gICAgaWYgKHRoaXMua2VybmVsSW5kZXggPT09IHRoaXMua2VybmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN1Ymtlcm5lbHMgPSBbXTtcblxuICAgICAgc3Via2VybmVscy5wdXNoKFxuICAgICAgICB0aGlzLmdwdS5jcmVhdGVLZXJuZWxNYXAoe1xuICAgICAgICAgIHNhdmVYcDogZnVuY3Rpb24oYSkge3JldHVybiBhfSxcbiAgICAgICAgICBzYXZlWXA6IGZ1bmN0aW9uKGEpIHtyZXR1cm4gYX1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24ocHJ1bmVkRXh0cmVtYXMsIHBydW5lZEV4dHJlbWFzQW5nbGVzLCBmcmVha1BvaW50cykge1xuICAgICAgICAgIGNvbnN0IGdhdXNzaWFuTnVtT2N0YXZlcyA9IHRoaXMuY29uc3RhbnRzLmdhdXNzaWFuTnVtT2N0YXZlcztcbiAgICAgICAgICBjb25zdCBnYXVzc2lhbk51bVNjYWxlc1Blck9jdGF2ZXMgPSB0aGlzLmNvbnN0YW50cy5nYXVzc2lhbk51bVNjYWxlc1Blck9jdGF2ZXM7XG4gICAgICAgICAgY29uc3QgZXhwYW5zaW9uRmFjdG9yID0gdGhpcy5jb25zdGFudHMuZXhwYW5zaW9uRmFjdG9yO1xuXG4gICAgICAgICAgY29uc3QgYnVja2V0UG9pbnRJbmRleCA9IHRoaXMudGhyZWFkLnk7XG4gICAgICAgICAgY29uc3QgYnVja2V0SW5kZXggPSB0aGlzLnRocmVhZC56O1xuXG4gICAgICAgICAgY29uc3QgbUsgPSBNYXRoLnBvdygyLCAxLjAgLyAoZ2F1c3NpYW5OdW1TY2FsZXNQZXJPY3RhdmVzLTEpKTtcbiAgICAgICAgICBjb25zdCBvbmVPdmVyTG9nSyA9IDEuMCAvIE1hdGgubG9nKG1LKTtcblxuICAgICAgICAgIGNvbnN0IGlucHV0WCA9IHBydW5lZEV4dHJlbWFzW2J1Y2tldEluZGV4XVtidWNrZXRQb2ludEluZGV4XVsyXTtcbiAgICAgICAgICBjb25zdCBpbnB1dFkgPSBwcnVuZWRFeHRyZW1hc1tidWNrZXRJbmRleF1bYnVja2V0UG9pbnRJbmRleF1bM107XG4gICAgICAgICAgY29uc3QgaW5wdXRTaWdtYSA9IHBydW5lZEV4dHJlbWFzW2J1Y2tldEluZGV4XVtidWNrZXRQb2ludEluZGV4XVsxXTtcbiAgICAgICAgICBjb25zdCBpbnB1dEFuZ2xlID0gcHJ1bmVkRXh0cmVtYXNBbmdsZXNbYnVja2V0SW5kZXhdW2J1Y2tldFBvaW50SW5kZXhdWzBdO1xuXG4gICAgICAgICAgY29uc3QgZnJlYWtTaWdtYSA9IGZyZWFrUG9pbnRzW3RoaXMudGhyZWFkLnhdWzBdO1xuICAgICAgICAgIGNvbnN0IGZyZWFrWCA9IGZyZWFrUG9pbnRzW3RoaXMudGhyZWFkLnhdWzFdO1xuICAgICAgICAgIGNvbnN0IGZyZWFrWSA9IGZyZWFrUG9pbnRzW3RoaXMudGhyZWFkLnhdWzJdO1xuXG4gICAgICAgICAgLy8gRW5zdXJlIHRoZSBzY2FsZSBvZiB0aGUgc2ltaWxhcml0eSB0cmFuc2Zvcm0gaXMgYXQgbGVhc3QgXCIxXCIuXG4gICAgICAgICAgY29uc3QgdHJhbnNmb3JtU2NhbGUgPSBNYXRoLm1heCgxLCBpbnB1dFNpZ21hICogZXhwYW5zaW9uRmFjdG9yKTtcbiAgICAgICAgICBjb25zdCBjID0gdHJhbnNmb3JtU2NhbGUgKiBNYXRoLmNvcyhpbnB1dEFuZ2xlKTtcbiAgICAgICAgICBjb25zdCBzID0gdHJhbnNmb3JtU2NhbGUgKiBNYXRoLnNpbihpbnB1dEFuZ2xlKTtcbiAgICAgICAgICAvLyBzaW1pbGFyaXR5IG1hdHJpeFxuICAgICAgICAgIC8vIGNvbnN0IFMgPSBbXG4gICAgICAgICAgLy8gIGMsIC1zLCB4LFxuICAgICAgICAgIC8vICBzLCBjLCB5LFxuICAgICAgICAgIC8vICAwLCAwLCAxXG4gICAgICAgICAgLy9dXG4gICAgICAgICAgY29uc3QgUzAgPSBjO1xuICAgICAgICAgIGNvbnN0IFMxID0gLXM7XG4gICAgICAgICAgY29uc3QgUzIgPSBpbnB1dFg7XG4gICAgICAgICAgY29uc3QgUzMgPSBzO1xuICAgICAgICAgIGNvbnN0IFM0ID0gYztcbiAgICAgICAgICBjb25zdCBTNSA9IGlucHV0WTtcblxuICAgICAgICAgIGNvbnN0IHNpZ21hID0gdHJhbnNmb3JtU2NhbGUgKiBmcmVha1NpZ21hO1xuICAgICAgICAgIGxldCBvY3RhdmUgPSBNYXRoLmZsb29yKE1hdGgubG9nMihzaWdtYSkpO1xuICAgICAgICAgIGNvbnN0IGZzY2FsZSA9IE1hdGgubG9nKHNpZ21hIC8gTWF0aC5wb3coMiwgb2N0YXZlKSkgKiBvbmVPdmVyTG9nSztcbiAgICAgICAgICBsZXQgc2NhbGUgPSBNYXRoLnJvdW5kKGZzY2FsZSk7XG5cbiAgICAgICAgICAvLyBzZ2ltYSBvZiBsYXN0IHNjYWxlID0gc2lnbWEgb2YgdGhlIGZpcnN0IHNjYWxlIGluIG5leHQgb2N0YXZlXG4gICAgICAgICAgLy8gcHJlZmVyIGNvYXJzZXIgb2N0YXZlcyBmb3IgZWZmaWNpZW5jeVxuICAgICAgICAgIGlmIChzY2FsZSA9PT0gZ2F1c3NpYW5OdW1TY2FsZXNQZXJPY3RhdmVzIC0gMSkge1xuICAgICAgICAgICAgb2N0YXZlID0gb2N0YXZlICsgMTtcbiAgICAgICAgICAgIHNjYWxlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2xpcCBvY3RhdmUgYW5kIHNjYWxlXG4gICAgICAgICAgaWYgKG9jdGF2ZSA8IDApIHtcbiAgICAgICAgICAgIG9jdGF2ZSA9IDA7XG4gICAgICAgICAgICBzY2FsZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvY3RhdmUgPj0gZ2F1c3NpYW5OdW1PY3RhdmVzKSB7XG4gICAgICAgICAgICBvY3RhdmUgPSBnYXVzc2lhbk51bU9jdGF2ZXMgLSAxO1xuICAgICAgICAgICAgc2NhbGUgPSBnYXVzc2lhbk51bVNjYWxlc1Blck9jdGF2ZXMgLSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGZvciBkb3duc2FtcGxlIHBvaW50XG4gICAgICAgICAgY29uc3QgaW1hZ2VJbmRleCA9IG9jdGF2ZSAqIGdhdXNzaWFuTnVtU2NhbGVzUGVyT2N0YXZlcyArIHNjYWxlO1xuICAgICAgICAgIGNvbnN0IGEgPSAxLjAgLyAoTWF0aC5wb3coMiwgb2N0YXZlKSk7XG4gICAgICAgICAgY29uc3QgYiA9IDAuNSAqIGEgLSAwLjU7XG5cbiAgICAgICAgICBjb25zdCB4ID0gUzAgKiBmcmVha1ggKyBTMSAqIGZyZWFrWSArIFMyO1xuICAgICAgICAgIGNvbnN0IHkgPSBTMyAqIGZyZWFrWCArIFM0ICogZnJlYWtZICsgUzU7XG4gICAgICAgICAgbGV0IHhwID0geCAqIGEgKyBiOyAvLyB4IGluIG9jdGF2ZVxuICAgICAgICAgIGxldCB5cCA9IHkgKiBhICsgYjsgLy8geSBpbiBvY3RhdmVcblxuICAgICAgICAgIHNhdmVYcCh4cCk7XG4gICAgICAgICAgc2F2ZVlwKHlwKTtcbiAgICAgICAgICByZXR1cm4gaW1hZ2VJbmRleDtcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNvbnN0YW50czoge1xuICAgICAgICAgICAgZ2F1c3NpYW5OdW1PY3RhdmVzOiBnYXVzc2lhbk51bU9jdGF2ZXMsXG4gICAgICAgICAgICBnYXVzc2lhbk51bVNjYWxlc1Blck9jdGF2ZXM6IFBZUkFNSURfTlVNX1NDQUxFU19QRVJfT0NUQVZFUyxcbiAgICAgICAgICAgIGV4cGFuc2lvbkZhY3RvcjogRlJFQUtfRVhQQU5TSU9OX0ZBQ1RPUlxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3V0cHV0OiBbRlJFQUtQT0lOVFMubGVuZ3RoLCBNQVhfRkVBVFVSRVNfUEVSX0JVQ0tFVCwgTlVNX0JVQ0tFVFNdLFxuICAgICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgKVxuXG4gICAgICBzdWJrZXJuZWxzLnB1c2goXG4gICAgICAgIHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSwge1xuICAgICAgICAgIG91dHB1dDogW0ZSRUFLUE9JTlRTLmxlbmd0aCwgTUFYX0ZFQVRVUkVTX1BFUl9CVUNLRVQsIE5VTV9CVUNLRVRTXSxcbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHlyYW1pZEltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdWJrZXJuZWxzLnB1c2goXG4gICAgICAgICAgdGhpcy5ncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGZyZWFrUmVzdWx0LCBpbWFnZURhdGEsIHhwcywgeXBzLCBpbWFnZUluZGV4ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGdhdXNzaWFuSW5kZXggPSB0aGlzLmNvbnN0YW50cy5nYXVzc2lhbkluZGV4O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmNvbnN0YW50cy53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY29uc3RhbnRzLmhlaWdodDtcblxuICAgICAgICAgICAgaWYgKGltYWdlSW5kZXhlc1t0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XSAhPT0gZ2F1c3NpYW5JbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm4gZnJlYWtSZXN1bHRbdGhpcy50aHJlYWQuel1bdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB4cCA9IHhwc1t0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgICAgICAgIGxldCB5cCA9IHlwc1t0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcblxuICAgICAgICAgICAgLy8gYmlsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgeHAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih4cCwgd2lkdGggLSAyKSk7XG4gICAgICAgICAgICB5cCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHlwLCBoZWlnaHQgLSAyKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHgwID0gTWF0aC5mbG9vcih4cCk7XG4gICAgICAgICAgICBjb25zdCB4MSA9IHgwICsgMTtcbiAgICAgICAgICAgIGNvbnN0IHkwID0gTWF0aC5mbG9vcih5cCk7XG4gICAgICAgICAgICBjb25zdCB5MSA9IHkwICsgMTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKHgxLXhwKSAqICh5MS15cCkgKiBpbWFnZURhdGFbeTAgKiB3aWR0aCArIHgwXVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoeHAteDApICogKHkxLXlwKSAqIGltYWdlRGF0YVt5MCAqIHdpZHRoICsgeDFdXG4gICAgICAgICAgICAgICAgICAgICAgICArICh4MS14cCkgKiAoeXAteTApICogaW1hZ2VEYXRhW3kxICogd2lkdGggKyB4MF1cbiAgICAgICAgICAgICAgICAgICAgICAgICsgKHhwLXgwKSAqICh5cC15MCkgKiBpbWFnZURhdGFbeTEgKiB3aWR0aCArIHgxXTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjb25zdGFudHM6IHtcbiAgICAgICAgICAgICAgZ2F1c3NpYW5JbmRleDogaSxcbiAgICAgICAgICAgICAgd2lkdGg6IHB5cmFtaWRJbWFnZXNbaV0ud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogcHlyYW1pZEltYWdlc1tpXS5oZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvdXRwdXQ6IFtGUkVBS1BPSU5UUy5sZW5ndGgsIE1BWF9GRUFUVVJFU19QRVJfQlVDS0VULCBOVU1fQlVDS0VUU10sXG4gICAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9XG4gICAgICB0aGlzLmtlcm5lbHMucHVzaChzdWJrZXJuZWxzKTtcbiAgICB9XG4gICAgY29uc3Qgc3Via2VybmVscyA9IHRoaXMua2VybmVsc1t0aGlzLmtlcm5lbEluZGV4KytdO1xuXG4gICAgLy8gY29tcHV0ZSB0aGUgbG9jYXRpb25zIG9mIGFsbCBmcmVhayBwb2ludHNcbiAgICBjb25zdCByZXN1bHQgPSBzdWJrZXJuZWxzWzBdKHBydW5lZEV4dHJlbWFzLCBwcnVuZWRFeHRyZW1hc0FuZ2xlcywgRlJFQUtQT0lOVFMpO1xuICAgIGNvbnN0IGltYWdlSW5kZXhlcyA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgY29uc3QgeHBzID0gcmVzdWx0LnNhdmVYcDtcbiAgICBjb25zdCB5cHMgPSByZXN1bHQuc2F2ZVlwO1xuXG4gICAgLy8gY29tcHV0ZSB0aGUgaW50ZXJwb2xhdGVkIHZhbHVlcyBvZiBlYWNoIGZyZWFrIGNvb3JkaW5hdGVzICh0aGlzIHZhbHVlcyBpcyB1c2VkIHRvIGJ1aWxkIHRoZSBmcmVhayBkZXNjcmlwdG9ycylcbiAgICBsZXQgZnJlYWtSZXN1bHQgPSBzdWJrZXJuZWxzWzFdKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBweXJhbWlkSW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmcmVha1Jlc3VsdCA9IHN1Ymtlcm5lbHNbaSsyXShmcmVha1Jlc3VsdCwgcHlyYW1pZEltYWdlc1tpXS5kYXRhLCB4cHMsIHlwcywgaW1hZ2VJbmRleGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyZWFrUmVzdWx0O1xuICB9XG5cbiAgX2J1aWxkRXh0cmVtYXMoaW1hZ2UwLCBpbWFnZTEsIGltYWdlMiwgb2N0YXZlLCBzY2FsZSwgc3RhcnRJLCBzdGFydEosIGVuZEksIGVuZEopIHtcbiAgICBjb25zdCBvcmlnaW5hbFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBvcmlnaW5hbEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IGRvZ051bVNjYWxlc1Blck9jdGF2ZXMgPSBQWVJBTUlEX05VTV9TQ0FMRVNfUEVSX09DVEFWRVMgLSAxO1xuXG4gICAgaWYgKHRoaXMua2VybmVsSW5kZXggPT09IHRoaXMua2VybmVscy5sZW5ndGgpIHtcbiAgICAgIHRoaXMua2VybmVscy5wdXNoKFxuICAgICAgICAvLyByZXR1cm5cbiAgICAgICAgLy8gIDEuIHNjb3JlOiBob3cgc3Ryb25nIGlzIHRoZSBleHRyZW1hLiAodGhlIGxhcmdlciB0aGUgZGlmZmVyZW5jZSBvZiBnYXVzc2lhbiB2YWx1ZSwgdGhlIHN0cm9uZ2VyKVxuICAgICAgICAvLyAgICAgIHNjb3JlIGNhbiBiZSBwb3NpdGl2ZSAobWF4aW1hKSBvciBuZWdhdGl2ZSAobWluaW1hKVxuICAgICAgICAvLyAgMi4geCwgeTogdGhlIGVmZmVjdGl2ZSB4LCB5IGNvb3JkaW5hdGUgaW4gdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgICAgIC8vICAzLiBzaWdtYTogdGhlIGVmZmVjdGl2ZSBzaWdtYSBpbiB0aGUgb3JpZ2luYWwgaW1hZ2UgKEknbSBub3Qgc3VyZSB3aGF0IHNpZ21hIGlzLiBhbnkgZWR1Y2F0aW9uYWwgcmVmZXJlbmNlPylcbiAgICAgICAgdGhpcy5ncHUuY3JlYXRlS2VybmVsTWFwKHtcbiAgICAgICAgICBzYXZlU2lnbWE6IGZ1bmN0aW9uKGEpIHtyZXR1cm4gYTt9LFxuICAgICAgICAgIHNhdmVYOiBmdW5jdGlvbihhKSB7cmV0dXJuIGE7fSxcbiAgICAgICAgICBzYXZlWTogZnVuY3Rpb24oYSkge3JldHVybiBhO31cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oZGF0YTAsIGRhdGExLCBkYXRhMiwgc3RhcnRJLCBzdGFydEosIGVuZEksIGVuZEopIHtcbiAgICAgICAgICBjb25zdCBMQVBMQUNJQU5fU1FSX1RIUkVTSE9MRCA9IHRoaXMuY29uc3RhbnRzLkxBUExBQ0lBTl9TUVJfVEhSRVNIT0xEO1xuICAgICAgICAgIGNvbnN0IE1BWF9TVUJQSVhFTF9ESVNUQU5DRV9TUVIgPSB0aGlzLmNvbnN0YW50cy5NQVhfU1VCUElYRUxfRElTVEFOQ0VfU1FSO1xuICAgICAgICAgIGNvbnN0IEVER0VfSEVTU0lBTl9USFJFU0hPTEQgPSB0aGlzLmNvbnN0YW50cy5FREdFX0hFU1NJQU5fVEhSRVNIT0xEO1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsV2lkdGggPSB0aGlzLmNvbnN0YW50cy5vcmlnaW5hbFdpZHRoO1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSGVpZ2h0ID0gdGhpcy5jb25zdGFudHMub3JpZ2luYWxIZWlnaHQ7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmNvbnN0YW50cy53aWR0aDtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmNvbnN0YW50cy5oZWlnaHQ7XG4gICAgICAgICAgY29uc3Qgb2N0YXZlID0gdGhpcy5jb25zdGFudHMub2N0YXZlO1xuICAgICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5jb25zdGFudHMuc2NhbGU7XG4gICAgICAgICAgY29uc3QgZG9nTnVtU2NhbGVzUGVyT2N0YXZlcyA9IHRoaXMuY29uc3RhbnRzLmRvZ051bVNjYWxlc1Blck9jdGF2ZXM7XG5cbiAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLnRocmVhZC54O1xuICAgICAgICAgIGNvbnN0IHBvc0kgPSBwb3MgJSB3aWR0aDtcbiAgICAgICAgICBjb25zdCBwb3NKID0gTWF0aC5mbG9vcihwb3MgLyB3aWR0aCk7XG4gICAgICAgICAgaWYgKHBvc0kgPCBzdGFydEkgfHwgcG9zSSA+IGVuZEkgfHwgcG9zSiA8IHN0YXJ0SiB8fCBwb3NKID4gZW5kSikgcmV0dXJuIDA7XG5cbiAgICAgICAgICBjb25zdCB2ID0gZGF0YTFbcG9zXTtcbiAgICAgICAgICBpZiAodiAqIHYgPCBMQVBMQUNJQU5fU1FSX1RIUkVTSE9MRCkgcmV0dXJuIDA7XG5cbiAgICAgICAgICBsZXQgaXNNYXggPSB0cnVlO1xuICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgOTsgZCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gZCAlIDM7XG4gICAgICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihkIC8gMyk7XG4gICAgICAgICAgICBjb25zdCBwb3MyID0gcG9zICsgKGotMSkgKiB3aWR0aCArIChpLTEpO1xuICAgICAgICAgICAgaWYgKGRhdGExW3Bvc10gPD0gZGF0YTBbcG9zMl0pIHtpc01heCA9IGZhbHNlOyBicmVhazt9O1xuICAgICAgICAgICAgaWYgKGRhdGExW3Bvc10gPD0gZGF0YTJbcG9zMl0pIHtpc01heCA9IGZhbHNlOyBicmVhazt9O1xuICAgICAgICAgICAgaWYgKHBvcyAhPT0gcG9zMiAmJiBkYXRhMVtwb3NdIDw9IGRhdGExW3BvczJdKSB7aXNNYXggPSBmYWxzZTsgYnJlYWs7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgaXNNaW4gPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIWlzTWF4KSB7XG4gICAgICAgICAgICBpc01pbiA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IDk7IGQrKykge1xuICAgICAgICAgICAgICBjb25zdCBpID0gZCAlIDM7XG4gICAgICAgICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKGQgLyAzKTtcbiAgICAgICAgICAgICAgY29uc3QgcG9zMiA9IHBvcyArIChqLTEpICogd2lkdGggKyAoaS0xKTtcbiAgICAgICAgICAgICAgaWYgKGRhdGExW3Bvc10gPj0gZGF0YTBbcG9zMl0pIHtpc01pbiA9IGZhbHNlOyBicmVha307XG4gICAgICAgICAgICAgIGlmIChkYXRhMVtwb3NdID49IGRhdGEyW3BvczJdKSB7aXNNaW4gPSBmYWxzZTsgYnJlYWt9O1xuICAgICAgICAgICAgICBpZiAocG9zICE9PSBwb3MyICYmIGRhdGExW3Bvc10gPj0gZGF0YTFbcG9zMl0pIHtpc01pbiA9IGZhbHNlOyBicmVha307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNNYXggJiYgIWlzTWluKSByZXR1cm4gMDtcblxuICAgICAgICAgIC8vIFN0ZXAgMjogc3ViLXBpeGVsIHJlZmluZW1lbnQgKEknbSBub3Qgc3VyZSB3aGF0IHRoYXQgbWVhbnMuIEFueSBlZHVjYXRpb25hbCByZWY/KVxuXG4gICAgICAgICAgLy8gQ29tcHV0ZSBzcGF0aWFsIGRlcml2YXRpdmVzXG4gICAgICAgICAgY29uc3QgZHggPSAwLjUgKiAoZGF0YTFbcG9zICsgMV0gLSBkYXRhMVtwb3MgLSAxXSk7XG4gICAgICAgICAgY29uc3QgZHkgPSAwLjUgKiAoZGF0YTFbcG9zICsgd2lkdGhdIC0gZGF0YTFbcG9zIC0gd2lkdGhdKTtcbiAgICAgICAgICBjb25zdCBkeHggPSBkYXRhMVtwb3MgKyAxXSArIGRhdGExW3BvcyAtIDFdIC0gMiAqIGRhdGExW3Bvc107XG4gICAgICAgICAgY29uc3QgZHl5ID0gZGF0YTFbcG9zICsgd2lkdGhdICsgZGF0YTFbcG9zIC0gd2lkdGhdIC0gMiAqIGRhdGExW3Bvc107XG4gICAgICAgICAgY29uc3QgZHh5ID0gMC4yNSAqIChkYXRhMVtwb3MgLSB3aWR0aCAtMV0gKyBkYXRhMVtwb3MgKyB3aWR0aCArIDFdIC0gZGF0YTFbcG9zIC0gd2lkdGggKzFdIC0gZGF0YTFbcG9zICsgd2lkdGggLSAxXSk7XG5cbiAgICAgICAgICAvLyBDb21wdXRlIHNjYWxlIGRlcml2YXRlc1xuICAgICAgICAgIGNvbnN0IGRzID0gMC41ICogKGRhdGEyW3Bvc10gLSBkYXRhMFtwb3NdKTtcbiAgICAgICAgICBjb25zdCBkc3MgPSBkYXRhMltwb3NdICsgZGF0YTBbcG9zXSAtIDIgKiBkYXRhMVtwb3NdO1xuICAgICAgICAgIGNvbnN0IGR4cyA9IDAuMjUgKiAoKGRhdGEwW3Bvcy0xXSAtIGRhdGEwW3BvcysxXSkgKyAoLWRhdGEyW3Bvcy0xXSArIGRhdGEyW3BvcysxXSkpO1xuICAgICAgICAgIGNvbnN0IGR5cyA9IDAuMjUgKiAoKGRhdGEwW3Bvcy13aWR0aF0gLSBkYXRhMFtwb3Mrd2lkdGhdKSArICgtZGF0YTJbcG9zLXdpZHRoXSArIGRhdGEyW3Bvcyt3aWR0aF0pKTtcblxuICAgICAgICAgIC8vIFNvbHZlIEhlc3NpYW4gQSAqIHUgPSBiO1xuICAgICAgICAgIGNvbnN0IEEwID0gZHh4O1xuICAgICAgICAgIGNvbnN0IEExID0gZHh5O1xuICAgICAgICAgIGNvbnN0IEEyID0gZHhzO1xuICAgICAgICAgIGNvbnN0IEEzID0gZHh5O1xuICAgICAgICAgIGNvbnN0IEE0ID0gZHl5O1xuICAgICAgICAgIGNvbnN0IEE1ID0gZHlzO1xuICAgICAgICAgIGNvbnN0IEE2ID0gZHhzO1xuICAgICAgICAgIGNvbnN0IEE3ID0gZHlzO1xuICAgICAgICAgIGNvbnN0IEE4ID0gZHNzO1xuICAgICAgICAgIGNvbnN0IGIwID0gLWR4O1xuICAgICAgICAgIGNvbnN0IGIxID0gLWR5O1xuICAgICAgICAgIGNvbnN0IGIyID0gLWRzO1xuXG4gICAgICAgICAgY29uc3QgZGV0QSA9IEEwICogQTQgKiBBOFxuICAgICAgICAgICAgICAgICAgICAtIEEwICogQTUgKiBBNVxuICAgICAgICAgICAgICAgICAgICAtIEE0ICogQTIgKiBBMlxuICAgICAgICAgICAgICAgICAgICAtIEE4ICogQTEgKiBBMVxuICAgICAgICAgICAgICAgICAgICArIDIgKiBBMSAqIEEyICogQTU7XG5cbiAgICAgICAgICBpZiAoIE1hdGguYWJzKGRldEEpIDwgMC4wMDAwMDAxKSByZXR1cm4gMDsgLy8gZGV0ZXJtaW5hbnQgdW5kZWZpbmVkLiBubyBzb2x1dGlvblxuXG4gICAgICAgICAgLy8gQiA9IGludmVyc2Ugb2YgQVxuICAgICAgICAgIGNvbnN0IEIwID0gQTQgKiBBOCAtIEE1ICogQTc7XG4gICAgICAgICAgY29uc3QgQjEgPSBBMiAqIEE3IC0gQTEgKiBBODtcbiAgICAgICAgICBjb25zdCBCMiA9IEExICogQTUgLSBBMiAqIEE0O1xuICAgICAgICAgIGNvbnN0IEIzID0gQjE7XG4gICAgICAgICAgY29uc3QgQjQgPSBBMCAqIEE4IC0gQTIgKiBBNjtcbiAgICAgICAgICBjb25zdCBCNSA9IEEyICogQTMgLSBBMCAqIEE1O1xuICAgICAgICAgIGNvbnN0IEI2ID0gQjI7XG4gICAgICAgICAgY29uc3QgQjcgPSBCNTtcbiAgICAgICAgICBjb25zdCBCOCA9IEEwICogQTQgLSBBMSAqIEEzO1xuXG4gICAgICAgICAgY29uc3QgdTAgPSAoQjAgKiBiMCArIEIxICogYjEgKyBCMiAqIGIyKSAvIGRldEE7XG4gICAgICAgICAgY29uc3QgdTEgPSAoQjMgKiBiMCArIEI0ICogYjEgKyBCNSAqIGIyKSAvIGRldEE7XG4gICAgICAgICAgY29uc3QgdTIgPSAoQjYgKiBiMCArIEI3ICogYjEgKyBCOCAqIGIyKSAvIGRldEE7XG5cbiAgICAgICAgICAvLyBJZiBwb2ludHMgbW92ZSB0b28gbXVjaCBpbiB0aGUgc3ViLXBpeGVsIHVwZGF0ZSwgdGhlbiB0aGUgcG9pbnQgcHJvYmFibHkgdW5zdGFibGUuXG4gICAgICAgICAgaWYgKHUwICogdTAgKyB1MSAqIHUxID4gTUFYX1NVQlBJWEVMX0RJU1RBTkNFX1NRUikgcmV0dXJuIDA7XG5cbiAgICAgICAgICAvLyBjb21wdXRlIGVkZ2Ugc2NvcmVcbiAgICAgICAgICBjb25zdCBkZXQgPSAoZHh4ICogZHl5KSAtIChkeHkgKiBkeHkpO1xuICAgICAgICAgIGlmIChkZXQgPT09IDApIHJldHVybiAwO1xuXG4gICAgICAgICAgY29uc3QgZWRnZVNjb3JlID0gKGR4eCArIGR5eSkgKiAoZHh4ICsgZHl5KSAvIGRldDtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoZWRnZVNjb3JlKSA+PSBFREdFX0hFU1NJQU5fVEhSRVNIT0xEICkgcmV0dXJuIDA7XG5cbiAgICAgICAgICBjb25zdCBzY29yZSA9IHYgLSAoYjAgKiB1MCArIGIxICogdTEgKyBiMiAqIHUyKTtcbiAgICAgICAgICBpZiAoc2NvcmUgKiBzY29yZSA8IExBUExBQ0lBTl9TUVJfVEhSRVNIT0xEKSByZXR1cm4gMDtcblxuICAgICAgICAgIC8vIG9yaWdpbmFsIHggPSB4KjJebiArIDJeKG4tMSkgLSAwLjVcbiAgICAgICAgICAvLyBvcmlnaW5hbCB5ID0geSoyXm4gKyAyXihuLTEpIC0gMC41XG4gICAgICAgICAgbGV0IG9yaWdpbmFsWCA9IHBvc0kgKiBNYXRoLnBvdygyLCBvY3RhdmUpICsgTWF0aC5wb3coMiwgb2N0YXZlLTEpIC0gMC41O1xuICAgICAgICAgIGxldCBvcmlnaW5hbFkgPSBwb3NKICogTWF0aC5wb3coMiwgb2N0YXZlKSArIE1hdGgucG93KDIsIG9jdGF2ZS0xKSAtIDAuNTtcbiAgICAgICAgICBvcmlnaW5hbFggPSBvcmlnaW5hbFggKyB1MCAqIE1hdGgucG93KDIsIG9jdGF2ZSk7XG4gICAgICAgICAgb3JpZ2luYWxZID0gb3JpZ2luYWxZICsgdTEgKiBNYXRoLnBvdygyLCBvY3RhdmUpO1xuICAgICAgICAgIGlmIChvcmlnaW5hbFggPCAwIHx8IG9yaWdpbmFsWCA+PSBvcmlnaW5hbFdpZHRoIHx8IG9yaWdpbmFsWSA8IDAgfHwgb3JpZ2luYWxZID49IG9yaWdpbmFsSGVpZ2h0KSByZXR1cm4gMDtcblxuICAgICAgICAgIGNvbnN0IHNwU2NhbGUgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBzY2FsZSArIHUyKSwgZG9nTnVtU2NhbGVzUGVyT2N0YXZlcyk7XG4gICAgICAgICAgY29uc3QgbUsgPSBNYXRoLnBvdygyLCAxLjAgLyBkb2dOdW1TY2FsZXNQZXJPY3RhdmVzKTtcbiAgICAgICAgICBjb25zdCBuZXdTaWdtYSA9IE1hdGgucG93KG1LLCBzcFNjYWxlKSAqICgxIDw8IG9jdGF2ZSk7XG5cbiAgICAgICAgICBzYXZlU2lnbWEobmV3U2lnbWEpO1xuICAgICAgICAgIHNhdmVYKG9yaWdpbmFsWCk7XG4gICAgICAgICAgc2F2ZVkob3JpZ2luYWxZKTtcbiAgICAgICAgICByZXR1cm4gc2NvcmU7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjb25zdGFudHM6IHtcbiAgICAgICAgICAgIExBUExBQ0lBTl9TUVJfVEhSRVNIT0xEOiBMQVBMQUNJQU5fU1FSX1RIUkVTSE9MRCxcbiAgICAgICAgICAgIE1BWF9TVUJQSVhFTF9ESVNUQU5DRV9TUVI6IE1BWF9TVUJQSVhFTF9ESVNUQU5DRV9TUVIsXG4gICAgICAgICAgICBFREdFX0hFU1NJQU5fVEhSRVNIT0xEOiBFREdFX0hFU1NJQU5fVEhSRVNIT0xELFxuICAgICAgICAgICAgb3JpZ2luYWxXaWR0aDogb3JpZ2luYWxXaWR0aCxcbiAgICAgICAgICAgIG9yaWdpbmFsSGVpZ2h0OiBvcmlnaW5hbEhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBpbWFnZTEud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGltYWdlMS5oZWlnaHQsXG4gICAgICAgICAgICBvY3RhdmU6IG9jdGF2ZSxcbiAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgIGRvZ051bVNjYWxlc1Blck9jdGF2ZXM6IGRvZ051bVNjYWxlc1Blck9jdGF2ZXMsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvdXRwdXQ6IFtpbWFnZTEud2lkdGggKiBpbWFnZTEuaGVpZ2h0XSxcbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVsc1t0aGlzLmtlcm5lbEluZGV4KytdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbChpbWFnZTAuZGF0YSwgaW1hZ2UxLmRhdGEsIGltYWdlMi5kYXRhLCBzdGFydEksIHN0YXJ0SiwgZW5kSSwgZW5kSik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF9kb3duc2FtcGxlQmlsaW5lYXIoaW1hZ2UpIHtcbiAgICBjb25zdCBkc3RXaWR0aCA9IE1hdGguZmxvb3IoaW1hZ2Uud2lkdGggLyAyKTtcbiAgICBjb25zdCBkc3RIZWlnaHQgPSBNYXRoLmZsb29yKGltYWdlLmhlaWdodCAvIDIpO1xuXG4gICAgaWYgKHRoaXMua2VybmVsSW5kZXggPT09IHRoaXMua2VybmVscy5sZW5ndGgpIHtcbiAgICAgIHRoaXMua2VybmVscy5wdXNoKFxuICAgICAgICB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jb25zdGFudHMud2lkdGg7XG4gICAgICAgICAgY29uc3Qgc3JjV2lkdGggPSB0aGlzLmNvbnN0YW50cy5zcmNXaWR0aDtcbiAgICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcih0aGlzLnRocmVhZC54IC8gd2lkdGgpO1xuICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLnRocmVhZC54ICUgd2lkdGg7XG4gICAgICAgICAgY29uc3Qgc3JjUG9zID0gaiAqIDIgKiBzcmNXaWR0aCArIGkgKiAyO1xuICAgICAgICAgIGNvbnN0IHYgPSAoZGF0YVtzcmNQb3NdICsgZGF0YVtzcmNQb3MrMV0gKyBkYXRhW3NyY1BvcytzcmNXaWR0aF0gKyBkYXRhW3NyY1BvcytzcmNXaWR0aCsxXSkgKiAwLjI1O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9LCB7XG4gICAgICAgICAgY29uc3RhbnRzOiB7c3JjV2lkdGg6IGltYWdlLndpZHRoLCB3aWR0aDogZHN0V2lkdGh9LFxuICAgICAgICAgIG91dHB1dDogW2RzdFdpZHRoICogZHN0SGVpZ2h0XSxcbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVsc1t0aGlzLmtlcm5lbEluZGV4KytdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbChpbWFnZS5kYXRhKTtcbiAgICByZXR1cm4ge3dpZHRoOiBkc3RXaWR0aCwgaGVpZ2h0OiBkc3RIZWlnaHQsIGRhdGE6IHJlc3VsdH07XG4gIH1cblxuICBfdXBzYW1wbGVCaWxpbmVhcihpbWFnZSwgcGFkT25lV2lkdGgsIHBhZE9uZUhlaWdodCkge1xuICAgIGNvbnN0IGRzdFdpZHRoID0gaW1hZ2Uud2lkdGggKiAyICsgKHBhZE9uZVdpZHRoPzE6MCk7XG4gICAgY29uc3QgZHN0SGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0ICogMiArIChwYWRPbmVIZWlnaHQ/MTowKTtcblxuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmtlcm5lbHMucHVzaChcbiAgICAgICAgdGhpcy5ncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuY29uc3RhbnRzLndpZHRoO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY29uc3RhbnRzLmhlaWdodDtcblxuICAgICAgICAgIGNvbnN0IHNyY1dpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAvIDIpO1xuICAgICAgICAgIGNvbnN0IHNyY0hlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcih0aGlzLnRocmVhZC54IC8gd2lkdGgpO1xuICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLnRocmVhZC54ICUgd2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2kgPSAwLjUgKiBpIC0gMC4yNTtcbiAgICAgICAgICBjb25zdCBzaiA9IDAuNSAqIGogLSAwLjI1O1xuICAgICAgICAgIGNvbnN0IHNpMCA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3Ioc2kpKTtcbiAgICAgICAgICBjb25zdCBzaTEgPSBNYXRoLm1pbihNYXRoLmNlaWwoc2kpLCBzcmNXaWR0aC0xKTtcbiAgICAgICAgICBjb25zdCBzajAgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHNqKSk7XG4gICAgICAgICAgY29uc3Qgc2oxID0gTWF0aC5taW4oTWF0aC5jZWlsKHNqKSwgc3JjSGVpZ2h0LTEpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gKHNpMSAtIHNpKSAqIChzajEgLSBzaikgKiBkYXRhWyBzajAgKiB3aWR0aCArIHNpMCBdICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzaTEgLSBzaSkgKiAoc2ogLSBzajApICogZGF0YVsgc2oxICogd2lkdGggKyBzaTAgXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2kgLSBzaTApICogKHNqMSAtIHNqKSAqIGRhdGFbIHNqMCAqIHdpZHRoICsgc2kxIF0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNpIC0gc2kwKSAqIChzaiAtIHNqMCkgKiBkYXRhWyBzajEgKiB3aWR0aCArIHNpMSBdO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNvbnN0YW50czoge3dpZHRoOiBkc3RXaWR0aCwgaGVpZ2h0OiBkc3RIZWlnaHR9LFxuICAgICAgICAgIG91dHB1dDogW2RzdFdpZHRoICogZHN0SGVpZ2h0XSxcbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVsc1t0aGlzLmtlcm5lbEluZGV4KytdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbChpbWFnZS5kYXRhKTtcbiAgICByZXR1cm4ge3dpZHRoOiBkc3RXaWR0aCwgaGVpZ2h0OiBkc3RIZWlnaHQsIGRhdGE6IHJlc3VsdH07XG4gIH1cblxuICAvLyA0dGggb3JkZXIgYmlub21haWwgZmlsdGVyXG4gIF9hcHBseUZpbHRlcihpbWFnZSkge1xuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBmMSA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jb25zdGFudHMud2lkdGg7XG4gICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKHRoaXMudGhyZWFkLnggLyB3aWR0aCk7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLnRocmVhZC54ICUgd2lkdGg7XG4gICAgICAgIGNvbnN0IGpvZmZzZXQgPSBqICogd2lkdGg7XG4gICAgICAgIGNvbnN0IHYgPSBkYXRhW2pvZmZzZXQgKyBNYXRoLm1heChpLTIsMCldICtcbiAgICAgICAgICAgICAgICAgIGRhdGFbam9mZnNldCArIE1hdGgubWF4KGktMSwwKV0gKiA0ICtcbiAgICAgICAgICAgICAgICAgIGRhdGFbam9mZnNldCArIGldICogNiArXG4gICAgICAgICAgICAgICAgICBkYXRhW2pvZmZzZXQgKyBNYXRoLm1pbihpKzEsd2lkdGgtMSldICogNCArXG4gICAgICAgICAgICAgICAgICBkYXRhW2pvZmZzZXQgKyBNYXRoLm1pbihpKzIsd2lkdGgtMSldO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0sIHtcbiAgICAgICAgY29uc3RhbnRzOiB7d2lkdGg6IGltYWdlLndpZHRofSxcbiAgICAgICAgb3V0cHV0OiBbaW1hZ2Uud2lkdGggKiBpbWFnZS5oZWlnaHRdLFxuICAgICAgICBwaXBlbGluZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGYyID0gdGhpcy5ncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmNvbnN0YW50cy53aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jb25zdGFudHMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcih0aGlzLnRocmVhZC54IC8gd2lkdGgpO1xuICAgICAgICBjb25zdCBpID0gdGhpcy50aHJlYWQueCAlIHdpZHRoO1xuICAgICAgICBjb25zdCB2ID0gZGF0YVtNYXRoLm1heChqLTIsMCkgKiB3aWR0aCArIGldICtcbiAgICAgICAgICAgICAgICAgIGRhdGFbTWF0aC5tYXgoai0xLDApICogd2lkdGggKyBpXSAqIDQgK1xuICAgICAgICAgICAgICAgICAgZGF0YVtqICogd2lkdGggKyBpXSAqIDYgK1xuICAgICAgICAgICAgICAgICAgZGF0YVtNYXRoLm1pbihqKzEsaGVpZ2h0LTEpICogd2lkdGggKyBpXSAqIDQgK1xuICAgICAgICAgICAgICAgICAgZGF0YVtNYXRoLm1pbihqKzIsaGVpZ2h0LTEpICogd2lkdGggKyBpXTtcblxuICAgICAgICByZXR1cm4gdiAvIDI1NjsgLy8gYWx0b2dldGhlciAoMSs0KzYrNCsxKSAqICgxKzQrNis0KzEpIG51bWJlcnNcbiAgICAgIH0sIHtcbiAgICAgICAgY29uc3RhbnRzOiB7d2lkdGg6IGltYWdlLndpZHRoLCBoZWlnaHQ6IGltYWdlLmhlaWdodH0sXG4gICAgICAgIG91dHB1dDogW2ltYWdlLndpZHRoICogaW1hZ2UuaGVpZ2h0XSxcbiAgICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICB9KTtcbiAgICAgIHRoaXMua2VybmVscy5wdXNoKHtmMSwgZjJ9KTtcbiAgICB9XG4gICAgY29uc3Qge2YxLCBmMn0gPSB0aGlzLmtlcm5lbHNbdGhpcy5rZXJuZWxJbmRleCsrXTtcbiAgICBjb25zdCByZXN1bHQgPSBmMihmMShpbWFnZS5kYXRhKSk7XG4gICAgcmV0dXJuIHt3aWR0aDogaW1hZ2Uud2lkdGgsIGhlaWdodDogaW1hZ2UuaGVpZ2h0LCBkYXRhOiByZXN1bHR9O1xuICB9XG5cbiAgX2RpZmZlcmVuY2VJbWFnZUJpbm9taWFsKGltYWdlMSwgaW1hZ2UyKSB7XG4gICAgaWYgKHRoaXMua2VybmVsSW5kZXggPT09IHRoaXMua2VybmVscy5sZW5ndGgpIHtcbiAgICAgIHRoaXMua2VybmVscy5wdXNoKFxuICAgICAgICB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oZGF0YTEsIGRhdGEyKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGExW3RoaXMudGhyZWFkLnhdIC0gZGF0YTJbdGhpcy50aHJlYWQueF07XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvdXRwdXQ6IFtpbWFnZTEud2lkdGggKiBpbWFnZTEuaGVpZ2h0XSxcbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVsc1t0aGlzLmtlcm5lbEluZGV4KytdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbChpbWFnZTEuZGF0YSwgaW1hZ2UyLmRhdGEpO1xuICAgIHJldHVybiB7d2lkdGg6IGltYWdlMS53aWR0aCwgaGVpZ2h0OiBpbWFnZTEuaGVpZ2h0LCBkYXRhOiByZXN1bHR9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBEZXRlY3RvclxufTtcbiIsImNvbnN0IHtyZXNpemV9ID0gcmVxdWlyZShcIi4vdXRpbHMvaW1hZ2VzLmpzXCIpO1xuXG5jb25zdCBERUZBVUxUX0RQSSA9IDE7XG5jb25zdCBNSU5fSU1BR0VfUElYRUxfU0laRSA9IDI4O1xuXG4vLyByZXR1cm4gbGlzdCBvZiB7ZGF0YSwgd2lkdGgsIGhlaWdodCwgZHBpfVxuY29uc3QgYnVpbGRJbWFnZUxpc3QgPSAoaW5wdXRJbWFnZSkgPT4ge1xuICBjb25zdCBkcGkgPSBERUZBVUxUX0RQSTtcbiAgY29uc3QgbWluRHBpID0gTWF0aC5mbG9vcigxLjAgKiBNSU5fSU1BR0VfUElYRUxfU0laRSAvIE1hdGgubWluKGlucHV0SW1hZ2Uud2lkdGgsIGlucHV0SW1hZ2UuaGVpZ2h0KSAqIGRwaSAqIDEwMDApIC8gMTAwMDtcbiAgY29uc3QgZHBpTGlzdCA9IFtdO1xuXG4gIGxldCBjID0gbWluRHBpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGRwaUxpc3QucHVzaChjKTtcbiAgICBjICo9IE1hdGgucG93KDIuMCwgMS4wLzMuMCk7XG4gICAgYyA9IE1hdGguZnJvdW5kKGMpOyAvLyBjYW4gcmVtb3ZlIHRoaXMgbGluZSBpbiBwcm9kdWN0aW9uLiB0cnlpbmcgdG8gcmVwcm9kdWNlIHRoZSBzYW1lIHJlc3VsdCBhcyBhcnRvb2xraXQsIHdoaWNoIHVzZSBmbG9hdC5cbiAgICBpZiAoYyA+PSBkcGkgKiAwLjk1KSB7XG4gICAgICBjID0gZHBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGRwaUxpc3QucHVzaChjKTtcbiAgZHBpTGlzdC5yZXZlcnNlKCk7XG5cbiAgY29uc3QgaW1hZ2VMaXN0ID0gW107IC8vIGxpc3Qgb2Yge2RhdGE6IFt3aWR0aCB4IGhlaWdodF0sIHdpZHRoLCBoZWlnaHR9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZHBpTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHcgPSBpbnB1dEltYWdlLndpZHRoICogZHBpTGlzdFtpXSAvIGRwaTtcbiAgICBjb25zdCBoID0gaW5wdXRJbWFnZS5oZWlnaHQgKiBkcGlMaXN0W2ldIC8gZHBpO1xuICAgIGltYWdlTGlzdC5wdXNoKE9iamVjdC5hc3NpZ24ocmVzaXplKHtpbWFnZTogaW5wdXRJbWFnZSwgcmF0aW86IGRwaUxpc3RbaV0vZHBpfSksIHtkcGk6IGRwaUxpc3RbaV19KSk7XG4gIH1cblxuICByZXR1cm4gaW1hZ2VMaXN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGRJbWFnZUxpc3Rcbn1cbiIsIi8vIEZhc3QgY29tcHV0YXRpb24gb24gbnVtYmVyIG9mIGJpdCBzZXRzXG4vLyBSZWY6IGh0dHBzOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L35zZWFuZGVyL2JpdGhhY2tzLmh0bWwjQ291bnRCaXRzU2V0UGFyYWxsZWxcbmNvbnN0IGNvbXB1dGUgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCB7djEsIHYyfSA9IG9wdGlvbnM7XG4gIGxldCBkID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkrKykge1xuICAgIGxldCB4ID0gKHYxW2ldIF4gdjJbaV0pID4+PiAwO1xuICAgIGQgKz0gYml0Q291bnQoeCk7XG4gIH1cbiAgcmV0dXJuIGQ7XG59XG5cbmNvbnN0IGJpdENvdW50ID0gKHYpID0+IHtcbiAgdmFyIGMgPSB2IC0gKCh2ID4+IDEpICYgMHg1NTU1NTU1NSk7XG4gIGMgPSAoKGMgPj4gMikgJiAweDMzMzMzMzMzKSArIChjICYgMHgzMzMzMzMzMyk7XG4gIGMgPSAoKGMgPj4gNCkgKyBjKSAmIDB4MEYwRjBGMEY7XG4gIGMgPSAoKGMgPj4gOCkgKyBjKSAmIDB4MDBGRjAwRkY7XG4gIGMgPSAoKGMgPj4gMTYpICsgYykgJiAweDAwMDBGRkZGO1xuICByZXR1cm4gYztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXB1dGVcbn07XG4iLCJjb25zdCB7Y29tcHV0ZTogaGFtbWluZ0NvbXB1dGV9ID0gcmVxdWlyZSgnLi9oYW1taW5nLWRpc3RhbmNlLmpzJyk7XG5jb25zdCB7Y3JlYXRlUmFuZG9taXplcn0gPSByZXF1aXJlKCcuLi91dGlscy9yYW5kb21pemVyLmpzJyk7XG5cbmNvbnN0IE1JTl9GRUFUVVJFX1BFUl9OT0RFID0gMTY7XG5jb25zdCBOVU1fQVNTSUdOTUVOVF9IWVBPVEhFU0VTID0gIDEyODtcbmNvbnN0IE5VTV9DRU5URVJTID0gODtcblxuLy8ga21lZG9pZHMgY2x1c3RlcmluZyBvZiBwb2ludHMsIHdpdGggaGFtbWluZyBkaXN0YW5jZSBvZiBGUkVBSyBkZXNjcmlwdG9yXG4vL1xuLy8gbm9kZSA9IHtcbi8vICAgaXNMZWFmOiBib29sLFxuLy8gICBjaGlsZHJlbjogW10sIGxpc3Qgb2YgY2hpbGRyZW4gbm9kZVxuLy8gICBwb2ludEluZGV4ZXM6IFtdLCBsaXN0IG9mIGludCwgcG9pbnQgaW5kZXhlc1xuLy8gICBjZW50ZXJQb2ludEluZGV4OiBpbnRcbi8vIH1cbmNvbnN0IGJ1aWxkID0gKHtwb2ludHN9KSA9PiB7XG4gIGNvbnN0IHBvaW50SW5kZXhlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHBvaW50SW5kZXhlcy5wdXNoKGkpO1xuICB9XG5cbiAgY29uc3QgcmFuZG9taXplciA9IGNyZWF0ZVJhbmRvbWl6ZXIoKTtcblxuICBjb25zdCByb290Tm9kZSA9IF9idWlsZCh7cG9pbnRzOiBwb2ludHMsIHBvaW50SW5kZXhlczogcG9pbnRJbmRleGVzLCBjZW50ZXJQb2ludEluZGV4OiBudWxsLCByYW5kb21pemVyfSk7XG4gIHJldHVybiB7cm9vdE5vZGV9O1xufVxuXG4vLyByZWN1cnNpdmUgYnVpbGQgaGllcmFyY2h5IGNsdXN0ZXJzXG5jb25zdCBfYnVpbGQgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCB7cG9pbnRzLCBwb2ludEluZGV4ZXMsIGNlbnRlclBvaW50SW5kZXgsIHJhbmRvbWl6ZXJ9ID0gb3B0aW9ucztcblxuICBsZXQgaXNMZWFmID0gZmFsc2U7XG5cbiAgaWYgKHBvaW50SW5kZXhlcy5sZW5ndGggPD0gTlVNX0NFTlRFUlMgfHwgcG9pbnRJbmRleGVzLmxlbmd0aCA8PSBNSU5fRkVBVFVSRV9QRVJfTk9ERSkge1xuICAgIGlzTGVhZiA9IHRydWU7XG4gIH1cblxuICBjb25zdCBjbHVzdGVycyA9IHt9O1xuICBpZiAoIWlzTGVhZikge1xuICAgIC8vIGNvbXB1dGUgY2x1c3RlcnNcbiAgICBjb25zdCBhc3NpZ25tZW50ID0gX2NvbXB1dGVLTWVkb2lkcyh7cG9pbnRzLCBwb2ludEluZGV4ZXMsIHJhbmRvbWl6ZXJ9KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXNzaWdubWVudC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNsdXN0ZXJzW3BvaW50SW5kZXhlc1thc3NpZ25tZW50W2ldXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbHVzdGVyc1twb2ludEluZGV4ZXNbYXNzaWdubWVudFtpXV1dID0gW107XG4gICAgICB9XG4gICAgICBjbHVzdGVyc1twb2ludEluZGV4ZXNbYXNzaWdubWVudFtpXV1dLnB1c2gocG9pbnRJbmRleGVzW2ldKTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKGNsdXN0ZXJzKS5sZW5ndGggPT09IDEpIHtcbiAgICBpc0xlYWYgPSB0cnVlO1xuICB9XG5cbiAgY29uc3Qgbm9kZSA9IHtcbiAgICBjZW50ZXJQb2ludEluZGV4OiBjZW50ZXJQb2ludEluZGV4XG4gIH1cblxuICBpZiAoaXNMZWFmKSB7XG4gICAgbm9kZS5sZWFmID0gdHJ1ZTtcbiAgICBub2RlLnBvaW50SW5kZXhlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlLnBvaW50SW5kZXhlcy5wdXNoKHBvaW50SW5kZXhlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLy8gcmVjdXJzaXZlIGJ1aWxkIGNoaWxkcmVuXG4gIG5vZGUubGVhZiA9IGZhbHNlO1xuICBub2RlLmNoaWxkcmVuID0gW107XG5cbiAgT2JqZWN0LmtleXMoY2x1c3RlcnMpLmZvckVhY2goKGNlbnRlckluZGV4KSA9PiB7XG4gICAgbm9kZS5jaGlsZHJlbi5wdXNoKF9idWlsZCh7cG9pbnRzOiBwb2ludHMsIHBvaW50SW5kZXhlczogY2x1c3RlcnNbY2VudGVySW5kZXhdLCBjZW50ZXJQb2ludEluZGV4OiBjZW50ZXJJbmRleCwgcmFuZG9taXplcn0pKTtcbiAgfSk7XG4gIHJldHVybiBub2RlO1xufVxuXG5fY29tcHV0ZUtNZWRvaWRzID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3Qge3BvaW50cywgcG9pbnRJbmRleGVzLCByYW5kb21pemVyfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgcmFuZG9tUG9pbnRJbmRleGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmFuZG9tUG9pbnRJbmRleGVzLnB1c2goaSk7XG4gIH1cblxuICBsZXQgYmVzdFN1bUQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgbGV0IGJlc3RBc3NpZ25tZW50SW5kZXggPSAtMTtcblxuICBjb25zdCBhc3NpZ25tZW50cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IE5VTV9BU1NJR05NRU5UX0hZUE9USEVTRVM7IGkrKykge1xuICAgIHJhbmRvbWl6ZXIuYXJyYXlTaHVmZmxlKHthcnI6IHJhbmRvbVBvaW50SW5kZXhlcywgc2FtcGxlU2l6ZTogTlVNX0NFTlRFUlN9KTtcblxuICAgIGxldCBzdW1EID0gMDtcbiAgICBjb25zdCBhc3NpZ25tZW50ID0gW107XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb2ludEluZGV4ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxldCBiZXN0RCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBOVU1fQ0VOVEVSUzsgaysrKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlckluZGV4ID0gcG9pbnRJbmRleGVzW3JhbmRvbVBvaW50SW5kZXhlc1trXV07XG4gICAgICAgIGNvbnN0IGQgPSBoYW1taW5nQ29tcHV0ZSh7djE6IHBvaW50c1twb2ludEluZGV4ZXNbal1dLmRlc2NyaXB0b3JzLCB2MjogcG9pbnRzW2NlbnRlckluZGV4XS5kZXNjcmlwdG9yc30pO1xuICAgICAgICBpZiAoZCA8IGJlc3REKSB7XG4gICAgICAgICAgYXNzaWdubWVudFtqXSA9IHJhbmRvbVBvaW50SW5kZXhlc1trXTtcbiAgICAgICAgICBiZXN0RCA9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN1bUQgKz0gYmVzdEQ7XG4gICAgfVxuICAgIGFzc2lnbm1lbnRzLnB1c2goYXNzaWdubWVudCk7XG5cbiAgICBpZiAoc3VtRCA8IGJlc3RTdW1EKSB7XG4gICAgICBiZXN0U3VtRCA9IHN1bUQ7XG4gICAgICBiZXN0QXNzaWdubWVudEluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFzc2lnbm1lbnRzW2Jlc3RBc3NpZ25tZW50SW5kZXhdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGQsXG59O1xuXG4iLCJjb25zdCB7Q3Vtc3VtfSA9IHJlcXVpcmUoJy4uL3V0aWxzL2N1bXN1bScpO1xuXG5jb25zdCBTRUFSQ0hfU0laRTEgPSAxMDtcbmNvbnN0IFNFQVJDSF9TSVpFMiA9IDI7XG5cbmNvbnN0IFRFTVBMQVRFX1NJWkUgPSAyMiAvLyBERUZBVUxUXG4vL2NvbnN0IFRFTVBMQVRFX1NJWkUgPSA2O1xuY29uc3QgVEVNUExBVEVfU0RfVEhSRVNIID0gNS4wO1xuY29uc3QgTUFYX1NJTV9USFJFU0ggPSAwLjk1O1xuXG5jb25zdCBNQVhfVEhSRVNIID0gMC45O1xuY29uc3QgTUlOX1RIUkVTSCA9IDAuNTU7XG5jb25zdCBTRF9USFJFU0ggPSA4LjA7XG5jb25zdCBPQ0NVUEFOQ1lfU0laRSA9IDI0ICogMiAvIDM7XG5cbi8qXG4gKiBJbnB1dCBpbWFnZSBpcyBpbiBncmV5IGZvcm1hdC4gdGhlIGltYWdlRGF0YSBhcnJheSBzaXplIGlzIHdpZHRoICogaGVpZ2h0LiB2YWx1ZSByYW5nZSBmcm9tIDAtMjU1XG4gKiBwaXhlbCB2YWx1ZSBhdCByb3cgciBhbmQgYyA9IGltYWdlRGF0YVtyICogd2lkdGggKyBjXVxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gb3B0aW9ucy5pbWFnZURhdGFcbiAqIEBwYXJhbSB7aW50fSBvcHRpb25zLndpZHRoIGltYWdlIHdpZHRoXG4gKiBAcGFyYW0ge2ludH0gb3B0aW9ucy5oZWlnaHQgaW1hZ2UgaGVpZ2h0XG4gKi9cbmNvbnN0IGV4dHJhY3QgPSAoaW1hZ2UpID0+IHtcbiAgY29uc3Qge2RhdGE6IGltYWdlRGF0YSwgd2lkdGgsIGhlaWdodCwgZHBpfSA9IGltYWdlO1xuXG4gIC8vIFN0ZXAgMSAtIGZpbHRlciBvdXQgaW50ZXJlc3RpbmcgcG9pbnRzLiBJbnRlcmVzdGluZyBwb2ludHMgaGF2ZSBzdHJvbmcgcGl4ZWwgdmFsdWUgY2hhbmdlZCBhY3Jvc3MgbmVpZ2hib3Vyc1xuICBjb25zdCBpc1BpeGVsU2VsZWN0ZWQgPSBbd2lkdGggKiBoZWlnaHRdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlzUGl4ZWxTZWxlY3RlZC5sZW5ndGg7IGkrKykgaXNQaXhlbFNlbGVjdGVkW2ldID0gZmFsc2U7XG5cbiAgLy8gU3RlcCAxLjEgY29uc2lkZXIgYSBwaXhlbCBhdCBwb3NpdGlvbiAoeCwgeSkuIGNvbXB1dGU6XG4gIC8vICAgZHggPSAoKGRhdGFbeCsxLCB5LTFdIC0gZGF0YVt4LTEsIHktMV0pICsgKGRhdGFbeCsxLCB5XSAtIGRhdGFbeC0xLCB5XSkgKyAoZGF0YVt4KzEsIHkrMV0gLSBkYXRhW3gtMSwgeS0xXSkpIC8gMjU2IC8gM1xuICAvLyAgIGR5ID0gKChkYXRhW3grMSwgeSsxXSAtIGRhdGFbeCsxLCB5LTFdKSArIChkYXRhW3gsIHkrMV0gLSBkYXRhW3gsIHktMV0pICsgKGRhdGFbeC0xLCB5KzFdIC0gZGF0YVt4LTEsIHktMV0pKSAvIDI1NiAvIDNcbiAgLy8gICBkVmFsdWUgPSAgc3FydChkeF4yICsgZHleMikgLyAyO1xuICBjb25zdCBkVmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KGltYWdlRGF0YS5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICBkVmFsdWVbaV0gPSAtMTtcbiAgICBkVmFsdWVbd2lkdGggKiAoaGVpZ2h0LTEpICsgaV0gPSAtMTtcbiAgfVxuICBmb3IgKGxldCBqID0gMDsgaiA8IGhlaWdodDsgaisrKSB7XG4gICAgZFZhbHVlW2oqd2lkdGhdID0gLTE7XG4gICAgZFZhbHVlW2oqd2lkdGggKyB3aWR0aC0xXSA9IC0xO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aWR0aC0xOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8IGhlaWdodC0xOyBqKyspIHtcbiAgICAgIGxldCBwb3MgPSBpICsgd2lkdGggKiBqO1xuXG4gICAgICBsZXQgZHggPSAwLjA7XG4gICAgICBsZXQgZHkgPSAwLjA7XG4gICAgICBmb3IgKGxldCBrID0gLTE7IGsgPD0gMTsgaysrKSB7XG4gICAgICAgIGR4ICs9IChpbWFnZURhdGFbcG9zICsgd2lkdGgqayArIDFdIC0gaW1hZ2VEYXRhW3BvcyArIHdpZHRoKmsgLTFdKTtcbiAgICAgICAgZHkgKz0gKGltYWdlRGF0YVtwb3MgKyB3aWR0aCArIGtdIC0gaW1hZ2VEYXRhW3BvcyAtIHdpZHRoICsga10pO1xuICAgICAgfVxuICAgICAgZHggLz0gKDMgKiAyNTYpO1xuICAgICAgZHkgLz0gKDMgKiAyNTYpO1xuICAgICAgZFZhbHVlW3Bvc10gPSBNYXRoLnNxcnQoIChkeCAqIGR4ICsgZHkgKiBkeSkgLyAyKTtcbiAgICB9XG4gIH1cblxuICAvLyBTdGVwIDEuMiAtIHNlbGVjdCBhbGwgcGl4ZWwgd2hpY2ggaXMgZFZhbHVlIGxhcmdlc3QgdGhhbiBhbGwgaXRzIG5laWdoYm91ciBhcyBcInBvdGVudGlhbFwiIGNhbmRpZGF0ZVxuICAvLyAgdGhlIG51bWJlciBvZiBzZWxlY3RlZCBwb2ludHMgaXMgc3RpbGwgdG9vIG1hbnksIHNvIHdlIHVzZSB0aGUgdmFsdWUgdG8gZnVydGhlciBmaWx0ZXIgKGUuZy4gbGFyZ2VzdCB0aGUgZFZhbHVlLCB0aGUgYmV0dGVyKVxuICBjb25zdCBkVmFsdWVIaXN0ID0gbmV3IFVpbnQzMkFycmF5KDEwMDApOyAvLyBoaXN0b2dyYW0gb2YgZHZhbHVlIHNjYWxlZCB0byBbMCwgMTAwMClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspIGRWYWx1ZUhpc3RbaV0gPSAwO1xuICBjb25zdCBuZWlnaGJvdXJPZmZzZXRzID0gWy0xLCAxLCAtd2lkdGgsIHdpZHRoXTtcbiAgbGV0IGFsbENvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aWR0aC0xOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8IGhlaWdodC0xOyBqKyspIHtcbiAgICAgIGxldCBwb3MgPSBpICsgd2lkdGggKiBqO1xuICAgICAgbGV0IGlzTWF4ID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgbmVpZ2hib3VyT2Zmc2V0cy5sZW5ndGg7IGQrKykge1xuICAgICAgICBpZiAoZFZhbHVlW3Bvc10gPD0gZFZhbHVlW3BvcyArIG5laWdoYm91ck9mZnNldHNbZF1dKSB7XG4gICAgICAgICAgaXNNYXggPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTWF4KSB7XG4gICAgICAgIGxldCBrID0gTWF0aC5mbG9vcihkVmFsdWVbcG9zXSAqIDEwMDApO1xuICAgICAgICBpZiAoayA+IDk5OSkgayA9IDk5OTsgLy8gaz45OTkgc2hvdWxkIG5vdCBoYXBwZW4gaWYgY29tcHV0YWl0b24gaXMgY29ycmVjdGlvblxuICAgICAgICBpZiAoayA8IDApIGsgPSAwOyAvLyBrPDAgc2hvdWxkIG5vdCBoYXBwZW4gaWYgY29tcHV0YWl0b24gaXMgY29ycmVjdGlvblxuICAgICAgICBkVmFsdWVIaXN0W2tdICs9IDE7XG4gICAgICAgIGFsbENvdW50ICs9IDE7XG4gICAgICAgIGlzUGl4ZWxTZWxlY3RlZFtwb3NdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZWR1Y2UgbnVtYmVyIG9mIHBvaW50cyBhY2NvcmRpbmcgdG8gZFZhbHVlLlxuICAvLyBhY3R1YWxseSwgdGhlIHdob2xlIFN0ZXAgMS4gbWlnaHQgYmUgYmV0dGVyIHRvIGp1c3Qgc29ydCB0aGUgZHZhbHVlcyBhbmQgcGljayB0aGUgdG9wICgwLjAyICogd2lkdGggKiBoZWlnaHQpIHBvaW50c1xuICBjb25zdCBtYXhQb2ludHMgPSAwLjAyICogd2lkdGggKiBoZWlnaHQ7XG4gIGxldCBrID0gOTk5O1xuICBsZXQgZmlsdGVyZWRDb3VudCA9IDA7XG4gIHdoaWxlIChrID49IDApIHtcbiAgICBmaWx0ZXJlZENvdW50ICs9IGRWYWx1ZUhpc3Rba107XG4gICAgaWYgKGZpbHRlcmVkQ291bnQgPiBtYXhQb2ludHMpIGJyZWFrO1xuICAgIGstLTtcbiAgfVxuXG4gIC8vY29uc29sZS5sb2coXCJpbWFnZSBzaXplOiBcIiwgd2lkdGggKiBoZWlnaHQpO1xuICAvL2NvbnNvbGUubG9nKFwiZXh0cmFjdGVkIGZlYXR1ZXM6IFwiLCBhbGxDb3VudCk7XG4gIC8vY29uc29sZS5sb2coXCJmaWx0ZXJlZCBmZWF0dWVzOiBcIiwgZmlsdGVyZWRDb3VudCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpc1BpeGVsU2VsZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNQaXhlbFNlbGVjdGVkW2ldKSB7XG4gICAgICBpZiAoZFZhbHVlW2ldICogMTAwMCA8IGspIGlzUGl4ZWxTZWxlY3RlZFtpXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vY29uc29sZS5sb2coXCJzZWxlY3RlZCBjb3VudDogXCIsIGlzUGl4ZWxTZWxlY3RlZC5yZWR1Y2UoKGEsIGIpID0+IHtyZXR1cm4gYSArIChiPzE6MCk7fSwgMCkpO1xuXG4gIC8vIFN0ZXAgMlxuICAvLyBwcmVidWlsZCBjdW11bGF0aXZlIHN1bSBtYXRyaXggZm9yIGZhc3QgY29tcHV0YXRpb25cbiAgY29uc3QgaW1hZ2VEYXRhU3FyID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW1hZ2VEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaW1hZ2VEYXRhU3FyW2ldID0gaW1hZ2VEYXRhW2ldICogaW1hZ2VEYXRhW2ldO1xuICB9XG4gIGNvbnN0IGltYWdlRGF0YUN1bXN1bSA9IG5ldyBDdW1zdW0oaW1hZ2VEYXRhLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY29uc3QgaW1hZ2VEYXRhU3FyQ3Vtc3VtID0gbmV3IEN1bXN1bShpbWFnZURhdGFTcXIsIHdpZHRoLCBoZWlnaHQpO1xuXG4gIC8vIGhvbGRzIHRoZSBtYXggc2ltaWxhcmlsaXkgdmFsdWUgY29tcHV0ZWQgd2l0aGluIFNFQVJDSCBhcmVhIG9mIGVhY2ggcGl4ZWxcbiAgLy8gICBpZGVhOiBpZiB0aGVyZSBpcyBoaWdoIHNpbWxpYXJpdHkgd2l0aCBhbm90aGVyIHBpeGVsIGluIG5lYXJieSBhcmVhLCB0aGVuIGl0J3Mgbm90IGEgZ29vZCBmZWF0dXJlIHBvaW50XG4gIC8vICAgICAgICAgbmV4dCBzdGVwIGlzIHRvIGZpbmQgcGl4ZWwgd2l0aCBsb3cgc2ltaWxhcml0eVxuICBjb25zdCBmZWF0dXJlTWFwID0gbmV3IEZsb2F0MzJBcnJheShpbWFnZURhdGEubGVuZ3RoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhlaWdodDsgaisrKSB7XG4gICAgICBjb25zdCBwb3MgPSBqICogd2lkdGggKyBpO1xuICAgICAgaWYgKCFpc1BpeGVsU2VsZWN0ZWRbcG9zXSkge1xuICAgICAgICBmZWF0dXJlTWFwW3Bvc10gPSAxLjA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2bGVuID0gX3RlbXBsYXRlVmFyKHtpbWFnZSwgY3g6IGksIGN5OiBqLCBzZFRocmVzaDogVEVNUExBVEVfU0RfVEhSRVNILCBpbWFnZURhdGFDdW1zdW0sIGltYWdlRGF0YVNxckN1bXN1bX0pO1xuICAgICAgaWYgKHZsZW4gPT09IG51bGwpIHtcbiAgICAgICAgZmVhdHVyZU1hcFtwb3NdID0gMS4wO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IG1heCA9IC0xLjA7XG4gICAgICBmb3IgKGxldCBqaiA9IC1TRUFSQ0hfU0laRTE7IGpqIDw9IFNFQVJDSF9TSVpFMTsgamorKykge1xuICAgICAgICBmb3IgKGxldCBpaSA9IC1TRUFSQ0hfU0laRTE7IGlpIDw9IFNFQVJDSF9TSVpFMTsgaWkrKykge1xuICAgICAgICAgIGlmIChpaSAqIGlpICsgamogKiBqaiA8PSBTRUFSQ0hfU0laRTIgKiBTRUFSQ0hfU0laRTIpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IHNpbSA9IF9nZXRTaW1pbGFyaXR5KHtpbWFnZSwgY3g6IGkraWksIGN5OiBqK2pqLCB2bGVuOiB2bGVuLCB0eDogaSwgdHk6IGosIGltYWdlRGF0YUN1bXN1bSwgaW1hZ2VEYXRhU3FyQ3Vtc3VtfSk7XG5cbiAgICAgICAgICBpZiAoc2ltID09PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICAgIGlmIChzaW0gPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IHNpbTtcbiAgICAgICAgICAgIGlmIChtYXggPiBNQVhfU0lNX1RIUkVTSCkgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXggPiBNQVhfU0lNX1RIUkVTSCkgYnJlYWs7XG4gICAgICB9XG4gICAgICBmZWF0dXJlTWFwW3Bvc10gPSBtYXg7XG4gICAgfVxuICB9XG5cbiAgLy8gU3RlcCAyLjIgc2VsZWN0IGZlYXR1cmVcbiAgY29uc3QgY29vcmRzID0gX3NlbGVjdEZlYXR1cmUoe2ltYWdlLCBmZWF0dXJlTWFwLCB0ZW1wbGF0ZVNpemU6IFRFTVBMQVRFX1NJWkUsIHNlYXJjaFNpemU6IFNFQVJDSF9TSVpFMiwgb2NjU2l6ZTogT0NDVVBBTkNZX1NJWkUsIG1heFNpbVRocmVzaDogTUFYX1RIUkVTSCwgbWluU2ltVGhyZXNoOiBNSU5fVEhSRVNILCBzZFRocmVzaDogU0RfVEhSRVNILCBpbWFnZURhdGFDdW1zdW0sIGltYWdlRGF0YVNxckN1bXN1bX0pO1xuXG4gIHJldHVybiBjb29yZHM7XG59XG5cbmNvbnN0IF9zZWxlY3RGZWF0dXJlID0gKG9wdGlvbnMpID0+IHtcbiAgbGV0IHtpbWFnZSwgZmVhdHVyZU1hcCwgdGVtcGxhdGVTaXplLCBzZWFyY2hTaXplLCBvY2NTaXplLCBtYXhTaW1UaHJlc2gsIG1pblNpbVRocmVzaCwgc2RUaHJlc2gsIGltYWdlRGF0YUN1bXN1bSwgaW1hZ2VEYXRhU3FyQ3Vtc3VtfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHtkYXRhOiBpbWFnZURhdGEsIHdpZHRoLCBoZWlnaHQsIGRwaX0gPSBpbWFnZTtcblxuICAvL2NvbnNvbGUubG9nKFwicGFyYW1zOiBcIiwgdGVtcGxhdGVTaXplLCB0ZW1wbGF0ZVNpemUsIG9jY1NpemUsIG1heFNpbVRocmVzaCwgbWluU2ltVGhyZXNoLCBzZFRocmVzaCk7XG5cbiAgLy9vY2NTaXplICo9IDI7XG4gIG9jY1NpemUgPSBNYXRoLmZsb29yKE1hdGgubWluKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpIC8gMTApO1xuXG4gIGNvbnN0IGRpdlNpemUgPSAodGVtcGxhdGVTaXplICogMiArIDEpICogMztcbiAgY29uc3QgeERpdiA9IE1hdGguZmxvb3Iod2lkdGggLyBkaXZTaXplKTtcbiAgY29uc3QgeURpdiA9IE1hdGguZmxvb3IoaGVpZ2h0IC8gZGl2U2l6ZSk7XG5cbiAgbGV0IG1heEZlYXR1cmVOdW0gPSBNYXRoLmZsb29yKHdpZHRoIC8gb2NjU2l6ZSkgKiBNYXRoLmZsb29yKGhlaWdodCAvIG9jY1NpemUpICsgeERpdiAqIHlEaXY7XG4gIC8vY29uc29sZS5sb2coXCJtYXggZmVhdHVyZSBudW06IFwiLCBtYXhGZWF0dXJlTnVtKTtcblxuICBjb25zdCBjb29yZHMgPSBbXTtcbiAgY29uc3QgaW1hZ2UyID0gbmV3IEZsb2F0MzJBcnJheShpbWFnZURhdGEubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZTIubGVuZ3RoOyBpKyspIHtcbiAgICBpbWFnZTJbaV0gPSBmZWF0dXJlTWFwW2ldO1xuICB9XG5cbiAgbGV0IG51bSA9IDA7XG4gIHdoaWxlIChudW0gPCBtYXhGZWF0dXJlTnVtKSB7XG4gICAgbGV0IG1pblNpbSA9IG1heFNpbVRocmVzaDtcbiAgICBsZXQgY3ggPSAtMTtcbiAgICBsZXQgY3kgPSAtMTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhlaWdodDsgaisrKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgaWYgKGltYWdlMltqKndpZHRoK2ldIDwgbWluU2ltKSB7XG4gICAgICAgICAgbWluU2ltID0gaW1hZ2UyW2oqd2lkdGgraV07XG4gICAgICAgICAgY3ggPSBpO1xuICAgICAgICAgIGN5ID0gajtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3ggPT09IC0xKSBicmVhaztcblxuICAgIGNvbnN0IHZsZW4gPSBfdGVtcGxhdGVWYXIoe2ltYWdlLCBjeDogY3gsIGN5OiBjeSwgc2RUaHJlc2g6IDAsIGltYWdlRGF0YUN1bXN1bSwgaW1hZ2VEYXRhU3FyQ3Vtc3VtfSk7XG4gICAgaWYgKHZsZW4gPT09IG51bGwpIHtcbiAgICAgIGltYWdlMlsgY3kgKiB3aWR0aCArIGN4IF0gPSAxLjA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHZsZW4gLyAodGVtcGxhdGVTaXplICogMiArIDEpIDwgc2RUaHJlc2gpIHtcbiAgICAgIGltYWdlMlsgY3kgKiB3aWR0aCArIGN4IF0gPSAxLjA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgbWluID0gMS4wO1xuICAgIGxldCBtYXggPSAtMS4wO1xuXG4gICAgZm9yIChsZXQgaiA9IC1zZWFyY2hTaXplOyBqIDw9IHNlYXJjaFNpemU7IGorKykge1xuICAgICAgZm9yIChsZXQgaSA9IC1zZWFyY2hTaXplOyBpIDw9IHNlYXJjaFNpemU7IGkrKykge1xuICAgICAgICBpZiAoaSppICsgaipqID4gc2VhcmNoU2l6ZSAqIHNlYXJjaFNpemUpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoaSA9PT0gMCAmJiBqID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICBjb25zdCBzaW0gPSBfZ2V0U2ltaWxhcml0eSh7aW1hZ2UsIHZsZW4sIGN4OiBjeCtpLCBjeTogY3kraiwgdHg6IGN4LCB0eTpjeSwgaW1hZ2VEYXRhQ3Vtc3VtLCBpbWFnZURhdGFTcXJDdW1zdW19KTtcbiAgICAgICAgaWYgKHNpbSA9PT0gbnVsbCkgY29udGludWU7XG5cbiAgICAgICAgaWYgKHNpbSA8IG1pbikge1xuICAgICAgICAgIG1pbiA9IHNpbTtcbiAgICAgICAgICBpZiAobWluIDwgbWluU2ltVGhyZXNoICYmIG1pbiA8IG1pblNpbSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbSA+IG1heCkge1xuICAgICAgICAgIG1heCA9IHNpbTtcbiAgICAgICAgICBpZiAobWF4ID4gMC45OSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKCAobWluIDwgbWluU2ltVGhyZXNoICYmIG1pbiA8IG1pblNpbSkgfHwgbWF4ID4gMC45OSApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmKCAobWluIDwgbWluU2ltVGhyZXNoICYmIG1pbiA8IG1pblNpbSkgfHwgbWF4ID4gMC45OSApIHtcbiAgICAgICAgaW1hZ2UyWyBjeSAqIHdpZHRoICsgY3ggXSA9IDEuMDtcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29vcmRzLnB1c2goe1xuICAgICAgLy94OiBjeCxcbiAgICAgIC8veTogY3ksXG4gICAgICAvL214OiAxLjAgKiBjeCAvIGRwaSAqIDI1LjQsXG4gICAgICAvL215OiAxLjAgKiAoaGVpZ2h0IC0gY3kpIC8gZHBpICogMjUuNCxcbiAgICAgIG14OiAxLjAgKiBjeCAvIGRwaSxcbiAgICAgIG15OiAxLjAgKiAoaGVpZ2h0IC0gY3kpIC8gZHBpLFxuICAgICAgLy9tYXhTaW06IG1pblNpbSxcbiAgICB9KVxuXG4gICAgbnVtICs9IDE7XG4gICAgLy9jb25zb2xlLmxvZyhudW0sICcoJywgY3gsICcsJywgY3ksICcpJywgbWluU2ltLCAnbWluID0gJywgbWluLCAnbWF4ID0gJywgbWF4LCAnc2QgPSAnLCB2bGVuLyh0ZW1wbGF0ZVNpemUqMisxKSk7XG5cbiAgICAvLyBubyBvdGhlciBmZWF0dXJlIHBvaW50cyB3aXRoaW4gb2NjU2l6ZSBzcXVhcmVcbiAgICBmb3IgKGxldCBqID0gLW9jY1NpemU7IGogPD0gb2NjU2l6ZTsgaisrKSB7XG4gICAgICBmb3IgKGxldCBpID0gLW9jY1NpemU7IGkgPD0gb2NjU2l6ZTsgaSsrKSB7XG4gICAgICAgIGlmIChjeSArIGogPCAwIHx8IGN5ICsgaiA+PSBoZWlnaHQgfHwgY3ggKyBpIDwgMCB8fCBjeCArIGkgPj0gd2lkdGgpIGNvbnRpbnVlO1xuICAgICAgICBpbWFnZTJbIChjeStqKSp3aWR0aCArIChjeCtpKSBdID0gMS4wO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29vcmRzO1xufVxuXG4vLyBjb21wdXRlIHZhcmlhbmNlcyBvZiB0aGUgcGl4ZWxzLCBjZW50ZXJlZCBhdCAoY3gsIGN5KVxuY29uc3QgX3RlbXBsYXRlVmFyID0gKHtpbWFnZSwgY3gsIGN5LCBzZFRocmVzaCwgaW1hZ2VEYXRhQ3Vtc3VtLCBpbWFnZURhdGFTcXJDdW1zdW19KSA9PiB7XG4gIGlmIChjeCAtIFRFTVBMQVRFX1NJWkUgPCAwIHx8IGN4ICsgVEVNUExBVEVfU0laRSA+PSBpbWFnZS53aWR0aCkgcmV0dXJuIG51bGw7XG4gIGlmIChjeSAtIFRFTVBMQVRFX1NJWkUgPCAwIHx8IGN5ICsgVEVNUExBVEVfU0laRSA+PSBpbWFnZS5oZWlnaHQpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IHRlbXBsYXRlV2lkdGggPSAyICogVEVNUExBVEVfU0laRSArIDE7XG4gIGNvbnN0IG5QaXhlbHMgPSB0ZW1wbGF0ZVdpZHRoICogdGVtcGxhdGVXaWR0aDtcblxuICBsZXQgYXZlcmFnZSA9IGltYWdlRGF0YUN1bXN1bS5xdWVyeShjeCAtIFRFTVBMQVRFX1NJWkUsIGN5IC0gVEVNUExBVEVfU0laRSwgY3ggKyBURU1QTEFURV9TSVpFLCBjeStURU1QTEFURV9TSVpFKTtcbiAgYXZlcmFnZSAvPSBuUGl4ZWxzO1xuXG4gIC8vdiA9IHN1bSgocGl4ZWxfaSAtIGF2ZyleMikgZm9yIGFsbCBwaXhlbCBpIHdpdGhpbiB0aGUgdGVtcGxhdGVcbiAgLy8gID0gc3VtKHBpeGVsX2leMikgLSBzdW0oMiAqIGF2ZyAqIHBpeGVsX2kpICsgc3VtKGF2Z15hdmcpXG5cbiAgbGV0IHZsZW4gPSBpbWFnZURhdGFTcXJDdW1zdW0ucXVlcnkoY3ggLSBURU1QTEFURV9TSVpFLCBjeSAtIFRFTVBMQVRFX1NJWkUsIGN4ICsgVEVNUExBVEVfU0laRSwgY3krVEVNUExBVEVfU0laRSk7XG4gIHZsZW4gLT0gMiAqIGF2ZXJhZ2UgKiBpbWFnZURhdGFDdW1zdW0ucXVlcnkoY3ggLSBURU1QTEFURV9TSVpFLCBjeSAtIFRFTVBMQVRFX1NJWkUsIGN4ICsgVEVNUExBVEVfU0laRSwgY3krVEVNUExBVEVfU0laRSk7XG4gIHZsZW4gKz0gblBpeGVscyAqIGF2ZXJhZ2UgKiBhdmVyYWdlO1xuXG4gIGlmICh2bGVuIC8gblBpeGVscyA8IHNkVGhyZXNoICogc2RUaHJlc2gpIHJldHVybiBudWxsO1xuICB2bGVuID0gTWF0aC5zcXJ0KHZsZW4pO1xuICByZXR1cm4gdmxlbjtcbn1cblxuY29uc3QgX2dldFNpbWlsYXJpdHkgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCB7aW1hZ2UsIGN4LCBjeSwgdmxlbiwgdHgsIHR5LCBpbWFnZURhdGFDdW1zdW0sIGltYWdlRGF0YVNxckN1bXN1bX0gPSBvcHRpb25zO1xuICBjb25zdCB7ZGF0YTogaW1hZ2VEYXRhLCB3aWR0aCwgaGVpZ2h0fSA9IGltYWdlO1xuICBjb25zdCB0ZW1wbGF0ZVNpemUgPSBURU1QTEFURV9TSVpFO1xuXG4gIGlmIChjeCAtIHRlbXBsYXRlU2l6ZSA8IDAgfHwgY3ggKyB0ZW1wbGF0ZVNpemUgPj0gd2lkdGgpIHJldHVybiBudWxsO1xuICBpZiAoY3kgLSB0ZW1wbGF0ZVNpemUgPCAwIHx8IGN5ICsgdGVtcGxhdGVTaXplID49IGhlaWdodCkgcmV0dXJuIG51bGw7XG5cbiAgY29uc3QgdGVtcGxhdGVXaWR0aCA9IDIgKiB0ZW1wbGF0ZVNpemUgKyAxO1xuXG4gIGxldCBzeCA9IGltYWdlRGF0YUN1bXN1bS5xdWVyeShjeC10ZW1wbGF0ZVNpemUsIGN5LXRlbXBsYXRlU2l6ZSwgY3grdGVtcGxhdGVTaXplLCBjeSt0ZW1wbGF0ZVNpemUpO1xuICBsZXQgc3h4ID0gaW1hZ2VEYXRhU3FyQ3Vtc3VtLnF1ZXJ5KGN4LXRlbXBsYXRlU2l6ZSwgY3ktdGVtcGxhdGVTaXplLCBjeCt0ZW1wbGF0ZVNpemUsIGN5K3RlbXBsYXRlU2l6ZSk7XG4gIGxldCBzeHkgPSAwO1xuXG4gIC8vICEhIFRoaXMgbG9vcCBpcyB0aGUgcGVyZm9ybWFuY2UgYm90dGxlbmVjay4gVXNlIG1vdmluZyBwb2ludGVycyB0byBvcHRpbWl6ZVxuICAvL1xuICAvLyAgIGZvciAobGV0IGkgPSBjeCAtIHRlbXBsYXRlU2l6ZSwgaTIgPSB0eCAtIHRlbXBsYXRlU2l6ZTsgaSA8PSBjeCArIHRlbXBsYXRlU2l6ZTsgaSsrLCBpMisrKSB7XG4gIC8vICAgICBmb3IgKGxldCBqID0gY3kgLSB0ZW1wbGF0ZVNpemUsIGoyID0gdHkgLSB0ZW1wbGF0ZVNpemU7IGogPD0gY3kgKyB0ZW1wbGF0ZVNpemU7IGorKywgajIrKykge1xuICAvLyAgICAgICBzeHkgKz0gaW1hZ2VEYXRhW2oqd2lkdGggKyBpXSAqIGltYWdlRGF0YVtqMip3aWR0aCArIGkyXTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vXG4gIGxldCBwMSA9IChjeS10ZW1wbGF0ZVNpemUpICogd2lkdGggKyAoY3gtdGVtcGxhdGVTaXplKTtcbiAgbGV0IHAyID0gKHR5LXRlbXBsYXRlU2l6ZSkgKiB3aWR0aCArICh0eC10ZW1wbGF0ZVNpemUpO1xuICBsZXQgbmV4dFJvd09mZnNldCA9IHdpZHRoIC0gdGVtcGxhdGVXaWR0aDtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZW1wbGF0ZVdpZHRoOyBqKyspIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBsYXRlV2lkdGg7IGkrKykge1xuICAgICAgc3h5ICs9IGltYWdlRGF0YVtwMV0gKiBpbWFnZURhdGFbcDJdO1xuICAgICAgcDEgKz0xO1xuICAgICAgcDIgKz0xO1xuICAgIH1cbiAgICBwMSArPSBuZXh0Um93T2Zmc2V0O1xuICAgIHAyICs9IG5leHRSb3dPZmZzZXQ7XG4gIH1cblxuICBsZXQgdGVtcGxhdGVBdmVyYWdlID0gaW1hZ2VEYXRhQ3Vtc3VtLnF1ZXJ5KHR4LXRlbXBsYXRlU2l6ZSwgdHktdGVtcGxhdGVTaXplLCB0eCt0ZW1wbGF0ZVNpemUsIHR5K3RlbXBsYXRlU2l6ZSk7XG4gIHRlbXBsYXRlQXZlcmFnZSAvPSB0ZW1wbGF0ZVdpZHRoICogdGVtcGxhdGVXaWR0aDtcbiAgc3h5IC09IHRlbXBsYXRlQXZlcmFnZSAqIHN4O1xuXG4gIGxldCB2bGVuMiA9IHN4eCAtIHN4KnN4IC8gKHRlbXBsYXRlV2lkdGggKiB0ZW1wbGF0ZVdpZHRoKTtcbiAgaWYgKHZsZW4yID09IDApIHJldHVybiBudWxsO1xuICB2bGVuMiA9IE1hdGguc3FydCh2bGVuMik7XG5cbiAgLy8gY292YXJpYW5jZSBiZXR3ZWVuIHRlbXBsYXRlIGFuZCBjdXJyZW50IHBpeGVsXG4gIGNvbnN0IHNpbSA9IDEuMCAqIHN4eSAvICh2bGVuICogdmxlbjIpO1xuICByZXR1cm4gc2ltO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXh0cmFjdFxufTtcbiIsIi8vIGZhc3QgMkQgc3VibWF0cml4IHN1bSB1c2luZyBjdW11bGF0aXZlIHN1bSBhbGdvcml0aG1cbmNsYXNzIEN1bXN1bSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmN1bXN1bSA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgaGVpZ2h0OyBqKyspIHtcbiAgICAgIHRoaXMuY3Vtc3VtLnB1c2goW10pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuY3Vtc3VtW2pdLnB1c2goMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jdW1zdW1bMF1bMF0gPSBkYXRhWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgdGhpcy5jdW1zdW1bMF1baV0gPSB0aGlzLmN1bXN1bVswXVtpLTFdICsgZGF0YVtpXTtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDE7IGogPCBoZWlnaHQ7IGorKykge1xuICAgICAgdGhpcy5jdW1zdW1bal1bMF0gPSB0aGlzLmN1bXN1bVtqLTFdWzBdICsgZGF0YVtqKndpZHRoXTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBqID0gMTsgaiA8IGhlaWdodDsgaisrKSB7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgdGhpcy5jdW1zdW1bal1baV0gPSBkYXRhW2oqd2lkdGgraV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHRoaXMuY3Vtc3VtW2otMV1baV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHRoaXMuY3Vtc3VtW2pdW2ktMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHRoaXMuY3Vtc3VtW2otMV1baS0xXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBxdWVyeSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIGxldCByZXQgPSB0aGlzLmN1bXN1bVt5Ml1beDJdO1xuICAgIGlmICh5MSA+IDApIHJldCAtPSB0aGlzLmN1bXN1bVt5MS0xXVt4Ml07XG4gICAgaWYgKHgxID4gMCkgcmV0IC09IHRoaXMuY3Vtc3VtW3kyXVt4MS0xXTtcbiAgICBpZiAoeDEgPiAwICYmIHkxID4gMCkgcmV0ICs9IHRoaXMuY3Vtc3VtW3kxLTFdW3gxLTFdO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEN1bXN1bVxufVxuIiwiLy8gc2ltcGxlciB2ZXJzaW9uIG9mIHVwc2FtcGxpbmcuIGJldHRlciBwZXJmb3JtYW5jZVxuY29uc3QgX3Vwc2FtcGxlQmlsaW5lYXIgPSAoe2ltYWdlLCBwYWRPbmVXaWR0aCwgcGFkT25lSGVpZ2h0fSkgPT4ge1xuICBjb25zdCB7d2lkdGgsIGhlaWdodCwgZGF0YX0gPSBpbWFnZTtcbiAgY29uc3QgZHN0V2lkdGggPSBpbWFnZS53aWR0aCAqIDIgKyAocGFkT25lV2lkdGg/MTowKTtcbiAgY29uc3QgZHN0SGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0ICogMiArIChwYWRPbmVIZWlnaHQ/MTowKTtcbiAgY29uc3QgdGVtcCA9IG5ldyBGbG9hdDMyQXJyYXkoZHN0V2lkdGggKiBkc3RIZWlnaHQpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgaGVpZ2h0OyBqKyspIHtcbiAgICAgIGNvbnN0IHYgPSAwLjI1ICogZGF0YVtqICogd2lkdGggKyBpXTtcbiAgICAgIGNvbnN0IGlpID0gTWF0aC5mbG9vcihpLzIpO1xuICAgICAgY29uc3QgamogPSBNYXRoLmZsb29yKGovMik7XG4gICAgICBjb25zdCBwb3MgPSBNYXRoLmZsb29yKGovMikgKiBkc3RXaWR0aCArIE1hdGguZmxvb3IoaS8yKTtcbiAgICAgIHRlbXBbcG9zXSArPSB2O1xuICAgICAgdGVtcFtwb3MrMV0gKz0gdjtcbiAgICAgIHRlbXBbcG9zK2RzdFdpZHRoXSArPSB2O1xuICAgICAgdGVtcFtwb3MrZHN0V2lkdGgrMV0gKz0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtkYXRhOiB0ZW1wLCB3aWR0aDogZHN0V2lkdGgsIGhlaWdodDogZHN0SGVpZ2h0fTtcbn1cblxuLy8gYXJ0b29sa2l0IHZlcnNpb24uIHNsb3dlci4gaXMgaXQgbmVjZXNzYXJ5P1xuY29uc3QgdXBzYW1wbGVCaWxpbmVhciA9ICh7aW1hZ2UsIHBhZE9uZVdpZHRoLCBwYWRPbmVIZWlnaHR9KSA9PiB7XG4gIGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBkYXRhfSA9IGltYWdlO1xuXG4gIGNvbnN0IGRzdFdpZHRoID0gaW1hZ2Uud2lkdGggKiAyICsgKHBhZE9uZVdpZHRoPzE6MCk7XG4gIGNvbnN0IGRzdEhlaWdodCA9IGltYWdlLmhlaWdodCAqIDIgKyAocGFkT25lSGVpZ2h0PzE6MCk7XG5cbiAgY29uc3QgdGVtcCA9IG5ldyBGbG9hdDMyQXJyYXkoZHN0V2lkdGggKiBkc3RIZWlnaHQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRzdFdpZHRoOyBpKyspIHtcbiAgICBjb25zdCBzaSA9IDAuNSAqIGkgLSAwLjI1O1xuICAgIGxldCBzaTAgPSBNYXRoLmZsb29yKHNpKTtcbiAgICBsZXQgc2kxID0gTWF0aC5jZWlsKHNpKTtcbiAgICBpZiAoc2kwIDwgMCkgc2kwID0gMDsgLy8gYm9yZGVyXG4gICAgaWYgKHNpMSA+PSB3aWR0aCkgc2kxID0gd2lkdGggLSAxOyAvLyBib3JkZXJcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgZHN0SGVpZ2h0OyBqKyspIHtcbiAgICAgIGNvbnN0IHNqID0gMC41ICogaiAtIDAuMjU7XG4gICAgICBsZXQgc2owID0gTWF0aC5mbG9vcihzaik7XG4gICAgICBsZXQgc2oxID0gTWF0aC5jZWlsKHNqKTtcbiAgICAgIGlmIChzajAgPCAwKSBzajAgPSAwOyAvLyBib3JkZXJcbiAgICAgIGlmIChzajEgPj0gaGVpZ2h0KSBzajEgPSBoZWlnaHQgLSAxOyAvL2JvcmRlclxuXG4gICAgICBjb25zdCB2YWx1ZSA9IChzaTEgLSBzaSkgKiAoc2oxIC0gc2opICogZGF0YVsgc2owICogd2lkdGggKyBzaTAgXSArXG4gICAgICAgICAgICAgICAgICAgIChzaTEgLSBzaSkgKiAoc2ogLSBzajApICogZGF0YVsgc2oxICogd2lkdGggKyBzaTAgXSArXG4gICAgICAgICAgICAgICAgICAgIChzaSAtIHNpMCkgKiAoc2oxIC0gc2opICogZGF0YVsgc2owICogd2lkdGggKyBzaTEgXSArXG4gICAgICAgICAgICAgICAgICAgIChzaSAtIHNpMCkgKiAoc2ogLSBzajApICogZGF0YVsgc2oxICogd2lkdGggKyBzaTEgXTtcblxuICAgICAgdGVtcFtqICogZHN0V2lkdGggKyBpXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7ZGF0YTogdGVtcCwgd2lkdGg6IGRzdFdpZHRoLCBoZWlnaHQ6IGRzdEhlaWdodH07XG59XG5cbmNvbnN0IGRvd25zYW1wbGVCaWxpbmVhciA9ICh7aW1hZ2V9KSA9PiB7XG4gIGNvbnN0IHtkYXRhLCB3aWR0aCwgaGVpZ2h0fSA9IGltYWdlO1xuXG4gIGNvbnN0IGRzdFdpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAvIDIpO1xuICBjb25zdCBkc3RIZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAvIDIpO1xuXG4gIGNvbnN0IHRlbXAgPSBuZXcgRmxvYXQzMkFycmF5KGRzdFdpZHRoICogZHN0SGVpZ2h0KTtcbiAgY29uc3Qgb2Zmc2V0cyA9IFswLCAxLCB3aWR0aCwgd2lkdGgrMV07XG5cbiAgZm9yIChsZXQgaiA9IDA7IGogPCBkc3RIZWlnaHQ7IGorKykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHN0V2lkdGg7IGkrKykge1xuICAgICAgbGV0IHNyY1BvcyA9IGoqMiAqIHdpZHRoICsgaSoyO1xuICAgICAgbGV0IHZhbHVlID0gMC4wO1xuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBvZmZzZXRzLmxlbmd0aDsgZCsrKSB7XG4gICAgICAgIHZhbHVlICs9IGRhdGFbc3JjUG9zKyBvZmZzZXRzW2RdXTtcbiAgICAgIH1cbiAgICAgIHZhbHVlICo9IDAuMjU7XG4gICAgICB0ZW1wW2oqZHN0V2lkdGgraV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtkYXRhOiB0ZW1wLCB3aWR0aDogZHN0V2lkdGgsIGhlaWdodDogZHN0SGVpZ2h0fTtcbn1cblxuY29uc3QgcmVzaXplID0gKHtpbWFnZSwgcmF0aW99KSA9PiB7XG4gIGNvbnN0IHdpZHRoID0gTWF0aC5yb3VuZChpbWFnZS53aWR0aCAqIHJhdGlvKTtcbiAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZChpbWFnZS5oZWlnaHQgKiByYXRpbyk7XG5cbiAgLy9jb25zdCBpbWFnZURhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0KTtcbiAgY29uc3QgaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICBsZXQgc2kxID0gTWF0aC5yb3VuZCgxLjAgKiBpIC8gcmF0aW8pO1xuICAgIGxldCBzaTIgPSBNYXRoLnJvdW5kKDEuMCAqIChpKzEpIC8gcmF0aW8pIC0gMTtcbiAgICBpZiAoc2kyID49IGltYWdlLndpZHRoKSBzaTIgPSBpbWFnZS53aWR0aCAtIDE7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhlaWdodDsgaisrKSB7XG4gICAgICBsZXQgc2oxID0gTWF0aC5yb3VuZCgxLjAgKiBqIC8gcmF0aW8pO1xuICAgICAgbGV0IHNqMiA9IE1hdGgucm91bmQoMS4wICogKGorMSkgLyByYXRpbykgLSAxO1xuICAgICAgaWYgKHNqMiA+PSBpbWFnZS5oZWlnaHQpIHNqMiA9IGltYWdlLmhlaWdodCAtIDE7XG5cbiAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgIGZvciAobGV0IGlpID0gc2kxOyBpaSA8PSBzaTI7IGlpKyspIHtcbiAgICAgICAgZm9yIChsZXQgamogPSBzajE7IGpqIDw9IHNqMjsgamorKykge1xuICAgICAgICAgIHN1bSArPSAoMS4wICogaW1hZ2UuZGF0YVtqaiAqIGltYWdlLndpZHRoICsgaWldKTtcbiAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbWFnZURhdGFbaiAqIHdpZHRoICsgaV0gPSBNYXRoLmZsb29yKHN1bSAvIGNvdW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtkYXRhOiBpbWFnZURhdGEsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZG93bnNhbXBsZUJpbGluZWFyLFxuICB1cHNhbXBsZUJpbGluZWFyLFxuICByZXNpemUsXG59XG5cbiIsImNvbnN0IG1SYW5kU2VlZCA9IDEyMzQ7XG5cbmNvbnN0IGNyZWF0ZVJhbmRvbWl6ZXIgPSAoKSA9PiB7XG4gIGNvbnN0IHJhbmRvbWl6ZXIgPSB7XG4gICAgc2VlZDogbVJhbmRTZWVkLFxuXG4gICAgYXJyYXlTaHVmZmxlKG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHthcnIsIHNhbXBsZVNpemV9ID0gb3B0aW9ucztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlU2l6ZTsgaSsrKSB7XG5cbiAgICAgICAgdGhpcy5zZWVkID0gKDIxNDAxMyAqIHRoaXMuc2VlZCArIDI1MzEwMTEpICUgKDEgPDwgMzEpO1xuICAgICAgICBsZXQgayA9ICh0aGlzLnNlZWQgPj4gMTYpICYgMHg3ZmZmO1xuICAgICAgICBrID0gayAlIGFyci5sZW5ndGg7XG5cbiAgICAgICAgbGV0IHRtcCA9IGFycltpXTtcbiAgICAgICAgYXJyW2ldID0gYXJyW2tdO1xuICAgICAgICBhcnJba10gPSB0bXA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG5leHRJbnQobWF4VmFsdWUpIHtcbiAgICAgIHRoaXMuc2VlZCA9ICgyMTQwMTMgKiB0aGlzLnNlZWQgKyAyNTMxMDExKSAlICgxIDw8IDMxKTtcbiAgICAgIGxldCBrID0gKHRoaXMuc2VlZCA+PiAxNikgJiAweDdmZmY7XG4gICAgICBrID0gayAlIG1heFZhbHVlO1xuICAgICAgcmV0dXJuIGs7XG4gICAgfVxuICB9XG4gIHJldHVybiByYW5kb21pemVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlUmFuZG9taXplclxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==