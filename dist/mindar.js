/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/~hiukim/projects/WebCards/mind-ar-js/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@msgpack/msgpack/dist.es5/msgpack.min.js":
/*!***************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5/msgpack.min.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {!function(e,t){ true?module.exports=t():undefined}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";r.r(t),r.d(t,"encode",(function(){return I})),r.d(t,"decode",(function(){return N})),r.d(t,"decodeAsync",(function(){return Y})),r.d(t,"decodeArrayStream",(function(){return Z})),r.d(t,"decodeStream",(function(){return $})),r.d(t,"Decoder",(function(){return V})),r.d(t,"Encoder",(function(){return L})),r.d(t,"ExtensionCodec",(function(){return S})),r.d(t,"ExtData",(function(){return p})),r.d(t,"EXT_TIMESTAMP",(function(){return w})),r.d(t,"encodeDateToTimeSpec",(function(){return g})),r.d(t,"encodeTimeSpecToTimestamp",(function(){return v})),r.d(t,"decodeTimestampToTimeSpec",(function(){return x})),r.d(t,"encodeTimestampExtension",(function(){return b})),r.d(t,"decodeTimestampExtension",(function(){return U}));var n=function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)s.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return s},i=function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(n(arguments[t]));return e},o="undefined"!=typeof process&&"undefined"!=typeof TextEncoder&&"undefined"!=typeof TextDecoder;function s(e){for(var t=e.length,r=0,n=0;n<t;){var i=e.charCodeAt(n++);if(0!=(4294967168&i))if(0==(4294965248&i))r+=2;else{if(i>=55296&&i<=56319&&n<t){var o=e.charCodeAt(n);56320==(64512&o)&&(++n,i=((1023&i)<<10)+(1023&o)+65536)}r+=0==(4294901760&i)?3:4}else r++}return r}var a=o?new TextEncoder:void 0,h="undefined"!=typeof process?200:0;var u=(null==a?void 0:a.encodeInto)?function(e,t,r){a.encodeInto(e,t.subarray(r))}:function(e,t,r){t.set(a.encode(e),r)};function c(e,t,r){for(var n=t,o=n+r,s=[],a="";n<o;){var h=e[n++];if(0==(128&h))s.push(h);else if(192==(224&h)){var u=63&e[n++];s.push((31&h)<<6|u)}else if(224==(240&h)){u=63&e[n++];var c=63&e[n++];s.push((31&h)<<12|u<<6|c)}else if(240==(248&h)){var f=(7&h)<<18|(u=63&e[n++])<<12|(c=63&e[n++])<<6|63&e[n++];f>65535&&(f-=65536,s.push(f>>>10&1023|55296),f=56320|1023&f),s.push(f)}else s.push(h);s.length>=4096&&(a+=String.fromCharCode.apply(String,i(s)),s.length=0)}return s.length>0&&(a+=String.fromCharCode.apply(String,i(s))),a}var f=o?new TextDecoder:null,l="undefined"!=typeof process?200:0;var p=function(e,t){this.type=e,this.data=t};function d(e,t,r){var n=Math.floor(r/4294967296),i=r;e.setUint32(t,n),e.setUint32(t+4,i)}function y(e,t){return 4294967296*e.getInt32(t)+e.getUint32(t+4)}var w=-1;function v(e){var t=e.sec,r=e.nsec;if(t>=0&&r>=0&&t<=17179869183){if(0===r&&t<=4294967295){var n=new Uint8Array(4);return(s=new DataView(n.buffer)).setUint32(0,t),n}var i=t/4294967296,o=4294967295&t;n=new Uint8Array(8);return(s=new DataView(n.buffer)).setUint32(0,r<<2|3&i),s.setUint32(4,o),n}var s;n=new Uint8Array(12);return(s=new DataView(n.buffer)).setUint32(0,r),d(s,4,t),n}function g(e){var t=e.getTime(),r=Math.floor(t/1e3),n=1e6*(t-1e3*r),i=Math.floor(n/1e9);return{sec:r+i,nsec:n-1e9*i}}function b(e){return e instanceof Date?v(g(e)):null}function x(e){var t=new DataView(e.buffer,e.byteOffset,e.byteLength);switch(e.byteLength){case 4:return{sec:t.getUint32(0),nsec:0};case 8:var r=t.getUint32(0);return{sec:4294967296*(3&r)+t.getUint32(4),nsec:r>>>2};case 12:return{sec:y(t,4),nsec:t.getUint32(0)};default:throw new Error("Unrecognized data size for timestamp: "+e.length)}}function U(e){var t=x(e);return new Date(1e3*t.sec+t.nsec/1e6)}var m={type:w,encode:b,decode:U},S=function(){function e(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(m)}return e.prototype.register=function(e){var t=e.type,r=e.encode,n=e.decode;if(t>=0)this.encoders[t]=r,this.decoders[t]=n;else{var i=1+t;this.builtInEncoders[i]=r,this.builtInDecoders[i]=n}},e.prototype.tryToEncode=function(e,t){for(var r=0;r<this.builtInEncoders.length;r++){if(null!=(n=this.builtInEncoders[r]))if(null!=(i=n(e,t)))return new p(-1-r,i)}for(r=0;r<this.encoders.length;r++){var n,i;if(null!=(n=this.encoders[r]))if(null!=(i=n(e,t)))return new p(r,i)}return e instanceof p?e:null},e.prototype.decode=function(e,t,r){var n=t<0?this.builtInDecoders[-1-t]:this.decoders[t];return n?n(e,t,r):new p(t,e)},e.defaultCodec=new e,e}();function E(e){return e instanceof Uint8Array?e:ArrayBuffer.isView(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e instanceof ArrayBuffer?new Uint8Array(e):Uint8Array.from(e)}var B=function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},L=function(){function e(e,t,r,n,i,o,s){void 0===e&&(e=S.defaultCodec),void 0===r&&(r=100),void 0===n&&(n=2048),void 0===i&&(i=!1),void 0===o&&(o=!1),void 0===s&&(s=!1),this.extensionCodec=e,this.context=t,this.maxDepth=r,this.initialBufferSize=n,this.sortKeys=i,this.forceFloat32=o,this.ignoreUndefined=s,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return e.prototype.encode=function(e,t){if(t>this.maxDepth)throw new Error("Too deep objects in depth "+t);null==e?this.encodeNil():"boolean"==typeof e?this.encodeBoolean(e):"number"==typeof e?this.encodeNumber(e):"string"==typeof e?this.encodeString(e):this.encodeObject(e,t)},e.prototype.getUint8Array=function(){return this.bytes.subarray(0,this.pos)},e.prototype.ensureBufferSizeToWrite=function(e){var t=this.pos+e;this.view.byteLength<t&&this.resizeBuffer(2*t)},e.prototype.resizeBuffer=function(e){var t=new ArrayBuffer(e),r=new Uint8Array(t),n=new DataView(t);r.set(this.bytes),this.view=n,this.bytes=r},e.prototype.encodeNil=function(){this.writeU8(192)},e.prototype.encodeBoolean=function(e){!1===e?this.writeU8(194):this.writeU8(195)},e.prototype.encodeNumber=function(e){Number.isSafeInteger(e)?e>=0?e<128?this.writeU8(e):e<256?(this.writeU8(204),this.writeU8(e)):e<65536?(this.writeU8(205),this.writeU16(e)):e<4294967296?(this.writeU8(206),this.writeU32(e)):(this.writeU8(207),this.writeU64(e)):e>=-32?this.writeU8(224|e+32):e>=-128?(this.writeU8(208),this.writeI8(e)):e>=-32768?(this.writeU8(209),this.writeI16(e)):e>=-2147483648?(this.writeU8(210),this.writeI32(e)):(this.writeU8(211),this.writeI64(e)):this.forceFloat32?(this.writeU8(202),this.writeF32(e)):(this.writeU8(203),this.writeF64(e))},e.prototype.writeStringHeader=function(e){if(e<32)this.writeU8(160+e);else if(e<256)this.writeU8(217),this.writeU8(e);else if(e<65536)this.writeU8(218),this.writeU16(e);else{if(!(e<4294967296))throw new Error("Too long string: "+e+" bytes in UTF-8");this.writeU8(219),this.writeU32(e)}},e.prototype.encodeString=function(e){var t=e.length;if(o&&t>h){var r=s(e);this.ensureBufferSizeToWrite(5+r),this.writeStringHeader(r),u(e,this.bytes,this.pos),this.pos+=r}else{r=s(e);this.ensureBufferSizeToWrite(5+r),this.writeStringHeader(r),function(e,t,r){for(var n=e.length,i=r,o=0;o<n;){var s=e.charCodeAt(o++);if(0!=(4294967168&s)){if(0==(4294965248&s))t[i++]=s>>6&31|192;else{if(s>=55296&&s<=56319&&o<n){var a=e.charCodeAt(o);56320==(64512&a)&&(++o,s=((1023&s)<<10)+(1023&a)+65536)}0==(4294901760&s)?(t[i++]=s>>12&15|224,t[i++]=s>>6&63|128):(t[i++]=s>>18&7|240,t[i++]=s>>12&63|128,t[i++]=s>>6&63|128)}t[i++]=63&s|128}else t[i++]=s}}(e,this.bytes,this.pos),this.pos+=r}},e.prototype.encodeObject=function(e,t){var r=this.extensionCodec.tryToEncode(e,this.context);if(null!=r)this.encodeExtension(r);else if(Array.isArray(e))this.encodeArray(e,t);else if(ArrayBuffer.isView(e))this.encodeBinary(e);else{if("object"!=typeof e)throw new Error("Unrecognized object: "+Object.prototype.toString.apply(e));this.encodeMap(e,t)}},e.prototype.encodeBinary=function(e){var t=e.byteLength;if(t<256)this.writeU8(196),this.writeU8(t);else if(t<65536)this.writeU8(197),this.writeU16(t);else{if(!(t<4294967296))throw new Error("Too large binary: "+t);this.writeU8(198),this.writeU32(t)}var r=E(e);this.writeU8a(r)},e.prototype.encodeArray=function(e,t){var r,n,i=e.length;if(i<16)this.writeU8(144+i);else if(i<65536)this.writeU8(220),this.writeU16(i);else{if(!(i<4294967296))throw new Error("Too large array: "+i);this.writeU8(221),this.writeU32(i)}try{for(var o=B(e),s=o.next();!s.done;s=o.next()){var a=s.value;this.encode(a,t+1)}}catch(e){r={error:e}}finally{try{s&&!s.done&&(n=o.return)&&n.call(o)}finally{if(r)throw r.error}}},e.prototype.countWithoutUndefined=function(e,t){var r,n,i=0;try{for(var o=B(t),s=o.next();!s.done;s=o.next()){void 0!==e[s.value]&&i++}}catch(e){r={error:e}}finally{try{s&&!s.done&&(n=o.return)&&n.call(o)}finally{if(r)throw r.error}}return i},e.prototype.encodeMap=function(e,t){var r,n,i=Object.keys(e);this.sortKeys&&i.sort();var o=this.ignoreUndefined?this.countWithoutUndefined(e,i):i.length;if(o<16)this.writeU8(128+o);else if(o<65536)this.writeU8(222),this.writeU16(o);else{if(!(o<4294967296))throw new Error("Too large map object: "+o);this.writeU8(223),this.writeU32(o)}try{for(var s=B(i),a=s.next();!a.done;a=s.next()){var h=a.value,u=e[h];this.ignoreUndefined&&void 0===u||(this.encodeString(h),this.encode(u,t+1))}}catch(e){r={error:e}}finally{try{a&&!a.done&&(n=s.return)&&n.call(s)}finally{if(r)throw r.error}}},e.prototype.encodeExtension=function(e){var t=e.data.length;if(1===t)this.writeU8(212);else if(2===t)this.writeU8(213);else if(4===t)this.writeU8(214);else if(8===t)this.writeU8(215);else if(16===t)this.writeU8(216);else if(t<256)this.writeU8(199),this.writeU8(t);else if(t<65536)this.writeU8(200),this.writeU16(t);else{if(!(t<4294967296))throw new Error("Too large extension object: "+t);this.writeU8(201),this.writeU32(t)}this.writeI8(e.type),this.writeU8a(e.data)},e.prototype.writeU8=function(e){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,e),this.pos++},e.prototype.writeU8a=function(e){var t=e.length;this.ensureBufferSizeToWrite(t),this.bytes.set(e,this.pos),this.pos+=t},e.prototype.writeI8=function(e){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,e),this.pos++},e.prototype.writeU16=function(e){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,e),this.pos+=2},e.prototype.writeI16=function(e){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,e),this.pos+=2},e.prototype.writeU32=function(e){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,e),this.pos+=4},e.prototype.writeI32=function(e){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,e),this.pos+=4},e.prototype.writeF32=function(e){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,e),this.pos+=4},e.prototype.writeF64=function(e){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,e),this.pos+=8},e.prototype.writeU64=function(e){this.ensureBufferSizeToWrite(8),function(e,t,r){var n=r/4294967296,i=r;e.setUint32(t,n),e.setUint32(t+4,i)}(this.view,this.pos,e),this.pos+=8},e.prototype.writeI64=function(e){this.ensureBufferSizeToWrite(8),d(this.view,this.pos,e),this.pos+=8},e}(),A={};function I(e,t){void 0===t&&(t=A);var r=new L(t.extensionCodec,t.context,t.maxDepth,t.initialBufferSize,t.sortKeys,t.forceFloat32,t.ignoreUndefined);return r.encode(e,1),r.getUint8Array()}function T(e){return(e<0?"-":"")+"0x"+Math.abs(e).toString(16).padStart(2,"0")}var k=function(){function e(e,t){void 0===e&&(e=16),void 0===t&&(t=16),this.maxKeyLength=e,this.maxLengthPerKey=t,this.caches=[];for(var r=0;r<this.maxKeyLength;r++)this.caches.push([])}return e.prototype.canBeCached=function(e){return e>0&&e<=this.maxKeyLength},e.prototype.get=function(e,t,r){var n=this.caches[r-1],i=n.length;e:for(var o=0;o<i;o++){for(var s=n[o],a=s.bytes,h=0;h<r;h++)if(a[h]!==e[t+h])continue e;return s.value}return null},e.prototype.store=function(e,t){var r=this.caches[e.length-1],n={bytes:e,value:t};r.length>=this.maxLengthPerKey?r[Math.random()*r.length|0]=n:r.push(n)},e.prototype.decode=function(e,t,r){var n=this.get(e,t,r);if(null!=n)return n;var i=c(e,t,r),o=Uint8Array.prototype.slice.call(e,t,t+r);return this.store(o,i),i},e}(),M=function(e,t,r,n){return new(r||(r=Promise))((function(i,o){function s(e){try{h(n.next(e))}catch(e){o(e)}}function a(e){try{h(n.throw(e))}catch(e){o(e)}}function h(e){var t;e.done?i(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(s,a)}h((n=n.apply(e,t||[])).next())}))},z=function(e,t){var r,n,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,n=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(i=s.trys,(i=i.length>0&&i[i.length-1])||6!==o[0]&&2!==o[0])){s=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){s.label=o[1];break}if(6===o[0]&&s.label<i[1]){s.label=i[1],i=o;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(o);break}i[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}},C=function(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,r=e[Symbol.asyncIterator];return r?r.call(e):(e="function"==typeof __values?__values(e):e[Symbol.iterator](),t={},n("next"),n("throw"),n("return"),t[Symbol.asyncIterator]=function(){return this},t);function n(r){t[r]=e[r]&&function(t){return new Promise((function(n,i){(function(e,t,r,n){Promise.resolve(n).then((function(t){e({value:t,done:r})}),t)})(n,i,(t=e[r](t)).done,t.value)}))}}},D=function(e){return this instanceof D?(this.v=e,this):new D(e)},P=function(e,t,r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n,i=r.apply(e,t||[]),o=[];return n={},s("next"),s("throw"),s("return"),n[Symbol.asyncIterator]=function(){return this},n;function s(e){i[e]&&(n[e]=function(t){return new Promise((function(r,n){o.push([e,t,r,n])>1||a(e,t)}))})}function a(e,t){try{(r=i[e](t)).value instanceof D?Promise.resolve(r.value.v).then(h,u):c(o[0][2],r)}catch(e){c(o[0][3],e)}var r}function h(e){a("next",e)}function u(e){a("throw",e)}function c(e,t){e(t),o.shift(),o.length&&a(o[0][0],o[0][1])}},j=new DataView(new ArrayBuffer(0)),F=new Uint8Array(j.buffer),W=function(){try{j.getInt8(0)}catch(e){return e.constructor}throw new Error("never reached")}(),O=new W("Insufficient data"),K=new k,V=function(){function e(e,t,r,n,i,o,s,a){void 0===e&&(e=S.defaultCodec),void 0===r&&(r=4294967295),void 0===n&&(n=4294967295),void 0===i&&(i=4294967295),void 0===o&&(o=4294967295),void 0===s&&(s=4294967295),void 0===a&&(a=K),this.extensionCodec=e,this.context=t,this.maxStrLength=r,this.maxBinLength=n,this.maxArrayLength=i,this.maxMapLength=o,this.maxExtLength=s,this.cachedKeyDecoder=a,this.totalPos=0,this.pos=0,this.view=j,this.bytes=F,this.headByte=-1,this.stack=[]}return e.prototype.setBuffer=function(e){this.bytes=E(e),this.view=function(e){if(e instanceof ArrayBuffer)return new DataView(e);var t=E(e);return new DataView(t.buffer,t.byteOffset,t.byteLength)}(this.bytes),this.pos=0},e.prototype.appendBuffer=function(e){if(-1!==this.headByte||this.hasRemaining()){var t=this.bytes.subarray(this.pos),r=E(e),n=new Uint8Array(t.length+r.length);n.set(t),n.set(r,t.length),this.setBuffer(n)}else this.setBuffer(e)},e.prototype.hasRemaining=function(e){return void 0===e&&(e=1),this.view.byteLength-this.pos>=e},e.prototype.createNoExtraBytesError=function(e){var t=this.view,r=this.pos;return new RangeError("Extra "+(t.byteLength-r)+" byte(s) found at buffer["+e+"]")},e.prototype.decodeSingleSync=function(){var e=this.decodeSync();if(this.hasRemaining())throw this.createNoExtraBytesError(this.pos);return e},e.prototype.decodeSingleAsync=function(e){var t,r,n,i;return M(this,void 0,void 0,(function(){var o,s,a,h,u,c,f,l;return z(this,(function(p){switch(p.label){case 0:o=!1,p.label=1;case 1:p.trys.push([1,6,7,12]),t=C(e),p.label=2;case 2:return[4,t.next()];case 3:if((r=p.sent()).done)return[3,5];if(a=r.value,o)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(a);try{s=this.decodeSync(),o=!0}catch(e){if(!(e instanceof W))throw e}this.totalPos+=this.pos,p.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return h=p.sent(),n={error:h},[3,12];case 7:return p.trys.push([7,,10,11]),r&&!r.done&&(i=t.return)?[4,i.call(t)]:[3,9];case 8:p.sent(),p.label=9;case 9:return[3,11];case 10:if(n)throw n.error;return[7];case 11:return[7];case 12:if(o){if(this.hasRemaining())throw this.createNoExtraBytesError(this.totalPos);return[2,s]}throw c=(u=this).headByte,f=u.pos,l=u.totalPos,new RangeError("Insufficient data in parcing "+T(c)+" at "+l+" ("+f+" in the current buffer)")}}))}))},e.prototype.decodeArrayStream=function(e){return this.decodeMultiAsync(e,!0)},e.prototype.decodeStream=function(e){return this.decodeMultiAsync(e,!1)},e.prototype.decodeMultiAsync=function(e,t){return P(this,arguments,(function(){var r,n,i,o,s,a,h,u,c;return z(this,(function(f){switch(f.label){case 0:r=t,n=-1,f.label=1;case 1:f.trys.push([1,13,14,19]),i=C(e),f.label=2;case 2:return[4,D(i.next())];case 3:if((o=f.sent()).done)return[3,12];if(s=o.value,t&&0===n)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(s),r&&(n=this.readArraySize(),r=!1,this.complete()),f.label=4;case 4:f.trys.push([4,9,,10]),f.label=5;case 5:return[4,D(this.decodeSync())];case 6:return[4,f.sent()];case 7:return f.sent(),0==--n?[3,8]:[3,5];case 8:return[3,10];case 9:if(!((a=f.sent())instanceof W))throw a;return[3,10];case 10:this.totalPos+=this.pos,f.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return h=f.sent(),u={error:h},[3,19];case 14:return f.trys.push([14,,17,18]),o&&!o.done&&(c=i.return)?[4,D(c.call(i))]:[3,16];case 15:f.sent(),f.label=16;case 16:return[3,18];case 17:if(u)throw u.error;return[7];case 18:return[7];case 19:return[2]}}))}))},e.prototype.decodeSync=function(){e:for(;;){var e=this.readHeadByte(),t=void 0;if(e>=224)t=e-256;else if(e<192)if(e<128)t=e;else if(e<144){if(0!==(n=e-128)){this.pushMapState(n),this.complete();continue e}t={}}else if(e<160){if(0!==(n=e-144)){this.pushArrayState(n),this.complete();continue e}t=[]}else{var r=e-160;t=this.decodeUtf8String(r,0)}else if(192===e)t=null;else if(194===e)t=!1;else if(195===e)t=!0;else if(202===e)t=this.readF32();else if(203===e)t=this.readF64();else if(204===e)t=this.readU8();else if(205===e)t=this.readU16();else if(206===e)t=this.readU32();else if(207===e)t=this.readU64();else if(208===e)t=this.readI8();else if(209===e)t=this.readI16();else if(210===e)t=this.readI32();else if(211===e)t=this.readI64();else if(217===e){r=this.lookU8();t=this.decodeUtf8String(r,1)}else if(218===e){r=this.lookU16();t=this.decodeUtf8String(r,2)}else if(219===e){r=this.lookU32();t=this.decodeUtf8String(r,4)}else if(220===e){if(0!==(n=this.readU16())){this.pushArrayState(n),this.complete();continue e}t=[]}else if(221===e){if(0!==(n=this.readU32())){this.pushArrayState(n),this.complete();continue e}t=[]}else if(222===e){if(0!==(n=this.readU16())){this.pushMapState(n),this.complete();continue e}t={}}else if(223===e){if(0!==(n=this.readU32())){this.pushMapState(n),this.complete();continue e}t={}}else if(196===e){var n=this.lookU8();t=this.decodeBinary(n,1)}else if(197===e){n=this.lookU16();t=this.decodeBinary(n,2)}else if(198===e){n=this.lookU32();t=this.decodeBinary(n,4)}else if(212===e)t=this.decodeExtension(1,0);else if(213===e)t=this.decodeExtension(2,0);else if(214===e)t=this.decodeExtension(4,0);else if(215===e)t=this.decodeExtension(8,0);else if(216===e)t=this.decodeExtension(16,0);else if(199===e){n=this.lookU8();t=this.decodeExtension(n,1)}else if(200===e){n=this.lookU16();t=this.decodeExtension(n,2)}else{if(201!==e)throw new Error("Unrecognized type byte: "+T(e));n=this.lookU32();t=this.decodeExtension(n,4)}this.complete();for(var i=this.stack;i.length>0;){var o=i[i.length-1];if(0===o.type){if(o.array[o.position]=t,o.position++,o.position!==o.size)continue e;i.pop(),t=o.array}else{if(1===o.type){if(s=void 0,"string"!==(s=typeof t)&&"number"!==s)throw new Error("The type of key must be string or number but "+typeof t);o.key=t,o.type=2;continue e}if(o.map[o.key]=t,o.readCount++,o.readCount!==o.size){o.key=null,o.type=1;continue e}i.pop(),t=o.map}}return t}var s},e.prototype.readHeadByte=function(){return-1===this.headByte&&(this.headByte=this.readU8()),this.headByte},e.prototype.complete=function(){this.headByte=-1},e.prototype.readArraySize=function(){var e=this.readHeadByte();switch(e){case 220:return this.readU16();case 221:return this.readU32();default:if(e<160)return e-144;throw new Error("Unrecognized array type byte: "+T(e))}},e.prototype.pushMapState=function(e){if(e>this.maxMapLength)throw new Error("Max length exceeded: map length ("+e+") > maxMapLengthLength ("+this.maxMapLength+")");this.stack.push({type:1,size:e,key:null,readCount:0,map:{}})},e.prototype.pushArrayState=function(e){if(e>this.maxArrayLength)throw new Error("Max length exceeded: array length ("+e+") > maxArrayLength ("+this.maxArrayLength+")");this.stack.push({type:0,size:e,array:new Array(e),position:0})},e.prototype.decodeUtf8String=function(e,t){var r;if(e>this.maxStrLength)throw new Error("Max length exceeded: UTF-8 byte length ("+e+") > maxStrLength ("+this.maxStrLength+")");if(this.bytes.byteLength<this.pos+t+e)throw O;var n,i=this.pos+t;return n=this.stateIsMapKey()&&(null===(r=this.cachedKeyDecoder)||void 0===r?void 0:r.canBeCached(e))?this.cachedKeyDecoder.decode(this.bytes,i,e):o&&e>l?function(e,t,r){var n=e.subarray(t,t+r);return f.decode(n)}(this.bytes,i,e):c(this.bytes,i,e),this.pos+=t+e,n},e.prototype.stateIsMapKey=function(){return this.stack.length>0&&1===this.stack[this.stack.length-1].type},e.prototype.decodeBinary=function(e,t){if(e>this.maxBinLength)throw new Error("Max length exceeded: bin length ("+e+") > maxBinLength ("+this.maxBinLength+")");if(!this.hasRemaining(e+t))throw O;var r=this.pos+t,n=this.bytes.subarray(r,r+e);return this.pos+=t+e,n},e.prototype.decodeExtension=function(e,t){if(e>this.maxExtLength)throw new Error("Max length exceeded: ext length ("+e+") > maxExtLength ("+this.maxExtLength+")");var r=this.view.getInt8(this.pos+t),n=this.decodeBinary(e,t+1);return this.extensionCodec.decode(n,r,this.context)},e.prototype.lookU8=function(){return this.view.getUint8(this.pos)},e.prototype.lookU16=function(){return this.view.getUint16(this.pos)},e.prototype.lookU32=function(){return this.view.getUint32(this.pos)},e.prototype.readU8=function(){var e=this.view.getUint8(this.pos);return this.pos++,e},e.prototype.readI8=function(){var e=this.view.getInt8(this.pos);return this.pos++,e},e.prototype.readU16=function(){var e=this.view.getUint16(this.pos);return this.pos+=2,e},e.prototype.readI16=function(){var e=this.view.getInt16(this.pos);return this.pos+=2,e},e.prototype.readU32=function(){var e=this.view.getUint32(this.pos);return this.pos+=4,e},e.prototype.readI32=function(){var e=this.view.getInt32(this.pos);return this.pos+=4,e},e.prototype.readU64=function(){var e,t,r=(e=this.view,t=this.pos,4294967296*e.getUint32(t)+e.getUint32(t+4));return this.pos+=8,r},e.prototype.readI64=function(){var e=y(this.view,this.pos);return this.pos+=8,e},e.prototype.readF32=function(){var e=this.view.getFloat32(this.pos);return this.pos+=4,e},e.prototype.readF64=function(){var e=this.view.getFloat64(this.pos);return this.pos+=8,e},e}(),_={};function N(e,t){void 0===t&&(t=_);var r=new V(t.extensionCodec,t.context,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength);return r.setBuffer(e),r.decodeSingleSync()}var R=function(e,t){var r,n,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,n=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(i=s.trys,(i=i.length>0&&i[i.length-1])||6!==o[0]&&2!==o[0])){s=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){s.label=o[1];break}if(6===o[0]&&s.label<i[1]){s.label=i[1],i=o;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(o);break}i[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}},H=function(e){return this instanceof H?(this.v=e,this):new H(e)},G=function(e,t,r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n,i=r.apply(e,t||[]),o=[];return n={},s("next"),s("throw"),s("return"),n[Symbol.asyncIterator]=function(){return this},n;function s(e){i[e]&&(n[e]=function(t){return new Promise((function(r,n){o.push([e,t,r,n])>1||a(e,t)}))})}function a(e,t){try{(r=i[e](t)).value instanceof H?Promise.resolve(r.value.v).then(h,u):c(o[0][2],r)}catch(e){c(o[0][3],e)}var r}function h(e){a("next",e)}function u(e){a("throw",e)}function c(e,t){e(t),o.shift(),o.length&&a(o[0][0],o[0][1])}};function X(e){if(null==e)throw new Error("Assertion Failure: value must not be null nor undefined")}function q(e){return null!=e[Symbol.asyncIterator]?e:function(e){return G(this,arguments,(function(){var t,r,n,i;return R(this,(function(o){switch(o.label){case 0:t=e.getReader(),o.label=1;case 1:o.trys.push([1,,9,10]),o.label=2;case 2:return[4,H(t.read())];case 3:return r=o.sent(),n=r.done,i=r.value,n?[4,H(void 0)]:[3,5];case 4:return[2,o.sent()];case 5:return X(i),[4,H(i)];case 6:return[4,o.sent()];case 7:return o.sent(),[3,2];case 8:return[3,10];case 9:return t.releaseLock(),[7];case 10:return[2]}}))}))}(e)}var J=function(e,t,r,n){return new(r||(r=Promise))((function(i,o){function s(e){try{h(n.next(e))}catch(e){o(e)}}function a(e){try{h(n.throw(e))}catch(e){o(e)}}function h(e){var t;e.done?i(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(s,a)}h((n=n.apply(e,t||[])).next())}))},Q=function(e,t){var r,n,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,n=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(i=s.trys,(i=i.length>0&&i[i.length-1])||6!==o[0]&&2!==o[0])){s=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){s.label=o[1];break}if(6===o[0]&&s.label<i[1]){s.label=i[1],i=o;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(o);break}i[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}};function Y(e,t){return void 0===t&&(t=_),J(this,void 0,void 0,(function(){var r;return Q(this,(function(n){return r=q(e),[2,new V(t.extensionCodec,t.context,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeSingleAsync(r)]}))}))}function Z(e,t){void 0===t&&(t=_);var r=q(e);return new V(t.extensionCodec,t.context,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeArrayStream(r)}function $(e,t){void 0===t&&(t=_);var r=q(e);return new V(t.extensionCodec,t.context,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeStream(r)}}])}));
//# sourceMappingURL=msgpack.min.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/gpu.js/dist/gpu-browser.js":
/*!*************************************************!*\
  !*** ./node_modules/gpu.js/dist/gpu-browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/**
 * gpu.js
 * http://gpu.rocks/
 *
 * GPU Accelerated JavaScript
 *
 * @version 2.9.4
 * @date Sat May 02 2020 11:46:49 GMT-0400 (Eastern Daylight Time)
 *
 * @license MIT
 * The MIT License
 *
 * Copyright (c) 2020 gpu.js Team
 */(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.acorn = {}));
}(this, function (exports) { 'use strict';


  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };


  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

  var keywords = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };

  var keywordRelationalOperator = /^in(stanceof)?$/;


  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;


  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];

  function isInAstralSet(code, set) {
    var pos = 0x10000;
    for (var i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code) { return false }
      pos += set[i + 1];
      if (pos >= code) { return true }
    }
  }


  function isIdentifierStart(code, astral) {
    if (code < 65) { return code === 36 }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes)
  }


  function isIdentifierChar(code, astral) {
    if (code < 48) { return code === 36 }
    if (code < 58) { return true }
    if (code < 65) { return false }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
  }





  var TokenType = function TokenType(label, conf) {
    if ( conf === void 0 ) conf = {};

    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };

  function binop(name, prec) {
    return new TokenType(name, {beforeExpr: true, binop: prec})
  }
  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};


  var keywords$1 = {};

  function kw(name, options) {
    if ( options === void 0 ) options = {};

    options.keyword = name;
    return keywords$1[name] = new TokenType(name, options)
  }

  var types = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    eof: new TokenType("eof"),

    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),


    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
    prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {beforeExpr: true}),

    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {isLoop: true, beforeExpr: true}),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {isLoop: true}),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {isLoop: true}),
    _with: kw("with"),
    _new: kw("new", {beforeExpr: true, startsExpr: true}),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {beforeExpr: true, binop: 7}),
    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
  };


  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");

  function isNewLine(code, ecma2019String) {
    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
  }

  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  var ref = Object.prototype;
  var hasOwnProperty = ref.hasOwnProperty;
  var toString = ref.toString;


  function has(obj, propName) {
    return hasOwnProperty.call(obj, propName)
  }

  var isArray = Array.isArray || (function (obj) { return (
    toString.call(obj) === "[object Array]"
  ); });

  function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
  }


  var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
  };

  Position.prototype.offset = function offset (n) {
    return new Position(this.line, this.column + n)
  };

  var SourceLocation = function SourceLocation(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) { this.source = p.sourceFile; }
  };


  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0;;) {
      lineBreakG.lastIndex = cur;
      var match = lineBreakG.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else {
        return new Position(line, offset - cur)
      }
    }
  }


  var defaultOptions = {
    ecmaVersion: 10,
    sourceType: "script",
    onInsertedSemicolon: null,
    onTrailingComma: null,
    allowReserved: null,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowAwaitOutsideFunction: false,
    allowHashBang: false,
    locations: false,
    onToken: null,
    onComment: null,
    ranges: false,
    program: null,
    sourceFile: null,
    directSourceFile: null,
    preserveParens: false
  };


  function getOptions(opts) {
    var options = {};

    for (var opt in defaultOptions)
      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

    if (options.ecmaVersion >= 2015)
      { options.ecmaVersion -= 2009; }

    if (options.allowReserved == null)
      { options.allowReserved = options.ecmaVersion < 5; }

    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function (token) { return tokens.push(token); };
    }
    if (isArray(options.onComment))
      { options.onComment = pushComment(options, options.onComment); }

    return options
  }

  function pushComment(options, array) {
    return function(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text,
        start: start,
        end: end
      };
      if (options.locations)
        { comment.loc = new SourceLocation(this, startLoc, endLoc); }
      if (options.ranges)
        { comment.range = [start, end]; }
      array.push(comment);
    }
  }

  var
      SCOPE_TOP = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
      SCOPE_ASYNC = 4,
      SCOPE_GENERATOR = 8,
      SCOPE_ARROW = 16,
      SCOPE_SIMPLE_CATCH = 32,
      SCOPE_SUPER = 64,
      SCOPE_DIRECT_SUPER = 128;

  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
  }

  var
      BIND_NONE = 0, 
      BIND_VAR = 1, 
      BIND_LEXICAL = 2, 
      BIND_FUNCTION = 3, 
      BIND_SIMPLE_CATCH = 4, 
      BIND_OUTSIDE = 5; 

  var Parser = function Parser(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
      for (var v = options.ecmaVersion;; v--)
        { if (reserved = reservedWords[v]) { break } }
      if (options.sourceType === "module") { reserved += " await"; }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);

    this.containsEsc = false;


    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }

    this.type = types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();

    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    this.context = this.initialContext();
    this.exprAllowed = true;

    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);

    this.potentialArrowAt = -1;

    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    this.labels = [];
    this.undefinedExports = {};

    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
      { this.skipLineComment(2); }

    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);

    this.regexpState = null;
  };

  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

  Parser.prototype.parse = function parse () {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node)
  };

  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
  prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

  Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

  Parser.extend = function extend () {
      var plugins = [], len = arguments.length;
      while ( len-- ) plugins[ len ] = arguments[ len ];

    var cls = this;
    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
    return cls
  };

  Parser.parse = function parse (input, options) {
    return new this(options, input).parse()
  };

  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression()
  };

  Parser.tokenizer = function tokenizer (input, options) {
    return new this(options, input)
  };

  Object.defineProperties( Parser.prototype, prototypeAccessors );

  var pp = Parser.prototype;


  var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
  pp.strictDirective = function(start) {
    for (;;) {
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match) { return false }
      if ((match[1] || match[2]) === "use strict") { return true }
      start += match[0].length;

      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";")
        { start++; }
    }
  };


  pp.eat = function(type) {
    if (this.type === type) {
      this.next();
      return true
    } else {
      return false
    }
  };


  pp.isContextual = function(name) {
    return this.type === types.name && this.value === name && !this.containsEsc
  };


  pp.eatContextual = function(name) {
    if (!this.isContextual(name)) { return false }
    this.next();
    return true
  };


  pp.expectContextual = function(name) {
    if (!this.eatContextual(name)) { this.unexpected(); }
  };


  pp.canInsertSemicolon = function() {
    return this.type === types.eof ||
      this.type === types.braceR ||
      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  pp.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon)
        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
      return true
    }
  };


  pp.semicolon = function() {
    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
  };

  pp.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma)
        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
      if (!notNext)
        { this.next(); }
      return true
    }
  };


  pp.expect = function(type) {
    this.eat(type) || this.unexpected();
  };


  pp.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };

  function DestructuringErrors() {
    this.shorthandAssign =
    this.trailingComma =
    this.parenthesizedAssign =
    this.parenthesizedBind =
    this.doubleProto =
      -1;
  }

  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) { return }
    if (refDestructuringErrors.trailingComma > -1)
      { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
  };

  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) { return false }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
    if (shorthandAssign >= 0)
      { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
    if (doubleProto >= 0)
      { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
  };

  pp.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
      { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
    if (this.awaitPos)
      { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
  };

  pp.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression")
      { return this.isSimpleAssignTarget(expr.expression) }
    return expr.type === "Identifier" || expr.type === "MemberExpression"
  };

  var pp$1 = Parser.prototype;



  pp$1.parseTopLevel = function(node) {
    var exports = {};
    if (!node.body) { node.body = []; }
    while (this.type !== types.eof) {
      var stmt = this.parseStatement(null, true, exports);
      node.body.push(stmt);
    }
    if (this.inModule)
      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
        {
          var name = list[i];

          this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
        } }
    this.adaptDirectivePrologue(node.body);
    this.next();
    node.sourceType = this.options.sourceType;
    return this.finishNode(node, "Program")
  };

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  pp$1.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    if (nextCh === 91) { return true } 
    if (context) { return false }

    if (nextCh === 123) { return true } 
    if (isIdentifierStart(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) { return true }
    }
    return false
  };

  pp$1.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
      { return false }

    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length;
    return !lineBreak.test(this.input.slice(this.pos, next)) &&
      this.input.slice(next, next + 8) === "function" &&
      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
  };


  pp$1.parseStatement = function(context, topLevel, exports) {
    var starttype = this.type, node = this.startNode(), kind;

    if (this.isLet(context)) {
      starttype = types._var;
      kind = "let";
    }


    switch (starttype) {
    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
    case types._debugger: return this.parseDebuggerStatement(node)
    case types._do: return this.parseDoStatement(node)
    case types._for: return this.parseForStatement(node)
    case types._function:
      if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
      return this.parseFunctionStatement(node, false, !context)
    case types._class:
      if (context) { this.unexpected(); }
      return this.parseClass(node, true)
    case types._if: return this.parseIfStatement(node)
    case types._return: return this.parseReturnStatement(node)
    case types._switch: return this.parseSwitchStatement(node)
    case types._throw: return this.parseThrowStatement(node)
    case types._try: return this.parseTryStatement(node)
    case types._const: case types._var:
      kind = kind || this.value;
      if (context && kind !== "var") { this.unexpected(); }
      return this.parseVarStatement(node, kind)
    case types._while: return this.parseWhileStatement(node)
    case types._with: return this.parseWithStatement(node)
    case types.braceL: return this.parseBlock(true, node)
    case types.semi: return this.parseEmptyStatement(node)
    case types._export:
    case types._import:
      if (this.options.ecmaVersion > 10 && starttype === types._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40) 
          { return this.parseExpressionStatement(node, this.parseExpression()) }
      }

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel)
          { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
        if (!this.inModule)
          { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
      }
      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    default:
      if (this.isAsyncFunction()) {
        if (context) { this.unexpected(); }
        this.next();
        return this.parseFunctionStatement(node, true, !context)
      }

      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
        { return this.parseLabeledStatement(node, maybeName, expr, context) }
      else { return this.parseExpressionStatement(node, expr) }
    }
  };

  pp$1.parseBreakContinueStatement = function(node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
    else if (this.type !== types.name) { this.unexpected(); }
    else {
      node.label = this.parseIdent();
      this.semicolon();
    }

    var i = 0;
    for (; i < this.labels.length; ++i) {
      var lab = this.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
        if (node.label && isBreak) { break }
      }
    }
    if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
  };

  pp$1.parseDebuggerStatement = function(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement")
  };

  pp$1.parseDoStatement = function(node) {
    this.next();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types._while);
    node.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6)
      { this.eat(types.semi); }
    else
      { this.semicolon(); }
    return this.finishNode(node, "DoWhileStatement")
  };


  pp$1.parseForStatement = function(node) {
    this.next();
    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types.parenL);
    if (this.type === types.semi) {
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, null)
    }
    var isLet = this.isLet();
    if (this.type === types._var || this.type === types._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types._in) {
            if (awaitAt > -1) { this.unexpected(awaitAt); }
          } else { node.await = awaitAt > -1; }
        }
        return this.parseForIn(node, init$1)
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init$1)
    }
    var refDestructuringErrors = new DestructuringErrors;
    var init = this.parseExpression(true, refDestructuringErrors);
    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      this.toAssignable(init, false, refDestructuringErrors);
      this.checkLVal(init);
      return this.parseForIn(node, init)
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init)
  };

  pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
  };

  pp$1.parseIfStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement")
  };

  pp$1.parseReturnStatement = function(node) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
      { this.raise(this.start, "'return' outside of function"); }
    this.next();


    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
    else { node.argument = this.parseExpression(); this.semicolon(); }
    return this.finishNode(node, "ReturnStatement")
  };

  pp$1.parseSwitchStatement = function(node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(types.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);


    var cur;
    for (var sawDefault = false; this.type !== types.braceR;) {
      if (this.type === types._case || this.type === types._default) {
        var isCase = this.type === types._case;
        if (cur) { this.finishNode(cur, "SwitchCase"); }
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types.colon);
      } else {
        if (!cur) { this.unexpected(); }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) { this.finishNode(cur, "SwitchCase"); }
    this.next(); 
    this.labels.pop();
    return this.finishNode(node, "SwitchStatement")
  };

  pp$1.parseThrowStatement = function(node) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
      { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement")
  };


  var empty = [];

  pp$1.parseTryStatement = function(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.type === types._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types.parenL)) {
        clause.param = this.parseBindingAtom();
        var simple = clause.param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types.parenR);
      } else {
        if (this.options.ecmaVersion < 10) { this.unexpected(); }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer)
      { this.raise(node.start, "Missing catch or finally clause"); }
    return this.finishNode(node, "TryStatement")
  };

  pp$1.parseVarStatement = function(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration")
  };

  pp$1.parseWhileStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node, "WhileStatement")
  };

  pp$1.parseWithStatement = function(node) {
    if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement("with");
    return this.finishNode(node, "WithStatement")
  };

  pp$1.parseEmptyStatement = function(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement")
  };

  pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
      {
      var label = list[i$1];

      if (label.name === maybeName)
        { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    } }
    var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
    for (var i = this.labels.length - 1; i >= 0; i--) {
      var label$1 = this.labels[i];
      if (label$1.statementStart === node.start) {
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else { break }
    }
    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement")
  };

  pp$1.parseExpressionStatement = function(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement")
  };


  pp$1.parseBlock = function(createNewLexicalScope, node) {
    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
    if ( node === void 0 ) node = this.startNode();

    node.body = [];
    this.expect(types.braceL);
    if (createNewLexicalScope) { this.enterScope(0); }
    while (!this.eat(types.braceR)) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    if (createNewLexicalScope) { this.exitScope(); }
    return this.finishNode(node, "BlockStatement")
  };


  pp$1.parseFor = function(node, init) {
    node.init = init;
    this.expect(types.semi);
    node.test = this.type === types.semi ? null : this.parseExpression();
    this.expect(types.semi);
    node.update = this.type === types.parenR ? null : this.parseExpression();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, "ForStatement")
  };


  pp$1.parseForIn = function(node, init) {
    var isForIn = this.type === types._in;
    this.next();

    if (
      init.type === "VariableDeclaration" &&
      init.declarations[0].init != null &&
      (
        !isForIn ||
        this.options.ecmaVersion < 8 ||
        this.strict ||
        init.kind !== "var" ||
        init.declarations[0].id.type !== "Identifier"
      )
    ) {
      this.raise(
        init.start,
        ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
      );
    } else if (init.type === "AssignmentPattern") {
      this.raise(init.start, "Invalid left-hand side in for-loop");
    }
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
  };


  pp$1.parseVar = function(node, isFor, kind) {
    node.declarations = [];
    node.kind = kind;
    for (;;) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
        this.unexpected();
      } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types.comma)) { break }
    }
    return node
  };

  pp$1.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };

  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;


  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
    this.initFunction(node);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
        { this.unexpected(); }
      node.generator = this.eat(types.star);
    }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    if (statement & FUNC_STATEMENT) {
      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
        { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
    }

    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node.async, node.generator));

    if (!(statement & FUNC_STATEMENT))
      { node.id = this.type === types.name ? this.parseIdent() : null; }

    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
  };

  pp$1.parseFunctionParams = function(node) {
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };


  pp$1.parseClass = function(node, isStatement) {
    this.next();

    var oldStrict = this.strict;
    this.strict = true;

    this.parseClassId(node, isStatement);
    this.parseClassSuper(node);
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      var element = this.parseClassElement(node.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
          hadConstructor = true;
        }
      }
    }
    node.body = this.finishNode(classBody, "ClassBody");
    this.strict = oldStrict;
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
  };

  pp$1.parseClassElement = function(constructorAllowsSuper) {
    var this$1 = this;

    if (this.eat(types.semi)) { return null }

    var method = this.startNode();
    var tryContextual = function (k, noLineBreak) {
      if ( noLineBreak === void 0 ) noLineBreak = false;

      var start = this$1.start, startLoc = this$1.startLoc;
      if (!this$1.eatContextual(k)) { return false }
      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
      if (method.key) { this$1.unexpected(); }
      method.computed = false;
      method.key = this$1.startNodeAt(start, startLoc);
      method.key.name = k;
      this$1.finishNode(method.key, "Identifier");
      return false
    };

    method.kind = "method";
    method.static = tryContextual("static");
    var isGenerator = this.eat(types.star);
    var isAsync = false;
    if (!isGenerator) {
      if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      } else if (tryContextual("get")) {
        method.kind = "get";
      } else if (tryContextual("set")) {
        method.kind = "set";
      }
    }
    if (!method.key) { this.parsePropertyName(method); }
    var key = method.key;
    var allowsDirectSuper = false;
    if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
        key.type === "Literal" && key.value === "constructor")) {
      if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
      if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
      if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
      method.kind = "constructor";
      allowsDirectSuper = constructorAllowsSuper;
    } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }
    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && method.value.params.length !== 0)
      { this.raiseRecoverable(method.value.start, "getter should have no params"); }
    if (method.kind === "set" && method.value.params.length !== 1)
      { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
    if (method.kind === "set" && method.value.params[0].type === "RestElement")
      { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
    return method
  };

  pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    return this.finishNode(method, "MethodDefinition")
  };

  pp$1.parseClassId = function(node, isStatement) {
    if (this.type === types.name) {
      node.id = this.parseIdent();
      if (isStatement)
        { this.checkLVal(node.id, BIND_LEXICAL, false); }
    } else {
      if (isStatement === true)
        { this.unexpected(); }
      node.id = null;
    }
  };

  pp$1.parseClassSuper = function(node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
  };


  pp$1.parseExport = function(node, exports) {
    this.next();
    if (this.eat(types.star)) {
      this.expectContextual("from");
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
      this.semicolon();
      return this.finishNode(node, "ExportAllDeclaration")
    }
    if (this.eat(types._default)) { 
      this.checkExport(exports, "default", this.lastTokStart);
      var isAsync;
      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) { this.next(); }
        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
      } else if (this.type === types._class) {
        var cNode = this.startNode();
        node.declaration = this.parseClass(cNode, "nullableID");
      } else {
        node.declaration = this.parseMaybeAssign();
        this.semicolon();
      }
      return this.finishNode(node, "ExportDefaultDeclaration")
    }
    if (this.shouldParseExportStatement()) {
      node.declaration = this.parseStatement(null);
      if (node.declaration.type === "VariableDeclaration")
        { this.checkVariableExport(exports, node.declaration.declarations); }
      else
        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
      node.specifiers = [];
      node.source = null;
    } else { 
      node.declaration = null;
      node.specifiers = this.parseExportSpecifiers(exports);
      if (this.eatContextual("from")) {
        if (this.type !== types.string) { this.unexpected(); }
        node.source = this.parseExprAtom();
      } else {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          var spec = list[i];

          this.checkUnreserved(spec.local);
          this.checkLocalExport(spec.local);
        }

        node.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration")
  };

  pp$1.checkExport = function(exports, name, pos) {
    if (!exports) { return }
    if (has(exports, name))
      { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
    exports[name] = true;
  };

  pp$1.checkPatternExport = function(exports, pat) {
    var type = pat.type;
    if (type === "Identifier")
      { this.checkExport(exports, pat.name, pat.start); }
    else if (type === "ObjectPattern")
      { for (var i = 0, list = pat.properties; i < list.length; i += 1)
        {
          var prop = list[i];

          this.checkPatternExport(exports, prop);
        } }
    else if (type === "ArrayPattern")
      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];

          if (elt) { this.checkPatternExport(exports, elt); }
      } }
    else if (type === "Property")
      { this.checkPatternExport(exports, pat.value); }
    else if (type === "AssignmentPattern")
      { this.checkPatternExport(exports, pat.left); }
    else if (type === "RestElement")
      { this.checkPatternExport(exports, pat.argument); }
    else if (type === "ParenthesizedExpression")
      { this.checkPatternExport(exports, pat.expression); }
  };

  pp$1.checkVariableExport = function(exports, decls) {
    if (!exports) { return }
    for (var i = 0, list = decls; i < list.length; i += 1)
      {
      var decl = list[i];

      this.checkPatternExport(exports, decl.id);
    }
  };

  pp$1.shouldParseExportStatement = function() {
    return this.type.keyword === "var" ||
      this.type.keyword === "const" ||
      this.type.keyword === "class" ||
      this.type.keyword === "function" ||
      this.isLet() ||
      this.isAsyncFunction()
  };


  pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node = this.startNode();
      node.local = this.parseIdent(true);
      node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
      this.checkExport(exports, node.exported.name, node.exported.start);
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    return nodes
  };


  pp$1.parseImport = function(node) {
    this.next();
    if (this.type === types.string) {
      node.specifiers = empty;
      node.source = this.parseExprAtom();
    } else {
      node.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration")
  };


  pp$1.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types.name) {
      var node = this.startNode();
      node.local = this.parseIdent();
      this.checkLVal(node.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
      if (!this.eat(types.comma)) { return nodes }
    }
    if (this.type === types.star) {
      var node$1 = this.startNode();
      this.next();
      this.expectContextual("as");
      node$1.local = this.parseIdent();
      this.checkLVal(node$1.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
      return nodes
    }
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node$2 = this.startNode();
      node$2.imported = this.parseIdent(true);
      if (this.eatContextual("as")) {
        node$2.local = this.parseIdent();
      } else {
        this.checkUnreserved(node$2.imported);
        node$2.local = node$2.imported;
      }
      this.checkLVal(node$2.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes
  };

  pp$1.adaptDirectivePrologue = function(statements) {
    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
      statements[i].directive = statements[i].expression.raw.slice(1, -1);
    }
  };
  pp$1.isDirectiveCandidate = function(statement) {
    return (
      statement.type === "ExpressionStatement" &&
      statement.expression.type === "Literal" &&
      typeof statement.expression.value === "string" &&
      (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
    )
  };

  var pp$2 = Parser.prototype;


  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) {
      switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await")
          { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
        break

      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break

      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];

        this.toAssignable(prop, isBinding);
          if (
            prop.type === "RestElement" &&
            (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
          ) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break

      case "Property":
        if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
        this.toAssignable(node.value, isBinding);
        break

      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        this.toAssignableList(node.elements, isBinding);
        break

      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern")
          { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
        break

      case "AssignmentExpression":
        if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);

      case "AssignmentPattern":
        break

      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break

      case "MemberExpression":
        if (!isBinding) { break }

      default:
        this.raise(node.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
    return node
  };


  pp$2.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i = 0; i < end; i++) {
      var elt = exprList[i];
      if (elt) { this.toAssignable(elt, isBinding); }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
        { this.unexpected(last.argument.start); }
    }
    return exprList
  };


  pp$2.parseSpread = function(refDestructuringErrors) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node, "SpreadElement")
  };

  pp$2.parseRestBinding = function() {
    var node = this.startNode();
    this.next();

    if (this.options.ecmaVersion === 6 && this.type !== types.name)
      { this.unexpected(); }

    node.argument = this.parseBindingAtom();

    return this.finishNode(node, "RestElement")
  };


  pp$2.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
      case types.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern")

      case types.braceL:
        return this.parseObj(true)
      }
    }
    return this.parseIdent()
  };

  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first) { first = false; }
      else { this.expect(types.comma); }
      if (allowEmpty && this.type === types.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
        break
      } else if (this.type === types.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        this.expect(close);
        break
      } else {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        elts.push(elem);
      }
    }
    return elts
  };

  pp$2.parseBindingListItem = function(param) {
    return param
  };


  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern")
  };


  pp$2.checkLVal = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    switch (expr.type) {
    case "Identifier":
      if (bindingType === BIND_LEXICAL && expr.name === "let")
        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
        { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
      if (checkClashes) {
        if (has(checkClashes, expr.name))
          { this.raiseRecoverable(expr.start, "Argument name clash"); }
        checkClashes[expr.name] = true;
      }
      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
      break

    case "MemberExpression":
      if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
      break

    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1)
        {
      var prop = list[i];

      this.checkLVal(prop, bindingType, checkClashes);
    }
      break

    case "Property":
      this.checkLVal(expr.value, bindingType, checkClashes);
      break

    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];

      if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
      }
      break

    case "AssignmentPattern":
      this.checkLVal(expr.left, bindingType, checkClashes);
      break

    case "RestElement":
      this.checkLVal(expr.argument, bindingType, checkClashes);
      break

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, bindingType, checkClashes);
      break

    default:
      this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
    }
  };


  var pp$3 = Parser.prototype;


  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
      { return }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
      { return }
    var key = prop.key;
    var name;
    switch (key.type) {
    case "Identifier": name = key.name; break
    case "Literal": name = String(key.value); break
    default: return
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors) {
            if (refDestructuringErrors.doubleProto < 0)
              { refDestructuringErrors.doubleProto = key.start; }
          } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
        }
        propHash.proto = true;
      }
      return
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition)
        { this.raiseRecoverable(key.start, "Redefinition of property"); }
    } else {
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };




  pp$3.parseExpression = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
    if (this.type === types.comma) {
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];
      while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
      return this.finishNode(node, "SequenceExpression")
    }
    return expr
  };


  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) { return this.parseYield(noIn) }
      else { this.exprAllowed = false; }
    }

    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors;
      ownDestructuringErrors = true;
    }

    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types.parenL || this.type === types.name)
      { this.potentialArrowAt = this.start; }
    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
    if (this.type.isAssign) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
      if (!ownDestructuringErrors) {
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
      }
      if (refDestructuringErrors.shorthandAssign >= node.left.start)
        { refDestructuringErrors.shorthandAssign = -1; } 
      this.checkLVal(left);
      this.next();
      node.right = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "AssignmentExpression")
    } else {
      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
    }
    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
    return left
  };


  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(noIn, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    if (this.eat(types.question)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(types.colon);
      node.alternate = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "ConditionalExpression")
    }
    return expr
  };


  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
  };


  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    var prec = this.type.binop;
    if (prec != null && (!noIn || this.type !== types._in)) {
      if (prec > minPrec) {
        var logical = this.type === types.logicalOR || this.type === types.logicalAND;
        var op = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
      }
    }
    return left
  };

  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.operator = op;
    node.right = right;
    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
  };


  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
      expr = this.parseAwait();
      sawUnary = true;
    } else if (this.type.prefix) {
      var node = this.startNode(), update = this.type === types.incDec;
      node.operator = this.value;
      node.prefix = true;
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) { this.checkLVal(node.argument); }
      else if (this.strict && node.operator === "delete" &&
               node.argument.type === "Identifier")
        { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
      else { sawUnary = true; }
      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.operator = this.value;
        node$1.prefix = false;
        node$1.argument = expr;
        this.checkLVal(expr);
        this.next();
        expr = this.finishNode(node$1, "UpdateExpression");
      }
    }

    if (!sawUnary && this.eat(types.starstar))
      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
    else
      { return expr }
  };


  pp$3.parseExprSubscripts = function(refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
      { return expr }
    var result = this.parseSubscripts(expr, startPos, startLoc);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
    }
    return result
  };

  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
        this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
      if (element === base || element.type === "ArrowFunctionExpression") { return element }
      base = element;
    }
  };

  pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
    var computed = this.eat(types.bracketL);
    if (computed || this.eat(types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
      node.computed = !!computed;
      if (computed) { this.expect(types.bracketR); }
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0)
          { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types.backQuote) {
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({isTagged: true});
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base
  };


  pp$3.parseExprAtom = function(refDestructuringErrors) {
    if (this.type === types.slash) { this.readRegexp(); }

    var node, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
    case types._super:
      if (!this.allowSuper)
        { this.raise(this.start, "'super' keyword outside a method"); }
      node = this.startNode();
      this.next();
      if (this.type === types.parenL && !this.allowDirectSuper)
        { this.raise(node.start, "super() call outside constructor of a subclass"); }
      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
        { this.unexpected(); }
      return this.finishNode(node, "Super")

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression")

    case types.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
        { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types.arrow))
          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types.arrow))
            { this.unexpected(); }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
        }
      }
      return id

    case types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = {pattern: value.pattern, flags: value.flags};
      return node

    case types.num: case types.string:
      return this.parseLiteral(this.value)

    case types._null: case types._true: case types._false:
      node = this.startNode();
      node.value = this.type === types._null ? null : this.type === types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal")

    case types.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
          { refDestructuringErrors.parenthesizedAssign = start; }
        if (refDestructuringErrors.parenthesizedBind < 0)
          { refDestructuringErrors.parenthesizedBind = start; }
      }
      return expr

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression")

    case types.braceL:
      return this.parseObj(false, refDestructuringErrors)

    case types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0)

    case types._class:
      return this.parseClass(this.startNode(), false)

    case types._new:
      return this.parseNew()

    case types.backQuote:
      return this.parseTemplate()

    case types._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport()
      } else {
        return this.unexpected()
      }

    default:
      this.unexpected();
    }
  };

  pp$3.parseExprImport = function() {
    var node = this.startNode();
    this.next(); 
    switch (this.type) {
    case types.parenL:
      return this.parseDynamicImport(node)
    default:
      this.unexpected();
    }
  };

  pp$3.parseDynamicImport = function(node) {
    this.next(); 

    node.source = this.parseMaybeAssign();

    if (!this.eat(types.parenR)) {
      var errorPos = this.start;
      if (this.eat(types.comma) && this.eat(types.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }

    return this.finishNode(node, "ImportExpression")
  };

  pp$3.parseLiteral = function(value) {
    var node = this.startNode();
    node.value = value;
    node.raw = this.input.slice(this.start, this.end);
    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
    this.next();
    return this.finishNode(node, "Literal")
  };

  pp$3.parseParenExpression = function() {
    this.expect(types.parenL);
    var val = this.parseExpression();
    this.expect(types.parenR);
    return val
  };

  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();

      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      while (this.type !== types.parenR) {
        first ? first = false : this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
          lastIsComma = true;
          break
        } else if (this.type === types.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
          break
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.start, innerEndLoc = this.startLoc;
      this.expect(types.parenR);

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList)
      }

      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
      if (spreadStart) { this.unexpected(spreadStart); }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }

    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression")
    } else {
      return val
    }
  };

  pp$3.parseParenItem = function(item) {
    return item
  };

  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
  };


  var empty$1 = [];

  pp$3.parseNew = function() {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
    var node = this.startNode();
    var meta = this.parseIdent(true);
    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
      node.meta = meta;
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "target" || containsEsc)
        { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
      if (!this.inNonArrowFunction())
        { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
      return this.finishNode(node, "MetaProperty")
    }
    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    if (isImport && node.callee.type === "ImportExpression") {
      this.raise(startPos, "Cannot use new with import()");
    }
    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
    else { node.arguments = empty$1; }
    return this.finishNode(node, "NewExpression")
  };


  pp$3.parseTemplateElement = function(ref) {
    var isTagged = ref.isTagged;

    var elem = this.startNode();
    if (this.type === types.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value,
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types.backQuote;
    return this.finishNode(elem, "TemplateElement")
  };

  pp$3.parseTemplate = function(ref) {
    if ( ref === void 0 ) ref = {};
    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement({isTagged: isTagged});
    node.quasis = [curElt];
    while (!curElt.tail) {
      if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
      this.expect(types.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(types.braceR);
      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral")
  };

  pp$3.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };


  pp$3.parseObj = function(isPattern, refDestructuringErrors) {
    var node = this.startNode(), first = true, propHash = {};
    node.properties = [];
    this.next();
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
      node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
  };

  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement")
      }
      if (this.type === types.parenL && refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0) {
          refDestructuringErrors.parenthesizedAssign = this.start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = this.start;
        }
      }
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      return this.finishNode(prop, "SpreadElement")
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern)
        { isGenerator = this.eat(types.star); }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      this.parsePropertyName(prop, refDestructuringErrors);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property")
  };

  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types.colon)
      { this.unexpected(); }

    if (this.eat(types.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
      if (isPattern) { this.unexpected(); }
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc &&
               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
               (prop.key.name === "get" || prop.key.name === "set") &&
               (this.type !== types.comma && this.type !== types.braceR)) {
      if (isGenerator || isAsync) { this.unexpected(); }
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get")
          { this.raiseRecoverable(start, "getter should have no params"); }
        else
          { this.raiseRecoverable(start, "setter should have exactly one param"); }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
          { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
      }
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) { this.unexpected(); }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = startPos; }
      prop.kind = "init";
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else if (this.type === types.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0)
          { refDestructuringErrors.shorthandAssign = this.start; }
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else {
        prop.value = prop.key;
      }
      prop.shorthand = true;
    } else { this.unexpected(); }
  };

  pp$3.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types.bracketR);
        return prop.key
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
  };


  pp$3.initFunction = function(node) {
    node.id = null;
    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
    if (this.options.ecmaVersion >= 8) { node.async = false; }
  };


  pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.initFunction(node);
    if (this.options.ecmaVersion >= 6)
      { node.generator = isGenerator; }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node, false, true);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "FunctionExpression")
  };


  pp$3.parseArrowExpression = function(node, params, isAsync) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node);
    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;

    node.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node, true, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "ArrowFunctionExpression")
  };


  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
    var isExpression = isArrowFunction && this.type !== types.braceL;
    var oldStrict = this.strict, useStrict = false;

    if (isExpression) {
      node.body = this.parseMaybeAssign();
      node.expression = true;
      this.checkParams(node, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        if (useStrict && nonSimple)
          { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
      }
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) { this.strict = true; }

      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
      node.body = this.parseBlock(false);
      node.expression = false;
      this.adaptDirectivePrologue(node.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();

    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
    this.strict = oldStrict;
  };

  pp$3.isSimpleParamList = function(params) {
    for (var i = 0, list = params; i < list.length; i += 1)
      {
      var param = list[i];

      if (param.type !== "Identifier") { return false
    } }
    return true
  };


  pp$3.checkParams = function(node, allowDuplicates) {
    var nameHash = {};
    for (var i = 0, list = node.params; i < list.length; i += 1)
      {
      var param = list[i];

      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };


  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (!first) {
        this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(close)) { break }
      } else { first = false; }

      var elt = (void 0);
      if (allowEmpty && this.type === types.comma)
        { elt = null; }
      else if (this.type === types.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
          { refDestructuringErrors.trailingComma = this.start; }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts
  };

  pp$3.checkUnreserved = function(ref) {
    var start = ref.start;
    var end = ref.end;
    var name = ref.name;

    if (this.inGenerator && name === "yield")
      { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
    if (this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
    if (this.keywords.test(name))
      { this.raise(start, ("Unexpected keyword '" + name + "'")); }
    if (this.options.ecmaVersion < 6 &&
      this.input.slice(start, end).indexOf("\\") !== -1) { return }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name)) {
      if (!this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
      this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
    }
  };


  pp$3.parseIdent = function(liberal, isBinding) {
    var node = this.startNode();
    if (this.type === types.name) {
      node.name = this.value;
    } else if (this.type.keyword) {
      node.name = this.type.keyword;

      if ((node.name === "class" || node.name === "function") &&
          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
    } else {
      this.unexpected();
    }
    this.next(!!liberal);
    this.finishNode(node, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node);
      if (node.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = node.start; }
    }
    return node
  };


  pp$3.parseYield = function(noIn) {
    if (!this.yieldPos) { this.yieldPos = this.start; }

    var node = this.startNode();
    this.next();
    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(types.star);
      node.argument = this.parseMaybeAssign(noIn);
    }
    return this.finishNode(node, "YieldExpression")
  };

  pp$3.parseAwait = function() {
    if (!this.awaitPos) { this.awaitPos = this.start; }

    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(null, false);
    return this.finishNode(node, "AwaitExpression")
  };

  var pp$4 = Parser.prototype;


  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
    throw err
  };

  pp$4.raiseRecoverable = pp$4.raise;

  pp$4.curPosition = function() {
    if (this.options.locations) {
      return new Position(this.curLine, this.pos - this.lineStart)
    }
  };

  var pp$5 = Parser.prototype;

  var Scope = function Scope(flags) {
    this.flags = flags;
    this.var = [];
    this.lexical = [];
    this.functions = [];
  };


  pp$5.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
  };

  pp$5.exitScope = function() {
    this.scopeStack.pop();
  };

  pp$5.treatFunctionsAsVarInScope = function(scope) {
    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
  };

  pp$5.declareName = function(name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope = this.currentScope();
      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      scope.lexical.push(name);
      if (this.inModule && (scope.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$1 = this.currentScope();
      scope$1.lexical.push(name);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar)
        { redeclared = scope$2.lexical.indexOf(name) > -1; }
      else
        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
      scope$2.functions.push(name);
    } else {
      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
        var scope$3 = this.scopeStack[i];
        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
          redeclared = true;
          break
        }
        scope$3.var.push(name);
        if (this.inModule && (scope$3.flags & SCOPE_TOP))
          { delete this.undefinedExports[name]; }
        if (scope$3.flags & SCOPE_VAR) { break }
      }
    }
    if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
  };

  pp$5.checkLocalExport = function(id) {
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
        this.scopeStack[0].var.indexOf(id.name) === -1) {
      this.undefinedExports[id.name] = id;
    }
  };

  pp$5.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1]
  };

  pp$5.currentVarScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR) { return scope }
    }
  };

  pp$5.currentThisScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
    }
  };

  var Node = function Node(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations)
      { this.loc = new SourceLocation(parser, loc); }
    if (parser.options.directSourceFile)
      { this.sourceFile = parser.options.directSourceFile; }
    if (parser.options.ranges)
      { this.range = [pos, 0]; }
  };


  var pp$6 = Parser.prototype;

  pp$6.startNode = function() {
    return new Node(this, this.start, this.startLoc)
  };

  pp$6.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc)
  };


  function finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    if (this.options.locations)
      { node.loc.end = loc; }
    if (this.options.ranges)
      { node.range[1] = pos; }
    return node
  }

  pp$6.finishNode = function(node, type) {
    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
  };


  pp$6.finishNodeAt = function(node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc)
  };


  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };

  var types$1 = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };

  var pp$7 = Parser.prototype;

  pp$7.initialContext = function() {
    return [types$1.b_stat]
  };

  pp$7.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types$1.f_expr || parent === types$1.f_stat)
      { return true }
    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
      { return !parent.isExpr }

    if (prevType === types._return || prevType === types.name && this.exprAllowed)
      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
      { return true }
    if (prevType === types.braceL)
      { return parent === types$1.b_stat }
    if (prevType === types._var || prevType === types._const || prevType === types.name)
      { return false }
    return !this.exprAllowed
  };

  pp$7.inGeneratorContext = function() {
    for (var i = this.context.length - 1; i >= 1; i--) {
      var context = this.context[i];
      if (context.token === "function")
        { return context.generator }
    }
    return false
  };

  pp$7.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types.dot)
      { this.exprAllowed = false; }
    else if (update = type.updateContext)
      { update.call(this, prevType); }
    else
      { this.exprAllowed = type.beforeExpr; }
  };


  types.parenR.updateContext = types.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return
    }
    var out = this.context.pop();
    if (out === types$1.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };

  types.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
    this.exprAllowed = true;
  };

  types.dollarBraceL.updateContext = function() {
    this.context.push(types$1.b_tmpl);
    this.exprAllowed = true;
  };

  types.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
    this.exprAllowed = true;
  };

  types.incDec.updateContext = function() {
  };

  types._function.updateContext = types._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
        !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
      { this.context.push(types$1.f_expr); }
    else
      { this.context.push(types$1.f_stat); }
    this.exprAllowed = false;
  };

  types.backQuote.updateContext = function() {
    if (this.curContext() === types$1.q_tmpl)
      { this.context.pop(); }
    else
      { this.context.push(types$1.q_tmpl); }
    this.exprAllowed = false;
  };

  types.star.updateContext = function(prevType) {
    if (prevType === types._function) {
      var index = this.context.length - 1;
      if (this.context[index] === types$1.f_expr)
        { this.context[index] = types$1.f_expr_gen; }
      else
        { this.context[index] = types$1.f_gen; }
    }
    this.exprAllowed = true;
  };

  types.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
      if (this.value === "of" && !this.exprAllowed ||
          this.value === "yield" && this.inGeneratorContext())
        { allowed = true; }
    }
    this.exprAllowed = allowed;
  };


  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties
  };

  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

  var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues
  };

  var data = {};
  function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;

    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  buildUnicodeData(9);
  buildUnicodeData(10);
  buildUnicodeData(11);

  var pp$8 = Parser.prototype;

  var RegExpValidationState = function RegExpValidationState(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = [];
    this.backReferenceNames = [];
  };

  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  };

  RegExpValidationState.prototype.raise = function raise (message) {
    this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
  };

  RegExpValidationState.prototype.at = function at (i) {
    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return -1
    }
    var c = s.charCodeAt(i);
    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
      return c
    }
    var next = s.charCodeAt(i + 1);
    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
  };

  RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return l
    }
    var c = s.charCodeAt(i), next;
    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
      return i + 1
    }
    return i + 2
  };

  RegExpValidationState.prototype.current = function current () {
    return this.at(this.pos)
  };

  RegExpValidationState.prototype.lookahead = function lookahead () {
    return this.at(this.nextIndex(this.pos))
  };

  RegExpValidationState.prototype.advance = function advance () {
    this.pos = this.nextIndex(this.pos);
  };

  RegExpValidationState.prototype.eat = function eat (ch) {
    if (this.current() === ch) {
      this.advance();
      return true
    }
    return false
  };

  function codePointToString(ch) {
    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
    ch -= 0x10000;
    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
  }

  pp$8.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;

    for (var i = 0; i < flags.length; i++) {
      var flag = flags.charAt(i);
      if (validFlags.indexOf(flag) === -1) {
        this.raise(state.start, "Invalid regular expression flag");
      }
      if (flags.indexOf(flag, i + 1) > -1) {
        this.raise(state.start, "Duplicate regular expression flag");
      }
    }
  };

  pp$8.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);

    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };

  pp$8.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames.length = 0;
    state.backReferenceNames.length = 0;

    this.regexp_disjunction(state);

    if (state.pos !== state.source.length) {
      if (state.eat(0x29 )) {
        state.raise("Unmatched ')'");
      }
      if (state.eat(0x5D ) || state.eat(0x7D )) {
        state.raise("Lone quantifier brackets");
      }
    }
    if (state.maxBackReference > state.numCapturingParens) {
      state.raise("Invalid escape");
    }
    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
      var name = list[i];

      if (state.groupNames.indexOf(name) === -1) {
        state.raise("Invalid named capture referenced");
      }
    }
  };

  pp$8.regexp_disjunction = function(state) {
    this.regexp_alternative(state);
    while (state.eat(0x7C )) {
      this.regexp_alternative(state);
    }

    if (this.regexp_eatQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    if (state.eat(0x7B )) {
      state.raise("Lone quantifier brackets");
    }
  };

  pp$8.regexp_alternative = function(state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state))
      { }
  };

  pp$8.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        if (state.switchU) {
          state.raise("Invalid quantifier");
        }
      }
      return true
    }

    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true
    }

    return false
  };

  pp$8.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;

    if (state.eat(0x5E ) || state.eat(0x24 )) {
      return true
    }

    if (state.eat(0x5C )) {
      if (state.eat(0x42 ) || state.eat(0x62 )) {
        return true
      }
      state.pos = start;
    }

    if (state.eat(0x28 ) && state.eat(0x3F )) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9) {
        lookbehind = state.eat(0x3C );
      }
      if (state.eat(0x3D ) || state.eat(0x21 )) {
        this.regexp_disjunction(state);
        if (!state.eat(0x29 )) {
          state.raise("Unterminated group");
        }
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true
      }
    }

    state.pos = start;
    return false
  };

  pp$8.regexp_eatQuantifier = function(state, noError) {
    if ( noError === void 0 ) noError = false;

    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(0x3F );
      return true
    }
    return false
  };

  pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
    return (
      state.eat(0x2A ) ||
      state.eat(0x2B ) ||
      state.eat(0x3F ) ||
      this.regexp_eatBracedQuantifier(state, noError)
    )
  };
  pp$8.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(0x7B )) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(0x2C ) && this.regexp_eatDecimalDigits(state)) {
          max = state.lastIntValue;
        }
        if (state.eat(0x7D )) {
          if (max !== -1 && max < min && !noError) {
            state.raise("numbers out of order in {} quantifier");
          }
          return true
        }
      }
      if (state.switchU && !noError) {
        state.raise("Incomplete quantifier");
      }
      state.pos = start;
    }
    return false
  };

  pp$8.regexp_eatAtom = function(state) {
    return (
      this.regexp_eatPatternCharacters(state) ||
      state.eat(0x2E ) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state)
    )
  };
  pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(0x5C )) {
      if (this.regexp_eatAtomEscape(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(0x28 )) {
      if (state.eat(0x3F ) && state.eat(0x3A )) {
        this.regexp_disjunction(state);
        if (state.eat(0x29 )) {
          return true
        }
        state.raise("Unterminated group");
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatCapturingGroup = function(state) {
    if (state.eat(0x28 )) {
      if (this.options.ecmaVersion >= 9) {
        this.regexp_groupSpecifier(state);
      } else if (state.current() === 0x3F ) {
        state.raise("Invalid group");
      }
      this.regexp_disjunction(state);
      if (state.eat(0x29 )) {
        state.numCapturingParens += 1;
        return true
      }
      state.raise("Unterminated group");
    }
    return false
  };

  pp$8.regexp_eatExtendedAtom = function(state) {
    return (
      state.eat(0x2E ) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state) ||
      this.regexp_eatInvalidBracedQuantifier(state) ||
      this.regexp_eatExtendedPatternCharacter(state)
    )
  };

  pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    return false
  };

  pp$8.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }
    return false
  };
  function isSyntaxCharacter(ch) {
    return (
      ch === 0x24  ||
      ch >= 0x28  && ch <= 0x2B  ||
      ch === 0x2E  ||
      ch === 0x3F  ||
      ch >= 0x5B  && ch <= 0x5E  ||
      ch >= 0x7B  && ch <= 0x7D 
    )
  }

  pp$8.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch = 0;
    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
      state.advance();
    }
    return state.pos !== start
  };

  pp$8.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (
      ch !== -1 &&
      ch !== 0x24  &&
      !(ch >= 0x28  && ch <= 0x2B ) &&
      ch !== 0x2E  &&
      ch !== 0x3F  &&
      ch !== 0x5B  &&
      ch !== 0x5E  &&
      ch !== 0x7C 
    ) {
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_groupSpecifier = function(state) {
    if (state.eat(0x3F )) {
      if (this.regexp_eatGroupName(state)) {
        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
          state.raise("Duplicate capture group name");
        }
        state.groupNames.push(state.lastStringValue);
        return
      }
      state.raise("Invalid group");
    }
  };

  pp$8.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(0x3C )) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E )) {
        return true
      }
      state.raise("Invalid capture group name");
    }
    return false
  };

  pp$8.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
      }
      return true
    }
    return false
  };

  pp$8.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var ch = state.current();
    state.advance();

    if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierStart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 0x24  || ch === 0x5F 
  }

  pp$8.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var ch = state.current();
    state.advance();

    if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierPart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 0x24  || ch === 0x5F  || ch === 0x200C  || ch === 0x200D 
  }

  pp$8.regexp_eatAtomEscape = function(state) {
    if (
      this.regexp_eatBackReference(state) ||
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state) ||
      (state.switchN && this.regexp_eatKGroupName(state))
    ) {
      return true
    }
    if (state.switchU) {
      if (state.current() === 0x63 ) {
        state.raise("Invalid unicode escape");
      }
      state.raise("Invalid escape");
    }
    return false
  };
  pp$8.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n = state.lastIntValue;
      if (state.switchU) {
        if (n > state.maxBackReference) {
          state.maxBackReference = n;
        }
        return true
      }
      if (n <= state.numCapturingParens) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatKGroupName = function(state) {
    if (state.eat(0x6B )) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true
      }
      state.raise("Invalid named reference");
    }
    return false
  };

  pp$8.regexp_eatCharacterEscape = function(state) {
    return (
      this.regexp_eatControlEscape(state) ||
      this.regexp_eatCControlLetter(state) ||
      this.regexp_eatZero(state) ||
      this.regexp_eatHexEscapeSequence(state) ||
      this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
      this.regexp_eatIdentityEscape(state)
    )
  };
  pp$8.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(0x63 )) {
      if (this.regexp_eatControlLetter(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatZero = function(state) {
    if (state.current() === 0x30  && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 0x74 ) {
      state.lastIntValue = 0x09; 
      state.advance();
      return true
    }
    if (ch === 0x6E ) {
      state.lastIntValue = 0x0A; 
      state.advance();
      return true
    }
    if (ch === 0x76 ) {
      state.lastIntValue = 0x0B; 
      state.advance();
      return true
    }
    if (ch === 0x66 ) {
      state.lastIntValue = 0x0C; 
      state.advance();
      return true
    }
    if (ch === 0x72 ) {
      state.lastIntValue = 0x0D; 
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };
  function isControlLetter(ch) {
    return (
      (ch >= 0x41  && ch <= 0x5A ) ||
      (ch >= 0x61  && ch <= 0x7A )
    )
  }

  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
    var start = state.pos;

    if (state.eat(0x75 )) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(0x5C ) && state.eat(0x75 ) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 0xDC00 && trail <= 0xDFFF) {
              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
              return true
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true
      }
      if (
        state.switchU &&
        state.eat(0x7B ) &&
        this.regexp_eatHexDigits(state) &&
        state.eat(0x7D ) &&
        isValidUnicode(state.lastIntValue)
      ) {
        return true
      }
      if (state.switchU) {
        state.raise("Invalid unicode escape");
      }
      state.pos = start;
    }

    return false
  };
  function isValidUnicode(ch) {
    return ch >= 0 && ch <= 0x10FFFF
  }

  pp$8.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state)) {
        return true
      }
      if (state.eat(0x2F )) {
        state.lastIntValue = 0x2F; 
        return true
      }
      return false
    }

    var ch = state.current();
    if (ch !== 0x63  && (!state.switchN || ch !== 0x6B )) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  pp$8.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 0x31  && ch <= 0x39 ) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );
        state.advance();
      } while ((ch = state.current()) >= 0x30  && ch <= 0x39 )
      return true
    }
    return false
  };

  pp$8.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();

    if (isCharacterClassEscape(ch)) {
      state.lastIntValue = -1;
      state.advance();
      return true
    }

    if (
      state.switchU &&
      this.options.ecmaVersion >= 9 &&
      (ch === 0x50  || ch === 0x70 )
    ) {
      state.lastIntValue = -1;
      state.advance();
      if (
        state.eat(0x7B ) &&
        this.regexp_eatUnicodePropertyValueExpression(state) &&
        state.eat(0x7D )
      ) {
        return true
      }
      state.raise("Invalid property name");
    }

    return false
  };
  function isCharacterClassEscape(ch) {
    return (
      ch === 0x64  ||
      ch === 0x44  ||
      ch === 0x73  ||
      ch === 0x53  ||
      ch === 0x77  ||
      ch === 0x57 
    )
  }

  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;

    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D )) {
      var name = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
        return true
      }
    }
    state.pos = start;

    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
      return true
    }
    return false
  };
  pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
    if (!has(state.unicodeProperties.nonBinary, name))
      { state.raise("Invalid property name"); }
    if (!state.unicodeProperties.nonBinary[name].test(value))
      { state.raise("Invalid property value"); }
  };
  pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (!state.unicodeProperties.binary.test(nameOrValue))
      { state.raise("Invalid property name"); }
  };

  pp$8.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 0x5F 
  }

  pp$8.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
  }

  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state)
  };

  pp$8.regexp_eatCharacterClass = function(state) {
    if (state.eat(0x5B )) {
      state.eat(0x5E );
      this.regexp_classRanges(state);
      if (state.eat(0x5D )) {
        return true
      }
      state.raise("Unterminated character class");
    }
    return false
  };

  pp$8.regexp_classRanges = function(state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(0x2D ) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1)) {
          state.raise("Invalid character class");
        }
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
      }
    }
  };

  pp$8.regexp_eatClassAtom = function(state) {
    var start = state.pos;

    if (state.eat(0x5C )) {
      if (this.regexp_eatClassEscape(state)) {
        return true
      }
      if (state.switchU) {
        var ch$1 = state.current();
        if (ch$1 === 0x63  || isOctalDigit(ch$1)) {
          state.raise("Invalid class escape");
        }
        state.raise("Invalid escape");
      }
      state.pos = start;
    }

    var ch = state.current();
    if (ch !== 0x5D ) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  pp$8.regexp_eatClassEscape = function(state) {
    var start = state.pos;

    if (state.eat(0x62 )) {
      state.lastIntValue = 0x08; 
      return true
    }

    if (state.switchU && state.eat(0x2D )) {
      state.lastIntValue = 0x2D; 
      return true
    }

    if (!state.switchU && state.eat(0x63 )) {
      if (this.regexp_eatClassControlLetter(state)) {
        return true
      }
      state.pos = start;
    }

    return (
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state)
    )
  };

  pp$8.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 0x5F ) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(0x78 )) {
      if (this.regexp_eatFixedHexDigits(state, 2)) {
        return true
      }
      if (state.switchU) {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return false
  };

  pp$8.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );
      state.advance();
    }
    return state.pos !== start
  };
  function isDecimalDigit(ch) {
    return ch >= 0x30  && ch <= 0x39 
  }

  pp$8.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isHexDigit(ch = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return state.pos !== start
  };
  function isHexDigit(ch) {
    return (
      (ch >= 0x30  && ch <= 0x39 ) ||
      (ch >= 0x41  && ch <= 0x46 ) ||
      (ch >= 0x61  && ch <= 0x66 )
    )
  }
  function hexToInt(ch) {
    if (ch >= 0x41  && ch <= 0x46 ) {
      return 10 + (ch - 0x41 )
    }
    if (ch >= 0x61  && ch <= 0x66 ) {
      return 10 + (ch - 0x61 )
    }
    return ch - 0x30 
  }

  pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
        } else {
          state.lastIntValue = n1 * 8 + n2;
        }
      } else {
        state.lastIntValue = n1;
      }
      return true
    }
    return false
  };

  pp$8.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
      state.lastIntValue = ch - 0x30; 
      state.advance();
      return true
    }
    state.lastIntValue = 0;
    return false
  };
  function isOctalDigit(ch) {
    return ch >= 0x30  && ch <= 0x37 
  }

  pp$8.regexp_eatFixedHexDigits = function(state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i = 0; i < length; ++i) {
      var ch = state.current();
      if (!isHexDigit(ch)) {
        state.pos = start;
        return false
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return true
  };


  var Token = function Token(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations)
      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
    if (p.options.ranges)
      { this.range = [p.start, p.end]; }
  };


  var pp$9 = Parser.prototype;


  pp$9.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
      { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
    if (this.options.onToken)
      { this.options.onToken(new Token(this)); }

    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };

  pp$9.getToken = function() {
    this.next();
    return new Token(this)
  };

  if (typeof Symbol !== "undefined")
    { pp$9[Symbol.iterator] = function() {
      var this$1 = this;

      return {
        next: function () {
          var token = this$1.getToken();
          return {
            done: token.type === types.eof,
            value: token
          }
        }
      }
    }; }


  pp$9.curContext = function() {
    return this.context[this.context.length - 1]
  };


  pp$9.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

    this.start = this.pos;
    if (this.options.locations) { this.startLoc = this.curPosition(); }
    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

    if (curContext.override) { return curContext.override(this) }
    else { this.readToken(this.fullCharCodeAtPos()); }
  };

  pp$9.readToken = function(code) {
    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 )
      { return this.readWord() }

    return this.getTokenFromCode(code)
  };

  pp$9.fullCharCodeAtPos = function() {
    var code = this.input.charCodeAt(this.pos);
    if (code <= 0xd7ff || code >= 0xe000) { return code }
    var next = this.input.charCodeAt(this.pos + 1);
    return (code << 10) + next - 0x35fdc00
  };

  pp$9.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
    this.pos = end + 2;
    if (this.options.locations) {
      lineBreakG.lastIndex = start;
      var match;
      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
        ++this.curLine;
        this.lineStart = match.index + match[0].length;
      }
    }
    if (this.options.onComment)
      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  pp$9.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch)) {
      ch = this.input.charCodeAt(++this.pos);
    }
    if (this.options.onComment)
      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                             startLoc, this.curPosition()); }
  };


  pp$9.skipSpace = function() {
    loop: while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
      case 32: case 160: 
        ++this.pos;
        break
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10: case 8232: case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break
      case 47: 
        switch (this.input.charCodeAt(this.pos + 1)) {
        case 42: 
          this.skipBlockComment();
          break
        case 47:
          this.skipLineComment(2);
          break
        default:
          break loop
        }
        break
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop
        }
      }
    }
  };


  pp$9.finishToken = function(type, val) {
    this.end = this.pos;
    if (this.options.locations) { this.endLoc = this.curPosition(); }
    var prevType = this.type;
    this.type = type;
    this.value = val;

    this.updateContext(prevType);
  };


  pp$9.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) { return this.readNumber(true) }
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { 
      this.pos += 3;
      return this.finishToken(types.ellipsis)
    } else {
      ++this.pos;
      return this.finishToken(types.dot)
    }
  };

  pp$9.readToken_slash = function() { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.slash, 1)
  };

  pp$9.readToken_mult_modulo_exp = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code === 42 ? types.star : types.modulo;

    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
      ++size;
      tokentype = types.starstar;
      next = this.input.charCodeAt(this.pos + 2);
    }

    if (next === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(tokentype, size)
  };

  pp$9.readToken_pipe_amp = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
  };

  pp$9.readToken_caret = function() { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.bitwiseXOR, 1)
  };

  pp$9.readToken_plus_min = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken()
      }
      return this.finishOp(types.incDec, 2)
    }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.plusMin, 1)
  };

  pp$9.readToken_lt_gt = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
      return this.finishOp(types.bitShift, size)
    }
    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
        this.input.charCodeAt(this.pos + 3) === 45) {
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken()
    }
    if (next === 61) { size = 2; }
    return this.finishOp(types.relational, size)
  };

  pp$9.readToken_eq_excl = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { 
      this.pos += 2;
      return this.finishToken(types.arrow)
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
  };

  pp$9.getTokenFromCode = function(code) {
    switch (code) {
    case 46: 
      return this.readToken_dot()

    case 40: ++this.pos; return this.finishToken(types.parenL)
    case 41: ++this.pos; return this.finishToken(types.parenR)
    case 59: ++this.pos; return this.finishToken(types.semi)
    case 44: ++this.pos; return this.finishToken(types.comma)
    case 91: ++this.pos; return this.finishToken(types.bracketL)
    case 93: ++this.pos; return this.finishToken(types.bracketR)
    case 123: ++this.pos; return this.finishToken(types.braceL)
    case 125: ++this.pos; return this.finishToken(types.braceR)
    case 58: ++this.pos; return this.finishToken(types.colon)
    case 63: ++this.pos; return this.finishToken(types.question)

    case 96: 
      if (this.options.ecmaVersion < 6) { break }
      ++this.pos;
      return this.finishToken(types.backQuote)

    case 48: 
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) { return this.readRadixNumber(16) } 
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) { return this.readRadixNumber(8) } 
        if (next === 98 || next === 66) { return this.readRadixNumber(2) } 
      }

    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: 
      return this.readNumber(false)

    case 34: case 39: 
      return this.readString(code)


    case 47: 
      return this.readToken_slash()

    case 37: case 42: 
      return this.readToken_mult_modulo_exp(code)

    case 124: case 38: 
      return this.readToken_pipe_amp(code)

    case 94: 
      return this.readToken_caret()

    case 43: case 45: 
      return this.readToken_plus_min(code)

    case 60: case 62: 
      return this.readToken_lt_gt(code)

    case 61: case 33: 
      return this.readToken_eq_excl(code)

    case 126: 
      return this.finishOp(types.prefix, 1)
    }

    this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
  };

  pp$9.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str)
  };

  pp$9.readRegexp = function() {
    var escaped, inClass, start = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
      if (!escaped) {
        if (ch === "[") { inClass = true; }
        else if (ch === "]" && inClass) { inClass = false; }
        else if (ch === "/" && !inClass) { break }
        escaped = ch === "\\";
      } else { escaped = false; }
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) { this.unexpected(flagsStart); }

    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);

    var value = null;
    try {
      value = new RegExp(pattern, flags);
    } catch (e) {
    }

    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
  };


  pp$9.readInt = function(radix, len) {
    var start = this.pos, total = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = this.input.charCodeAt(this.pos), val = (void 0);
      if (code >= 97) { val = code - 97 + 10; } 
      else if (code >= 65) { val = code - 65 + 10; } 
      else if (code >= 48 && code <= 57) { val = code - 48; } 
      else { val = Infinity; }
      if (val >= radix) { break }
      ++this.pos;
      total = total * radix + val;
    }
    if (this.pos === start || len != null && this.pos - start !== len) { return null }

    return total
  };

  pp$9.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2; 
    var val = this.readInt(radix);
    if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
      ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val)
  };


  pp$9.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) { this.raise(start, "Invalid number"); }
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
      var str$1 = this.input.slice(start, this.pos);
      var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
      ++this.pos;
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types.num, val$1)
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
    if (next === 46 && !octal) { 
      ++this.pos;
      this.readInt(10);
      next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) { 
      next = this.input.charCodeAt(++this.pos);
      if (next === 43 || next === 45) { ++this.pos; } 
      if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

    var str = this.input.slice(start, this.pos);
    var val = octal ? parseInt(str, 8) : parseFloat(str);
    return this.finishToken(types.num, val)
  };


  pp$9.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code;

    if (ch === 123) { 
      if (this.options.ecmaVersion < 6) { this.unexpected(); }
      var codePos = ++this.pos;
      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
    } else {
      code = this.readHexChar(4);
    }
    return code
  };

  function codePointToString$1(code) {
    if (code <= 0xFFFF) { return String.fromCharCode(code) }
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
  }

  pp$9.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) { break }
      if (ch === 92) { 
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else {
        if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types.string, out)
  };


  var INVALID_TEMPLATE_ESCAPE_ERROR = {};

  pp$9.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
        this.readInvalidTemplateToken();
      } else {
        throw err
      }
    }

    this.inTemplateElement = false;
  };

  pp$9.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
      throw INVALID_TEMPLATE_ESCAPE_ERROR
    } else {
      this.raise(position, message);
    }
  };

  pp$9.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { 
        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
          if (ch === 36) {
            this.pos += 2;
            return this.finishToken(types.dollarBraceL)
          } else {
            ++this.pos;
            return this.finishToken(types.backQuote)
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types.template, out)
      }
      if (ch === 92) { 
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
        case 10:
          out += "\n";
          break
        default:
          out += String.fromCharCode(ch);
          break
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
  };

  pp$9.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++) {
      switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break

      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break
        }

      case "`":
        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

      }
    }
    this.raise(this.start, "Unterminated template");
  };


  pp$9.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch) {
    case 110: return "\n" 
    case 114: return "\r" 
    case 120: return String.fromCharCode(this.readHexChar(2)) 
    case 117: return codePointToString$1(this.readCodePoint()) 
    case 116: return "\t" 
    case 98: return "\b" 
    case 118: return "\u000b" 
    case 102: return "\f" 
    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } 
    case 10: 
      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
      return ""
    case 56:
    case 57:
      if (inTemplate) {
        var codePos = this.pos - 1;

        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );

        return null
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate
              ? "Octal literal in template string"
              : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal)
      }
      if (isNewLine(ch)) {
        return ""
      }
      return String.fromCharCode(ch)
    }
  };


  pp$9.readHexChar = function(len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
    return n
  };


  pp$9.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral)) {
        this.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) { 
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117) 
          { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
          { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
        word += codePointToString$1(esc);
        chunkStart = this.pos;
      } else {
        break
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos)
  };


  pp$9.readWord = function() {
    var word = this.readWord1();
    var type = types.name;
    if (this.keywords.test(word)) {
      type = keywords$1[word];
    }
    return this.finishToken(type, word)
  };


  var version = "7.1.0";

  Parser.acorn = {
    Parser: Parser,
    version: version,
    defaultOptions: defaultOptions,
    Position: Position,
    SourceLocation: SourceLocation,
    getLineInfo: getLineInfo,
    Node: Node,
    TokenType: TokenType,
    tokTypes: types,
    keywordTypes: keywords$1,
    TokContext: TokContext,
    tokContexts: types$1,
    isIdentifierChar: isIdentifierChar,
    isIdentifierStart: isIdentifierStart,
    Token: Token,
    isNewLine: isNewLine,
    lineBreak: lineBreak,
    lineBreakG: lineBreakG,
    nonASCIIwhitespace: nonASCIIwhitespace
  };


  function parse(input, options) {
    return Parser.parse(input, options)
  }


  function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options)
  }


  function tokenizer(input, options) {
    return Parser.tokenizer(input, options)
  }

  exports.Node = Node;
  exports.Parser = Parser;
  exports.Position = Position;
  exports.SourceLocation = SourceLocation;
  exports.TokContext = TokContext;
  exports.Token = Token;
  exports.TokenType = TokenType;
  exports.defaultOptions = defaultOptions;
  exports.getLineInfo = getLineInfo;
  exports.isIdentifierChar = isIdentifierChar;
  exports.isIdentifierStart = isIdentifierStart;
  exports.isNewLine = isNewLine;
  exports.keywordTypes = keywords$1;
  exports.lineBreak = lineBreak;
  exports.lineBreakG = lineBreakG;
  exports.nonASCIIwhitespace = nonASCIIwhitespace;
  exports.parse = parse;
  exports.parseExpressionAt = parseExpressionAt;
  exports.tokContexts = types$1;
  exports.tokTypes = types;
  exports.tokenizer = tokenizer;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
function glWiretap(gl, options = {}) {
  const {
    contextName = 'gl',
    throwGetError,
    useTrackablePrimitives,
    readPixelsFile,
    recording = [],
    variables = {},
    onReadPixels,
    onUnrecognizedArgumentLookup,
  } = options;
  const proxy = new Proxy(gl, { get: listen });
  const contextVariables = [];
  const entityNames = {};
  let imageCount = 0;
  let indent = '';
  let readPixelsVariableName;
  return proxy;
  function listen(obj, property) {
    switch (property) {
      case 'addComment': return addComment;
      case 'checkThrowError': return checkThrowError;
      case 'getReadPixelsVariableName': return readPixelsVariableName;
      case 'insertVariable': return insertVariable;
      case 'reset': return reset;
      case 'setIndent': return setIndent;
      case 'toString': return toString;
      case 'getContextVariableName': return getContextVariableName;
    }
    if (typeof gl[property] === 'function') {
      return function() { 
        switch (property) {
          case 'getError':
            if (throwGetError) {
              recording.push(`${indent}if (${contextName}.getError() !== ${contextName}.NONE) throw new Error('error');`);
            } else {
              recording.push(`${indent}${contextName}.getError();`); 
            }
            return gl.getError();
          case 'getExtension': {
            const variableName = `${contextName}Variables${contextVariables.length}`;
            recording.push(`${indent}const ${variableName} = ${contextName}.getExtension('${arguments[0]}');`);
            const extension = gl.getExtension(arguments[0]);
            if (extension && typeof extension === 'object') {
              const tappedExtension = glExtensionWiretap(extension, {
                getEntity,
                useTrackablePrimitives,
                recording,
                contextName: variableName,
                contextVariables,
                variables,
                indent,
                onUnrecognizedArgumentLookup,
              });
              contextVariables.push(tappedExtension);
              return tappedExtension;
            } else {
              contextVariables.push(null);
            }
            return extension;
          }
          case 'readPixels':
            const i = contextVariables.indexOf(arguments[6]);
            let targetVariableName;
            if (i === -1) {
              const variableName = getVariableName(arguments[6]);
              if (variableName) {
                targetVariableName = variableName;
                recording.push(`${indent}${variableName}`);
              } else {
                targetVariableName = `${contextName}Variable${contextVariables.length}`;
                contextVariables.push(arguments[6]);
                recording.push(`${indent}const ${targetVariableName} = new ${arguments[6].constructor.name}(${arguments[6].length});`);
              }
            } else {
              targetVariableName = `${contextName}Variable${i}`;
            }
            readPixelsVariableName = targetVariableName;
            const argumentAsStrings = [
              arguments[0],
              arguments[1],
              arguments[2],
              arguments[3],
              getEntity(arguments[4]),
              getEntity(arguments[5]),
              targetVariableName
            ];
            recording.push(`${indent}${contextName}.readPixels(${argumentAsStrings.join(', ')});`);
            if (readPixelsFile) {
              writePPM(arguments[2], arguments[3]);
            }
            if (onReadPixels) {
              onReadPixels(targetVariableName, argumentAsStrings);
            }
            return gl.readPixels.apply(gl, arguments);
          case 'drawBuffers':
            recording.push(`${indent}${contextName}.drawBuffers([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup } )}]);`);
            return gl.drawBuffers(arguments[0]);
        }
        let result = gl[property].apply(gl, arguments);
        switch (typeof result) {
          case 'undefined':
            recording.push(`${indent}${methodCallToString(property, arguments)};`);
            return;
          case 'number':
          case 'boolean':
            if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result = trackablePrimitive(result));
              break;
            }
          default:
            if (result === null) {
              recording.push(`${methodCallToString(property, arguments)};`);
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
            }

            contextVariables.push(result);
        }
        return result;
      }
    }
    entityNames[gl[property]] = property;
    return gl[property];
  }
  function toString() {
    return recording.join('\n');
  }
  function reset() {
    while (recording.length > 0) {
      recording.pop();
    }
  }
  function insertVariable(name, value) {
    variables[name] = value;
  }
  function getEntity(value) {
    const name = entityNames[value];
    if (name) {
      return contextName + '.' + name;
    }
    return value;
  }
  function setIndent(spaces) {
    indent = ' '.repeat(spaces);
  }
  function addVariable(value, source) {
    const variableName = `${contextName}Variable${contextVariables.length}`;
    recording.push(`${indent}const ${variableName} = ${source};`);
    contextVariables.push(value);
    return variableName;
  }
  function writePPM(width, height) {
    const sourceVariable = `${contextName}Variable${contextVariables.length}`;
    const imageVariable = `imageDatum${imageCount}`;
    recording.push(`${indent}let ${imageVariable} = ["P3\\n# ${readPixelsFile}.ppm\\n", ${width}, ' ', ${height}, "\\n255\\n"].join("");`);
    recording.push(`${indent}for (let i = 0; i < ${imageVariable}.length; i += 4) {`);
    recording.push(`${indent}  ${imageVariable} += ${sourceVariable}[i] + ' ' + ${sourceVariable}[i + 1] + ' ' + ${sourceVariable}[i + 2] + ' ';`);
    recording.push(`${indent}}`);
    recording.push(`${indent}if (typeof require !== "undefined") {`);
    recording.push(`${indent}  require('fs').writeFileSync('./${readPixelsFile}.ppm', ${imageVariable});`);
    recording.push(`${indent}}`);
    imageCount++;
  }
  function addComment(value) {
    recording.push(`${indent}// ${value}`);
  }
  function checkThrowError() {
    recording.push(`${indent}(() => {
${indent}const error = ${contextName}.getError();
${indent}if (error !== ${contextName}.NONE) {
${indent}  const names = Object.getOwnPropertyNames(gl);
${indent}  for (let i = 0; i < names.length; i++) {
${indent}    const name = names[i];
${indent}    if (${contextName}[name] === error) {
${indent}      throw new Error('${contextName} threw ' + name);
${indent}    }
${indent}  }
${indent}}
${indent}})();`);
  }
  function methodCallToString(method, args) {
    return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
  }

  function getVariableName(value) {
    if (variables) {
      for (const name in variables) {
        if (variables[name] === value) {
          return name;
        }
      }
    }
    return null;
  }

  function getContextVariableName(value) {
    const i = contextVariables.indexOf(value);
    if (i !== -1) {
      return `${contextName}Variable${i}`;
    }
    return null;
  }
}

function glExtensionWiretap(extension, options) {
  const proxy = new Proxy(extension, { get: listen });
  const extensionEntityNames = {};
  const {
    contextName,
    contextVariables,
    getEntity,
    useTrackablePrimitives,
    recording,
    variables,
    indent,
    onUnrecognizedArgumentLookup,
  } = options;
  return proxy;
  function listen(obj, property) {
    if (typeof obj[property] === 'function') {
      return function() {
        switch (property) {
          case 'drawBuffersWEBGL':
            recording.push(`${indent}${contextName}.drawBuffersWEBGL([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })}]);`);
            return extension.drawBuffersWEBGL(arguments[0]);
        }
        let result = extension[property].apply(extension, arguments);
        switch (typeof result) {
          case 'undefined':
            recording.push(`${indent}${methodCallToString(property, arguments)};`);
            return;
          case 'number':
          case 'boolean':
            if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result = trackablePrimitive(result));
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result);
            }
            break;
          default:
            if (result === null) {
              recording.push(`${methodCallToString(property, arguments)};`);
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
            }
            contextVariables.push(result);
        }
        return result;
      };
    }
    extensionEntityNames[extension[property]] = property;
    return extension[property];
  }

  function getExtensionEntity(value) {
    if (extensionEntityNames.hasOwnProperty(value)) {
      return `${contextName}.${extensionEntityNames[value]}`;
    }
    return getEntity(value);
  }

  function methodCallToString(method, args) {
    return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
  }

  function addVariable(value, source) {
    const variableName = `${contextName}Variable${contextVariables.length}`;
    contextVariables.push(value);
    recording.push(`${indent}const ${variableName} = ${source};`);
    return variableName;
  }
}

function argumentsToString(args, options) {
  const { variables, onUnrecognizedArgumentLookup } = options;
  return (Array.from(args).map((arg) => {
    const variableName = getVariableName(arg);
    if (variableName) {
      return variableName;
    }
    return argumentToString(arg, options);
  }).join(', '));

  function getVariableName(value) {
    if (variables) {
      for (const name in variables) {
        if (!variables.hasOwnProperty(name)) continue;
        if (variables[name] === value) {
          return name;
        }
      }
    }
    if (onUnrecognizedArgumentLookup) {
      return onUnrecognizedArgumentLookup(value);
    }
    return null;
  }
}

function argumentToString(arg, options) {
  const { contextName, contextVariables, getEntity, addVariable, onUnrecognizedArgumentLookup } = options;
  if (typeof arg === 'undefined') {
    return 'undefined';
  }
  if (arg === null) {
    return 'null';
  }
  const i = contextVariables.indexOf(arg);
  if (i > -1) {
    return `${contextName}Variable${i}`;
  }
  switch (arg.constructor.name) {
    case 'String':
      const hasLines = /\n/.test(arg);
      const hasSingleQuotes = /'/.test(arg);
      const hasDoubleQuotes = /"/.test(arg);
      if (hasLines) {
        return '`' + arg + '`';
      } else if (hasSingleQuotes && !hasDoubleQuotes) {
        return '"' + arg + '"';
      } else if (!hasSingleQuotes && hasDoubleQuotes) {
        return "'" + arg + "'";
      } else {
        return '\'' + arg + '\'';
      }
    case 'Number': return getEntity(arg);
    case 'Boolean': return getEntity(arg);
    case 'Array':
      return addVariable(arg, `new ${arg.constructor.name}([${Array.from(arg).join(',')}])`);
    case 'Float32Array':
    case 'Uint8Array':
    case 'Uint16Array':
    case 'Int32Array':
      return addVariable(arg, `new ${arg.constructor.name}(${JSON.stringify(Array.from(arg))})`);
    default:
      if (onUnrecognizedArgumentLookup) {
        const instantiationString = onUnrecognizedArgumentLookup(arg);
        if (instantiationString) {
          return instantiationString;
        }
      }
      throw new Error(`unrecognized argument type ${arg.constructor.name}`);
  }
}

function trackablePrimitive(value) {
  return new value.constructor(value);
}

if (typeof module !== 'undefined') {
  module.exports = { glWiretap, glExtensionWiretap };
}

if (typeof window !== 'undefined') {
  glWiretap.glExtensionWiretap = glExtensionWiretap;
  window.glWiretap = glWiretap;
}

},{}],4:[function(require,module,exports){
function setupArguments(args) {
  const newArguments = new Array(args.length);
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.toArray) {
      newArguments[i] = arg.toArray();
    } else {
      newArguments[i] = arg;
    }
  }
  return newArguments;
}

function mock1D() {
  const args = setupArguments(arguments);
  const row = new Float32Array(this.output.x);
  for (let x = 0; x < this.output.x; x++) {
    this.thread.x = x;
    this.thread.y = 0;
    this.thread.z = 0;
    row[x] = this._fn.apply(this, args);
  }
  return row;
}

function mock2D() {
  const args = setupArguments(arguments);
  const matrix = new Array(this.output.y);
  for (let y = 0; y < this.output.y; y++) {
    const row = new Float32Array(this.output.x);
    for (let x = 0; x < this.output.x; x++) {
      this.thread.x = x;
      this.thread.y = y;
      this.thread.z = 0;
      row[x] = this._fn.apply(this, args);
    }
    matrix[y] = row;
  }
  return matrix;
}

function mock2DGraphical() {
  const args = setupArguments(arguments);
  for (let y = 0; y < this.output.y; y++) {
    for (let x = 0; x < this.output.x; x++) {
      this.thread.x = x;
      this.thread.y = y;
      this.thread.z = 0;
      this._fn.apply(this, args);
    }
  }
}

function mock3D() {
  const args = setupArguments(arguments);
  const cube = new Array(this.output.z);
  for (let z = 0; z < this.output.z; z++) {
    const matrix = new Array(this.output.y);
    for (let y = 0; y < this.output.y; y++) {
      const row = new Float32Array(this.output.x);
      for (let x = 0; x < this.output.x; x++) {
        this.thread.x = x;
        this.thread.y = y;
        this.thread.z = z;
        row[x] = this._fn.apply(this, args);
      }
      matrix[y] = row;
    }
    cube[z] = matrix;
  }
  return cube;
}

function apiDecorate(kernel) {
  kernel.setOutput = (output) => {
    kernel.output = setupOutput(output);
    if (kernel.graphical) {
      setupGraphical(kernel);
    }
  };
  kernel.toJSON = () => {
    throw new Error('Not usable with gpuMock');
  };
  kernel.setConstants = (flag) => {
    kernel.constants = flag;
    return kernel;
  };
  kernel.setGraphical = (flag) => {
    kernel.graphical = flag;
    return kernel;
  };
  kernel.setCanvas = (flag) => {
    kernel.canvas = flag;
    return kernel;
  };
  kernel.setContext = (flag) => {
    kernel.context = flag;
    return kernel;
  };
  kernel.destroy = () => {};
  kernel.validateSettings = () => {};
  if (kernel.graphical && kernel.output) {
    setupGraphical(kernel);
  }
  kernel.exec = function() {
    return new Promise((resolve, reject) => {
      try {
        resolve(kernel.apply(kernel, arguments));
      } catch(e) {
        reject(e);
      }
    });
  };
  kernel.getPixels = (flip) => {
    const {x, y} = kernel.output;
    return flip ? flipPixels(kernel._imageData.data, x, y) : kernel._imageData.data.slice(0);
  };
  kernel.color = function(r, g, b, a) {
    if (typeof a === 'undefined') {
      a = 1;
    }

    r = Math.floor(r * 255);
    g = Math.floor(g * 255);
    b = Math.floor(b * 255);
    a = Math.floor(a * 255);

    const width = kernel.output.x;
    const height = kernel.output.y;

    const x = kernel.thread.x;
    const y = height - kernel.thread.y - 1;

    const index = x + y * width;

    kernel._colorData[index * 4 + 0] = r;
    kernel._colorData[index * 4 + 1] = g;
    kernel._colorData[index * 4 + 2] = b;
    kernel._colorData[index * 4 + 3] = a;
  };

  const mockMethod = () => kernel;
  const methods = [
    'setWarnVarUsage',
    'setArgumentTypes',
    'setTactic',
    'setOptimizeFloatMemory',
    'setDebug',
    'setLoopMaxIterations',
    'setConstantTypes',
    'setFunctions',
    'setNativeFunctions',
    'setInjectedNative',
    'setPipeline',
    'setPrecision',
    'setOutputToTexture',
    'setImmutable',
    'setStrictIntegers',
    'setDynamicOutput',
    'setHardcodeConstants',
    'setDynamicArguments',
    'setUseLegacyEncoder',
    'setWarnVarUsage',
    'addSubKernel',
  ];
  for (let i = 0; i < methods.length; i++) {
    kernel[methods[i]] = mockMethod;
  }
  return kernel;
}

function setupGraphical(kernel) {
  const {x, y} = kernel.output;
  if (kernel.context && kernel.context.createImageData) {
    const data = new Uint8ClampedArray(x * y * 4);
    kernel._imageData = kernel.context.createImageData(x, y);
    kernel._colorData = data;
  } else {
    const data = new Uint8ClampedArray(x * y * 4);
    kernel._imageData = { data };
    kernel._colorData = data;
  }
}

function setupOutput(output) {
  let result = null;
  if (output.length) {
    if (output.length === 3) {
      const [x,y,z] = output;
      result = { x, y, z };
    } else if (output.length === 2) {
      const [x,y] = output;
      result = { x, y };
    } else {
      const [x] = output;
      result = { x };
    }
  } else {
    result = output;
  }
  return result;
}

function gpuMock(fn, settings = {}) {
  const output = settings.output ? setupOutput(settings.output) : null;
  function kernel() {
    if (kernel.output.z) {
      return mock3D.apply(kernel, arguments);
    } else if (kernel.output.y) {
      if (kernel.graphical) {
        return mock2DGraphical.apply(kernel, arguments);
      }
      return mock2D.apply(kernel, arguments);
    } else {
      return mock1D.apply(kernel, arguments);
    }
  }
  kernel._fn = fn;
  kernel.constants = settings.constants || null;
  kernel.context = settings.context || null;
  kernel.canvas = settings.canvas || null;
  kernel.graphical = settings.graphical || false;
  kernel._imageData = null;
  kernel._colorData = null;
  kernel.output = output;
  kernel.thread = {
    x: 0,
    y: 0,
    z: 0
  };
  return apiDecorate(kernel);
}

function flipPixels(pixels, width, height) {
  const halfHeight = height / 2 | 0; 
  const bytesPerRow = width * 4;
  const temp = new Uint8ClampedArray(width * 4);
  const result = pixels.slice(0);
  for (let y = 0; y < halfHeight; ++y) {
    const topOffset = y * bytesPerRow;
    const bottomOffset = (height - y - 1) * bytesPerRow;

    temp.set(result.subarray(topOffset, topOffset + bytesPerRow));

    result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);

    result.set(temp, bottomOffset);
  }
  return result;
}

module.exports = {
  gpuMock
};

},{}],5:[function(require,module,exports){
const { utils } = require('./utils');

function alias(name, source) {
  const fnString = source.toString();
  return new Function(`return function ${ name } (${ utils.getArgumentNamesFromString(fnString).join(', ') }) {
  ${ utils.getFunctionBodyFromString(fnString) }
}`)();
}

module.exports = {
  alias
};
},{"./utils":114}],6:[function(require,module,exports){
const { FunctionNode } = require('../function-node');

class CPUFunctionNode extends FunctionNode {
  astFunction(ast, retArr) {

    if (!this.isRootKernel) {
      retArr.push('function');
      retArr.push(' ');
      retArr.push(this.name);
      retArr.push('(');

      for (let i = 0; i < this.argumentNames.length; ++i) {
        const argumentName = this.argumentNames[i];

        if (i > 0) {
          retArr.push(', ');
        }
        retArr.push('user_');
        retArr.push(argumentName);
      }

      retArr.push(') {\n');
    }

    for (let i = 0; i < ast.body.body.length; ++i) {
      this.astGeneric(ast.body.body[i], retArr);
      retArr.push('\n');
    }

    if (!this.isRootKernel) {
      retArr.push('}\n');
    }
    return retArr;
  }

  astReturnStatement(ast, retArr) {
    const type = this.returnType || this.getType(ast.argument);

    if (!this.returnType) {
      this.returnType = type;
    }

    if (this.isRootKernel) {
      retArr.push(this.leadingReturnStatement);
      this.astGeneric(ast.argument, retArr);
      retArr.push(';\n');
      retArr.push(this.followingReturnStatement);
      retArr.push('continue;\n');
    } else if (this.isSubKernel) {
      retArr.push(`subKernelResult_${ this.name } = `);
      this.astGeneric(ast.argument, retArr);
      retArr.push(';');
      retArr.push(`return subKernelResult_${ this.name };`);
    } else {
      retArr.push('return ');
      this.astGeneric(ast.argument, retArr);
      retArr.push(';');
    }
    return retArr;
  }

  astLiteral(ast, retArr) {

    if (isNaN(ast.value)) {
      throw this.astErrorOutput(
        'Non-numeric literal not supported : ' + ast.value,
        ast
      );
    }

    retArr.push(ast.value);

    return retArr;
  }

  astBinaryExpression(ast, retArr) {
    retArr.push('(');
    this.astGeneric(ast.left, retArr);
    retArr.push(ast.operator);
    this.astGeneric(ast.right, retArr);
    retArr.push(')');
    return retArr;
  }

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput(
        'IdentifierExpression - not an Identifier',
        idtNode
      );
    }

    switch (idtNode.name) {
      case 'Infinity':
        retArr.push('Infinity');
        break;
      default:
        if (this.constants && this.constants.hasOwnProperty(idtNode.name)) {
          retArr.push('constants_' + idtNode.name);
        } else {
          retArr.push('user_' + idtNode.name);
        }
    }

    return retArr;
  }

  astForStatement(forNode, retArr) {
    if (forNode.type !== 'ForStatement') {
      throw this.astErrorOutput('Invalid for statement', forNode);
    }

    const initArr = [];
    const testArr = [];
    const updateArr = [];
    const bodyArr = [];
    let isSafe = null;

    if (forNode.init) {
      this.pushState('in-for-loop-init');
      this.astGeneric(forNode.init, initArr);
      for (let i = 0; i < initArr.length; i++) {
        if (initArr[i].includes && initArr[i].includes(',')) {
          isSafe = false;
        }
      }
      this.popState('in-for-loop-init');
    } else {
      isSafe = false;
    }

    if (forNode.test) {
      this.astGeneric(forNode.test, testArr);
    } else {
      isSafe = false;
    }

    if (forNode.update) {
      this.astGeneric(forNode.update, updateArr);
    } else {
      isSafe = false;
    }

    if (forNode.body) {
      this.pushState('loop-body');
      this.astGeneric(forNode.body, bodyArr);
      this.popState('loop-body');
    }

    if (isSafe === null) {
      isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
    }

    if (isSafe) {
      retArr.push(`for (${initArr.join('')};${testArr.join('')};${updateArr.join('')}){\n`);
      retArr.push(bodyArr.join(''));
      retArr.push('}\n');
    } else {
      const iVariableName = this.getInternalVariableName('safeI');
      if (initArr.length > 0) {
        retArr.push(initArr.join(''), ';\n');
      }
      retArr.push(`for (let ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
      if (testArr.length > 0) {
        retArr.push(`if (!${testArr.join('')}) break;\n`);
      }
      retArr.push(bodyArr.join(''));
      retArr.push(`\n${updateArr.join('')};`);
      retArr.push('}\n');
    }
    return retArr;
  }

  astWhileStatement(whileNode, retArr) {
    if (whileNode.type !== 'WhileStatement') {
      throw this.astErrorOutput(
        'Invalid while statement',
        whileNode
      );
    }

    retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
    retArr.push('if (');
    this.astGeneric(whileNode.test, retArr);
    retArr.push(') {\n');
    this.astGeneric(whileNode.body, retArr);
    retArr.push('} else {\n');
    retArr.push('break;\n');
    retArr.push('}\n');
    retArr.push('}\n');

    return retArr;
  }

  astDoWhileStatement(doWhileNode, retArr) {
    if (doWhileNode.type !== 'DoWhileStatement') {
      throw this.astErrorOutput(
        'Invalid while statement',
        doWhileNode
      );
    }

    retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
    this.astGeneric(doWhileNode.body, retArr);
    retArr.push('if (!');
    this.astGeneric(doWhileNode.test, retArr);
    retArr.push(') {\n');
    retArr.push('break;\n');
    retArr.push('}\n');
    retArr.push('}\n');

    return retArr;

  }

  astAssignmentExpression(assNode, retArr) {
    const declaration = this.getDeclaration(assNode.left);
    if (declaration && !declaration.assignable) {
      throw this.astErrorOutput(`Variable ${assNode.left.name} is not assignable here`, assNode);
    }
    this.astGeneric(assNode.left, retArr);
    retArr.push(assNode.operator);
    this.astGeneric(assNode.right, retArr);
    return retArr;
  }

  astBlockStatement(bNode, retArr) {
    if (this.isState('loop-body')) {
      this.pushState('block-body'); 
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      this.popState('block-body');
    } else {
      retArr.push('{\n');
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      retArr.push('}\n');
    }
    return retArr;
  }

  astVariableDeclaration(varDecNode, retArr) {
    retArr.push(`${varDecNode.kind} `);
    const { declarations } = varDecNode;
    for (let i = 0; i < declarations.length; i++) {
      if (i > 0) {
        retArr.push(',');
      }
      const declaration = declarations[i];
      const info = this.getDeclaration(declaration.id);
      if (!info.valueType) {
        info.valueType = this.getType(declaration.init);
      }
      this.astGeneric(declaration, retArr);
    }
    if (!this.isState('in-for-loop-init')) {
      retArr.push(';');
    }
    return retArr;
  }

  astIfStatement(ifNode, retArr) {
    retArr.push('if (');
    this.astGeneric(ifNode.test, retArr);
    retArr.push(')');
    if (ifNode.consequent.type === 'BlockStatement') {
      this.astGeneric(ifNode.consequent, retArr);
    } else {
      retArr.push(' {\n');
      this.astGeneric(ifNode.consequent, retArr);
      retArr.push('\n}\n');
    }

    if (ifNode.alternate) {
      retArr.push('else ');
      if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {
        this.astGeneric(ifNode.alternate, retArr);
      } else {
        retArr.push(' {\n');
        this.astGeneric(ifNode.alternate, retArr);
        retArr.push('\n}\n');
      }
    }
    return retArr;

  }

  astSwitchStatement(ast, retArr) {
    const { discriminant, cases } = ast;
    retArr.push('switch (');
    this.astGeneric(discriminant, retArr);
    retArr.push(') {\n');
    for (let i = 0; i < cases.length; i++) {
      if (cases[i].test === null) {
        retArr.push('default:\n');
        this.astGeneric(cases[i].consequent, retArr);
        if (cases[i].consequent && cases[i].consequent.length > 0) {
          retArr.push('break;\n');
        }
        continue;
      }
      retArr.push('case ');
      this.astGeneric(cases[i].test, retArr);
      retArr.push(':\n');
      if (cases[i].consequent && cases[i].consequent.length > 0) {
        this.astGeneric(cases[i].consequent, retArr);
        retArr.push('break;\n');
      }
    }
    retArr.push('\n}');
  }

  astThisExpression(tNode, retArr) {
    retArr.push('_this');
    return retArr;
  }

  astMemberExpression(mNode, retArr) {
    const {
      signature,
      type,
      property,
      xProperty,
      yProperty,
      zProperty,
      name,
      origin
    } = this.getMemberExpressionDetails(mNode);
    switch (signature) {
      case 'this.thread.value':
        retArr.push(`_this.thread.${ name }`);
        return retArr;
      case 'this.output.value':
        switch (name) {
          case 'x':
            retArr.push('outputX');
            break;
          case 'y':
            retArr.push('outputY');
            break;
          case 'z':
            retArr.push('outputZ');
            break;
          default:
            throw this.astErrorOutput('Unexpected expression', mNode);
        }
        return retArr;
      case 'value':
        throw this.astErrorOutput('Unexpected expression', mNode);
      case 'value[]':
      case 'value[][]':
      case 'value[][][]':
      case 'value.value':
        if (origin === 'Math') {
          retArr.push(Math[name]);
          return retArr;
        }
        switch (property) {
          case 'r':
            retArr.push(`user_${ name }[0]`);
            return retArr;
          case 'g':
            retArr.push(`user_${ name }[1]`);
            return retArr;
          case 'b':
            retArr.push(`user_${ name }[2]`);
            return retArr;
          case 'a':
            retArr.push(`user_${ name }[3]`);
            return retArr;
        }
        break;
      case 'value.value[]': 
        if (this.removeIstanbulCoverage) {
          return retArr;
        }
        retArr.push(`${mNode.object.object.name}.${mNode.object.property.name}[${mNode.property.value}]`);
        return retArr;
      case 'value.value[][]': 
        if (this.removeIstanbulCoverage) {
          return retArr;
        }
        retArr.push(`${mNode.object.object.object.name}.${mNode.object.object.property.name}[${mNode.object.property.value}][${mNode.property.value}]`);
        return retArr;
      case 'this.constants.value':
      case 'this.constants.value[]':
      case 'this.constants.value[][]':
      case 'this.constants.value[][][]':
        break;
      case 'fn()[]':
        this.astGeneric(mNode.object, retArr);
        retArr.push('[');
        this.astGeneric(mNode.property, retArr);
        retArr.push(']');
        return retArr;
      default:
        throw this.astErrorOutput('Unexpected expression', mNode);
    }

    if (!mNode.computed) {
      switch (type) {
        case 'Number':
        case 'Integer':
        case 'Float':
        case 'Boolean':
          retArr.push(`${origin}_${name}`);
          return retArr;
      }
    }

    const markupName = `${origin}_${name}`;

    switch (type) {
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'HTMLImageArray':
      case 'ArrayTexture(1)':
      case 'ArrayTexture(2)':
      case 'ArrayTexture(3)':
      case 'ArrayTexture(4)':
      case 'HTMLImage':
      default:
        let size;
        let isInput;
        if (origin === 'constants') {
          const constant = this.constants[name];
          isInput = this.constantTypes[name] === 'Input';
          size = isInput ? constant.size : null;
        } else {
          isInput = this.isInput(name);
          size = isInput ? this.argumentSizes[this.argumentNames.indexOf(name)] : null;
        }
        retArr.push(`${ markupName }`);
        if (zProperty && yProperty) {
          if (isInput) {
            retArr.push('[(');
            this.astGeneric(zProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? '(outputY * outputX)' : size[1] * size[0] })+(`);
            this.astGeneric(yProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          } else {
            retArr.push('[');
            this.astGeneric(zProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(yProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          }
        } else if (yProperty) {
          if (isInput) {
            retArr.push('[(');
            this.astGeneric(yProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          } else {
            retArr.push('[');
            this.astGeneric(yProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          }
        } else if (typeof xProperty !== 'undefined') {
          retArr.push('[');
          this.astGeneric(xProperty, retArr);
          retArr.push(']');
        }
    }
    return retArr;
  }

  astCallExpression(ast, retArr) {
    if (ast.type !== 'CallExpression') {
      throw this.astErrorOutput('Unknown CallExpression', ast);
    }
    let functionName = this.astMemberExpressionUnroll(ast.callee);

    if (this.calledFunctions.indexOf(functionName) < 0) {
      this.calledFunctions.push(functionName);
    }

    const isMathFunction = this.isAstMathFunction(ast);

    if (this.onFunctionCall) {
      this.onFunctionCall(this.name, functionName, ast.arguments);
    }

    retArr.push(functionName);

    retArr.push('(');
    const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
    for (let i = 0; i < ast.arguments.length; ++i) {
      const argument = ast.arguments[i];

      let argumentType = this.getType(argument);
      if (!targetTypes[i]) {
        this.triggerImplyArgumentType(functionName, i, argumentType, this);
      }

      if (i > 0) {
        retArr.push(', ');
      }
      this.astGeneric(argument, retArr);
    }
    retArr.push(')');

    return retArr;
  }

  astArrayExpression(arrNode, retArr) {
    const arrLen = arrNode.elements.length;

    retArr.push('new Float32Array([');
    for (let i = 0; i < arrLen; ++i) {
      if (i > 0) {
        retArr.push(', ');
      }
      const subNode = arrNode.elements[i];
      this.astGeneric(subNode, retArr)
    }
    retArr.push('])');

    return retArr;
  }

  astDebuggerStatement(arrNode, retArr) {
    retArr.push('debugger;');
    return retArr;
  }
}

module.exports = {
  CPUFunctionNode
};
},{"../function-node":10}],7:[function(require,module,exports){
const { utils } = require('../../utils');

function constantsToString(constants, types) {
  const results = [];
  for (const name in types) {
    if (!types.hasOwnProperty(name)) continue;
    const type = types[name];
    const constant = constants[name];
    switch (type) {
      case 'Number':
      case 'Integer':
      case 'Float':
      case 'Boolean':
        results.push(`${name}:${constant}`);
        break;
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
        results.push(`${name}:new ${constant.constructor.name}(${JSON.stringify(Array.from(constant))})`);
        break;
    }
  }
  return `{ ${ results.join() } }`;
}

function cpuKernelString(cpuKernel, name) {
  const header = [];
  const thisProperties = [];
  const beforeReturn = [];

  const useFunctionKeyword = !/^function/.test(cpuKernel.color.toString());

  header.push(
    '  const { context, canvas, constants: incomingConstants } = settings;',
    `  const output = new Int32Array(${JSON.stringify(Array.from(cpuKernel.output))});`,
    `  const _constantTypes = ${JSON.stringify(cpuKernel.constantTypes)};`,
    `  const _constants = ${constantsToString(cpuKernel.constants, cpuKernel.constantTypes)};`,
  );

  thisProperties.push(
    '    constants: _constants,',
    '    context,',
    '    output,',
    '    thread: {x: 0, y: 0, z: 0},',
  );

  if (cpuKernel.graphical) {
    header.push(`  const _imageData = context.createImageData(${cpuKernel.output[0]}, ${cpuKernel.output[1]});`);
    header.push(`  const _colorData = new Uint8ClampedArray(${cpuKernel.output[0]} * ${cpuKernel.output[1]} * 4);`);

    const colorFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.color.toString(), {
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case '_colorData':
            return '_colorData';
          case '_imageData':
            return '_imageData';
          case 'output':
            return 'output';
          case 'thread':
            return 'this.thread';
        }
        return JSON.stringify(cpuKernel[propertyName]);
      },
      findDependency: (object, name) => {
        return null;
      }
    });

    const getPixelsFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.getPixels.toString(), {
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case '_colorData':
            return '_colorData';
          case '_imageData':
            return '_imageData';
          case 'output':
            return 'output';
          case 'thread':
            return 'this.thread';
        }
        return JSON.stringify(cpuKernel[propertyName]);
      },
      findDependency: () => {
        return null;
      }
    });

    thisProperties.push(
      '    _imageData,',
      '    _colorData,',
      `    color: ${colorFn},`,
    );

    beforeReturn.push(
      `  kernel.getPixels = ${getPixelsFn};`
    );
  }

  const constantTypes = [];
  const constantKeys = Object.keys(cpuKernel.constantTypes);
  for (let i = 0; i < constantKeys.length; i++) {
    constantTypes.push(cpuKernel.constantTypes[constantKeys]);
  }
  if (cpuKernel.argumentTypes.indexOf('HTMLImageArray') !== -1 || constantTypes.indexOf('HTMLImageArray') !== -1) {
    const flattenedImageTo3DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._imageTo3DArray.toString(), {
      doNotDefine: ['canvas'],
      findDependency: (object, name) => {
        if (object === 'this') {
          return (useFunctionKeyword ? 'function ' : '') + cpuKernel[name].toString();
        }
        return null;
      },
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case 'canvas':
            return;
          case 'context':
            return 'context';
        }
      }
    });
    beforeReturn.push(flattenedImageTo3DArray);
    thisProperties.push(`    _mediaTo2DArray,`);
    thisProperties.push(`    _imageTo3DArray,`);
  } else if (cpuKernel.argumentTypes.indexOf('HTMLImage') !== -1 || constantTypes.indexOf('HTMLImage') !== -1) {
    const flattenedImageTo2DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._mediaTo2DArray.toString(), {
      findDependency: (object, name) => {
        return null;
      },
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case 'canvas':
            return 'settings.canvas';
          case 'context':
            return 'settings.context';
        }
        throw new Error('unhandled thisLookup');
      }
    });
    beforeReturn.push(flattenedImageTo2DArray);
    thisProperties.push(`    _mediaTo2DArray,`);
  }

  return `function(settings) {
${ header.join('\n') }
  for (const p in _constantTypes) {
    if (!_constantTypes.hasOwnProperty(p)) continue;
    const type = _constantTypes[p];
    switch (type) {
      case 'Number':
      case 'Integer':
      case 'Float':
      case 'Boolean':
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
        if (incomingConstants.hasOwnProperty(p)) {
          console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');
        }
        continue;
    }
    if (!incomingConstants.hasOwnProperty(p)) {
      throw new Error('constant ' + p + ' not found');
    }
    _constants[p] = incomingConstants[p];
  }
  const kernel = (function() {
${cpuKernel._kernelString}
  })
    .apply({ ${thisProperties.join('\n')} });
  ${ beforeReturn.join('\n') }
  return kernel;
}`;
}

module.exports = {
  cpuKernelString
};
},{"../../utils":114}],8:[function(require,module,exports){
const { Kernel } = require('../kernel');
const { FunctionBuilder } = require('../function-builder');
const { CPUFunctionNode } = require('./function-node');
const { utils } = require('../../utils');
const { cpuKernelString } = require('./kernel-string');

class CPUKernel extends Kernel {
  static getFeatures() {
    return this.features;
  }
  static get features() {
    return Object.freeze({
      kernelMap: true,
      isIntegerDivisionAccurate: true
    });
  }
  static get isSupported() {
    return true;
  }
  static isContextMatch(context) {
    return false;
  }
  static get mode() {
    return 'cpu';
  }

  static nativeFunctionArguments() {
    return null;
  }

  static nativeFunctionReturnType() {
    throw new Error(`Looking up native function return type not supported on ${this.name}`);
  }

  static combineKernels(combinedKernel) {
    return combinedKernel;
  }

  static getSignature(kernel, argumentTypes) {
    return 'cpu' + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');
  }

  constructor(source, settings) {
    super(source, settings);
    this.mergeSettings(source.settings || settings);

    this._imageData = null;
    this._colorData = null;
    this._kernelString = null;
    this._prependedString = [];
    this.thread = {
      x: 0,
      y: 0,
      z: 0
    };
    this.translatedSources = null;
  }

  initCanvas() {
    if (typeof document !== 'undefined') {
      return document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      return new OffscreenCanvas(0, 0);
    }
  }

  initContext() {
    if (!this.canvas) return null;
    return this.canvas.getContext('2d');
  }

  initPlugins(settings) {
    return [];
  }

  validateSettings(args) {
    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      if (argType === 'Array') {
        this.output = utils.getDimensions(argType);
      } else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {
        this.output = args[0].output;
      } else {
        throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }
    }

    this.checkOutput();
  }

  translateSource() {
    this.leadingReturnStatement = this.output.length > 1 ? 'resultX[x] = ' : 'result[x] = ';
    if (this.subKernels) {
      const followingReturnStatement = [];
      for (let i = 0; i < this.subKernels.length; i++) {
        const {
          name
        } = this.subKernels[i];
        followingReturnStatement.push(this.output.length > 1 ? `resultX_${ name }[x] = subKernelResult_${ name };\n` : `result_${ name }[x] = subKernelResult_${ name };\n`);
      }
      this.followingReturnStatement = followingReturnStatement.join('');
    }
    const functionBuilder = FunctionBuilder.fromKernel(this, CPUFunctionNode);
    this.translatedSources = functionBuilder.getPrototypes('kernel');
    if (!this.graphical && !this.returnType) {
      this.returnType = functionBuilder.getKernelResultType();
    }
  }

  build() {
    if (this.built) return;
    this.setupConstants();
    this.setupArguments(arguments);
    this.validateSettings(arguments);
    this.translateSource();

    if (this.graphical) {
      const {
        canvas,
        output
      } = this;
      if (!canvas) {
        throw new Error('no canvas available for using graphical output');
      }
      const width = output[0];
      const height = output[1] || 1;
      canvas.width = width;
      canvas.height = height;
      this._imageData = this.context.createImageData(width, height);
      this._colorData = new Uint8ClampedArray(width * height * 4);
    }

    const kernelString = this.getKernelString();
    this.kernelString = kernelString;

    if (this.debug) {
      console.log('Function output:');
      console.log(kernelString);
    }

    try {
      this.run = new Function([], kernelString).bind(this)();
    } catch (e) {
      console.error('An error occurred compiling the javascript: ', e);
    }
    this.buildSignature(arguments);
    this.built = true;
  }

  color(r, g, b, a) {
    if (typeof a === 'undefined') {
      a = 1;
    }

    r = Math.floor(r * 255);
    g = Math.floor(g * 255);
    b = Math.floor(b * 255);
    a = Math.floor(a * 255);

    const width = this.output[0];
    const height = this.output[1];

    const x = this.thread.x;
    const y = height - this.thread.y - 1;

    const index = x + y * width;

    this._colorData[index * 4 + 0] = r;
    this._colorData[index * 4 + 1] = g;
    this._colorData[index * 4 + 2] = b;
    this._colorData[index * 4 + 3] = a;
  }

  getKernelString() {
    if (this._kernelString !== null) return this._kernelString;

    let kernelThreadString = null;
    let {
      translatedSources
    } = this;
    if (translatedSources.length > 1) {
      translatedSources = translatedSources.filter(fn => {
        if (/^function/.test(fn)) return fn;
        kernelThreadString = fn;
        return false;
      });
    } else {
      kernelThreadString = translatedSources.shift();
    }
    return this._kernelString = `  const LOOP_MAX = ${ this._getLoopMaxString() };
  ${ this.injectedNative || '' }
  const _this = this;
  ${ this._resultKernelHeader() }
  ${ this._processConstants() }
  return (${ this.argumentNames.map(argumentName => 'user_' + argumentName).join(', ') }) => {
    ${ this._prependedString.join('') }
    ${ this._earlyThrows() }
    ${ this._processArguments() }
    ${ this.graphical ? this._graphicalKernelBody(kernelThreadString) : this._resultKernelBody(kernelThreadString) }
    ${ translatedSources.length > 0 ? translatedSources.join('\n') : '' }
  };`;
  }

  toString() {
    return cpuKernelString(this);
  }

  _getLoopMaxString() {
    return (
      this.loopMaxIterations ?
      ` ${ parseInt(this.loopMaxIterations) };` :
      ' 1000;'
    );
  }

  _processConstants() {
    if (!this.constants) return '';

    const result = [];
    for (let p in this.constants) {
      const type = this.constantTypes[p];
      switch (type) {
        case 'HTMLCanvas':
        case 'HTMLImage':
        case 'HTMLVideo':
          result.push(`    const constants_${p} = this._mediaTo2DArray(this.constants.${p});\n`);
          break;
        case 'HTMLImageArray':
          result.push(`    const constants_${p} = this._imageTo3DArray(this.constants.${p});\n`);
          break;
        case 'Input':
          result.push(`    const constants_${p} = this.constants.${p}.value;\n`);
          break;
        default:
          result.push(`    const constants_${p} = this.constants.${p};\n`);
      }
    }
    return result.join('');
  }

  _earlyThrows() {
    if (this.graphical) return '';
    if (this.immutable) return '';
    if (!this.pipeline) return '';
    const arrayArguments = [];
    for (let i = 0; i < this.argumentTypes.length; i++) {
      if (this.argumentTypes[i] === 'Array') {
        arrayArguments.push(this.argumentNames[i]);
      }
    }
    if (arrayArguments.length === 0) return '';
    const checks = [];
    for (let i = 0; i < arrayArguments.length; i++) {
      const argumentName = arrayArguments[i];
      const checkSubKernels = this._mapSubKernels(subKernel => `user_${argumentName} === result_${subKernel.name}`).join(' || ');
      checks.push(`user_${argumentName} === result${checkSubKernels ? ` || ${checkSubKernels}` : ''}`);
    }
    return `if (${checks.join(' || ')}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`;
  }

  _processArguments() {
    const result = [];
    for (let i = 0; i < this.argumentTypes.length; i++) {
      const variableName = `user_${this.argumentNames[i]}`;
      switch (this.argumentTypes[i]) {
        case 'HTMLCanvas':
        case 'HTMLImage':
        case 'HTMLVideo':
          result.push(`    ${variableName} = this._mediaTo2DArray(${variableName});\n`);
          break;
        case 'HTMLImageArray':
          result.push(`    ${variableName} = this._imageTo3DArray(${variableName});\n`);
          break;
        case 'Input':
          result.push(`    ${variableName} = ${variableName}.value;\n`);
          break;
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
          result.push(`
    if (${variableName}.toArray) {
      if (!_this.textureCache) {
        _this.textureCache = [];
        _this.arrayCache = [];
      }
      const textureIndex = _this.textureCache.indexOf(${variableName});
      if (textureIndex !== -1) {
        ${variableName} = _this.arrayCache[textureIndex];
      } else {
        _this.textureCache.push(${variableName});
        ${variableName} = ${variableName}.toArray();
        _this.arrayCache.push(${variableName});
      }
    }`);
          break;
      }
    }
    return result.join('');
  }

  _mediaTo2DArray(media) {
    const canvas = this.canvas;
    const width = media.width > 0 ? media.width : media.videoWidth;
    const height = media.height > 0 ? media.height : media.videoHeight;
    if (canvas.width < width) {
      canvas.width = width;
    }
    if (canvas.height < height) {
      canvas.height = height;
    }
    const ctx = this.context;
    ctx.drawImage(media, 0, 0, width, height);
    const pixelsData = ctx.getImageData(0, 0, width, height).data;
    const imageArray = new Array(height);
    let index = 0;
    for (let y = height - 1; y >= 0; y--) {
      const row = imageArray[y] = new Array(width);
      for (let x = 0; x < width; x++) {
        const pixel = new Float32Array(4);
        pixel[0] = pixelsData[index++] / 255; 
        pixel[1] = pixelsData[index++] / 255; 
        pixel[2] = pixelsData[index++] / 255; 
        pixel[3] = pixelsData[index++] / 255; 
        row[x] = pixel;
      }
    }
    return imageArray;
  }

  getPixels(flip) {
    const [width, height] = this.output;
    return flip ? utils.flipPixels(this._imageData.data, width, height) : this._imageData.data.slice(0);
  }

  _imageTo3DArray(images) {
    const imagesArray = new Array(images.length);
    for (let i = 0; i < images.length; i++) {
      imagesArray[i] = this._mediaTo2DArray(images[i]);
    }
    return imagesArray;
  }

  _resultKernelHeader() {
    if (this.graphical) return '';
    if (this.immutable) return '';
    if (!this.pipeline) return '';
    switch (this.output.length) {
      case 1:
        return this._mutableKernel1DResults();
      case 2:
        return this._mutableKernel2DResults();
      case 3:
        return this._mutableKernel3DResults();
    }
  }

  _resultKernelBody(kernelString) {
    switch (this.output.length) {
      case 1:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel1DLoop(kernelString) : this._resultImmutableKernel1DLoop(kernelString)) + this._kernelOutput();
      case 2:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel2DLoop(kernelString) : this._resultImmutableKernel2DLoop(kernelString)) + this._kernelOutput();
      case 3:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel3DLoop(kernelString) : this._resultImmutableKernel3DLoop(kernelString)) + this._kernelOutput();
      default:
        throw new Error('unsupported size kernel');
    }
  }

  _graphicalKernelBody(kernelThreadString) {
    switch (this.output.length) {
      case 2:
        return this._graphicalKernel2DLoop(kernelThreadString) + this._graphicalOutput();
      default:
        throw new Error('unsupported size kernel');
    }
  }

  _graphicalOutput() {
    return `
    this._imageData.data.set(this._colorData);
    this.context.putImageData(this._imageData, 0, 0);
    return;`
  }

  _getKernelResultTypeConstructorString() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return 'Float32Array';
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
        return 'Array';
      default:
        if (this.graphical) {
          return 'Float32Array';
        }
        throw new Error(`unhandled returnType ${ this.returnType }`);
    }
  }

  _resultImmutableKernel1DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const result = new ${constructorString}(outputX);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${ kernelString }
    }`;
  }

  _mutableKernel1DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const result = new ${constructorString}(outputX);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }`;
  }

  _resultMutableKernel1DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${ kernelString }
    }`;
  }

  _resultImmutableKernel2DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y] = new ${constructorString}(outputX);
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _mutableKernel2DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let y = 0; y < outputY; y++) {
      const resultX = result[y] = new ${constructorString}(outputX);
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
    }`;
  }

  _resultMutableKernel2DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y];
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _graphicalKernel2DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _resultImmutableKernel3DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z] = new Array(outputY);
      ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\n`).join('      ') }
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y] = new ${constructorString}(outputX);
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('        ') }
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }
    }`;
  }

  _mutableKernel3DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let z = 0; z < outputZ; z++) {
      const resultY = result[z] = new Array(outputY);
      ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\n`).join('      ') }
      for (let y = 0; y < outputY; y++) {
        const resultX = resultY[y] = new ${constructorString}(outputX);
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('        ') }
      }
    }`;
  }

  _resultMutableKernel3DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z];
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y];
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }
    }`;
  }

  _kernelOutput() {
    if (!this.subKernels) {
      return '\n    return result;';
    }
    return `\n    return {
      result: result,
      ${ this.subKernels.map(subKernel => `${ subKernel.property }: result_${ subKernel.name }`).join(',\n      ') }
    };`;
  }

  _mapSubKernels(fn) {
    return this.subKernels === null ? [''] :
      this.subKernels.map(fn);
  }

  destroy(removeCanvasReference) {
    if (removeCanvasReference) {
      delete this.canvas;
    }
  }

  static destroyContext(context) {}

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, CPUFunctionNode).toJSON();
    return json;
  }

  setOutput(output) {
    super.setOutput(output);
    const [width, height] = this.output;
    if (this.graphical) {
      this._imageData = this.context.createImageData(width, height);
      this._colorData = new Uint8ClampedArray(width * height * 4);
    }
  }

  prependString(value) {
    if (this._kernelString) throw new Error('Kernel already built');
    this._prependedString.push(value);
  }

  hasPrependString(value) {
    return this._prependedString.indexOf(value) > -1;
  }
}

module.exports = {
  CPUKernel
};
},{"../../utils":114,"../function-builder":9,"../kernel":36,"./function-node":6,"./kernel-string":7}],9:[function(require,module,exports){
class FunctionBuilder {
  static fromKernel(kernel, FunctionNode, extraNodeOptions) {
    const {
      kernelArguments,
      kernelConstants,
      argumentNames,
      argumentSizes,
      argumentBitRatios,
      constants,
      constantBitRatios,
      debug,
      loopMaxIterations,
      nativeFunctions,
      output,
      optimizeFloatMemory,
      precision,
      plugins,
      source,
      subKernels,
      functions,
      leadingReturnStatement,
      followingReturnStatement,
      dynamicArguments,
      dynamicOutput,
      onIstanbulCoverageVariable,
      removeIstanbulCoverage,
    } = kernel;

    const argumentTypes = new Array(kernelArguments.length);
    const constantTypes = {};

    for (let i = 0; i < kernelArguments.length; i++) {
      argumentTypes[i] = kernelArguments[i].type;
    }

    for (let i = 0; i < kernelConstants.length; i++) {
      const kernelConstant = kernelConstants[i];
      constantTypes[kernelConstant.name] = kernelConstant.type;
    }

    const needsArgumentType = (functionName, index) => {
      return functionBuilder.needsArgumentType(functionName, index);
    };

    const assignArgumentType = (functionName, index, type) => {
      functionBuilder.assignArgumentType(functionName, index, type);
    };

    const lookupReturnType = (functionName, ast, requestingNode) => {
      return functionBuilder.lookupReturnType(functionName, ast, requestingNode);
    };

    const lookupFunctionArgumentTypes = (functionName) => {
      return functionBuilder.lookupFunctionArgumentTypes(functionName);
    };

    const lookupFunctionArgumentName = (functionName, argumentIndex) => {
      return functionBuilder.lookupFunctionArgumentName(functionName, argumentIndex);
    };

    const lookupFunctionArgumentBitRatio = (functionName, argumentName) => {
      return functionBuilder.lookupFunctionArgumentBitRatio(functionName, argumentName);
    };

    const triggerImplyArgumentType = (functionName, i, argumentType, requestingNode) => {
      functionBuilder.assignArgumentType(functionName, i, argumentType, requestingNode);
    };

    const triggerImplyArgumentBitRatio = (functionName, argumentName, calleeFunctionName, argumentIndex) => {
      functionBuilder.assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex);
    };

    const onFunctionCall = (functionName, calleeFunctionName, args) => {
      functionBuilder.trackFunctionCall(functionName, calleeFunctionName, args);
    };

    const onNestedFunction = (ast, returnType) => {
      const argumentNames = [];
      for (let i = 0; i < ast.params.length; i++) {
        argumentNames.push(ast.params[i].name);
      }
      const nestedFunction = new FunctionNode(null, Object.assign({}, nodeOptions, {
        returnType: null,
        ast,
        name: ast.id.name,
        argumentNames,
        lookupReturnType,
        lookupFunctionArgumentTypes,
        lookupFunctionArgumentName,
        lookupFunctionArgumentBitRatio,
        needsArgumentType,
        assignArgumentType,
        triggerImplyArgumentType,
        triggerImplyArgumentBitRatio,
        onFunctionCall,
      }));
      nestedFunction.traceFunctionAST(ast);
      functionBuilder.addFunctionNode(nestedFunction);
    };

    const nodeOptions = Object.assign({
      isRootKernel: false,
      onNestedFunction,
      lookupReturnType,
      lookupFunctionArgumentTypes,
      lookupFunctionArgumentName,
      lookupFunctionArgumentBitRatio,
      needsArgumentType,
      assignArgumentType,
      triggerImplyArgumentType,
      triggerImplyArgumentBitRatio,
      onFunctionCall,
      onIstanbulCoverageVariable: onIstanbulCoverageVariable ? (name) => onIstanbulCoverageVariable(name, kernel) : null,
      removeIstanbulCoverage,
      optimizeFloatMemory,
      precision,
      constants,
      constantTypes,
      constantBitRatios,
      debug,
      loopMaxIterations,
      output,
      plugins,
      dynamicArguments,
      dynamicOutput,
    }, extraNodeOptions || {});

    const rootNodeOptions = Object.assign({}, nodeOptions, {
      isRootKernel: true,
      name: 'kernel',
      argumentNames,
      argumentTypes,
      argumentSizes,
      argumentBitRatios,
      leadingReturnStatement,
      followingReturnStatement,
    });

    if (typeof source === 'object' && source.functionNodes) {
      return new FunctionBuilder().fromJSON(source.functionNodes, FunctionNode);
    }

    const rootNode = new FunctionNode(source, rootNodeOptions);

    let functionNodes = null;
    if (functions) {
      functionNodes = functions.map((fn) => new FunctionNode(fn.source, {
        returnType: fn.returnType,
        argumentTypes: fn.argumentTypes,
        output,
        plugins,
        constants,
        constantTypes,
        constantBitRatios,
        optimizeFloatMemory,
        precision,
        lookupReturnType,
        lookupFunctionArgumentTypes,
        lookupFunctionArgumentName,
        lookupFunctionArgumentBitRatio,
        needsArgumentType,
        assignArgumentType,
        triggerImplyArgumentType,
        triggerImplyArgumentBitRatio,
        onFunctionCall,
        onNestedFunction,
        onIstanbulCoverageVariable: onIstanbulCoverageVariable ? (name) => onIstanbulCoverageVariable(name, kernel) : null,
        removeIstanbulCoverage,
      }));
    }

    let subKernelNodes = null;
    if (subKernels) {
      subKernelNodes = subKernels.map((subKernel) => {
        const { name, source } = subKernel;
        return new FunctionNode(source, Object.assign({}, nodeOptions, {
          name,
          isSubKernel: true,
          isRootKernel: false,
        }));
      });
    }

    const functionBuilder = new FunctionBuilder({
      kernel,
      rootNode,
      functionNodes,
      nativeFunctions,
      subKernelNodes
    });

    return functionBuilder;
  }

  constructor(settings) {
    settings = settings || {};
    this.kernel = settings.kernel;
    this.rootNode = settings.rootNode;
    this.functionNodes = settings.functionNodes || [];
    this.subKernelNodes = settings.subKernelNodes || [];
    this.nativeFunctions = settings.nativeFunctions || [];
    this.functionMap = {};
    this.nativeFunctionNames = [];
    this.lookupChain = [];
    this.functionNodeDependencies = {};
    this.functionCalls = {};

    if (this.rootNode) {
      this.functionMap['kernel'] = this.rootNode;
    }

    if (this.functionNodes) {
      for (let i = 0; i < this.functionNodes.length; i++) {
        this.functionMap[this.functionNodes[i].name] = this.functionNodes[i];
      }
    }

    if (this.subKernelNodes) {
      for (let i = 0; i < this.subKernelNodes.length; i++) {
        this.functionMap[this.subKernelNodes[i].name] = this.subKernelNodes[i];
      }
    }

    if (this.nativeFunctions) {
      for (let i = 0; i < this.nativeFunctions.length; i++) {
        const nativeFunction = this.nativeFunctions[i];
        this.nativeFunctionNames.push(nativeFunction.name);
      }
    }
  }

  addFunctionNode(functionNode) {
    if (!functionNode.name) throw new Error('functionNode.name needs set');
    this.functionMap[functionNode.name] = functionNode;
    if (functionNode.isRootKernel) {
      this.rootNode = functionNode;
    }
  }

  traceFunctionCalls(functionName, retList) {
    functionName = functionName || 'kernel';
    retList = retList || [];

    if (this.nativeFunctionNames.indexOf(functionName) > -1) {
      if (retList.indexOf(functionName) === -1) {
        retList.push(functionName);
      }
      return retList;
    }

    const functionNode = this.functionMap[functionName];
    if (functionNode) {
      const functionIndex = retList.indexOf(functionName);
      if (functionIndex === -1) {
        retList.push(functionName);
        functionNode.toString(); 
        for (let i = 0; i < functionNode.calledFunctions.length; ++i) {
          this.traceFunctionCalls(functionNode.calledFunctions[i], retList);
        }
      } else {
        const dependantFunctionName = retList.splice(functionIndex, 1)[0];
        retList.push(dependantFunctionName);
      }
    }

    return retList;
  }

  getPrototypeString(functionName) {
    return this.getPrototypes(functionName).join('\n');
  }

  getPrototypes(functionName) {
    if (this.rootNode) {
      this.rootNode.toString();
    }
    if (functionName) {
      return this.getPrototypesFromFunctionNames(this.traceFunctionCalls(functionName, []).reverse());
    }
    return this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));
  }

  getStringFromFunctionNames(functionList) {
    const ret = [];
    for (let i = 0; i < functionList.length; ++i) {
      const node = this.functionMap[functionList[i]];
      if (node) {
        ret.push(this.functionMap[functionList[i]].toString());
      }
    }
    return ret.join('\n');
  }

  getPrototypesFromFunctionNames(functionList) {
    const ret = [];
    for (let i = 0; i < functionList.length; ++i) {
      const functionName = functionList[i];
      const functionIndex = this.nativeFunctionNames.indexOf(functionName);
      if (functionIndex > -1) {
        ret.push(this.nativeFunctions[functionIndex].source);
        continue;
      }
      const node = this.functionMap[functionName];
      if (node) {
        ret.push(node.toString());
      }
    }
    return ret;
  }

  toJSON() {
    return this.traceFunctionCalls(this.rootNode.name).reverse().map(name => {
      const nativeIndex = this.nativeFunctions.indexOf(name);
      if (nativeIndex > -1) {
        return {
          name,
          source: this.nativeFunctions[nativeIndex].source
        };
      } else if (this.functionMap[name]) {
        return this.functionMap[name].toJSON();
      } else {
        throw new Error(`function ${ name } not found`);
      }
    });
  }

  fromJSON(jsonFunctionNodes, FunctionNode) {
    this.functionMap = {};
    for (let i = 0; i < jsonFunctionNodes.length; i++) {
      const jsonFunctionNode = jsonFunctionNodes[i];
      this.functionMap[jsonFunctionNode.settings.name] = new FunctionNode(jsonFunctionNode.ast, jsonFunctionNode.settings);
    }
    return this;
  }

  getString(functionName) {
    if (functionName) {
      return this.getStringFromFunctionNames(this.traceFunctionCalls(functionName).reverse());
    }
    return this.getStringFromFunctionNames(Object.keys(this.functionMap));
  }

  lookupReturnType(functionName, ast, requestingNode) {
    if (ast.type !== 'CallExpression') {
      throw new Error(`expected ast type of "CallExpression", but is ${ ast.type }`);
    }
    if (this._isNativeFunction(functionName)) {
      return this._lookupNativeFunctionReturnType(functionName);
    } else if (this._isFunction(functionName)) {
      const node = this._getFunction(functionName);
      if (node.returnType) {
        return node.returnType;
      } else {
        for (let i = 0; i < this.lookupChain.length; i++) {
          if (this.lookupChain[i].ast === ast) {
            if (node.argumentTypes.length === 0 && ast.arguments.length > 0) {
              const args = ast.arguments;
              for (let j = 0; j < args.length; j++) {
                this.lookupChain.push({
                  name: requestingNode.name,
                  ast: args[i],
                  requestingNode
                });
                node.argumentTypes[j] = requestingNode.getType(args[j]);
                this.lookupChain.pop();
              }
              return node.returnType = node.getType(node.getJsAST());
            }

            throw new Error('circlical logic detected!');
          }
        }
        this.lookupChain.push({
          name: requestingNode.name,
          ast,
          requestingNode
        });
        const type = node.getType(node.getJsAST());
        this.lookupChain.pop();
        return node.returnType = type;
      }
    }

    return null;
  }

  _getFunction(functionName) {
    if (!this._isFunction(functionName)) {
      new Error(`Function ${functionName} not found`);
    }
    return this.functionMap[functionName];
  }

  _isFunction(functionName) {
    return Boolean(this.functionMap[functionName]);
  }

  _getNativeFunction(functionName) {
    for (let i = 0; i < this.nativeFunctions.length; i++) {
      if (this.nativeFunctions[i].name === functionName) return this.nativeFunctions[i];
    }
    return null;
  }

  _isNativeFunction(functionName) {
    return Boolean(this._getNativeFunction(functionName));
  }

  _lookupNativeFunctionReturnType(functionName) {
    let nativeFunction = this._getNativeFunction(functionName);
    if (nativeFunction) {
      return nativeFunction.returnType;
    }
    throw new Error(`Native function ${ functionName } not found`);
  }

  lookupFunctionArgumentTypes(functionName) {
    if (this._isNativeFunction(functionName)) {
      return this._getNativeFunction(functionName).argumentTypes;
    } else if (this._isFunction(functionName)) {
      return this._getFunction(functionName).argumentTypes;
    }
    return null;
  }

  lookupFunctionArgumentName(functionName, argumentIndex) {
    return this._getFunction(functionName).argumentNames[argumentIndex];
  }

  lookupFunctionArgumentBitRatio(functionName, argumentName) {
    if (!this._isFunction(functionName)) {
      throw new Error('function not found');
    }
    if (this.rootNode.name === functionName) {
      const i = this.rootNode.argumentNames.indexOf(argumentName);
      if (i !== -1) {
        return this.rootNode.argumentBitRatios[i];
      }
    }
    const node = this._getFunction(functionName);
    const i = node.argumentNames.indexOf(argumentName);
    if (i === -1) {
      throw new Error('argument not found');
    }
    const bitRatio = node.argumentBitRatios[i];
    if (typeof bitRatio !== 'number') {
      throw new Error('argument bit ratio not found');
    }
    return bitRatio;
  }

  needsArgumentType(functionName, i) {
    if (!this._isFunction(functionName)) return false;
    const fnNode = this._getFunction(functionName);
    return !fnNode.argumentTypes[i];
  }

  assignArgumentType(functionName, i, argumentType, requestingNode) {
    if (!this._isFunction(functionName)) return;
    const fnNode = this._getFunction(functionName);
    if (!fnNode.argumentTypes[i]) {
      fnNode.argumentTypes[i] = argumentType;
    }
  }

  assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex) {
    const node = this._getFunction(functionName);
    if (this._isNativeFunction(calleeFunctionName)) return null;
    const calleeNode = this._getFunction(calleeFunctionName);
    const i = node.argumentNames.indexOf(argumentName);
    if (i === -1) {
      throw new Error(`Argument ${argumentName} not found in arguments from function ${functionName}`);
    }
    const bitRatio = node.argumentBitRatios[i];
    if (typeof bitRatio !== 'number') {
      throw new Error(`Bit ratio for argument ${argumentName} not found in function ${functionName}`);
    }
    if (!calleeNode.argumentBitRatios) {
      calleeNode.argumentBitRatios = new Array(calleeNode.argumentNames.length);
    }
    const calleeBitRatio = calleeNode.argumentBitRatios[i];
    if (typeof calleeBitRatio === 'number') {
      if (calleeBitRatio !== bitRatio) {
        throw new Error(`Incompatible bit ratio found at function ${functionName} at argument ${argumentName}`);
      }
      return calleeBitRatio;
    }
    calleeNode.argumentBitRatios[i] = bitRatio;
    return bitRatio;
  }

  trackFunctionCall(functionName, calleeFunctionName, args) {
    if (!this.functionNodeDependencies[functionName]) {
      this.functionNodeDependencies[functionName] = new Set();
      this.functionCalls[functionName] = [];
    }
    this.functionNodeDependencies[functionName].add(calleeFunctionName);
    this.functionCalls[functionName].push(args);
  }

  getKernelResultType() {
    return this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast);
  }

  getSubKernelResultType(index) {
    const subKernelNode = this.subKernelNodes[index];
    let called = false;
    for (let functionCallIndex = 0; functionCallIndex < this.rootNode.functionCalls.length; functionCallIndex++) {
      const functionCall = this.rootNode.functionCalls[functionCallIndex];
      if (functionCall.ast.callee.name === subKernelNode.name) {
        called = true;
      }
    }
    if (!called) {
      throw new Error(`SubKernel ${ subKernelNode.name } never called by kernel`);
    }
    return subKernelNode.returnType || subKernelNode.getType(subKernelNode.getJsAST());
  }

  getReturnTypes() {
    const result = {
      [this.rootNode.name]: this.rootNode.getType(this.rootNode.ast),
    };
    const list = this.traceFunctionCalls(this.rootNode.name);
    for (let i = 0; i < list.length; i++) {
      const functionName = list[i];
      const functionNode = this.functionMap[functionName];
      result[functionName] = functionNode.getType(functionNode.ast);
    }
    return result;
  }
}

module.exports = {
  FunctionBuilder
};
},{}],10:[function(require,module,exports){
const acorn = require('acorn');
const { utils } = require('../utils');
const { FunctionTracer } = require('./function-tracer');

class FunctionNode {
  constructor(source, settings) {
    if (!source && !settings.ast) {
      throw new Error('source parameter is missing');
    }
    settings = settings || {};
    this.source = source;
    this.ast = null;
    this.name = typeof source === 'string' ? settings.isRootKernel ?
      'kernel' :
      (settings.name || utils.getFunctionNameFromString(source)) : null;
    this.calledFunctions = [];
    this.constants = {};
    this.constantTypes = {};
    this.constantBitRatios = {};
    this.isRootKernel = false;
    this.isSubKernel = false;
    this.debug = null;
    this.functions = null;
    this.identifiers = null;
    this.contexts = null;
    this.functionCalls = null;
    this.states = [];
    this.needsArgumentType = null;
    this.assignArgumentType = null;
    this.lookupReturnType = null;
    this.lookupFunctionArgumentTypes = null;
    this.lookupFunctionArgumentBitRatio = null;
    this.triggerImplyArgumentType = null;
    this.triggerImplyArgumentBitRatio = null;
    this.onNestedFunction = null;
    this.onFunctionCall = null;
    this.optimizeFloatMemory = null;
    this.precision = null;
    this.loopMaxIterations = null;
    this.argumentNames = (typeof this.source === 'string' ? utils.getArgumentNamesFromString(this.source) : null);
    this.argumentTypes = [];
    this.argumentSizes = [];
    this.argumentBitRatios = null;
    this.returnType = null;
    this.output = [];
    this.plugins = null;
    this.leadingReturnStatement = null;
    this.followingReturnStatement = null;
    this.dynamicOutput = null;
    this.dynamicArguments = null;
    this.strictTypingChecking = false;
    this.fixIntegerDivisionAccuracy = null;
    this.onIstanbulCoverageVariable = null;
    this.removeIstanbulCoverage = false;

    if (settings) {
      for (const p in settings) {
        if (!settings.hasOwnProperty(p)) continue;
        if (!this.hasOwnProperty(p)) continue;
        this[p] = settings[p];
      }
    }

    this.literalTypes = {};

    this.validate();
    this._string = null;
    this._internalVariableNames = {};
  }

  validate() {
    if (typeof this.source !== 'string' && !this.ast) {
      throw new Error('this.source not a string');
    }

    if (!this.ast && !utils.isFunctionString(this.source)) {
      throw new Error('this.source not a function string');
    }

    if (!this.name) {
      throw new Error('this.name could not be set');
    }

    if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length) {
      throw new Error(`argumentTypes count of ${ this.argumentTypes.length } exceeds ${ this.argumentNames.length }`);
    }

    if (this.output.length < 1) {
      throw new Error('this.output is not big enough');
    }
  }

  isIdentifierConstant(name) {
    if (!this.constants) return false;
    return this.constants.hasOwnProperty(name);
  }

  isInput(argumentName) {
    return this.argumentTypes[this.argumentNames.indexOf(argumentName)] === 'Input';
  }

  pushState(state) {
    this.states.push(state);
  }

  popState(state) {
    if (this.state !== state) {
      throw new Error(`Cannot popState ${ state } when in ${ this.state }`);
    }
    this.states.pop();
  }

  isState(state) {
    return this.state === state;
  }

  get state() {
    return this.states[this.states.length - 1];
  }

  astMemberExpressionUnroll(ast) {
    if (ast.type === 'Identifier') {
      return ast.name;
    } else if (ast.type === 'ThisExpression') {
      return 'this';
    }

    if (ast.type === 'MemberExpression') {
      if (ast.object && ast.property) {
        if (ast.object.hasOwnProperty('name') && ast.object.name[0] === '_') {
          return this.astMemberExpressionUnroll(ast.property);
        }

        return (
          this.astMemberExpressionUnroll(ast.object) +
          '.' +
          this.astMemberExpressionUnroll(ast.property)
        );
      }
    }

    if (ast.hasOwnProperty('expressions')) {
      const firstExpression = ast.expressions[0];
      if (firstExpression.type === 'Literal' && firstExpression.value === 0 && ast.expressions.length === 2) {
        return this.astMemberExpressionUnroll(ast.expressions[1]);
      }
    }

    throw this.astErrorOutput('Unknown astMemberExpressionUnroll', ast);
  }

  getJsAST(inParser) {
    if (this.ast) {
      return this.ast;
    }
    if (typeof this.source === 'object') {
      this.traceFunctionAST(this.source);
      return this.ast = this.source;
    }

    inParser = inParser || acorn;
    if (inParser === null) {
      throw new Error('Missing JS to AST parser');
    }

    const ast = Object.freeze(inParser.parse(`const parser_${ this.name } = ${ this.source };`, {
      locations: true
    }));
    const functionAST = ast.body[0].declarations[0].init;
    this.traceFunctionAST(functionAST);

    if (!ast) {
      throw new Error('Failed to parse JS code');
    }

    return this.ast = functionAST;
  }

  traceFunctionAST(ast) {
    const { contexts, declarations, functions, identifiers, functionCalls } = new FunctionTracer(ast);
    this.contexts = contexts;
    this.identifiers = identifiers;
    this.functionCalls = functionCalls;
    this.functions = functions;
    for (let i = 0; i < declarations.length; i++) {
      const declaration = declarations[i];
      const { ast, inForLoopInit, inForLoopTest } = declaration;
      const { init } = ast;
      const dependencies = this.getDependencies(init);
      let valueType = null;

      if (inForLoopInit && inForLoopTest) {
        valueType = 'Integer';
      } else {
        if (init) {
          const realType = this.getType(init);
          switch (realType) {
            case 'Integer':
            case 'Float':
            case 'Number':
              if (init.type === 'MemberExpression') {
                valueType = realType;
              } else {
                valueType = 'Number';
              }
              break;
            case 'LiteralInteger':
              valueType = 'Number';
              break;
            default:
              valueType = realType;
          }
        }
      }
      declaration.valueType = valueType;
      declaration.dependencies = dependencies;
      declaration.isSafe = this.isSafeDependencies(dependencies);
    }

    for (let i = 0; i < functions.length; i++) {
      this.onNestedFunction(functions[i]);
    }
  }

  getDeclaration(ast) {
    for (let i = 0; i < this.identifiers.length; i++) {
      const identifier = this.identifiers[i];
      if (ast === identifier.ast) {
        return identifier.declaration;
      }
    }
    return null;
  }

  getVariableType(ast) {
    if (ast.type !== 'Identifier') {
      throw new Error(`ast of ${ast.type} not "Identifier"`);
    }
    let type = null;
    const argumentIndex = this.argumentNames.indexOf(ast.name);
    if (argumentIndex === -1) {
      const declaration = this.getDeclaration(ast);
      if (declaration) {
        return declaration.valueType;
      }
    } else {
      const argumentType = this.argumentTypes[argumentIndex];
      if (argumentType) {
        type = argumentType;
      }
    }
    if (!type && this.strictTypingChecking) {
      throw new Error(`Declaration of ${name} not found`);
    }
    return type;
  }

  getLookupType(type) {
    if (!typeLookupMap.hasOwnProperty(type)) {
      throw new Error(`unknown typeLookupMap ${ type }`);
    }
    return typeLookupMap[type];
  }

  getConstantType(constantName) {
    if (this.constantTypes[constantName]) {
      const type = this.constantTypes[constantName];
      if (type === 'Float') {
        return 'Number';
      } else {
        return type;
      }
    }
    throw new Error(`Type for constant "${ constantName }" not declared`);
  }

  toString() {
    if (this._string) return this._string;
    return this._string = this.astGeneric(this.getJsAST(), []).join('').trim();
  }

  toJSON() {
    const settings = {
      source: this.source,
      name: this.name,
      constants: this.constants,
      constantTypes: this.constantTypes,
      isRootKernel: this.isRootKernel,
      isSubKernel: this.isSubKernel,
      debug: this.debug,
      output: this.output,
      loopMaxIterations: this.loopMaxIterations,
      argumentNames: this.argumentNames,
      argumentTypes: this.argumentTypes,
      argumentSizes: this.argumentSizes,
      returnType: this.returnType,
      leadingReturnStatement: this.leadingReturnStatement,
      followingReturnStatement: this.followingReturnStatement,
    };

    return {
      ast: this.ast,
      settings
    };
  }

  getType(ast) {
    if (Array.isArray(ast)) {
      return this.getType(ast[ast.length - 1]);
    }
    switch (ast.type) {
      case 'BlockStatement':
        return this.getType(ast.body);
      case 'ArrayExpression':
        return `Array(${ ast.elements.length })`;
      case 'Literal':
        const literalKey = this.astKey(ast);
        if (this.literalTypes[literalKey]) {
          return this.literalTypes[literalKey];
        }
        if (Number.isInteger(ast.value)) {
          return 'LiteralInteger';
        } else if (ast.value === true || ast.value === false) {
          return 'Boolean';
        } else {
          return 'Number';
        }
        case 'AssignmentExpression':
          return this.getType(ast.left);
        case 'CallExpression':
          if (this.isAstMathFunction(ast)) {
            return 'Number';
          }
          if (!ast.callee || !ast.callee.name) {
            if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[ast.callee.expressions.length - 1].property.name) {
              const functionName = ast.callee.expressions[ast.callee.expressions.length - 1].property.name;
              this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
              return this.lookupReturnType(functionName, ast, this);
            }
            if (this.getVariableSignature(ast.callee, true) === 'this.color') {
              return null;
            }
            throw this.astErrorOutput('Unknown call expression', ast);
          }
          if (ast.callee && ast.callee.name) {
            const functionName = ast.callee.name;
            this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
            return this.lookupReturnType(functionName, ast, this);
          }
          throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
        case 'LogicalExpression':
          return 'Boolean';
        case 'BinaryExpression':
          switch (ast.operator) {
            case '%':
            case '/':
              if (this.fixIntegerDivisionAccuracy) {
                return 'Number';
              } else {
                break;
              }
              case '>':
              case '<':
                return 'Boolean';
              case '&':
              case '|':
              case '^':
              case '<<':
              case '>>':
              case '>>>':
                return 'Integer';
          }
          const type = this.getType(ast.left);
          if (this.isState('skip-literal-correction')) return type;
          if (type === 'LiteralInteger') {
            const rightType = this.getType(ast.right);
            if (rightType === 'LiteralInteger') {
              if (ast.left.value % 1 === 0) {
                return 'Integer';
              } else {
                return 'Float';
              }
            }
            return rightType;
          }
          return typeLookupMap[type] || type;
        case 'UpdateExpression':
          return this.getType(ast.argument);
        case 'UnaryExpression':
          if (ast.operator === '~') {
            return 'Integer';
          }
          return this.getType(ast.argument);
        case 'VariableDeclaration': {
          const declarations = ast.declarations;
          let lastType;
          for (let i = 0; i < declarations.length; i++) {
            const declaration = declarations[i];
            lastType = this.getType(declaration);
          }
          if (!lastType) {
            throw this.astErrorOutput(`Unable to find type for declaration`, ast);
          }
          return lastType;
        }
        case 'VariableDeclarator':
          const declaration = this.getDeclaration(ast.id);
          if (!declaration) {
            throw this.astErrorOutput(`Unable to find declarator`, ast);
          }

          if (!declaration.valueType) {
            throw this.astErrorOutput(`Unable to find declarator valueType`, ast);
          }

          return declaration.valueType;
        case 'Identifier':
          if (ast.name === 'Infinity') {
            return 'Number';
          }
          if (this.isAstVariable(ast)) {
            const signature = this.getVariableSignature(ast);
            if (signature === 'value') {
              return this.getCheckVariableType(ast);
            }
          }
          const origin = this.findIdentifierOrigin(ast);
          if (origin && origin.init) {
            return this.getType(origin.init);
          }
          return null;
        case 'ReturnStatement':
          return this.getType(ast.argument);
        case 'MemberExpression':
          if (this.isAstMathFunction(ast)) {
            switch (ast.property.name) {
              case 'ceil':
                return 'Integer';
              case 'floor':
                return 'Integer';
              case 'round':
                return 'Integer';
            }
            return 'Number';
          }
          if (this.isAstVariable(ast)) {
            const variableSignature = this.getVariableSignature(ast);
            switch (variableSignature) {
              case 'value[]':
                return this.getLookupType(this.getCheckVariableType(ast.object));
              case 'value[][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object));
              case 'value[][][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object.object));
              case 'value[][][][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object.object.object));
              case 'value.thread.value':
              case 'this.thread.value':
                return 'Integer';
              case 'this.output.value':
                return this.dynamicOutput ? 'Integer' : 'LiteralInteger';
              case 'this.constants.value':
                return this.getConstantType(ast.property.name);
              case 'this.constants.value[]':
                return this.getLookupType(this.getConstantType(ast.object.property.name));
              case 'this.constants.value[][]':
                return this.getLookupType(this.getConstantType(ast.object.object.property.name));
              case 'this.constants.value[][][]':
                return this.getLookupType(this.getConstantType(ast.object.object.object.property.name));
              case 'this.constants.value[][][][]':
                return this.getLookupType(this.getConstantType(ast.object.object.object.object.property.name));
              case 'fn()[]':
              case 'fn()[][]':
              case 'fn()[][][]':
                return this.getLookupType(this.getType(ast.object));
              case 'value.value':
                if (this.isAstMathVariable(ast)) {
                  return 'Number';
                }
                switch (ast.property.name) {
                  case 'r':
                  case 'g':
                  case 'b':
                  case 'a':
                    return this.getLookupType(this.getCheckVariableType(ast.object));
                }
                case '[][]':
                  return 'Number';
            }
            throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
          }
          throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
        case 'ConditionalExpression':
          return this.getType(ast.consequent);
        case 'FunctionDeclaration':
        case 'FunctionExpression':
          const lastReturn = this.findLastReturn(ast.body);
          if (lastReturn) {
            return this.getType(lastReturn);
          }
          return null;
        case 'IfStatement':
          return this.getType(ast.consequent);
        case 'SequenceExpression':
          return this.getType(ast.expressions[ast.expressions.length - 1]);
        default:
          throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
    }
  }

  getCheckVariableType(ast) {
    const type = this.getVariableType(ast);
    if (!type) {
      throw this.astErrorOutput(`${ast.type} is not defined`, ast);
    }
    return type;
  }

  inferArgumentTypesIfNeeded(functionName, args) {
    for (let i = 0; i < args.length; i++) {
      if (!this.needsArgumentType(functionName, i)) continue;
      const type = this.getType(args[i]);
      if (!type) {
        throw this.astErrorOutput(`Unable to infer argument ${i}`, args[i]);
      }
      this.assignArgumentType(functionName, i, type);
    }
  }

  isAstMathVariable(ast) {
    const mathProperties = [
      'E',
      'PI',
      'SQRT2',
      'SQRT1_2',
      'LN2',
      'LN10',
      'LOG2E',
      'LOG10E',
    ];
    return ast.type === 'MemberExpression' &&
      ast.object && ast.object.type === 'Identifier' &&
      ast.object.name === 'Math' &&
      ast.property &&
      ast.property.type === 'Identifier' &&
      mathProperties.indexOf(ast.property.name) > -1;
  }

  isAstMathFunction(ast) {
    const mathFunctions = [
      'abs',
      'acos',
      'acosh',
      'asin',
      'asinh',
      'atan',
      'atan2',
      'atanh',
      'cbrt',
      'ceil',
      'clz32',
      'cos',
      'cosh',
      'expm1',
      'exp',
      'floor',
      'fround',
      'imul',
      'log',
      'log2',
      'log10',
      'log1p',
      'max',
      'min',
      'pow',
      'random',
      'round',
      'sign',
      'sin',
      'sinh',
      'sqrt',
      'tan',
      'tanh',
      'trunc',
    ];
    return ast.type === 'CallExpression' &&
      ast.callee &&
      ast.callee.type === 'MemberExpression' &&
      ast.callee.object &&
      ast.callee.object.type === 'Identifier' &&
      ast.callee.object.name === 'Math' &&
      ast.callee.property &&
      ast.callee.property.type === 'Identifier' &&
      mathFunctions.indexOf(ast.callee.property.name) > -1;
  }

  isAstVariable(ast) {
    return ast.type === 'Identifier' || ast.type === 'MemberExpression';
  }

  isSafe(ast) {
    return this.isSafeDependencies(this.getDependencies(ast));
  }

  isSafeDependencies(dependencies) {
    return dependencies && dependencies.every ? dependencies.every(dependency => dependency.isSafe) : true;
  }

  getDependencies(ast, dependencies, isNotSafe) {
    if (!dependencies) {
      dependencies = [];
    }
    if (!ast) return null;
    if (Array.isArray(ast)) {
      for (let i = 0; i < ast.length; i++) {
        this.getDependencies(ast[i], dependencies, isNotSafe);
      }
      return dependencies;
    }
    switch (ast.type) {
      case 'AssignmentExpression':
        this.getDependencies(ast.left, dependencies, isNotSafe);
        this.getDependencies(ast.right, dependencies, isNotSafe);
        return dependencies;
      case 'ConditionalExpression':
        this.getDependencies(ast.test, dependencies, isNotSafe);
        this.getDependencies(ast.alternate, dependencies, isNotSafe);
        this.getDependencies(ast.consequent, dependencies, isNotSafe);
        return dependencies;
      case 'Literal':
        dependencies.push({
          origin: 'literal',
          value: ast.value,
          isSafe: isNotSafe === true ? false : ast.value > -Infinity && ast.value < Infinity && !isNaN(ast.value)
        });
        break;
      case 'VariableDeclarator':
        return this.getDependencies(ast.init, dependencies, isNotSafe);
      case 'Identifier':
        const declaration = this.getDeclaration(ast);
        if (declaration) {
          dependencies.push({
            name: ast.name,
            origin: 'declaration',
            isSafe: isNotSafe ? false : this.isSafeDependencies(declaration.dependencies),
          });
        } else if (this.argumentNames.indexOf(ast.name) > -1) {
          dependencies.push({
            name: ast.name,
            origin: 'argument',
            isSafe: false,
          });
        } else if (this.strictTypingChecking) {
          throw new Error(`Cannot find identifier origin "${ast.name}"`);
        }
        break;
      case 'FunctionDeclaration':
        return this.getDependencies(ast.body.body[ast.body.body.length - 1], dependencies, isNotSafe);
      case 'ReturnStatement':
        return this.getDependencies(ast.argument, dependencies);
      case 'BinaryExpression':
      case 'LogicalExpression':
        isNotSafe = (ast.operator === '/' || ast.operator === '*');
        this.getDependencies(ast.left, dependencies, isNotSafe);
        this.getDependencies(ast.right, dependencies, isNotSafe);
        return dependencies;
      case 'UnaryExpression':
      case 'UpdateExpression':
        return this.getDependencies(ast.argument, dependencies, isNotSafe);
      case 'VariableDeclaration':
        return this.getDependencies(ast.declarations, dependencies, isNotSafe);
      case 'ArrayExpression':
        dependencies.push({
          origin: 'declaration',
          isSafe: true,
        });
        return dependencies;
      case 'CallExpression':
        dependencies.push({
          origin: 'function',
          isSafe: true,
        });
        return dependencies;
      case 'MemberExpression':
        const details = this.getMemberExpressionDetails(ast);
        switch (details.signature) {
          case 'value[]':
            this.getDependencies(ast.object, dependencies, isNotSafe);
            break;
          case 'value[][]':
            this.getDependencies(ast.object.object, dependencies, isNotSafe);
            break;
          case 'value[][][]':
            this.getDependencies(ast.object.object.object, dependencies, isNotSafe);
            break;
          case 'this.output.value':
            if (this.dynamicOutput) {
              dependencies.push({
                name: details.name,
                origin: 'output',
                isSafe: false,
              });
            }
            break;
        }
        if (details) {
          if (details.property) {
            this.getDependencies(details.property, dependencies, isNotSafe);
          }
          if (details.xProperty) {
            this.getDependencies(details.xProperty, dependencies, isNotSafe);
          }
          if (details.yProperty) {
            this.getDependencies(details.yProperty, dependencies, isNotSafe);
          }
          if (details.zProperty) {
            this.getDependencies(details.zProperty, dependencies, isNotSafe);
          }
          return dependencies;
        }
        case 'SequenceExpression':
          return this.getDependencies(ast.expressions, dependencies, isNotSafe);
        default:
          throw this.astErrorOutput(`Unhandled type ${ ast.type } in getDependencies`, ast);
    }
    return dependencies;
  }

  getVariableSignature(ast, returnRawValue) {
    if (!this.isAstVariable(ast)) {
      throw new Error(`ast of type "${ ast.type }" is not a variable signature`);
    }
    if (ast.type === 'Identifier') {
      return 'value';
    }
    const signature = [];
    while (true) {
      if (!ast) break;
      if (ast.computed) {
        signature.push('[]');
      } else if (ast.type === 'ThisExpression') {
        signature.unshift('this');
      } else if (ast.property && ast.property.name) {
        if (
          ast.property.name === 'x' ||
          ast.property.name === 'y' ||
          ast.property.name === 'z'
        ) {
          signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');
        } else if (
          ast.property.name === 'constants' ||
          ast.property.name === 'thread' ||
          ast.property.name === 'output'
        ) {
          signature.unshift('.' + ast.property.name);
        } else {
          signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');
        }
      } else if (ast.name) {
        signature.unshift(returnRawValue ? ast.name : 'value');
      } else if (ast.callee && ast.callee.name) {
        signature.unshift(returnRawValue ? ast.callee.name + '()' : 'fn()');
      } else if (ast.elements) {
        signature.unshift('[]');
      } else {
        signature.unshift('unknown');
      }
      ast = ast.object;
    }

    const signatureString = signature.join('');
    if (returnRawValue) {
      return signatureString;
    }

    const allowedExpressions = [
      'value',
      'value[]',
      'value[][]',
      'value[][][]',
      'value[][][][]',
      'value.value',
      'value.value[]', 
      'value.value[][]', 
      'value.thread.value',
      'this.thread.value',
      'this.output.value',
      'this.constants.value',
      'this.constants.value[]',
      'this.constants.value[][]',
      'this.constants.value[][][]',
      'this.constants.value[][][][]',
      'fn()[]',
      'fn()[][]',
      'fn()[][][]',
      '[][]',
    ];
    if (allowedExpressions.indexOf(signatureString) > -1) {
      return signatureString;
    }
    return null;
  }

  build() {
    return this.toString().length > 0;
  }

  astGeneric(ast, retArr) {
    if (ast === null) {
      throw this.astErrorOutput('NULL ast', ast);
    } else {
      if (Array.isArray(ast)) {
        for (let i = 0; i < ast.length; i++) {
          this.astGeneric(ast[i], retArr);
        }
        return retArr;
      }

      switch (ast.type) {
        case 'FunctionDeclaration':
          return this.astFunctionDeclaration(ast, retArr);
        case 'FunctionExpression':
          return this.astFunctionExpression(ast, retArr);
        case 'ReturnStatement':
          return this.astReturnStatement(ast, retArr);
        case 'Literal':
          return this.astLiteral(ast, retArr);
        case 'BinaryExpression':
          return this.astBinaryExpression(ast, retArr);
        case 'Identifier':
          return this.astIdentifierExpression(ast, retArr);
        case 'AssignmentExpression':
          return this.astAssignmentExpression(ast, retArr);
        case 'ExpressionStatement':
          return this.astExpressionStatement(ast, retArr);
        case 'EmptyStatement':
          return this.astEmptyStatement(ast, retArr);
        case 'BlockStatement':
          return this.astBlockStatement(ast, retArr);
        case 'IfStatement':
          return this.astIfStatement(ast, retArr);
        case 'SwitchStatement':
          return this.astSwitchStatement(ast, retArr);
        case 'BreakStatement':
          return this.astBreakStatement(ast, retArr);
        case 'ContinueStatement':
          return this.astContinueStatement(ast, retArr);
        case 'ForStatement':
          return this.astForStatement(ast, retArr);
        case 'WhileStatement':
          return this.astWhileStatement(ast, retArr);
        case 'DoWhileStatement':
          return this.astDoWhileStatement(ast, retArr);
        case 'VariableDeclaration':
          return this.astVariableDeclaration(ast, retArr);
        case 'VariableDeclarator':
          return this.astVariableDeclarator(ast, retArr);
        case 'ThisExpression':
          return this.astThisExpression(ast, retArr);
        case 'SequenceExpression':
          return this.astSequenceExpression(ast, retArr);
        case 'UnaryExpression':
          return this.astUnaryExpression(ast, retArr);
        case 'UpdateExpression':
          return this.astUpdateExpression(ast, retArr);
        case 'LogicalExpression':
          return this.astLogicalExpression(ast, retArr);
        case 'MemberExpression':
          return this.astMemberExpression(ast, retArr);
        case 'CallExpression':
          return this.astCallExpression(ast, retArr);
        case 'ArrayExpression':
          return this.astArrayExpression(ast, retArr);
        case 'DebuggerStatement':
          return this.astDebuggerStatement(ast, retArr);
        case 'ConditionalExpression':
          return this.astConditionalExpression(ast, retArr);
      }

      throw this.astErrorOutput('Unknown ast type : ' + ast.type, ast);
    }
  }
  astErrorOutput(error, ast) {
    if (typeof this.source !== 'string') {
      return new Error(error);
    }

    const debugString = utils.getAstString(this.source, ast);
    const leadingSource = this.source.substr(ast.start);
    const splitLines = leadingSource.split(/\n/);
    const lineBefore = splitLines.length > 0 ? splitLines[splitLines.length - 1] : 0;
    return new Error(`${error} on line ${ splitLines.length }, position ${ lineBefore.length }:\n ${ debugString }`);
  }

  astDebuggerStatement(arrNode, retArr) {
    return retArr;
  }

  astConditionalExpression(ast, retArr) {
    if (ast.type !== 'ConditionalExpression') {
      throw this.astErrorOutput('Not a conditional expression', ast);
    }
    retArr.push('(');
    this.astGeneric(ast.test, retArr);
    retArr.push('?');
    this.astGeneric(ast.consequent, retArr);
    retArr.push(':');
    this.astGeneric(ast.alternate, retArr);
    retArr.push(')');
    return retArr;
  }

  astFunction(ast, retArr) {
    throw new Error(`"astFunction" not defined on ${ this.constructor.name }`);
  }

  astFunctionDeclaration(ast, retArr) {
    if (this.isChildFunction(ast)) {
      return retArr;
    }
    return this.astFunction(ast, retArr);
  }
  astFunctionExpression(ast, retArr) {
    if (this.isChildFunction(ast)) {
      return retArr;
    }
    return this.astFunction(ast, retArr);
  }
  isChildFunction(ast) {
    for (let i = 0; i < this.functions.length; i++) {
      if (this.functions[i] === ast) {
        return true;
      }
    }
    return false;
  }
  astReturnStatement(ast, retArr) {
    return retArr;
  }
  astLiteral(ast, retArr) {
    this.literalTypes[this.astKey(ast)] = 'Number';
    return retArr;
  }
  astBinaryExpression(ast, retArr) {
    return retArr;
  }
  astIdentifierExpression(ast, retArr) {
    return retArr;
  }
  astAssignmentExpression(ast, retArr) {
    return retArr;
  }
  astExpressionStatement(esNode, retArr) {
    this.astGeneric(esNode.expression, retArr);
    retArr.push(';');
    return retArr;
  }
  astEmptyStatement(eNode, retArr) {
    return retArr;
  }
  astBlockStatement(ast, retArr) {
    return retArr;
  }
  astIfStatement(ast, retArr) {
    return retArr;
  }
  astSwitchStatement(ast, retArr) {
    return retArr;
  }
  astBreakStatement(brNode, retArr) {
    retArr.push('break;');
    return retArr;
  }
  astContinueStatement(crNode, retArr) {
    retArr.push('continue;\n');
    return retArr;
  }
  astForStatement(ast, retArr) {
    return retArr;
  }
  astWhileStatement(ast, retArr) {
    return retArr;
  }
  astDoWhileStatement(ast, retArr) {
    return retArr;
  }
  astVariableDeclarator(iVarDecNode, retArr) {
    this.astGeneric(iVarDecNode.id, retArr);
    if (iVarDecNode.init !== null) {
      retArr.push('=');
      this.astGeneric(iVarDecNode.init, retArr);
    }
    return retArr;
  }
  astThisExpression(ast, retArr) {
    return retArr;
  }
  isIstanbulAST(ast) {
    const variableSignature = this.getVariableSignature(ast);
    return variableSignature === 'value.value[]' || variableSignature === 'value.value[][]';
  }
  astSequenceExpression(sNode, retArr) {
    const { expressions } = sNode;
    const sequenceResult = [];
    for (let i = 0; i < expressions.length; i++) {
      const expression = expressions[i];
      if (this.removeIstanbulCoverage) {
        if (expression.type === 'UpdateExpression' && this.isIstanbulAST(expression.argument)) {
          continue;
        }
      }
      const expressionResult = [];
      this.astGeneric(expression, expressionResult);
      sequenceResult.push(expressionResult.join(''));
    }
    if (sequenceResult.length > 1) {
      retArr.push('(', sequenceResult.join(','), ')');
    } else {
      retArr.push(sequenceResult[0]);
    }
    return retArr;
  }
  astUnaryExpression(uNode, retArr) {
    const unaryResult = this.checkAndUpconvertBitwiseUnary(uNode, retArr);
    if (unaryResult) {
      return retArr;
    }

    if (uNode.prefix) {
      retArr.push(uNode.operator);
      this.astGeneric(uNode.argument, retArr);
    } else {
      this.astGeneric(uNode.argument, retArr);
      retArr.push(uNode.operator);
    }

    return retArr;
  }

  checkAndUpconvertBitwiseUnary(uNode, retArr) {}

  astUpdateExpression(uNode, retArr) {
    if (this.removeIstanbulCoverage) {
      const signature = this.getVariableSignature(uNode.argument);
      if (this.isIstanbulAST(uNode.argument)) {
        return retArr;
      }
    }
    if (uNode.prefix) {
      retArr.push(uNode.operator);
      this.astGeneric(uNode.argument, retArr);
    } else {
      this.astGeneric(uNode.argument, retArr);
      retArr.push(uNode.operator);
    }

    return retArr;
  }
  astLogicalExpression(logNode, retArr) {
    retArr.push('(');
    this.astGeneric(logNode.left, retArr);
    retArr.push(logNode.operator);
    this.astGeneric(logNode.right, retArr);
    retArr.push(')');
    return retArr;
  }
  astMemberExpression(ast, retArr) {
    return retArr;
  }
  astCallExpression(ast, retArr) {
    return retArr;
  }
  astArrayExpression(ast, retArr) {
    return retArr;
  }

  getMemberExpressionDetails(ast) {
    if (ast.type !== 'MemberExpression') {
      throw this.astErrorOutput(`Expression ${ ast.type } not a MemberExpression`, ast);
    }
    let name = null;
    let type = null;
    const variableSignature = this.getVariableSignature(ast);
    switch (variableSignature) {
      case 'value':
        return null;
      case 'value.thread.value':
      case 'this.thread.value':
      case 'this.output.value':
        return {
          signature: variableSignature,
            type: 'Integer',
            name: ast.property.name
        };
      case 'value[]':
        if (typeof ast.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object),
            xProperty: ast.property
        };
      case 'value[][]':
        if (typeof ast.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object),
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value[][][]':
        if (typeof ast.object.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object.object),
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value[][][][]':
        if (typeof ast.object.object.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object.object.object),
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value.value':
        if (typeof ast.property.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        if (this.isAstMathVariable(ast)) {
          name = ast.property.name;
          return {
            name,
            origin: 'Math',
            type: 'Number',
            signature: variableSignature,
          };
        }
        switch (ast.property.name) {
          case 'r':
          case 'g':
          case 'b':
          case 'a':
            name = ast.object.name;
            return {
              name,
              property: ast.property.name,
                origin: 'user',
                signature: variableSignature,
                type: 'Number'
            };
          default:
            throw this.astErrorOutput('Unexpected expression', ast);
        }
        case 'this.constants.value':
          if (typeof ast.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
              signature: variableSignature,
          };
        case 'this.constants.value[]':
          if (typeof ast.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
              signature: variableSignature,
              xProperty: ast.property,
          };
        case 'this.constants.value[][]': {
          if (typeof ast.object.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
            signature: variableSignature,
            yProperty: ast.object.property,
            xProperty: ast.property,
          };
        }
        case 'this.constants.value[][][]': {
          if (typeof ast.object.object.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.object.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
            signature: variableSignature,
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
          };
        }
        case 'fn()[]':
        case '[][]':
          return {
            signature: variableSignature,
              property: ast.property,
          };
        case 'value.value[]': 
          if (this.removeIstanbulCoverage) {
            return { signature: variableSignature };
          }
          if (this.onIstanbulCoverageVariable) {
            this.onIstanbulCoverageVariable(ast.object.object.name);
            return {
              signature: variableSignature
            };
          }
          case 'value.value[][]': 
            if (this.removeIstanbulCoverage) {
              return { signature: variableSignature };
            }
            if (this.onIstanbulCoverageVariable) {
              this.onIstanbulCoverageVariable(ast.object.object.object.name);
              return {
                signature: variableSignature
              };
            }
            default:
              throw this.astErrorOutput('Unexpected expression', ast);
    }
  }

  findIdentifierOrigin(astToFind) {
    const stack = [this.ast];

    while (stack.length > 0) {
      const atNode = stack[0];
      if (atNode.type === 'VariableDeclarator' && atNode.id && atNode.id.name && atNode.id.name === astToFind.name) {
        return atNode;
      }
      stack.shift();
      if (atNode.argument) {
        stack.push(atNode.argument);
      } else if (atNode.body) {
        stack.push(atNode.body);
      } else if (atNode.declarations) {
        stack.push(atNode.declarations);
      } else if (Array.isArray(atNode)) {
        for (let i = 0; i < atNode.length; i++) {
          stack.push(atNode[i]);
        }
      }
    }
    return null;
  }

  findLastReturn(ast) {
    const stack = [ast || this.ast];

    while (stack.length > 0) {
      const atNode = stack.pop();
      if (atNode.type === 'ReturnStatement') {
        return atNode;
      }
      if (atNode.type === 'FunctionDeclaration') {
        continue;
      }
      if (atNode.argument) {
        stack.push(atNode.argument);
      } else if (atNode.body) {
        stack.push(atNode.body);
      } else if (atNode.declarations) {
        stack.push(atNode.declarations);
      } else if (Array.isArray(atNode)) {
        for (let i = 0; i < atNode.length; i++) {
          stack.push(atNode[i]);
        }
      } else if (atNode.consequent) {
        stack.push(atNode.consequent);
      } else if (atNode.cases) {
        stack.push(atNode.cases);
      }
    }
    return null;
  }

  getInternalVariableName(name) {
    if (!this._internalVariableNames.hasOwnProperty(name)) {
      this._internalVariableNames[name] = 0;
    }
    this._internalVariableNames[name]++;
    if (this._internalVariableNames[name] === 1) {
      return name;
    }
    return name + this._internalVariableNames[name];
  }

  astKey(ast, separator = ',') {
    if (!ast.start || !ast.end) throw new Error('AST start and end needed');
    return `${ast.start}${separator}${ast.end}`;
  }
}

const typeLookupMap = {
  'Number': 'Number',
  'Float': 'Float',
  'Integer': 'Integer',
  'Array': 'Number',
  'Array(2)': 'Number',
  'Array(3)': 'Number',
  'Array(4)': 'Number',
  'Array2D': 'Number',
  'Array3D': 'Number',
  'Input': 'Number',
  'HTMLCanvas': 'Array(4)',
  'HTMLImage': 'Array(4)',
  'HTMLVideo': 'Array(4)',
  'HTMLImageArray': 'Array(4)',
  'NumberTexture': 'Number',
  'MemoryOptimizedNumberTexture': 'Number',
  'Array1D(2)': 'Array(2)',
  'Array1D(3)': 'Array(3)',
  'Array1D(4)': 'Array(4)',
  'Array2D(2)': 'Array(2)',
  'Array2D(3)': 'Array(3)',
  'Array2D(4)': 'Array(4)',
  'Array3D(2)': 'Array(2)',
  'Array3D(3)': 'Array(3)',
  'Array3D(4)': 'Array(4)',
  'ArrayTexture(1)': 'Number',
  'ArrayTexture(2)': 'Array(2)',
  'ArrayTexture(3)': 'Array(3)',
  'ArrayTexture(4)': 'Array(4)',
};

module.exports = {
  FunctionNode
};
},{"../utils":114,"./function-tracer":11,"acorn":1}],11:[function(require,module,exports){
const { utils } = require('../utils');

function last(array) {
  return array.length > 0 ? array[array.length - 1] : null;
}

const states = {
  trackIdentifiers: 'trackIdentifiers',
  memberExpression: 'memberExpression',
  inForLoopInit: 'inForLoopInit'
};

class FunctionTracer {
  constructor(ast) {
    this.runningContexts = [];
    this.functionContexts = [];
    this.contexts = [];
    this.functionCalls = [];
    this.declarations = [];
    this.identifiers = [];
    this.functions = [];
    this.returnStatements = [];
    this.trackedIdentifiers = null;
    this.states = [];
    this.newFunctionContext();
    this.scan(ast);
  }

  isState(state) {
    return this.states[this.states.length - 1] === state;
  }

  hasState(state) {
    return this.states.indexOf(state) > -1;
  }

  pushState(state) {
    this.states.push(state);
  }

  popState(state) {
    if (this.isState(state)) {
      this.states.pop();
    } else {
      throw new Error(`Cannot pop the non-active state "${state}"`);
    }
  }

  get currentFunctionContext() {
    return last(this.functionContexts);
  }

  get currentContext() {
    return last(this.runningContexts);
  }

  newFunctionContext() {
    const newContext = { '@contextType': 'function' };
    this.contexts.push(newContext);
    this.functionContexts.push(newContext);
  }

  newContext(run) {
    const newContext = Object.assign({ '@contextType': 'const/let' }, this.currentContext);
    this.contexts.push(newContext);
    this.runningContexts.push(newContext);
    run();
    const { currentFunctionContext } = this;
    for (const p in currentFunctionContext) {
      if (!currentFunctionContext.hasOwnProperty(p) || newContext.hasOwnProperty(p)) continue;
      newContext[p] = currentFunctionContext[p];
    }
    this.runningContexts.pop();
    return newContext;
  }

  useFunctionContext(run) {
    const functionContext = last(this.functionContexts);
    this.runningContexts.push(functionContext);
    run();
    this.runningContexts.pop();
  }

  getIdentifiers(run) {
    const trackedIdentifiers = this.trackedIdentifiers = [];
    this.pushState(states.trackIdentifiers);
    run();
    this.trackedIdentifiers = null;
    this.popState(states.trackIdentifiers);
    return trackedIdentifiers;
  }

  getDeclaration(name) {
    const { currentContext, currentFunctionContext, runningContexts } = this;
    const declaration = currentContext[name] || currentFunctionContext[name] || null;

    if (
      !declaration &&
      currentContext === currentFunctionContext &&
      runningContexts.length > 0
    ) {
      const previousRunningContext = runningContexts[runningContexts.length - 2];
      if (previousRunningContext[name]) {
        return previousRunningContext[name];
      }
    }

    return declaration;
  }

  scan(ast) {
    if (!ast) return;
    if (Array.isArray(ast)) {
      for (let i = 0; i < ast.length; i++) {
        this.scan(ast[i]);
      }
      return;
    }
    switch (ast.type) {
      case 'Program':
        this.useFunctionContext(() => {
          this.scan(ast.body);
        });
        break;
      case 'BlockStatement':
        this.newContext(() => {
          this.scan(ast.body);
        });
        break;
      case 'AssignmentExpression':
      case 'LogicalExpression':
        this.scan(ast.left);
        this.scan(ast.right);
        break;
      case 'BinaryExpression':
        this.scan(ast.left);
        this.scan(ast.right);
        break;
      case 'UpdateExpression':
        if (ast.operator === '++') {
          const declaration = this.getDeclaration(ast.argument.name);
          if (declaration) {
            declaration.suggestedType = 'Integer';
          }
        }
        this.scan(ast.argument);
        break;
      case 'UnaryExpression':
        this.scan(ast.argument);
        break;
      case 'VariableDeclaration':
        if (ast.kind === 'var') {
          this.useFunctionContext(() => {
            ast.declarations = utils.normalizeDeclarations(ast);
            this.scan(ast.declarations);
          });
        } else {
          ast.declarations = utils.normalizeDeclarations(ast);
          this.scan(ast.declarations);
        }
        break;
      case 'VariableDeclarator': {
        const { currentContext } = this;
        const inForLoopInit = this.hasState(states.inForLoopInit);
        const declaration = {
          ast: ast,
          context: currentContext,
          name: ast.id.name,
          origin: 'declaration',
          inForLoopInit,
          inForLoopTest: null,
          assignable: currentContext === this.currentFunctionContext || (!inForLoopInit && !currentContext.hasOwnProperty(ast.id.name)),
          suggestedType: null,
          valueType: null,
          dependencies: null,
          isSafe: null,
        };
        if (!currentContext[ast.id.name]) {
          currentContext[ast.id.name] = declaration;
        }
        this.declarations.push(declaration);
        this.scan(ast.id);
        this.scan(ast.init);
        break;
      }
      case 'FunctionExpression':
      case 'FunctionDeclaration':
        if (this.runningContexts.length === 0) {
          this.scan(ast.body);
        } else {
          this.functions.push(ast);
        }
        break;
      case 'IfStatement':
        this.scan(ast.test);
        this.scan(ast.consequent);
        if (ast.alternate) this.scan(ast.alternate);
        break;
      case 'ForStatement': {
        let testIdentifiers;
        const context = this.newContext(() => {
          this.pushState(states.inForLoopInit);
          this.scan(ast.init);
          this.popState(states.inForLoopInit);

          testIdentifiers = this.getIdentifiers(() => {
            this.scan(ast.test);
          });

          this.scan(ast.update);
          this.newContext(() => {
            this.scan(ast.body);
          });
        });

        if (testIdentifiers) {
          for (const p in context) {
            if (p === '@contextType') continue;
            if (testIdentifiers.indexOf(p) > -1) {
              context[p].inForLoopTest = true;
            }
          }
        }
        break;
      }
      case 'DoWhileStatement':
      case 'WhileStatement':
        this.newContext(() => {
          this.scan(ast.body);
          this.scan(ast.test);
        });
        break;
      case 'Identifier': {
        if (this.isState(states.trackIdentifiers)) {
          this.trackedIdentifiers.push(ast.name);
        }
        this.identifiers.push({
          context: this.currentContext,
          declaration: this.getDeclaration(ast.name),
          ast,
        });
        break;
      }
      case 'ReturnStatement':
        this.returnStatements.push(ast);
        this.scan(ast.argument);
        break;
      case 'MemberExpression':
        this.pushState(states.memberExpression);
        this.scan(ast.object);
        this.scan(ast.property);
        this.popState(states.memberExpression);
        break;
      case 'ExpressionStatement':
        this.scan(ast.expression);
        break;
      case 'SequenceExpression':
        this.scan(ast.expressions);
        break;
      case 'CallExpression':
        this.functionCalls.push({
          context: this.currentContext,
          ast,
        });
        this.scan(ast.arguments);
        break;
      case 'ArrayExpression':
        this.scan(ast.elements);
        break;
      case 'ConditionalExpression':
        this.scan(ast.test);
        this.scan(ast.alternate);
        this.scan(ast.consequent);
        break;
      case 'SwitchStatement':
        this.scan(ast.discriminant);
        this.scan(ast.cases);
        break;
      case 'SwitchCase':
        this.scan(ast.test);
        this.scan(ast.consequent);
        break;

      case 'ThisExpression':
      case 'Literal':
      case 'DebuggerStatement':
      case 'EmptyStatement':
      case 'BreakStatement':
      case 'ContinueStatement':
        break;
      default:
        throw new Error(`unhandled type "${ast.type}"`);
    }
  }
}

module.exports = {
  FunctionTracer,
};
},{"../utils":114}],12:[function(require,module,exports){
const { glWiretap } = require('gl-wiretap');
const { utils } = require('../../utils');

function toStringWithoutUtils(fn) {
  return fn.toString()
    .replace('=>', '')
    .replace(/^function /, '')
    .replace(/utils[.]/g, '/*utils.*/');
}

function glKernelString(Kernel, args, originKernel, setupContextString, destroyContextString) {
  if (!originKernel.built) {
    originKernel.build.apply(originKernel, args);
  }
  args = args ? Array.from(args).map(arg => {
    switch (typeof arg) {
      case 'boolean':
        return new Boolean(arg);
      case 'number':
        return new Number(arg);
      default:
        return arg;
    }
  }) : null;
  const uploadedValues = [];
  const postResult = [];
  const context = glWiretap(originKernel.context, {
    useTrackablePrimitives: true,
    onReadPixels: (targetName) => {
      if (kernel.subKernels) {
        if (!subKernelsResultVariableSetup) {
          postResult.push(`    const result = { result: ${getRenderString(targetName, kernel)} };`);
          subKernelsResultVariableSetup = true;
        } else {
          const property = kernel.subKernels[subKernelsResultIndex++].property;
          postResult.push(`    result${isNaN(property) ? '.' + property : `[${property}]`} = ${getRenderString(targetName, kernel)};`);
        }
        if (subKernelsResultIndex === kernel.subKernels.length) {
          postResult.push('    return result;');
        }
        return;
      }
      if (targetName) {
        postResult.push(`    return ${getRenderString(targetName, kernel)};`);
      } else {
        postResult.push(`    return null;`);
      }
    },
    onUnrecognizedArgumentLookup: (argument) => {
      const argumentName = findKernelValue(argument, kernel.kernelArguments, [], context, uploadedValues);
      if (argumentName) {
        return argumentName;
      }
      const constantName = findKernelValue(argument, kernel.kernelConstants, constants ? Object.keys(constants).map(key => constants[key]) : [], context, uploadedValues);
      if (constantName) {
        return constantName;
      }
      return null;
    }
  });
  let subKernelsResultVariableSetup = false;
  let subKernelsResultIndex = 0;
  const {
    source,
    canvas,
    output,
    pipeline,
    graphical,
    loopMaxIterations,
    constants,
    optimizeFloatMemory,
    precision,
    fixIntegerDivisionAccuracy,
    functions,
    nativeFunctions,
    subKernels,
    immutable,
    argumentTypes,
    constantTypes,
    kernelArguments,
    kernelConstants,
    tactic,
  } = originKernel;
  const kernel = new Kernel(source, {
    canvas,
    context,
    checkContext: false,
    output,
    pipeline,
    graphical,
    loopMaxIterations,
    constants,
    optimizeFloatMemory,
    precision,
    fixIntegerDivisionAccuracy,
    functions,
    nativeFunctions,
    subKernels,
    immutable,
    argumentTypes,
    constantTypes,
    tactic,
  });
  let result = [];
  context.setIndent(2);
  kernel.build.apply(kernel, args);
  result.push(context.toString());
  context.reset();

  kernel.kernelArguments.forEach((kernelArgument, i) => {
    switch (kernelArgument.type) {
      case 'Integer':
      case 'Boolean':
      case 'Number':
      case 'Float':
      case 'Array':
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'HTMLCanvas':
      case 'HTMLImage':
      case 'HTMLVideo':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);
        break;
      case 'HTMLImageArray':
        for (let imageIndex = 0; imageIndex < args[i].length; imageIndex++) {
          const arg = args[i];
          context.insertVariable(`uploadValue_${kernelArgument.name}[${imageIndex}]`, arg[imageIndex]);
        }
        break;
      case 'Input':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);
        break;
      case 'MemoryOptimizedNumberTexture':
      case 'NumberTexture':
      case 'Array1D(2)':
      case 'Array1D(3)':
      case 'Array1D(4)':
      case 'Array2D(2)':
      case 'Array2D(3)':
      case 'Array2D(4)':
      case 'Array3D(2)':
      case 'Array3D(3)':
      case 'Array3D(4)':
      case 'ArrayTexture(1)':
      case 'ArrayTexture(2)':
      case 'ArrayTexture(3)':
      case 'ArrayTexture(4)':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, args[i].texture);
        break;
      default:
        throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${kernelArgument.type}`);
    }
  });
  result.push('/** start of injected functions **/');
  result.push(`function ${toStringWithoutUtils(utils.flattenTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten2dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten3dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten4dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.isArray)}`);
  if (kernel.renderOutput !== kernel.renderTexture && kernel.formatValues) {
    result.push(
      `  const renderOutput = function ${toStringWithoutUtils(kernel.formatValues)};`
    );
  }
  result.push('/** end of injected functions **/');
  result.push(`  const innerKernel = function (${kernel.kernelArguments.map(kernelArgument => kernelArgument.varName).join(', ')}) {`);
  context.setIndent(4);
  kernel.run.apply(kernel, args);
  if (kernel.renderKernels) {
    kernel.renderKernels();
  } else if (kernel.renderOutput) {
    kernel.renderOutput();
  }
  result.push('    /** start setup uploads for kernel values **/');
  kernel.kernelArguments.forEach(kernelArgument => {
    result.push('    ' + kernelArgument.getStringValueHandler().split('\n').join('\n    '));
  });
  result.push('    /** end setup uploads for kernel values **/');
  result.push(context.toString());
  if (kernel.renderOutput === kernel.renderTexture) {
    context.reset();
    if (kernel.renderKernels) {
      const results = kernel.renderKernels();
      const textureName = context.getContextVariableName(kernel.texture.texture);
      result.push(`    return {
      result: {
        texture: ${ textureName },
        type: '${ results.result.type }',
        toArray: ${ getToArrayString(results.result, textureName) }
      },`);
      const { subKernels, mappedTextures } = kernel;
      for (let i = 0; i < subKernels.length; i++) {
        const texture = mappedTextures[i];
        const subKernel = subKernels[i];
        const subKernelResult = results[subKernel.property];
        const subKernelTextureName = context.getContextVariableName(texture.texture);
        result.push(`
      ${subKernel.property}: {
        texture: ${ subKernelTextureName },
        type: '${ subKernelResult.type }',
        toArray: ${ getToArrayString(subKernelResult, subKernelTextureName) }
      },`);
      }
      result.push(`    };`);
    } else {
      const rendered = kernel.renderOutput();
      const textureName = context.getContextVariableName(kernel.texture.texture);
      result.push(`    return {
        texture: ${ textureName },
        type: '${ rendered.type }',
        toArray: ${ getToArrayString(rendered, textureName) }
      };`);
    }
  }
  result.push(`    ${destroyContextString ? '\n' + destroyContextString + '    ': ''}`);
  result.push(postResult.join('\n'));
  result.push('  };');
  if (kernel.graphical) {
    result.push(getGetPixelsString(kernel));
    result.push(`  innerKernel.getPixels = getPixels;`);
  }
  result.push('  return innerKernel;');

  let constantsUpload = [];
  kernelConstants.forEach((kernelConstant) => {
    constantsUpload.push(`${  kernelConstant.getStringValueHandler()}`);
  });
  return `function kernel(settings) {
  const { context, constants } = settings;
  ${constantsUpload.join('')}
  ${setupContextString ? setupContextString : ''}
${result.join('\n')}
}`;
}

function getRenderString(targetName, kernel) {
  const readBackValue = kernel.precision === 'single' ? targetName : `new Float32Array(${targetName}.buffer)`;
  if (kernel.output[2]) {
    return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]}, ${kernel.output[2]})`;
  }
  if (kernel.output[1]) {
    return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]})`;
  }

  return `renderOutput(${readBackValue}, ${kernel.output[0]})`;
}

function getGetPixelsString(kernel) {
  const getPixels = kernel.getPixels.toString();
  const useFunctionKeyword = !/^function/.test(getPixels);
  return utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ getPixels }`, {
    findDependency: (object, name) => {
      if (object === 'utils') {
        return `const ${name} = ${utils[name].toString()};`;
      }
      return null;
    },
    thisLookup: (property) => {
      if (property === 'context') {
        return null;
      }
      if (kernel.hasOwnProperty(property)) {
        return JSON.stringify(kernel[property]);
      }
      throw new Error(`unhandled thisLookup ${ property }`);
    }
  });
}

function getToArrayString(kernelResult, textureName) {
  const toArray = kernelResult.toArray.toString();
  const useFunctionKeyword = !/^function/.test(toArray);
  const flattenedFunctions = utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ toArray }`, {
    findDependency: (object, name) => {
      if (object === 'utils') {
        return `const ${name} = ${utils[name].toString()};`;
      } else if (object === 'this') {
        return `${useFunctionKeyword ? 'function ' : ''}${kernelResult[name].toString()}`;
      } else {
        throw new Error('unhandled fromObject');
      }
    },
    thisLookup: (property, isDeclaration) => {
      if (property === 'texture') {
        return textureName;
      }
      if (property === 'context') {
        if (isDeclaration) return null;
        return 'gl';
      }
      if (property === '_framebuffer') {
        return '_framebuffer';
      }
      if (kernelResult.hasOwnProperty(property)) {
        return JSON.stringify(kernelResult[property]);
      }
      throw new Error(`unhandled thisLookup ${ property }`);
    }
  });
  return `() => {
  let _framebuffer;
  ${flattenedFunctions}
  return toArray();
  }`;
}

function findKernelValue(argument, kernelValues, values, context, uploadedValues) {
  if (argument === null) return null;
  if (kernelValues === null) return null;
  switch (typeof argument) {
    case 'boolean':
    case 'number':
      return null;
  }
  if (
    typeof HTMLImageElement !== 'undefined' &&
    argument instanceof HTMLImageElement
  ) {
    for (let i = 0; i < kernelValues.length; i++) {
      const kernelValue = kernelValues[i];
      if (kernelValue.type !== 'HTMLImageArray' && kernelValue) continue;
      if (kernelValue.uploadValue !== argument) continue;
      const variableIndex = values[i].indexOf(argument);
      if (variableIndex === -1) continue;
      const variableName = `uploadValue_${kernelValue.name}[${variableIndex}]`;
      context.insertVariable(variableName, argument);
      return variableName;
    }
  }

  for (let i = 0; i < kernelValues.length; i++) {
    const kernelValue = kernelValues[i];
    if (argument !== kernelValue.uploadValue) continue;
    const variable = `uploadValue_${kernelValue.name}`;
    context.insertVariable(variable, kernelValue);
    return variable;
  }
  return null;
}

module.exports = {
  glKernelString
};
},{"../../utils":114,"gl-wiretap":3}],13:[function(require,module,exports){
const { Kernel } = require('../kernel');
const { utils } = require('../../utils');
const { GLTextureArray2Float } = require('./texture/array-2-float');
const { GLTextureArray2Float2D } = require('./texture/array-2-float-2d');
const { GLTextureArray2Float3D } = require('./texture/array-2-float-3d');
const { GLTextureArray3Float } = require('./texture/array-3-float');
const { GLTextureArray3Float2D } = require('./texture/array-3-float-2d');
const { GLTextureArray3Float3D } = require('./texture/array-3-float-3d');
const { GLTextureArray4Float } = require('./texture/array-4-float');
const { GLTextureArray4Float2D } = require('./texture/array-4-float-2d');
const { GLTextureArray4Float3D } = require('./texture/array-4-float-3d');
const { GLTextureFloat } = require('./texture/float');
const { GLTextureFloat2D } = require('./texture/float-2d');
const { GLTextureFloat3D } = require('./texture/float-3d');
const { GLTextureMemoryOptimized } = require('./texture/memory-optimized');
const { GLTextureMemoryOptimized2D } = require('./texture/memory-optimized-2d');
const { GLTextureMemoryOptimized3D } = require('./texture/memory-optimized-3d');
const { GLTextureUnsigned } = require('./texture/unsigned');
const { GLTextureUnsigned2D } = require('./texture/unsigned-2d');
const { GLTextureUnsigned3D } = require('./texture/unsigned-3d');
const { GLTextureGraphical } = require('./texture/graphical');

class GLKernel extends Kernel {
  static get mode() {
    return 'gpu';
  }

  static getIsFloatRead() {
    const kernelString = `function kernelFunction() {
      return 1;
    }`;
    const kernel = new this(kernelString, {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [1],
      precision: 'single',
      returnType: 'Number',
      tactic: 'speed',
    });
    kernel.build();
    kernel.run();
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return result[0] === 1;
  }

  static getIsIntegerDivisionAccurate() {
    function kernelFunction(v1, v2) {
      return v1[this.thread.x] / v2[this.thread.x];
    }
    const kernel = new this(kernelFunction.toString(), {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [2],
      returnType: 'Number',
      precision: 'unsigned',
      tactic: 'speed',
    });
    const args = [
      [6, 6030401],
      [3, 3991]
    ];
    kernel.build.apply(kernel, args);
    kernel.run.apply(kernel, args);
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return result[0] === 2 && result[1] === 1511;
  }

  static getIsSpeedTacticSupported() {
    function kernelFunction(value) {
      return value[this.thread.x];
    }
    const kernel = new this(kernelFunction.toString(), {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [4],
      returnType: 'Number',
      precision: 'unsigned',
      tactic: 'speed',
    });
    const args = [
      [0, 1, 2, 3]
    ];
    kernel.build.apply(kernel, args);
    kernel.run.apply(kernel, args);
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return Math.round(result[0]) === 0 && Math.round(result[1]) === 1 && Math.round(result[2]) === 2 && Math.round(result[3]) === 3;
  }

  static get testCanvas() {
    throw new Error(`"testCanvas" not defined on ${ this.name }`);
  }

  static get testContext() {
    throw new Error(`"testContext" not defined on ${ this.name }`);
  }

  static getFeatures() {
    const gl = this.testContext;
    const isDrawBuffers = this.getIsDrawBuffers();
    return Object.freeze({
      isFloatRead: this.getIsFloatRead(),
      isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
      isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
      isTextureFloat: this.getIsTextureFloat(),
      isDrawBuffers,
      kernelMap: isDrawBuffers,
      channelCount: this.getChannelCount(),
      maxTextureSize: this.getMaxTextureSize(),
      lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),
      lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),
      mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),
      mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),
      highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),
      highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
    });
  }

  static setupFeatureChecks() {
    throw new Error(`"setupFeatureChecks" not defined on ${ this.name }`);
  }

  static getSignature(kernel, argumentTypes) {
    return kernel.getVariablePrecisionString() + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');
  }

  setFixIntegerDivisionAccuracy(fix) {
    this.fixIntegerDivisionAccuracy = fix;
    return this;
  }

  setPrecision(flag) {
    this.precision = flag;
    return this;
  }

  setFloatTextures(flag) {
    utils.warnDeprecated('method', 'setFloatTextures', 'setOptimizeFloatMemory');
    this.floatTextures = flag;
    return this;
  }

  static nativeFunctionArguments(source) {
    const argumentTypes = [];
    const argumentNames = [];
    const states = [];
    const isStartingVariableName = /^[a-zA-Z_]/;
    const isVariableChar = /[a-zA-Z_0-9]/;
    let i = 0;
    let argumentName = null;
    let argumentType = null;
    while (i < source.length) {
      const char = source[i];
      const nextChar = source[i + 1];
      const state = states.length > 0 ? states[states.length - 1] : null;

      if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '*') {
        states.push('MULTI_LINE_COMMENT');
        i += 2;
        continue;
      } else if (state === 'MULTI_LINE_COMMENT' && char === '*' && nextChar === '/') {
        states.pop();
        i += 2;
        continue;
      }

      else if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '/') {
        states.push('COMMENT');
        i += 2;
        continue;
      } else if (state === 'COMMENT' && char === '\n') {
        states.pop();
        i++;
        continue;
      }

      else if (state === null && char === '(') {
        states.push('FUNCTION_ARGUMENTS');
        i++;
        continue;
      } else if (state === 'FUNCTION_ARGUMENTS') {
        if (char === ')') {
          states.pop();
          break;
        }
        if (char === 'f' && nextChar === 'l' && source[i + 2] === 'o' && source[i + 3] === 'a' && source[i + 4] === 't' && source[i + 5] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'float';
          argumentName = '';
          i += 6;
          continue;
        } else if (char === 'i' && nextChar === 'n' && source[i + 2] === 't' && source[i + 3] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'int';
          argumentName = '';
          i += 4;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '2' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec2';
          argumentName = '';
          i += 5;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '3' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec3';
          argumentName = '';
          i += 5;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '4' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec4';
          argumentName = '';
          i += 5;
          continue;
        }
      }

      else if (state === 'DECLARE_VARIABLE') {
        if (argumentName === '') {
          if (char === ' ') {
            i++;
            continue;
          }
          if (!isStartingVariableName.test(char)) {
            throw new Error('variable name is not expected string');
          }
        }
        argumentName += char;
        if (!isVariableChar.test(nextChar)) {
          states.pop();
          argumentNames.push(argumentName);
          argumentTypes.push(typeMap[argumentType]);
        }
      }

      i++;
    }
    if (states.length > 0) {
      throw new Error('GLSL function was not parsable');
    }
    return {
      argumentNames,
      argumentTypes,
    };
  }

  static nativeFunctionReturnType(source) {
    return typeMap[source.match(/int|float|vec[2-4]/)[0]];
  }

  static combineKernels(combinedKernel, lastKernel) {
    combinedKernel.apply(null, arguments);
    const {
      texSize,
      context,
      threadDim
    } = lastKernel.texSize;
    let result;
    if (lastKernel.precision === 'single') {
      const w = texSize[0];
      const h = Math.ceil(texSize[1] / 4);
      result = new Float32Array(w * h * 4 * 4);
      context.readPixels(0, 0, w, h * 4, context.RGBA, context.FLOAT, result);
    } else {
      const bytes = new Uint8Array(texSize[0] * texSize[1] * 4);
      context.readPixels(0, 0, texSize[0], texSize[1], context.RGBA, context.UNSIGNED_BYTE, bytes);
      result = new Float32Array(bytes.buffer);
    }

    result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);

    if (lastKernel.output.length === 1) {
      return result;
    } else if (lastKernel.output.length === 2) {
      return utils.splitArray(result, lastKernel.output[0]);
    } else if (lastKernel.output.length === 3) {
      const cube = utils.splitArray(result, lastKernel.output[0] * lastKernel.output[1]);
      return cube.map(function(x) {
        return utils.splitArray(x, lastKernel.output[0]);
      });
    }
  }

  constructor(source, settings) {
    super(source, settings);
    this.transferValues = null;
    this.formatValues = null;
    this.TextureConstructor = null;
    this.renderOutput = null;
    this.renderRawOutput = null;
    this.texSize = null;
    this.translatedSource = null;
    this.compiledFragmentShader = null;
    this.compiledVertexShader = null;
    this.switchingKernels = null;
    this._textureSwitched = null;
    this._mappedTextureSwitched = null;
  }

  checkTextureSize() {
    const { features } = this.constructor;
    if (this.texSize[0] > features.maxTextureSize || this.texSize[1] > features.maxTextureSize) {
      throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${features.maxTextureSize},${features.maxTextureSize}]`);
    }
  }

  translateSource() {
    throw new Error(`"translateSource" not defined on ${this.constructor.name}`);
  }

  pickRenderStrategy(args) {
    if (this.graphical) {
      this.renderRawOutput = this.readPackedPixelsToUint8Array;
      this.transferValues = (pixels) => pixels;
      this.TextureConstructor = GLTextureGraphical;
      return null;
    }
    if (this.precision === 'unsigned') {
      this.renderRawOutput = this.readPackedPixelsToUint8Array;
      this.transferValues = this.readPackedPixelsToFloat32Array;
      if (this.pipeline) {
        this.renderOutput = this.renderTexture;
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToTextures;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer':
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureUnsigned3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureUnsigned2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureUnsigned;
              return null;
            }
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              return this.requestFallback(args);
        }
      } else {
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToArrays;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer':
            this.renderOutput = this.renderValues;
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureUnsigned3D;
              this.formatValues = utils.erect3DPackedFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureUnsigned2D;
              this.formatValues = utils.erect2DPackedFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureUnsigned;
              this.formatValues = utils.erectPackedFloat;
              return null;
            }
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              return this.requestFallback(args);
        }
      }
    } else if (this.precision === 'single') {
      this.renderRawOutput = this.readFloatPixelsToFloat32Array;
      this.transferValues = this.readFloatPixelsToFloat32Array;
      if (this.pipeline) {
        this.renderOutput = this.renderTexture;
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToTextures;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.optimizeFloatMemory) {
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureMemoryOptimized3D;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureMemoryOptimized2D;
                return null;
              } else {
                this.TextureConstructor = GLTextureMemoryOptimized;
                return null;
              }
            } else {
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureFloat3D;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureFloat2D;
                return null;
              } else {
                this.TextureConstructor = GLTextureFloat;
                return null;
              }
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              return null;
            }
          }
        }
      }
      this.renderOutput = this.renderValues;
      if (this.subKernels !== null) {
        this.renderKernels = this.renderKernelsToArrays;
      }
      if (this.optimizeFloatMemory) {
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureMemoryOptimized3D;
              this.formatValues = utils.erectMemoryOptimized3DFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureMemoryOptimized2D;
              this.formatValues = utils.erectMemoryOptimized2DFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureMemoryOptimized;
              this.formatValues = utils.erectMemoryOptimizedFloat;
              return null;
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              this.formatValues = utils.erect3DArray2;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              this.formatValues = utils.erect2DArray2;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              this.formatValues = utils.erectArray2;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              this.formatValues = utils.erect3DArray3;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              this.formatValues = utils.erect2DArray3;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              this.formatValues = utils.erectArray3;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              this.formatValues = utils.erect3DArray4;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              this.formatValues = utils.erect2DArray4;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              this.formatValues = utils.erectArray4;
              return null;
            }
          }
        }
      } else {
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureFloat3D;
              this.formatValues = utils.erect3DFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureFloat2D;
              this.formatValues = utils.erect2DFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureFloat;
              this.formatValues = utils.erectFloat;
              return null;
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              this.formatValues = utils.erect3DArray2;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              this.formatValues = utils.erect2DArray2;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              this.formatValues = utils.erectArray2;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              this.formatValues = utils.erect3DArray3;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              this.formatValues = utils.erect2DArray3;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              this.formatValues = utils.erectArray3;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              this.formatValues = utils.erect3DArray4;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              this.formatValues = utils.erect2DArray4;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              this.formatValues = utils.erectArray4;
              return null;
            }
          }
        }
      }
    } else {
      throw new Error(`unhandled precision of "${this.precision}"`);
    }

    throw new Error(`unhandled return type "${this.returnType}"`);
  }

  getKernelString() {
    throw new Error(`abstract method call`);
  }

  getMainResultTexture() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Float':
      case 'Integer':
      case 'Number':
        return this.getMainResultNumberTexture();
      case 'Array(2)':
        return this.getMainResultArray2Texture();
      case 'Array(3)':
        return this.getMainResultArray3Texture();
      case 'Array(4)':
        return this.getMainResultArray4Texture();
      default:
        throw new Error(`unhandled returnType type ${ this.returnType }`);
    }
  }

  getMainResultKernelNumberTexture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelNumberTexture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray2Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray2Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray3Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray3Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray4Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray4Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultGraphical() {
    throw new Error(`abstract method call`);
  }
  getMainResultMemoryOptimizedFloats() {
    throw new Error(`abstract method call`);
  }
  getMainResultPackedPixels() {
    throw new Error(`abstract method call`);
  }

  getMainResultString() {
    if (this.graphical) {
      return this.getMainResultGraphical();
    } else if (this.precision === 'single') {
      if (this.optimizeFloatMemory) {
        return this.getMainResultMemoryOptimizedFloats();
      }
      return this.getMainResultTexture();
    } else {
      return this.getMainResultPackedPixels();
    }
  }

  getMainResultNumberTexture() {
    return utils.linesToString(this.getMainResultKernelNumberTexture()) +
      utils.linesToString(this.getMainResultSubKernelNumberTexture());
  }

  getMainResultArray2Texture() {
    return utils.linesToString(this.getMainResultKernelArray2Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray2Texture());
  }

  getMainResultArray3Texture() {
    return utils.linesToString(this.getMainResultKernelArray3Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray3Texture());
  }

  getMainResultArray4Texture() {
    return utils.linesToString(this.getMainResultKernelArray4Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray4Texture());
  }

  getFloatTacticDeclaration() {
    const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);
    return `precision ${variablePrecision} float;\n`;
  }

  getIntTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic, true)} int;\n`;
  }

  getSampler2DTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2D;\n`;
  }

  getSampler2DArrayTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2DArray;\n`;
  }

  renderTexture() {
    return this.immutable ? this.texture.clone() : this.texture;
  }
  readPackedPixelsToUint8Array() {
    if (this.precision !== 'unsigned') throw new Error('Requires this.precision to be "unsigned"');
    const {
      texSize,
      context: gl
    } = this;
    const result = new Uint8Array(texSize[0] * texSize[1] * 4);
    gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
    return result;
  }

  readPackedPixelsToFloat32Array() {
    return new Float32Array(this.readPackedPixelsToUint8Array().buffer);
  }

  readFloatPixelsToFloat32Array() {
    if (this.precision !== 'single') throw new Error('Requires this.precision to be "single"');
    const {
      texSize,
      context: gl
    } = this;
    const w = texSize[0];
    const h = texSize[1];
    const result = new Float32Array(w * h * 4);
    gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);
    return result;
  }

  getPixels(flip) {
    const {
      context: gl,
      output
    } = this;
    const [width, height] = output;
    const pixels = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    return new Uint8ClampedArray((flip ? pixels : utils.flipPixels(pixels, width, height)).buffer);
  }

  renderKernelsToArrays() {
    const result = {
      result: this.renderOutput(),
    };
    for (let i = 0; i < this.subKernels.length; i++) {
      result[this.subKernels[i].property] = this.mappedTextures[i].toArray();
    }
    return result;
  }

  renderKernelsToTextures() {
    const result = {
      result: this.renderOutput(),
    };
    if (this.immutable) {
      for (let i = 0; i < this.subKernels.length; i++) {
        result[this.subKernels[i].property] = this.mappedTextures[i].clone();
      }
    } else {
      for (let i = 0; i < this.subKernels.length; i++) {
        result[this.subKernels[i].property] = this.mappedTextures[i];
      }
    }
    return result;
  }

  resetSwitchingKernels() {
    const existingValue = this.switchingKernels;
    this.switchingKernels = null;
    return existingValue;
  }

  setOutput(output) {
    const newOutput = this.toKernelOutput(output);
    if (this.program) {
      if (!this.dynamicOutput) {
        throw new Error('Resizing a kernel with dynamicOutput: false is not possible');
      }
      const newThreadDim = [newOutput[0], newOutput[1] || 1, newOutput[2] || 1];
      const newTexSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, newThreadDim);
      const oldTexSize = this.texSize;
      if (oldTexSize) {
        const oldPrecision = this.getVariablePrecisionString(oldTexSize, this.tactic);
        const newPrecision = this.getVariablePrecisionString(newTexSize, this.tactic);
        if (oldPrecision !== newPrecision) {
          if (this.debug) {
            console.warn('Precision requirement changed, asking GPU instance to recompile');
          }
          this.switchKernels({
            type: 'outputPrecisionMismatch',
            precision: newPrecision,
            needed: output
          });
          return;
        }
      }
      this.output = newOutput;
      this.threadDim = newThreadDim;
      this.texSize = newTexSize;
      const { context: gl } = this;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      this.updateMaxTexSize();
      this.framebuffer.width = this.texSize[0];
      this.framebuffer.height = this.texSize[1];
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      this.canvas.width = this.maxTexSize[0];
      this.canvas.height = this.maxTexSize[1];
      if (this.texture) {
        this.texture.delete();
      }
      this.texture = null;
      this._setupOutputTexture();
      if (this.mappedTextures && this.mappedTextures.length > 0) {
        for (let i = 0; i < this.mappedTextures.length; i++) {
          this.mappedTextures[i].delete();
        }
        this.mappedTextures = null;
        this._setupSubOutputTextures();
      }
    } else {
      this.output = newOutput;
    }
    return this;
  }
  renderValues() {
    return this.formatValues(
      this.transferValues(),
      this.output[0],
      this.output[1],
      this.output[2]
    );
  }
  switchKernels(reason) {
    if (this.switchingKernels) {
      this.switchingKernels.push(reason);
    } else {
      this.switchingKernels = [reason];
    }
  }
  getVariablePrecisionString(textureSize = this.texSize, tactic = this.tactic, isInt = false) {
    if (!tactic) {
      if (!this.constructor.features.isSpeedTacticSupported) return 'highp';
      const low = this.constructor.features[isInt ? 'lowIntPrecision' : 'lowFloatPrecision'];
      const medium = this.constructor.features[isInt ? 'mediumIntPrecision' : 'mediumFloatPrecision'];
      const high = this.constructor.features[isInt ? 'highIntPrecision' : 'highFloatPrecision'];
      const requiredSize = Math.log2(textureSize[0] * textureSize[1]);
      if (requiredSize <= low.rangeMax) {
        return 'lowp';
      } else if (requiredSize <= medium.rangeMax) {
        return 'mediump';
      } else if (requiredSize <= high.rangeMax) {
        return 'highp';
      } else {
        throw new Error(`The required size exceeds that of the ability of your system`);
      }
    }
    switch (tactic) {
      case 'speed':
        return 'lowp';
      case 'balanced':
        return 'mediump';
      case 'precision':
        return 'highp';
      default:
        throw new Error(`Unknown tactic "${tactic}" use "speed", "balanced", "precision", or empty for auto`);
    }
  }

  updateTextureArgumentRefs(kernelValue, arg) {
    if (!this.immutable) return;
    if (this.texture.texture === arg.texture) {
      const { prevArg } = kernelValue;
      if (prevArg) {
        if (prevArg.texture._refs === 1) {
          this.texture.delete();
          this.texture = prevArg.clone();
          this._textureSwitched = true;
        }
        prevArg.delete();
      }
      kernelValue.prevArg = arg.clone();
    } else if (this.mappedTextures && this.mappedTextures.length > 0) {
      const { mappedTextures } = this;
      for (let i = 0; i < mappedTextures.length; i++) {
        const mappedTexture = mappedTextures[i];
        if (mappedTexture.texture === arg.texture) {
          const { prevArg } = kernelValue;
          if (prevArg) {
            if (prevArg.texture._refs === 1) {
              mappedTexture.delete();
              mappedTextures[i] = prevArg.clone();
              this._mappedTextureSwitched[i] = true;
            }
            prevArg.delete();
          }
          kernelValue.prevArg = arg.clone();
          return;
        }
      }
    }
  }

  onActivate(previousKernel) {
    this._textureSwitched = true;
    this.texture = previousKernel.texture;
    if (this.mappedTextures) {
      for (let i = 0; i < this.mappedTextures.length; i++) {
        this._mappedTextureSwitched[i] = true;
      }
      this.mappedTextures = previousKernel.mappedTextures;
    }
  }

  initCanvas() {}
}

const typeMap = {
  int: 'Integer',
  float: 'Number',
  vec2: 'Array(2)',
  vec3: 'Array(3)',
  vec4: 'Array(4)',
};

module.exports = {
  GLKernel
};
},{"../../utils":114,"../kernel":36,"./texture/array-2-float":16,"./texture/array-2-float-2d":14,"./texture/array-2-float-3d":15,"./texture/array-3-float":19,"./texture/array-3-float-2d":17,"./texture/array-3-float-3d":18,"./texture/array-4-float":22,"./texture/array-4-float-2d":20,"./texture/array-4-float-3d":21,"./texture/float":25,"./texture/float-2d":23,"./texture/float-3d":24,"./texture/graphical":26,"./texture/memory-optimized":30,"./texture/memory-optimized-2d":28,"./texture/memory-optimized-3d":29,"./texture/unsigned":33,"./texture/unsigned-2d":31,"./texture/unsigned-3d":32}],14:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erect2DArray2(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray2Float2D
};
},{"../../../utils":114,"./float":25}],15:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erect3DArray2(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray2Float3D
};
},{"../../../utils":114,"./float":25}],16:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erectArray2(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray2Float
};
},{"../../../utils":114,"./float":25}],17:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erect2DArray3(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray3Float2D
};
},{"../../../utils":114,"./float":25}],18:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erect3DArray3(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray3Float3D
};
},{"../../../utils":114,"./float":25}],19:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erectArray3(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureArray3Float
};
},{"../../../utils":114,"./float":25}],20:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erect2DArray4(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray4Float2D
};
},{"../../../utils":114,"./float":25}],21:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erect3DArray4(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray4Float3D
};
},{"../../../utils":114,"./float":25}],22:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erectArray4(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureArray4Float
};
},{"../../../utils":114,"./float":25}],23:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureFloat2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  toArray() {
    return utils.erect2DFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureFloat2D
};
},{"../../../utils":114,"./float":25}],24:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureFloat3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  toArray() {
    return utils.erect3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureFloat3D
};
},{"../../../utils":114,"./float":25}],25:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTexture } = require('./index');

class GLTextureFloat extends GLTexture {
  get textureType() {
    return this.context.FLOAT;
  }
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  renderRawOutput() {
    const gl = this.context;
    const size = this.size;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      this.texture,
      0
    );
    const result = new Float32Array(size[0] * size[1] * 4);
    gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.FLOAT, result);
    return result;
  }
  renderValues() {
    if (this._deleted) return null;
    return this.renderRawOutput();
  }
  toArray() {
    return utils.erectFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureFloat
};
},{"../../../utils":114,"./index":27}],26:[function(require,module,exports){
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureGraphical extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return this.renderValues();
  }
}

module.exports = {
  GLTextureGraphical
};
},{"./unsigned":33}],27:[function(require,module,exports){
const { Texture } = require('../../../texture');

class GLTexture extends Texture {
  get textureType() {
    throw new Error(`"textureType" not implemented on ${ this.name }`);
  }

  clone() {
    return new this.constructor(this);
  }

  beforeMutate() {
    if (this.texture._refs > 1) {
      this.newTexture();
      return true;
    }
    return false;
  }

  cloneTexture() {
    this.texture._refs--;
    const { context: gl, size, texture, kernel } = this;
    if (kernel.debug) {
      console.warn('cloning internal texture');
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    selectTexture(gl, texture);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const target = gl.createTexture();
    selectTexture(gl, target);
    gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, size[0], size[1]);
    target._refs = 1;
    this.texture = target;
  }

  newTexture() {
    this.texture._refs--;
    const gl = this.context;
    const size = this.size;
    const kernel = this.kernel;
    if (kernel.debug) {
      console.warn('new internal texture');
    }
    const target = gl.createTexture();
    selectTexture(gl, target);
    gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    target._refs = 1;
    this.texture = target;
  }

  clear() {
    if (this.texture._refs) {
      this.texture._refs--;
      const gl = this.context;
      const target = this.texture = gl.createTexture();
      selectTexture(gl, target);
      const size = this.size;
      target._refs = 1;
      gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    }
    const { context: gl, texture } = this;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    gl.bindTexture(gl.TEXTURE_2D, texture);
    selectTexture(gl, texture);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  }

  delete() {
    if (this._deleted) return;
    this._deleted = true;
    if (this.texture._refs) {
      this.texture._refs--;
      if (this.texture._refs) return;
    }
    this.context.deleteTexture(this.texture);
    if (this.texture._refs === 0 && this._framebuffer) {
      this.context.deleteFramebuffer(this._framebuffer);
      this._framebuffer = null;
    }
  }

  framebuffer() {
    if (!this._framebuffer) {
      this._framebuffer = this.context.createFramebuffer();
    }
    this._framebuffer.width = this.size[0];
    this._framebuffer.height = this.size[1];
    return this._framebuffer;
  }
}

function selectTexture(gl, texture) {
  gl.activeTexture(gl.TEXTURE15);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
}

module.exports = { GLTexture };
},{"../../../texture":113}],28:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimized2DFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureMemoryOptimized2D
};
},{"../../../utils":114,"./float":25}],29:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimized3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureMemoryOptimized3D
};
},{"../../../utils":114,"./float":25}],30:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimizedFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureMemoryOptimized
};
},{"../../../utils":114,"./float":25}],31:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureUnsigned2D extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  toArray() {
    return utils.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureUnsigned2D
};
},{"../../../utils":114,"./unsigned":33}],32:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureUnsigned3D extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  toArray() {
    return utils.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureUnsigned3D
};
},{"../../../utils":114,"./unsigned":33}],33:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTexture } = require('./index');

class GLTextureUnsigned extends GLTexture {
  get textureType() {
    return this.context.UNSIGNED_BYTE;
  }
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  renderRawOutput() {
    const { context: gl } = this;
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      this.texture,
      0
    );
    const result = new Uint8Array(this.size[0] * this.size[1] * 4);
    gl.readPixels(0, 0, this.size[0], this.size[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
    return result;
  }
  renderValues() {
    if (this._deleted) return null;
    return new Float32Array(this.renderRawOutput().buffer);
  }
  toArray() {
    return utils.erectPackedFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureUnsigned
};
},{"../../../utils":114,"./index":27}],34:[function(require,module,exports){
const getContext = require('gl');
const { WebGLKernel } = require('../web-gl/kernel');
const { glKernelString } = require('../gl/kernel-string');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;
let features = null;

class HeadlessGLKernel extends WebGLKernel {
  static get isSupported() {
    if (isSupported !== null) return isSupported;
    this.setupFeatureChecks();
    isSupported = testContext !== null;
    return isSupported;
  }

  static setupFeatureChecks() {
    testCanvas = null;
    testExtensions = null;
    if (typeof getContext !== 'function') return;
    try { 
      testContext = getContext(2, 2, {
        preserveDrawingBuffer: true
      });
      if (!testContext || !testContext.getExtension) return;
      testExtensions = {
        STACKGL_resize_drawingbuffer: testContext.getExtension('STACKGL_resize_drawingbuffer'),
        STACKGL_destroy_context: testContext.getExtension('STACKGL_destroy_context'),
        OES_texture_float: testContext.getExtension('OES_texture_float'),
        OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
        OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
        WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
        WEBGL_color_buffer_float: testContext.getExtension('WEBGL_color_buffer_float'),
      };
      features = this.getFeatures();
    } catch (e) {
      console.warn(e);
    }
  }

  static isContextMatch(context) {
    try {
      return context.getParameter(context.RENDERER) === 'ANGLE';
    } catch (e) {
      return false;
    }
  }

  static getIsTextureFloat() {
    return Boolean(testExtensions.OES_texture_float);
  }

  static getIsDrawBuffers() {
    return Boolean(testExtensions.WEBGL_draw_buffers);
  }

  static getChannelCount() {
    return testExtensions.WEBGL_draw_buffers ?
      testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :
      1;
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  initCanvas() {
    return {};
  }

  initContext() {
    return getContext(2, 2, {
      preserveDrawingBuffer: true
    });
  }

  initExtensions() {
    this.extensions = {
      STACKGL_resize_drawingbuffer: this.context.getExtension('STACKGL_resize_drawingbuffer'),
      STACKGL_destroy_context: this.context.getExtension('STACKGL_destroy_context'),
      OES_texture_float: this.context.getExtension('OES_texture_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
    };
  }

  build() {
    super.build.apply(this, arguments);
    if (!this.fallbackRequested) {
      this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
    }
  }

  destroyExtensions() {
    this.extensions.STACKGL_resize_drawingbuffer = null;
    this.extensions.STACKGL_destroy_context = null;
    this.extensions.OES_texture_float = null;
    this.extensions.OES_texture_float_linear = null;
    this.extensions.OES_element_index_uint = null;
    this.extensions.WEBGL_draw_buffers = null;
  }

  static destroyContext(context) {
    const extension = context.getExtension('STACKGL_destroy_context');
    if (extension && extension.destroy) {
      extension.destroy();
    }
  }

  toString() {
    const setupContextString = `const gl = context || require('gl')(1, 1);\n`;
    const destroyContextString = `    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }\n`;
    return glKernelString(this.constructor, arguments, this, setupContextString, destroyContextString);
  }

  setOutput(output) {
    super.setOutput(output);
    if (this.graphical && this.extensions.STACKGL_resize_drawingbuffer) {
      this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
    }
    return this;
  }
}

module.exports = {
  HeadlessGLKernel
};
},{"../gl/kernel-string":12,"../web-gl/kernel":70,"gl":2}],35:[function(require,module,exports){
class KernelValue {
  constructor(value, settings) {
    const {
      name,
      kernel,
      context,
      checkContext,
      onRequestContextHandle,
      onUpdateValueMismatch,
      origin,
      strictIntegers,
      type,
      tactic,
    } = settings;
    if (!name) {
      throw new Error('name not set');
    }
    if (!type) {
      throw new Error('type not set');
    }
    if (!origin) {
      throw new Error('origin not set');
    }
    if (origin !== 'user' && origin !== 'constants') {
      throw new Error(`origin must be "user" or "constants" value is "${ origin }"`);
    }
    if (!onRequestContextHandle) {
      throw new Error('onRequestContextHandle is not set');
    }
    this.name = name;
    this.origin = origin;
    this.tactic = tactic;
    this.varName = origin === 'constants' ? `constants.${name}` : name;
    this.kernel = kernel;
    this.strictIntegers = strictIntegers;
    this.type = value.type || type;
    this.size = value.size || null;
    this.index = null;
    this.context = context;
    this.checkContext = checkContext !== null && checkContext !== undefined ? checkContext : true;
    this.contextHandle = null;
    this.onRequestContextHandle = onRequestContextHandle;
    this.onUpdateValueMismatch = onUpdateValueMismatch;
    this.forceUploadEachRun = null;
  }

  get id() {
    return `${this.origin}_${name}`;
  }

  getSource() {
    throw new Error(`"getSource" not defined on ${ this.constructor.name }`);
  }

  updateValue(value) {
    throw new Error(`"updateValue" not defined on ${ this.constructor.name }`);
  }
}

module.exports = {
  KernelValue
};
},{}],36:[function(require,module,exports){
const { utils } = require('../utils');
const { Input } = require('../input');

class Kernel {
  static get isSupported() {
    throw new Error(`"isSupported" not implemented on ${ this.name }`);
  }

  static isContextMatch(context) {
    throw new Error(`"isContextMatch" not implemented on ${ this.name }`);
  }

  static getFeatures() {
    throw new Error(`"getFeatures" not implemented on ${ this.name }`);
  }

  static destroyContext(context) {
    throw new Error(`"destroyContext" called on ${ this.name }`);
  }

  static nativeFunctionArguments() {
    throw new Error(`"nativeFunctionArguments" called on ${ this.name }`);
  }

  static nativeFunctionReturnType() {
    throw new Error(`"nativeFunctionReturnType" called on ${ this.name }`);
  }

  static combineKernels() {
    throw new Error(`"combineKernels" called on ${ this.name }`);
  }

  constructor(source, settings) {
    if (typeof source !== 'object') {
      if (typeof source !== 'string') {
        throw new Error('source not a string');
      }
      if (!utils.isFunctionString(source)) {
        throw new Error('source not a function string');
      }
    }
    this.useLegacyEncoder = false;
    this.fallbackRequested = false;
    this.onRequestFallback = null;

    this.argumentNames = typeof source === 'string' ? utils.getArgumentNamesFromString(source) : null;
    this.argumentTypes = null;
    this.argumentSizes = null;
    this.argumentBitRatios = null;
    this.kernelArguments = null;
    this.kernelConstants = null;
    this.forceUploadKernelConstants = null;


    this.source = source;

    this.output = null;

    this.debug = false;

    this.graphical = false;

    this.loopMaxIterations = 0;

    this.constants = null;

    this.constantTypes = null;

    this.constantBitRatios = null;

    this.dynamicArguments = false;

    this.dynamicOutput = false;

    this.canvas = null;

    this.context = null;

    this.checkContext = null;

    this.gpu = null;

    this.functions = null;

    this.nativeFunctions = null;

    this.injectedNative = null;

    this.subKernels = null;

    this.validate = true;

    this.immutable = false;

    this.pipeline = false;

    this.precision = null;

    this.tactic = null;

    this.plugins = null;

    this.returnType = null;
    this.leadingReturnStatement = null;
    this.followingReturnStatement = null;
    this.optimizeFloatMemory = null;
    this.strictIntegers = false;
    this.fixIntegerDivisionAccuracy = null;
    this.onIstanbulCoverageVariable = null;
    this.removeIstanbulCoverage = false;
    this.built = false;
    this.signature = null;
  }

  mergeSettings(settings) {
    for (let p in settings) {
      if (!settings.hasOwnProperty(p) || !this.hasOwnProperty(p)) continue;
      switch (p) {
        case 'output':
          if (!Array.isArray(settings.output)) {
            this.setOutput(settings.output); 
            continue;
          }
          break;
        case 'functions':
          this.functions = [];
          for (let i = 0; i < settings.functions.length; i++) {
            this.addFunction(settings.functions[i]);
          }
          continue;
        case 'graphical':
          if (settings[p] && !settings.hasOwnProperty('precision')) {
            this.precision = 'unsigned';
          }
          this[p] = settings[p];
          continue;
        case 'removeIstanbulCoverage':
          if (settings[p] !== null) {
            this[p] = settings[p];
          }
          continue;
        case 'nativeFunctions':
          if (!settings.nativeFunctions) continue;
          this.nativeFunctions = [];
          for (let i = 0; i < settings.nativeFunctions.length; i++) {
            const s = settings.nativeFunctions[i];
            const { name, source } = s;
            this.addNativeFunction(name, source, s);
          }
          continue;
      }
      this[p] = settings[p];
    }

    if (!this.canvas) this.canvas = this.initCanvas();
    if (!this.context) this.context = this.initContext();
    if (!this.plugins) this.plugins = this.initPlugins(settings);
  }
  build() {
    throw new Error(`"build" not defined on ${ this.constructor.name }`);
  }

  run() {
    throw new Error(`"run" not defined on ${ this.constructor.name }`)
  }

  initCanvas() {
    throw new Error(`"initCanvas" not defined on ${ this.constructor.name }`);
  }

  initContext() {
    throw new Error(`"initContext" not defined on ${ this.constructor.name }`);
  }

  initPlugins(settings) {
    throw new Error(`"initPlugins" not defined on ${ this.constructor.name }`);
  }

  addFunction(source, settings = {}) {
    if (source.name && source.source && source.argumentTypes && 'returnType' in source) {
      this.functions.push(source);
    } else if ('settings' in source && 'source' in source) {
      this.functions.push(this.functionToIGPUFunction(source.source, source.settings));
    } else if (typeof source === 'string' || typeof source === 'function') {
      this.functions.push(this.functionToIGPUFunction(source, settings));
    } else {
      throw new Error(`function not properly defined`);
    }
    return this;
  }

  addNativeFunction(name, source, settings = {}) {
    const { argumentTypes, argumentNames } = settings.argumentTypes ?
      splitArgumentTypes(settings.argumentTypes) :
      this.constructor.nativeFunctionArguments(source) || {};
    this.nativeFunctions.push({
      name,
      source,
      settings,
      argumentTypes,
      argumentNames,
      returnType: settings.returnType || this.constructor.nativeFunctionReturnType(source)
    });
    return this;
  }

  setupArguments(args) {
    this.kernelArguments = [];
    if (!this.argumentTypes) {
      if (!this.argumentTypes) {
        this.argumentTypes = [];
        for (let i = 0; i < args.length; i++) {
          const argType = utils.getVariableType(args[i], this.strictIntegers);
          const type = argType === 'Integer' ? 'Number' : argType;
          this.argumentTypes.push(type);
          this.kernelArguments.push({
            type
          });
        }
      }
    } else {
      for (let i = 0; i < this.argumentTypes.length; i++) {
        this.kernelArguments.push({
          type: this.argumentTypes[i]
        });
      }
    }

    this.argumentSizes = new Array(args.length);
    this.argumentBitRatios = new Int32Array(args.length);

    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      this.argumentSizes[i] = arg.constructor === Input ? arg.size : null;
      this.argumentBitRatios[i] = this.getBitRatio(arg);
    }

    if (this.argumentNames.length !== args.length) {
      throw new Error(`arguments are miss-aligned`);
    }
  }

  setupConstants() {
    this.kernelConstants = [];
    let needsConstantTypes = this.constantTypes === null;
    if (needsConstantTypes) {
      this.constantTypes = {};
    }
    this.constantBitRatios = {};
    if (this.constants) {
      for (let name in this.constants) {
        if (needsConstantTypes) {
          const type = utils.getVariableType(this.constants[name], this.strictIntegers);
          this.constantTypes[name] = type;
          this.kernelConstants.push({
            name,
            type
          });
        } else {
          this.kernelConstants.push({
            name,
            type: this.constantTypes[name]
          });
        }
        this.constantBitRatios[name] = this.getBitRatio(this.constants[name]);
      }
    }
  }

  setOptimizeFloatMemory(flag) {
    this.optimizeFloatMemory = flag;
    return this;
  }

  toKernelOutput(output) {
    if (output.hasOwnProperty('x')) {
      if (output.hasOwnProperty('y')) {
        if (output.hasOwnProperty('z')) {
          return [output.x, output.y, output.z];
        } else {
          return [output.x, output.y];
        }
      } else {
        return [output.x];
      }
    } else {
      return output;
    }
  }

  setOutput(output) {
    this.output = this.toKernelOutput(output);
    return this;
  }

  setDebug(flag) {
    this.debug = flag;
    return this;
  }

  setGraphical(flag) {
    this.graphical = flag;
    this.precision = 'unsigned';
    return this;
  }

  setLoopMaxIterations(max) {
    this.loopMaxIterations = max;
    return this;
  }

  setConstants(constants) {
    this.constants = constants;
    return this;
  }

  setConstantTypes(constantTypes) {
    this.constantTypes = constantTypes;
    return this;
  }

  setFunctions(functions) {
    for (let i = 0; i < functions.length; i++) {
      this.addFunction(functions[i]);
    }
    return this;
  }

  setNativeFunctions(nativeFunctions) {
    for (let i = 0; i < nativeFunctions.length; i++) {
      const settings = nativeFunctions[i];
      const { name, source } = settings;
      this.addNativeFunction(name, source, settings);
    }
    return this;
  }

  setInjectedNative(injectedNative) {
    this.injectedNative = injectedNative;
    return this;
  }

  setPipeline(flag) {
    this.pipeline = flag;
    return this;
  }

  setPrecision(flag) {
    this.precision = flag;
    return this;
  }

  setDimensions(flag) {
    utils.warnDeprecated('method', 'setDimensions', 'setOutput');
    this.output = flag;
    return this;
  }

  setOutputToTexture(flag) {
    utils.warnDeprecated('method', 'setOutputToTexture', 'setPipeline');
    this.pipeline = flag;
    return this;
  }

  setImmutable(flag) {
    this.immutable = flag;
    return this;
  }

  setCanvas(canvas) {
    this.canvas = canvas;
    return this;
  }

  setStrictIntegers(flag) {
    this.strictIntegers = flag;
    return this;
  }

  setDynamicOutput(flag) {
    this.dynamicOutput = flag;
    return this;
  }

  setHardcodeConstants(flag) {
    utils.warnDeprecated('method', 'setHardcodeConstants');
    this.setDynamicOutput(flag);
    this.setDynamicArguments(flag);
    return this;
  }

  setDynamicArguments(flag) {
    this.dynamicArguments = flag;
    return this;
  }

  setUseLegacyEncoder(flag) {
    this.useLegacyEncoder = flag;
    return this;
  }

  setWarnVarUsage(flag) {
    utils.warnDeprecated('method', 'setWarnVarUsage');
    return this;
  }

  getCanvas() {
    utils.warnDeprecated('method', 'getCanvas');
    return this.canvas;
  }

  getWebGl() {
    utils.warnDeprecated('method', 'getWebGl');
    return this.context;
  }

  setContext(context) {
    this.context = context;
    return this;
  }

  setArgumentTypes(argumentTypes) {
    if (Array.isArray(argumentTypes)) {
      this.argumentTypes = argumentTypes;
    } else {
      this.argumentTypes = [];
      for (const p in argumentTypes) {
        if (!argumentTypes.hasOwnProperty(p)) continue;
        const argumentIndex = this.argumentNames.indexOf(p);
        if (argumentIndex === -1) throw new Error(`unable to find argument ${ p }`);
        this.argumentTypes[argumentIndex] = argumentTypes[p];
      }
    }
    return this;
  }

  setTactic(tactic) {
    this.tactic = tactic;
    return this;
  }

  requestFallback(args) {
    if (!this.onRequestFallback) {
      throw new Error(`"onRequestFallback" not defined on ${ this.constructor.name }`);
    }
    this.fallbackRequested = true;
    return this.onRequestFallback(args);
  }

  validateSettings() {
    throw new Error(`"validateSettings" not defined on ${ this.constructor.name }`);
  }

  addSubKernel(subKernel) {
    if (this.subKernels === null) {
      this.subKernels = [];
    }
    if (!subKernel.source) throw new Error('subKernel missing "source" property');
    if (!subKernel.property && isNaN(subKernel.property)) throw new Error('subKernel missing "property" property');
    if (!subKernel.name) throw new Error('subKernel missing "name" property');
    this.subKernels.push(subKernel);
    return this;
  }

  destroy(removeCanvasReferences) {
    throw new Error(`"destroy" called on ${ this.constructor.name }`);
  }

  getBitRatio(value) {
    if (this.precision === 'single') {
      return 4;
    } else if (Array.isArray(value[0])) {
      return this.getBitRatio(value[0]);
    } else if (value.constructor === Input) {
      return this.getBitRatio(value.value);
    }
    switch (value.constructor) {
      case Uint8ClampedArray:
      case Uint8Array:
      case Int8Array:
        return 1;
      case Uint16Array:
      case Int16Array:
        return 2;
      case Float32Array:
      case Int32Array:
      default:
        return 4;
    }
  }

  getPixels(flip) {
    throw new Error(`"getPixels" called on ${ this.constructor.name }`);
  }

  checkOutput() {
    if (!this.output || !utils.isArray(this.output)) throw new Error('kernel.output not an array');
    if (this.output.length < 1) throw new Error('kernel.output is empty, needs at least 1 value');
    for (let i = 0; i < this.output.length; i++) {
      if (isNaN(this.output[i]) || this.output[i] < 1) {
        throw new Error(`${ this.constructor.name }.output[${ i }] incorrectly defined as \`${ this.output[i] }\`, needs to be numeric, and greater than 0`);
      }
    }
  }

  prependString(value) {
    throw new Error(`"prependString" called on ${ this.constructor.name }`);
  }

  hasPrependString(value) {
    throw new Error(`"hasPrependString" called on ${ this.constructor.name }`);
  }

  toJSON() {
    return {
      settings: {
        output: this.output,
        pipeline: this.pipeline,
        argumentNames: this.argumentNames,
        argumentsTypes: this.argumentTypes,
        constants: this.constants,
        pluginNames: this.plugins ? this.plugins.map(plugin => plugin.name) : null,
        returnType: this.returnType,
      }
    };
  }

  buildSignature(args) {
    const Constructor = this.constructor;
    this.signature = Constructor.getSignature(this, Constructor.getArgumentTypes(this, args));
  }

  static getArgumentTypes(kernel, args) {
    const argumentTypes = new Array(args.length);
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      const type = kernel.argumentTypes[i];
      if (arg.type) {
        argumentTypes[i] = arg.type;
      } else {
        switch (type) {
          case 'Number':
          case 'Integer':
          case 'Float':
          case 'ArrayTexture(1)':
            argumentTypes[i] = utils.getVariableType(arg);
            break;
          default:
            argumentTypes[i] = type;
        }
      }
    }
    return argumentTypes;
  }

  static getSignature(kernel, argumentTypes) {
    throw new Error(`"getSignature" not implemented on ${ this.name }`);
  }

  functionToIGPUFunction(source, settings = {}) {
    if (typeof source !== 'string' && typeof source !== 'function') throw new Error('source not a string or function');
    const sourceString = typeof source === 'string' ? source : source.toString();
    let argumentTypes = [];

    if (Array.isArray(settings.argumentTypes)) {
      argumentTypes = settings.argumentTypes;
    } else if (typeof settings.argumentTypes === 'object') {
      argumentTypes = utils.getArgumentNamesFromString(sourceString)
        .map(name => settings.argumentTypes[name]) || [];
    } else {
      argumentTypes = settings.argumentTypes || [];
    }

    return {
      name: utils.getFunctionNameFromString(sourceString) || null,
      source: sourceString,
      argumentTypes,
      returnType: settings.returnType || null,
    };
  }

  onActivate(previousKernel) {}
}

function splitArgumentTypes(argumentTypesObject) {
  const argumentNames = Object.keys(argumentTypesObject);
  const argumentTypes = [];
  for (let i = 0; i < argumentNames.length; i++) {
    const argumentName = argumentNames[i];
    argumentTypes.push(argumentTypesObject[argumentName]);
  }
  return { argumentTypes, argumentNames };
}

module.exports = {
  Kernel
};
},{"../input":110,"../utils":114}],37:[function(require,module,exports){
const fragmentShader = `__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

varying vec2 vTexCoord;

float acosh(float x) {
  return log(x + sqrt(x * x - 1.0));
}

float sinh(float x) {
  return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;
}

float asinh(float x) {
  return log(x + sqrt(x * x + 1.0));
}

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float atanh(float x) {
  x = (x + 1.0) / (x - 1.0);
  if (x < 0.0) {
    return 0.5 * log(-x);
  }
  return 0.5 * log(x);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float cosh(float x) {
  return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; 
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float tanh(float x) {
  float e = exp(2.0 * x);
  return (e - 1.0) / (e + 1.0);
}

float trunc(float x) {
  if (x >= 0.0) {
    return floor(x); 
  } else {
    return ceil(x);
  }
}

vec4 _round(vec4 x) {
  return floor(x + 0.5);
}

float _round(float x) {
  return floor(x + 0.5);
}

const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x / y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(_round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;
  if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;
  return 0.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  if (channel == 0) return texel.r * 255.0;
  if (channel == 1) return texel.g * 255.0;
  if (channel == 2) return texel.b * 255.0;
  if (channel == 3) return texel.a * 255.0;
  return 0.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return texel.r;
  if (channel == 1) return texel.g;
  if (channel == 2) return texel.b;
  if (channel == 3) return texel.a;
  return 0.0;
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture2D(tex, st / vec2(texSize));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
  
  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

void color(sampler2D image) {
  actualColor = texture2D(image, vTexCoord);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;

module.exports = {
  fragmentShader
};
},{}],38:[function(require,module,exports){
const { utils } = require('../../utils');
const { FunctionNode } = require('../function-node');

class WebGLFunctionNode extends FunctionNode {
  constructor(source, settings) {
    super(source, settings);
    if (settings && settings.hasOwnProperty('fixIntegerDivisionAccuracy')) {
      this.fixIntegerDivisionAccuracy = settings.fixIntegerDivisionAccuracy;
    }
  }

  astConditionalExpression(ast, retArr) {
    if (ast.type !== 'ConditionalExpression') {
      throw this.astErrorOutput('Not a conditional expression', ast);
    }
    const consequentType = this.getType(ast.consequent);
    const alternateType = this.getType(ast.alternate);
    if (consequentType === null && alternateType === null) {
      retArr.push('if (');
      this.astGeneric(ast.test, retArr);
      retArr.push(') {');
      this.astGeneric(ast.consequent, retArr);
      retArr.push(';');
      retArr.push('} else {');
      this.astGeneric(ast.alternate, retArr);
      retArr.push(';');
      retArr.push('}');
      return retArr;
    }
    retArr.push('(');
    this.astGeneric(ast.test, retArr);
    retArr.push('?');
    this.astGeneric(ast.consequent, retArr);
    retArr.push(':');
    this.astGeneric(ast.alternate, retArr);
    retArr.push(')');
    return retArr;
  }

  astFunction(ast, retArr) {
    if (this.isRootKernel) {
      retArr.push('void');
    } else {
      if (!this.returnType) {
        const lastReturn = this.findLastReturn();
        if (lastReturn) {
          this.returnType = this.getType(ast.body);
          if (this.returnType === 'LiteralInteger') {
            this.returnType = 'Number';
          }
        }
      }

      const { returnType } = this;
      if (!returnType) {
        retArr.push('void');
      } else {
        const type = typeMap[returnType];
        if (!type) {
          throw new Error(`unknown type ${returnType}`);
        }
        retArr.push(type);
      }
    }
    retArr.push(' ');
    retArr.push(this.name);
    retArr.push('(');

    if (!this.isRootKernel) {
      for (let i = 0; i < this.argumentNames.length; ++i) {
        const argumentName = this.argumentNames[i];

        if (i > 0) {
          retArr.push(', ');
        }
        let argumentType = this.argumentTypes[this.argumentNames.indexOf(argumentName)];
        if (!argumentType) {
          throw this.astErrorOutput(`Unknown argument ${argumentName} type`, ast);
        }
        if (argumentType === 'LiteralInteger') {
          this.argumentTypes[i] = argumentType = 'Number';
        }
        const type = typeMap[argumentType];
        if (!type) {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        const name = utils.sanitizeName(argumentName);
        if (type === 'sampler2D' || type === 'sampler2DArray') {
          retArr.push(`${type} user_${name},ivec2 user_${name}Size,ivec3 user_${name}Dim`);
        } else {
          retArr.push(`${type} user_${name}`);
        }
      }
    }

    retArr.push(') {\n');

    for (let i = 0; i < ast.body.body.length; ++i) {
      this.astGeneric(ast.body.body[i], retArr);
      retArr.push('\n');
    }

    retArr.push('}\n');
    return retArr;
  }

  astReturnStatement(ast, retArr) {
    if (!ast.argument) throw this.astErrorOutput('Unexpected return statement', ast);
    this.pushState('skip-literal-correction');
    const type = this.getType(ast.argument);
    this.popState('skip-literal-correction');

    const result = [];

    if (!this.returnType) {
      if (type === 'LiteralInteger' || type === 'Integer') {
        this.returnType = 'Number';
      } else {
        this.returnType = type;
      }
    }

    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Float':
        switch (type) {
          case 'Integer':
            result.push('float(');
            this.astGeneric(ast.argument, result);
            result.push(')');
            break;
          case 'LiteralInteger':
            this.castLiteralToFloat(ast.argument, result);

            if (this.getType(ast) === 'Integer') {
              result.unshift('float(');
              result.push(')');
            }
            break;
          default:
            this.astGeneric(ast.argument, result);
        }
        break;
      case 'Integer':
        switch (type) {
          case 'Float':
          case 'Number':
            this.castValueToInteger(ast.argument, result);
            break;
          case 'LiteralInteger':
            this.castLiteralToInteger(ast.argument, result);
            break;
          default:
            this.astGeneric(ast.argument, result);
        }
        break;
      case 'Array(4)':
      case 'Array(3)':
      case 'Array(2)':
      case 'Input':
        this.astGeneric(ast.argument, result);
        break;
      default:
        throw this.astErrorOutput(`unhandled return type ${this.returnType}`, ast);
    }

    if (this.isRootKernel) {
      retArr.push(`kernelResult = ${ result.join('') };`);
      retArr.push('return;');
    } else if (this.isSubKernel) {
      retArr.push(`subKernelResult_${ this.name } = ${ result.join('') };`);
      retArr.push(`return subKernelResult_${ this.name };`);
    } else {
      retArr.push(`return ${ result.join('') };`);
    }
    return retArr;
  }

  astLiteral(ast, retArr) {
    if (isNaN(ast.value)) {
      throw this.astErrorOutput(
        'Non-numeric literal not supported : ' + ast.value,
        ast
      );
    }

    const key = this.astKey(ast);
    if (Number.isInteger(ast.value)) {
      if (this.isState('casting-to-integer') || this.isState('building-integer')) {
        this.literalTypes[key] = 'Integer';
        retArr.push(`${ast.value}`);
      } else if (this.isState('casting-to-float') || this.isState('building-float')) {
        this.literalTypes[key] = 'Number';
        retArr.push(`${ast.value}.0`);
      } else {
        this.literalTypes[key] = 'Number';
        retArr.push(`${ast.value}.0`);
      }
    } else if (this.isState('casting-to-integer') || this.isState('building-integer')) {
      this.literalTypes[key] = 'Integer';
      retArr.push(Math.round(ast.value));
    } else {
      this.literalTypes[key] = 'Number';
      retArr.push(`${ast.value}`);
    }
    return retArr;
  }

  astBinaryExpression(ast, retArr) {
    if (this.checkAndUpconvertOperator(ast, retArr)) {
      return retArr;
    }

    if (this.fixIntegerDivisionAccuracy && ast.operator === '/') {
      retArr.push('divWithIntCheck(');
      this.pushState('building-float');
      switch (this.getType(ast.left)) {
        case 'Integer':
          this.castValueToFloat(ast.left, retArr);
          break;
        case 'LiteralInteger':
          this.castLiteralToFloat(ast.left, retArr);
          break;
        default:
          this.astGeneric(ast.left, retArr);
      }
      retArr.push(', ');
      switch (this.getType(ast.right)) {
        case 'Integer':
          this.castValueToFloat(ast.right, retArr);
          break;
        case 'LiteralInteger':
          this.castLiteralToFloat(ast.right, retArr);
          break;
        default:
          this.astGeneric(ast.right, retArr);
      }
      this.popState('building-float');
      retArr.push(')');
      return retArr;
    }

    retArr.push('(');
    const leftType = this.getType(ast.left) || 'Number';
    const rightType = this.getType(ast.right) || 'Number';
    if (!leftType || !rightType) {
      throw this.astErrorOutput(`Unhandled binary expression`, ast);
    }
    const key = leftType + ' & ' + rightType;
    switch (key) {
      case 'Integer & Integer':
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-integer');
        break;
      case 'Number & Float':
      case 'Float & Number':
      case 'Float & Float':
      case 'Number & Number':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'LiteralInteger & LiteralInteger':
        if (this.isState('casting-to-integer') || this.isState('building-integer')) {
          this.pushState('building-integer');
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.astGeneric(ast.right, retArr);
          this.popState('building-integer');
        } else {
          this.pushState('building-float');
          this.castLiteralToFloat(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.castLiteralToFloat(ast.right, retArr);
          this.popState('building-float');
        }
        break;

      case 'Integer & Float':
      case 'Integer & Number':
        if (ast.operator === '>' || ast.operator === '<' && ast.right.type === 'Literal') {
          if (!Number.isInteger(ast.right.value)) {
            this.pushState('building-float');
            this.castValueToFloat(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.astGeneric(ast.right, retArr);
            this.popState('building-float');
            break;
          }
        }
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.pushState('casting-to-integer');
        if (ast.right.type === 'Literal') {
          const literalResult = [];
          this.astGeneric(ast.right, literalResult);
          const literalType = this.getType(ast.right);
          if (literalType === 'Integer') {
            retArr.push(literalResult.join(''));
          } else {
            throw this.astErrorOutput(`Unhandled binary expression with literal`, ast);
          }
        } else {
          retArr.push('int(');
          this.astGeneric(ast.right, retArr);
          retArr.push(')');
        }
        this.popState('casting-to-integer');
        this.popState('building-integer');
        break;
      case 'Integer & LiteralInteger':
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castLiteralToInteger(ast.right, retArr);
        this.popState('building-integer');
        break;

      case 'Number & Integer':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castValueToFloat(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'Float & LiteralInteger':
      case 'Number & LiteralInteger':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castLiteralToFloat(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'LiteralInteger & Float':
      case 'LiteralInteger & Number':
        if (this.isState('casting-to-integer')) {
          this.pushState('building-integer');
          this.castLiteralToInteger(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.castValueToInteger(ast.right, retArr);
          this.popState('building-integer');
        } else {
          this.pushState('building-float');
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.pushState('casting-to-float');
          this.astGeneric(ast.right, retArr);
          this.popState('casting-to-float');
          this.popState('building-float');
        }
        break;
      case 'LiteralInteger & Integer':
        this.pushState('building-integer');
        this.castLiteralToInteger(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-integer');
        break;

      case 'Boolean & Boolean':
        this.pushState('building-boolean');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-boolean');
        break;

      case 'Float & Integer':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castValueToFloat(ast.right, retArr);
        this.popState('building-float');
        break;

      default:
        throw this.astErrorOutput(`Unhandled binary expression between ${key}`, ast);
    }
    retArr.push(')');

    return retArr;
  }

  checkAndUpconvertOperator(ast, retArr) {
    const bitwiseResult = this.checkAndUpconvertBitwiseOperators(ast, retArr);
    if (bitwiseResult) {
      return bitwiseResult;
    }
    const upconvertableOperators = {
      '%': this.fixIntegerDivisionAccuracy ? 'integerCorrectionModulo' : 'modulo',
      '**': 'pow',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    switch (this.getType(ast.left)) {
      case 'Integer':
        this.castValueToFloat(ast.left, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToFloat(ast.left, retArr);
        break;
      default:
        this.astGeneric(ast.left, retArr);
    }
    retArr.push(',');
    switch (this.getType(ast.right)) {
      case 'Integer':
        this.castValueToFloat(ast.right, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToFloat(ast.right, retArr);
        break;
      default:
        this.astGeneric(ast.right, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  checkAndUpconvertBitwiseOperators(ast, retArr) {
    const upconvertableOperators = {
      '&': 'bitwiseAnd',
      '|': 'bitwiseOr',
      '^': 'bitwiseXOR',
      '<<': 'bitwiseZeroFillLeftShift',
      '>>': 'bitwiseSignedRightShift',
      '>>>': 'bitwiseZeroFillRightShift',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    const leftType = this.getType(ast.left);
    switch (leftType) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.left, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.left, retArr);
        break;
      default:
        this.astGeneric(ast.left, retArr);
    }
    retArr.push(',');
    const rightType = this.getType(ast.right);
    switch (rightType) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.right, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.right, retArr);
        break;
      default:
        this.astGeneric(ast.right, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  checkAndUpconvertBitwiseUnary(ast, retArr) {
    const upconvertableOperators = {
      '~': 'bitwiseNot',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    switch (this.getType(ast.argument)) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.argument, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.argument, retArr);
        break;
      default:
        this.astGeneric(ast.argument, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  castLiteralToInteger(ast, retArr) {
    this.pushState('casting-to-integer');
    this.astGeneric(ast, retArr);
    this.popState('casting-to-integer');
    return retArr;
  }

  castLiteralToFloat(ast, retArr) {
    this.pushState('casting-to-float');
    this.astGeneric(ast, retArr);
    this.popState('casting-to-float');
    return retArr;
  }

  castValueToInteger(ast, retArr) {
    this.pushState('casting-to-integer');
    retArr.push('int(');
    this.astGeneric(ast, retArr);
    retArr.push(')');
    this.popState('casting-to-integer');
    return retArr;
  }

  castValueToFloat(ast, retArr) {
    this.pushState('casting-to-float');
    retArr.push('float(');
    this.astGeneric(ast, retArr);
    retArr.push(')');
    this.popState('casting-to-float');
    return retArr;
  }

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);
    }

    const type = this.getType(idtNode);

    const name = utils.sanitizeName(idtNode.name);
    if (idtNode.name === 'Infinity') {
      retArr.push('3.402823466e+38');
    } else if (type === 'Boolean') {
      if (this.argumentNames.indexOf(name) > -1) {
        retArr.push(`bool(user_${name})`);
      } else {
        retArr.push(`user_${name}`);
      }
    } else {
      retArr.push(`user_${name}`);
    }

    return retArr;
  }

  astForStatement(forNode, retArr) {
    if (forNode.type !== 'ForStatement') {
      throw this.astErrorOutput('Invalid for statement', forNode);
    }

    const initArr = [];
    const testArr = [];
    const updateArr = [];
    const bodyArr = [];
    let isSafe = null;

    if (forNode.init) {
      const { declarations } = forNode.init;
      if (declarations.length > 1) {
        isSafe = false;
      }
      this.astGeneric(forNode.init, initArr);
      for (let i = 0; i < declarations.length; i++) {
        if (declarations[i].init && declarations[i].init.type !== 'Literal') {
          isSafe = false;
        }
      }
    } else {
      isSafe = false;
    }

    if (forNode.test) {
      this.astGeneric(forNode.test, testArr);
    } else {
      isSafe = false;
    }

    if (forNode.update) {
      this.astGeneric(forNode.update, updateArr);
    } else {
      isSafe = false;
    }

    if (forNode.body) {
      this.pushState('loop-body');
      this.astGeneric(forNode.body, bodyArr);
      this.popState('loop-body');
    }

    if (isSafe === null) {
      isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
    }

    if (isSafe) {
      const initString = initArr.join('');
      const initNeedsSemiColon = initString[initString.length - 1] !== ';';
      retArr.push(`for (${initString}${initNeedsSemiColon ? ';' : ''}${testArr.join('')};${updateArr.join('')}){\n`);
      retArr.push(bodyArr.join(''));
      retArr.push('}\n');
    } else {
      const iVariableName = this.getInternalVariableName('safeI');
      if (initArr.length > 0) {
        retArr.push(initArr.join(''), '\n');
      }
      retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
      if (testArr.length > 0) {
        retArr.push(`if (!${testArr.join('')}) break;\n`);
      }
      retArr.push(bodyArr.join(''));
      retArr.push(`\n${updateArr.join('')};`);
      retArr.push('}\n');
    }
    return retArr;
  }

  astWhileStatement(whileNode, retArr) {
    if (whileNode.type !== 'WhileStatement') {
      throw this.astErrorOutput('Invalid while statement', whileNode);
    }

    const iVariableName = this.getInternalVariableName('safeI');
    retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
    retArr.push('if (!');
    this.astGeneric(whileNode.test, retArr);
    retArr.push(') break;\n');
    this.astGeneric(whileNode.body, retArr);
    retArr.push('}\n');

    return retArr;
  }

  astDoWhileStatement(doWhileNode, retArr) {
    if (doWhileNode.type !== 'DoWhileStatement') {
      throw this.astErrorOutput('Invalid while statement', doWhileNode);
    }

    const iVariableName = this.getInternalVariableName('safeI');
    retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
    this.astGeneric(doWhileNode.body, retArr);
    retArr.push('if (!');
    this.astGeneric(doWhileNode.test, retArr);
    retArr.push(') break;\n');
    retArr.push('}\n');

    return retArr;
  }


  astAssignmentExpression(assNode, retArr) {
    if (assNode.operator === '%=') {
      this.astGeneric(assNode.left, retArr);
      retArr.push('=');
      retArr.push('mod(');
      this.astGeneric(assNode.left, retArr);
      retArr.push(',');
      this.astGeneric(assNode.right, retArr);
      retArr.push(')');
    } else if (assNode.operator === '**=') {
      this.astGeneric(assNode.left, retArr);
      retArr.push('=');
      retArr.push('pow(');
      this.astGeneric(assNode.left, retArr);
      retArr.push(',');
      this.astGeneric(assNode.right, retArr);
      retArr.push(')');
    } else {
      const leftType = this.getType(assNode.left);
      const rightType = this.getType(assNode.right);
      this.astGeneric(assNode.left, retArr);
      retArr.push(assNode.operator);
      if (leftType !== 'Integer' && rightType === 'Integer') {
        retArr.push('float(');
        this.astGeneric(assNode.right, retArr);
        retArr.push(')');
      } else {
        this.astGeneric(assNode.right, retArr);
      }
      return retArr;
    }
  }

  astBlockStatement(bNode, retArr) {
    if (this.isState('loop-body')) {
      this.pushState('block-body'); 
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      this.popState('block-body');
    } else {
      retArr.push('{\n');
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      retArr.push('}\n');
    }
    return retArr;
  }

  astVariableDeclaration(varDecNode, retArr) {
    const declarations = varDecNode.declarations;
    if (!declarations || !declarations[0] || !declarations[0].init) {
      throw this.astErrorOutput('Unexpected expression', varDecNode);
    }
    const result = [];
    let lastType = null;
    const declarationSets = [];
    let declarationSet = [];
    for (let i = 0; i < declarations.length; i++) {
      const declaration = declarations[i];
      const init = declaration.init;
      const info = this.getDeclaration(declaration.id);
      const actualType = this.getType(declaration.init);
      let type = actualType;
      if (type === 'LiteralInteger') {
        if (info.suggestedType === 'Integer') {
          type = 'Integer';
        } else {
          type = 'Number';
        }
      }
      const markupType = typeMap[type];
      if (!markupType) {
        throw this.astErrorOutput(`Markup type ${ markupType } not handled`, varDecNode);
      }
      const declarationResult = [];
      if (actualType === 'Integer' && type === 'Integer') {
        info.valueType = 'Number';
        if (i === 0 || lastType === null) {
          declarationResult.push('float ');
        } else if (type !== lastType) {
          throw new Error('Unhandled declaration');
        }
        lastType = type;
        declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);
        declarationResult.push('float(');
        this.astGeneric(init, declarationResult);
        declarationResult.push(')');
      } else {
        info.valueType = type;
        if (i === 0 || lastType === null) {
          declarationResult.push(`${markupType} `);
        } else if (type !== lastType) {
          declarationSets.push(declarationSet.join(','));
          declarationSet = [];
          declarationResult.push(`${markupType} `);
        }
        lastType = type;
        declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);
        if (actualType === 'Number' && type === 'Integer') {
          if (init.left && init.left.type === 'Literal') {
            this.astGeneric(init, declarationResult);
          } else {
            declarationResult.push('int(');
            this.astGeneric(init, declarationResult);
            declarationResult.push(')');
          }
        } else if (actualType === 'LiteralInteger' && type === 'Integer') {
          this.castLiteralToInteger(init, declarationResult);
        } else {
          this.astGeneric(init, declarationResult);
        }
      }
      declarationSet.push(declarationResult.join(''));
    }

    if (declarationSet.length > 0) {
      declarationSets.push(declarationSet.join(','));
    }

    result.push(declarationSets.join(';'));

    retArr.push(result.join(''));
    retArr.push(';');
    return retArr;
  }

  astIfStatement(ifNode, retArr) {
    retArr.push('if (');
    this.astGeneric(ifNode.test, retArr);
    retArr.push(')');
    if (ifNode.consequent.type === 'BlockStatement') {
      this.astGeneric(ifNode.consequent, retArr);
    } else {
      retArr.push(' {\n');
      this.astGeneric(ifNode.consequent, retArr);
      retArr.push('\n}\n');
    }

    if (ifNode.alternate) {
      retArr.push('else ');
      if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {
        this.astGeneric(ifNode.alternate, retArr);
      } else {
        retArr.push(' {\n');
        this.astGeneric(ifNode.alternate, retArr);
        retArr.push('\n}\n');
      }
    }
    return retArr;
  }

  astSwitchStatement(ast, retArr) {
    if (ast.type !== 'SwitchStatement') {
      throw this.astErrorOutput('Invalid switch statement', ast);
    }
    const { discriminant, cases } = ast;
    const type = this.getType(discriminant);
    const varName = `switchDiscriminant${this.astKey(ast, '_')}`;
    switch (type) {
      case 'Float':
      case 'Number':
        retArr.push(`float ${varName} = `);
        this.astGeneric(discriminant, retArr);
        retArr.push(';\n');
        break;
      case 'Integer':
        retArr.push(`int ${varName} = `);
        this.astGeneric(discriminant, retArr);
        retArr.push(';\n');
        break;
    }
    if (cases.length === 1 && !cases[0].test) {
      this.astGeneric(cases[0].consequent, retArr);
      return retArr;
    }

    let fallingThrough = false;
    let defaultResult = [];
    let movingDefaultToEnd = false;
    let pastFirstIf = false;
    for (let i = 0; i < cases.length; i++) {
      if (!cases[i].test) {
        if (cases.length > i + 1) {
          movingDefaultToEnd = true;
          this.astGeneric(cases[i].consequent, defaultResult);
          continue;
        } else {
          retArr.push(' else {\n');
        }
      } else {
        if (i === 0 || !pastFirstIf) {
          pastFirstIf = true;
          retArr.push(`if (${varName} == `);
        } else {
          if (fallingThrough) {
            retArr.push(`${varName} == `);
            fallingThrough = false;
          } else {
            retArr.push(` else if (${varName} == `);
          }
        }
        if (type === 'Integer') {
          const testType = this.getType(cases[i].test);
          switch (testType) {
            case 'Number':
            case 'Float':
              this.castValueToInteger(cases[i].test, retArr);
              break;
            case 'LiteralInteger':
              this.castLiteralToInteger(cases[i].test, retArr);
              break;
          }
        } else if (type === 'Float') {
          const testType = this.getType(cases[i].test);
          switch (testType) {
            case 'LiteralInteger':
              this.castLiteralToFloat(cases[i].test, retArr);
              break;
            case 'Integer':
              this.castValueToFloat(cases[i].test, retArr);
              break;
          }
        } else {
          throw new Error('unhanlded');
        }
        if (!cases[i].consequent || cases[i].consequent.length === 0) {
          fallingThrough = true;
          retArr.push(' || ');
          continue;
        }
        retArr.push(`) {\n`);
      }
      this.astGeneric(cases[i].consequent, retArr);
      retArr.push('\n}');
    }
    if (movingDefaultToEnd) {
      retArr.push(' else {');
      retArr.push(defaultResult.join(''));
      retArr.push('}');
    }
    return retArr;
  }

  astThisExpression(tNode, retArr) {
    retArr.push('this');
    return retArr;
  }

  astMemberExpression(mNode, retArr) {
    const {
      property,
      name,
      signature,
      origin,
      type,
      xProperty,
      yProperty,
      zProperty
    } = this.getMemberExpressionDetails(mNode);
    switch (signature) {
      case 'value.thread.value':
      case 'this.thread.value':
        if (name !== 'x' && name !== 'y' && name !== 'z') {
          throw this.astErrorOutput('Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`', mNode);
        }
        retArr.push(`threadId.${name}`);
        return retArr;
      case 'this.output.value':
        if (this.dynamicOutput) {
          switch (name) {
            case 'x':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.x)');
              } else {
                retArr.push('uOutputDim.x');
              }
              break;
            case 'y':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.y)');
              } else {
                retArr.push('uOutputDim.y');
              }
              break;
            case 'z':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.z)');
              } else {
                retArr.push('uOutputDim.z');
              }
              break;
            default:
              throw this.astErrorOutput('Unexpected expression', mNode);
          }
        } else {
          switch (name) {
            case 'x':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[0]);
              } else {
                retArr.push(this.output[0], '.0');
              }
              break;
            case 'y':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[1]);
              } else {
                retArr.push(this.output[1], '.0');
              }
              break;
            case 'z':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[2]);
              } else {
                retArr.push(this.output[2], '.0');
              }
              break;
            default:
              throw this.astErrorOutput('Unexpected expression', mNode);
          }
        }
        return retArr;
      case 'value':
        throw this.astErrorOutput('Unexpected expression', mNode);
      case 'value[]':
      case 'value[][]':
      case 'value[][][]':
      case 'value[][][][]':
      case 'value.value':
        if (origin === 'Math') {
          retArr.push(Math[name]);
          return retArr;
        }
        const cleanName = utils.sanitizeName(name);
        switch (property) {
          case 'r':
            retArr.push(`user_${ cleanName }.r`);
            return retArr;
          case 'g':
            retArr.push(`user_${ cleanName }.g`);
            return retArr;
          case 'b':
            retArr.push(`user_${ cleanName }.b`);
            return retArr;
          case 'a':
            retArr.push(`user_${ cleanName }.a`);
            return retArr;
        }
        break;
      case 'this.constants.value':
        if (typeof xProperty === 'undefined') {
          switch (type) {
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              retArr.push(`constants_${ utils.sanitizeName(name) }`);
              return retArr;
          }
        }
        case 'this.constants.value[]':
        case 'this.constants.value[][]':
        case 'this.constants.value[][][]':
        case 'this.constants.value[][][][]':
          break;
        case 'fn()[]':
          this.astCallExpression(mNode.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(property));
          retArr.push(']');
          return retArr;
        case '[][]':
          this.astArrayExpression(mNode.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(property));
          retArr.push(']');
          return retArr;
        case 'value.value[]':
        case 'value.value[][]':
          if (this.removeIstanbulCoverage) {
            return retArr;
          }
          default:
            throw this.astErrorOutput('Unexpected expression', mNode);
    }

    if (mNode.computed === false) {
      switch (type) {
        case 'Number':
        case 'Integer':
        case 'Float':
        case 'Boolean':
          retArr.push(`${origin}_${utils.sanitizeName(name)}`);
          return retArr;
      }
    }

    const markupName = `${origin}_${utils.sanitizeName(name)}`;

    switch (type) {
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
        this.astGeneric(mNode.object, retArr);
        retArr.push('[');
        retArr.push(this.memberExpressionPropertyMarkup(xProperty));
        retArr.push(']');
        break;
      case 'HTMLImageArray':
        retArr.push(`getImage3D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(1)':
        retArr.push(`getFloatFromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(2)':
      case 'Array2D(2)':
      case 'Array3D(2)':
        retArr.push(`getMemoryOptimizedVec2(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(2)':
        retArr.push(`getVec2FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(3)':
      case 'Array2D(3)':
      case 'Array3D(3)':
        retArr.push(`getMemoryOptimizedVec3(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(3)':
        retArr.push(`getVec3FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(4)':
      case 'Array2D(4)':
      case 'Array3D(4)':
        retArr.push(`getMemoryOptimizedVec4(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(4)':
      case 'HTMLCanvas':
      case 'HTMLImage':
      case 'HTMLVideo':
        retArr.push(`getVec4FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'NumberTexture':
      case 'Array':
      case 'Array2D':
      case 'Array3D':
      case 'Array4D':
      case 'Input':
      case 'Number':
      case 'Float':
      case 'Integer':
        if (this.precision === 'single') {
          retArr.push(`getMemoryOptimized32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
        } else {
          const bitRatio = (origin === 'user' ?
            this.lookupFunctionArgumentBitRatio(this.name, name) :
            this.constantBitRatios[name]
          );
          switch (bitRatio) {
            case 1:
              retArr.push(`get8(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            case 2:
              retArr.push(`get16(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            case 4:
            case 0:
              retArr.push(`get32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            default:
              throw new Error(`unhandled bit ratio of ${bitRatio}`);
          }
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
        }
        break;
      case 'MemoryOptimizedNumberTexture':
        retArr.push(`getMemoryOptimized32(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      default:
        throw new Error(`unhandled member expression "${ type }"`);
    }
    return retArr;
  }

  astCallExpression(ast, retArr) {
    if (!ast.callee) {
      throw this.astErrorOutput('Unknown CallExpression', ast);
    }

    let functionName = null;
    const isMathFunction = this.isAstMathFunction(ast);

    if (isMathFunction || (ast.callee.object && ast.callee.object.type === 'ThisExpression')) {
      functionName = ast.callee.property.name;
    }
    else if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[0].type === 'Literal' && !isNaN(ast.callee.expressions[0].raw)) {
      functionName = ast.callee.expressions[1].property.name;
    } else {
      functionName = ast.callee.name;
    }

    if (!functionName) {
      throw this.astErrorOutput(`Unhandled function, couldn't find name`, ast);
    }

    switch (functionName) {
      case 'pow':
        functionName = '_pow';
        break;
      case 'round':
        functionName = '_round';
        break;
    }

    if (this.calledFunctions.indexOf(functionName) < 0) {
      this.calledFunctions.push(functionName);
    }

    if (functionName === 'random' && this.plugins && this.plugins.length > 0) {
      for (let i = 0; i < this.plugins.length; i++) {
        const plugin = this.plugins[i];
        if (plugin.functionMatch === 'Math.random()' && plugin.functionReplace) {
          retArr.push(plugin.functionReplace);
          return retArr;
        }
      }
    }

    if (this.onFunctionCall) {
      this.onFunctionCall(this.name, functionName, ast.arguments);
    }

    retArr.push(functionName);

    retArr.push('(');

    if (isMathFunction) {
      for (let i = 0; i < ast.arguments.length; ++i) {
        const argument = ast.arguments[i];
        const argumentType = this.getType(argument);
        if (i > 0) {
          retArr.push(', ');
        }

        switch (argumentType) {
          case 'Integer':
            this.castValueToFloat(argument, retArr);
            break;
          default:
            this.astGeneric(argument, retArr);
            break;
        }
      }
    } else {
      const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
      for (let i = 0; i < ast.arguments.length; ++i) {
        const argument = ast.arguments[i];
        let targetType = targetTypes[i];
        if (i > 0) {
          retArr.push(', ');
        }
        const argumentType = this.getType(argument);
        if (!targetType) {
          this.triggerImplyArgumentType(functionName, i, argumentType, this);
          targetType = argumentType;
        }
        switch (argumentType) {
          case 'Boolean':
            this.astGeneric(argument, retArr);
            continue;
          case 'Number':
          case 'Float':
            if (targetType === 'Integer') {
              retArr.push('int(');
              this.astGeneric(argument, retArr);
              retArr.push(')');
              continue;
            } else if (targetType === 'Number' || targetType === 'Float') {
              this.astGeneric(argument, retArr);
              continue;
            } else if (targetType === 'LiteralInteger') {
              this.castLiteralToFloat(argument, retArr);
              continue;
            }
            break;
          case 'Integer':
            if (targetType === 'Number' || targetType === 'Float') {
              retArr.push('float(');
              this.astGeneric(argument, retArr);
              retArr.push(')');
              continue;
            } else if (targetType === 'Integer') {
              this.astGeneric(argument, retArr);
              continue;
            }
            break;
          case 'LiteralInteger':
            if (targetType === 'Integer') {
              this.castLiteralToInteger(argument, retArr);
              continue;
            } else if (targetType === 'Number' || targetType === 'Float') {
              this.castLiteralToFloat(argument, retArr);
              continue;
            } else if (targetType === 'LiteralInteger') {
              this.astGeneric(argument, retArr);
              continue;
            }
            break;
          case 'Array(2)':
          case 'Array(3)':
          case 'Array(4)':
            if (targetType === argumentType) {
              if (argument.type === 'Identifier') {
                retArr.push(`user_${utils.sanitizeName(argument.name)}`);
              } else if (argument.type === 'ArrayExpression' || argument.type === 'MemberExpression' || argument.type === 'CallExpression') {
                this.astGeneric(argument, retArr);
              } else {
                throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);
              }
              continue;
            }
            break;
          case 'HTMLCanvas':
          case 'HTMLImage':
          case 'HTMLImageArray':
          case 'HTMLVideo':
          case 'ArrayTexture(1)':
          case 'ArrayTexture(2)':
          case 'ArrayTexture(3)':
          case 'ArrayTexture(4)':
          case 'Array':
          case 'Input':
            if (targetType === argumentType) {
              if (argument.type !== 'Identifier') throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);
              this.triggerImplyArgumentBitRatio(this.name, argument.name, functionName, i);
              const name = utils.sanitizeName(argument.name);
              retArr.push(`user_${name},user_${name}Size,user_${name}Dim`);
              continue;
            }
            break;
        }
        throw this.astErrorOutput(`Unhandled argument combination of ${ argumentType } and ${ targetType } for argument named "${ argument.name }"`, ast);
      }
    }
    retArr.push(')');

    return retArr;
  }

  astArrayExpression(arrNode, retArr) {
    const arrLen = arrNode.elements.length;

    retArr.push('vec' + arrLen + '(');
    for (let i = 0; i < arrLen; ++i) {
      if (i > 0) {
        retArr.push(', ');
      }
      const subNode = arrNode.elements[i];
      this.astGeneric(subNode, retArr)
    }
    retArr.push(')');

    return retArr;
  }

  memberExpressionXYZ(x, y, z, retArr) {
    if (z) {
      retArr.push(this.memberExpressionPropertyMarkup(z), ', ');
    } else {
      retArr.push('0, ');
    }
    if (y) {
      retArr.push(this.memberExpressionPropertyMarkup(y), ', ');
    } else {
      retArr.push('0, ');
    }
    retArr.push(this.memberExpressionPropertyMarkup(x));
    return retArr;
  }

  memberExpressionPropertyMarkup(property) {
    if (!property) {
      throw new Error('Property not set');
    }
    const type = this.getType(property);
    const result = [];
    switch (type) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(property, result);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(property, result);
        break;
      default:
        this.astGeneric(property, result);
    }
    return result.join('');
  }
}

const typeMap = {
  'Array': 'sampler2D',
  'Array(2)': 'vec2',
  'Array(3)': 'vec3',
  'Array(4)': 'vec4',
  'Array2D': 'sampler2D',
  'Array3D': 'sampler2D',
  'Boolean': 'bool',
  'Float': 'float',
  'Input': 'sampler2D',
  'Integer': 'int',
  'Number': 'float',
  'LiteralInteger': 'float',
  'NumberTexture': 'sampler2D',
  'MemoryOptimizedNumberTexture': 'sampler2D',
  'ArrayTexture(1)': 'sampler2D',
  'ArrayTexture(2)': 'sampler2D',
  'ArrayTexture(3)': 'sampler2D',
  'ArrayTexture(4)': 'sampler2D',
  'HTMLVideo': 'sampler2D',
  'HTMLCanvas': 'sampler2D',
  'HTMLImage': 'sampler2D',
  'HTMLImageArray': 'sampler2DArray',
};

const operatorMap = {
  '===': '==',
  '!==': '!='
};

module.exports = {
  WebGLFunctionNode
};
},{"../../utils":114,"../function-node":10}],39:[function(require,module,exports){
const { WebGLKernelValueBoolean } = require('./kernel-value/boolean');
const { WebGLKernelValueFloat } = require('./kernel-value/float');
const { WebGLKernelValueInteger } = require('./kernel-value/integer');

const { WebGLKernelValueHTMLImage } = require('./kernel-value/html-image');
const { WebGLKernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');

const { WebGLKernelValueHTMLVideo } = require('./kernel-value/html-video');
const { WebGLKernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');

const { WebGLKernelValueSingleInput } = require('./kernel-value/single-input');
const { WebGLKernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');

const { WebGLKernelValueUnsignedInput } = require('./kernel-value/unsigned-input');
const { WebGLKernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');

const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');
const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');

const { WebGLKernelValueNumberTexture } = require('./kernel-value/number-texture');
const { WebGLKernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');

const { WebGLKernelValueSingleArray } = require('./kernel-value/single-array');
const { WebGLKernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');

const { WebGLKernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');
const { WebGLKernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');

const { WebGLKernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');
const { WebGLKernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');

const { WebGLKernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');
const { WebGLKernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');

const { WebGLKernelValueSingleArray2 } = require('./kernel-value/single-array2');
const { WebGLKernelValueSingleArray3 } = require('./kernel-value/single-array3');
const { WebGLKernelValueSingleArray4 } = require('./kernel-value/single-array4');

const { WebGLKernelValueUnsignedArray } = require('./kernel-value/unsigned-array');
const { WebGLKernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');

const kernelValueMaps = {
  unsigned: {
    dynamic: {
      'Boolean': WebGLKernelValueBoolean,
      'Integer': WebGLKernelValueInteger,
      'Float': WebGLKernelValueFloat,
      'Array': WebGLKernelValueDynamicUnsignedArray,
      'Array(2)': false,
      'Array(3)': false,
      'Array(4)': false,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGLKernelValueDynamicUnsignedInput,
      'NumberTexture': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,
      'HTMLImage': WebGLKernelValueDynamicHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGLKernelValueBoolean,
      'Float': WebGLKernelValueFloat,
      'Integer': WebGLKernelValueInteger,
      'Array': WebGLKernelValueUnsignedArray,
      'Array(2)': false,
      'Array(3)': false,
      'Array(4)': false,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGLKernelValueUnsignedInput,
      'NumberTexture': WebGLKernelValueNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueHTMLImage,
      'HTMLImage': WebGLKernelValueHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueHTMLVideo,
    }
  },
  single: {
    dynamic: {
      'Boolean': WebGLKernelValueBoolean,
      'Integer': WebGLKernelValueInteger,
      'Float': WebGLKernelValueFloat,
      'Array': WebGLKernelValueDynamicSingleArray,
      'Array(2)': WebGLKernelValueSingleArray2,
      'Array(3)': WebGLKernelValueSingleArray3,
      'Array(4)': WebGLKernelValueSingleArray4,
      'Array1D(2)': WebGLKernelValueDynamicSingleArray1DI,
      'Array1D(3)': WebGLKernelValueDynamicSingleArray1DI,
      'Array1D(4)': WebGLKernelValueDynamicSingleArray1DI,
      'Array2D(2)': WebGLKernelValueDynamicSingleArray2DI,
      'Array2D(3)': WebGLKernelValueDynamicSingleArray2DI,
      'Array2D(4)': WebGLKernelValueDynamicSingleArray2DI,
      'Array3D(2)': WebGLKernelValueDynamicSingleArray3DI,
      'Array3D(3)': WebGLKernelValueDynamicSingleArray3DI,
      'Array3D(4)': WebGLKernelValueDynamicSingleArray3DI,
      'Input': WebGLKernelValueDynamicSingleInput,
      'NumberTexture': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,
      'HTMLImage': WebGLKernelValueDynamicHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGLKernelValueBoolean,
      'Float': WebGLKernelValueFloat,
      'Integer': WebGLKernelValueInteger,
      'Array': WebGLKernelValueSingleArray,
      'Array(2)': WebGLKernelValueSingleArray2,
      'Array(3)': WebGLKernelValueSingleArray3,
      'Array(4)': WebGLKernelValueSingleArray4,
      'Array1D(2)': WebGLKernelValueSingleArray1DI,
      'Array1D(3)': WebGLKernelValueSingleArray1DI,
      'Array1D(4)': WebGLKernelValueSingleArray1DI,
      'Array2D(2)': WebGLKernelValueSingleArray2DI,
      'Array2D(3)': WebGLKernelValueSingleArray2DI,
      'Array2D(4)': WebGLKernelValueSingleArray2DI,
      'Array3D(2)': WebGLKernelValueSingleArray3DI,
      'Array3D(3)': WebGLKernelValueSingleArray3DI,
      'Array3D(4)': WebGLKernelValueSingleArray3DI,
      'Input': WebGLKernelValueSingleInput,
      'NumberTexture': WebGLKernelValueNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueHTMLImage,
      'HTMLImage': WebGLKernelValueHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueHTMLVideo,
    }
  },
};

function lookupKernelValueType(type, dynamic, precision, value) {
  if (!type) {
    throw new Error('type missing');
  }
  if (!dynamic) {
    throw new Error('dynamic missing');
  }
  if (!precision) {
    throw new Error('precision missing');
  }
  if (value.type) {
    type = value.type;
  }
  const types = kernelValueMaps[precision][dynamic];
  if (types[type] === false) {
    return null;
  } else if (types[type] === undefined) {
    throw new Error(`Could not find a KernelValue for ${ type }`);
  }
  return types[type];
}

module.exports = {
  lookupKernelValueType,
  kernelValueMaps,
};
},{"./kernel-value/boolean":41,"./kernel-value/dynamic-html-image":42,"./kernel-value/dynamic-html-video":43,"./kernel-value/dynamic-memory-optimized-number-texture":44,"./kernel-value/dynamic-number-texture":45,"./kernel-value/dynamic-single-array":46,"./kernel-value/dynamic-single-array1d-i":47,"./kernel-value/dynamic-single-array2d-i":48,"./kernel-value/dynamic-single-array3d-i":49,"./kernel-value/dynamic-single-input":50,"./kernel-value/dynamic-unsigned-array":51,"./kernel-value/dynamic-unsigned-input":52,"./kernel-value/float":53,"./kernel-value/html-image":54,"./kernel-value/html-video":55,"./kernel-value/integer":57,"./kernel-value/memory-optimized-number-texture":58,"./kernel-value/number-texture":59,"./kernel-value/single-array":60,"./kernel-value/single-array1d-i":61,"./kernel-value/single-array2":62,"./kernel-value/single-array2d-i":63,"./kernel-value/single-array3":64,"./kernel-value/single-array3d-i":65,"./kernel-value/single-array4":66,"./kernel-value/single-input":67,"./kernel-value/unsigned-array":68,"./kernel-value/unsigned-input":69}],40:[function(require,module,exports){
const { WebGLKernelValue } = require('./index');
const { Input } = require('../../../input');

class WebGLKernelArray extends WebGLKernelValue {
  checkSize(width, height) {
    if (!this.kernel.validate) return;
    const { maxTextureSize } = this.kernel.constructor.features;
    if (width > maxTextureSize || height > maxTextureSize) {
      if (width > height) {
        throw new Error(`Argument texture width of ${width} larger than maximum size of ${maxTextureSize} for your GPU`);
      } else if (width < height) {
        throw new Error(`Argument texture height of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);
      } else {
        throw new Error(`Argument texture height and width of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);
      }
    }
  }

  setup() {
    this.requestTexture();
    this.setupTexture();
    this.defineTexture();
  }

  requestTexture() {
    this.texture = this.onRequestTexture();
  }

  defineTexture() {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  }

  setupTexture() {
    this.contextHandle = this.onRequestContextHandle();
    this.index = this.onRequestIndex();
    this.dimensionsId = this.id + 'Dim';
    this.sizeId = this.id + 'Size';
  }

  getBitRatio(value) {
    if (Array.isArray(value[0])) {
      return this.getBitRatio(value[0]);
    } else if (value.constructor === Input) {
      return this.getBitRatio(value.value);
    }
    switch (value.constructor) {
      case Uint8ClampedArray:
      case Uint8Array:
      case Int8Array:
        return 1;
      case Uint16Array:
      case Int16Array:
        return 2;
      case Float32Array:
      case Int32Array:
      default:
        return 4;
    }
  }

  destroy() {
    if (this.prevArg) {
      this.prevArg.delete();
    }
    this.context.deleteTexture(this.texture);
  }
}

module.exports = {
  WebGLKernelArray
};
},{"../../../input":110,"./index":56}],41:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueBoolean extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const bool ${this.id} = ${value};\n`;
    }
    return `uniform bool ${this.id};\n`;
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueBoolean
};
},{"../../../utils":114,"./index":56}],42:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueHTMLImage } = require('./html-image');

class WebGLKernelValueDynamicHTMLImage extends WebGLKernelValueHTMLImage {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    const { width, height } = value;
    this.checkSize(width, height);
    this.dimensions = [width, height, 1];
    this.textureSize = [width, height];
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicHTMLImage
};
},{"../../../utils":114,"./html-image":54}],43:[function(require,module,exports){
const { WebGLKernelValueDynamicHTMLImage } = require('./dynamic-html-image');

class WebGLKernelValueDynamicHTMLVideo extends WebGLKernelValueDynamicHTMLImage {}

module.exports = {
  WebGLKernelValueDynamicHTMLVideo
};
},{"./dynamic-html-image":42}],44:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./memory-optimized-number-texture');

class WebGLKernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(inputTexture) {
    this.dimensions = inputTexture.dimensions;
    this.checkSize(inputTexture.size[0], inputTexture.size[1]);
    this.textureSize = inputTexture.size;
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(inputTexture);
  }
}

module.exports = {
  WebGLKernelValueDynamicMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"./memory-optimized-number-texture":58}],45:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueNumberTexture } = require('./number-texture');

class WebGLKernelValueDynamicNumberTexture extends WebGLKernelValueNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = value.dimensions;
    this.checkSize(value.size[0], value.size[1]);
    this.textureSize = value.size;
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicNumberTexture
};
},{"../../../utils":114,"./number-texture":59}],46:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray } = require('./single-array');

class WebGLKernelValueDynamicSingleArray extends WebGLKernelValueSingleArray {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray
};
},{"../../../utils":114,"./single-array":60}],47:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray1DI } = require('./single-array1d-i');

class WebGLKernelValueDynamicSingleArray1DI extends WebGLKernelValueSingleArray1DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray1DI
};
},{"../../../utils":114,"./single-array1d-i":61}],48:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray2DI } = require('./single-array2d-i');

class WebGLKernelValueDynamicSingleArray2DI extends WebGLKernelValueSingleArray2DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray2DI
};
},{"../../../utils":114,"./single-array2d-i":63}],49:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray3DI } = require('./single-array3d-i');

class WebGLKernelValueDynamicSingleArray3DI extends WebGLKernelValueSingleArray3DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray3DI
};
},{"../../../utils":114,"./single-array3d-i":65}],50:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleInput } = require('./single-input');

class WebGLKernelValueDynamicSingleInput extends WebGLKernelValueSingleInput {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleInput
};
},{"../../../utils":114,"./single-input":67}],51:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedArray } = require('./unsigned-array');

class WebGLKernelValueDynamicUnsignedArray extends WebGLKernelValueUnsignedArray {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    const Type = this.getTransferArrayType(value);
    this.preUploadValue = new Type(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicUnsignedArray
};
},{"../../../utils":114,"./unsigned-array":68}],52:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedInput } = require('./unsigned-input');

class WebGLKernelValueDynamicUnsignedInput extends WebGLKernelValueUnsignedInput {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    const Type = this.getTransferArrayType(value.value);
    this.preUploadValue = new Type(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicUnsignedInput
};
},{"../../../utils":114,"./unsigned-input":69}],53:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueFloat extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      if (Number.isInteger(value)) {
        return `const float ${this.id} = ${value}.0;\n`;
      }
      return `const float ${this.id} = ${value};\n`;
    }
    return `uniform float ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1f(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueFloat
};
},{"../../../utils":114,"./index":56}],54:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueHTMLImage extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const { width, height } = value;
    this.checkSize(width, height);
    this.dimensions = [width, height, 1];
    this.textureSize = [width, height];
    this.uploadValue = value;
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputImage) {
    if (inputImage.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputImage.constructor);
      return;
    }
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue = inputImage);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueHTMLImage
};
},{"../../../utils":114,"./array":40}],55:[function(require,module,exports){
const { WebGLKernelValueHTMLImage } = require('./html-image');

class WebGLKernelValueHTMLVideo extends WebGLKernelValueHTMLImage {}

module.exports = {
  WebGLKernelValueHTMLVideo
};
},{"./html-image":54}],56:[function(require,module,exports){
const { utils } = require('../../../utils');
const { KernelValue } = require('../../kernel-value');

class WebGLKernelValue extends KernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.dimensionsId = null;
    this.sizeId = null;
    this.initialValueConstructor = value.constructor;
    this.onRequestTexture = settings.onRequestTexture;
    this.onRequestIndex = settings.onRequestIndex;
    this.uploadValue = null;
    this.textureSize = null;
    this.bitRatio = null;
    this.prevArg = null;
  }

  get id() {
    return `${this.origin}_${utils.sanitizeName(this.name)}`;
  }

  setup() {}

  getTransferArrayType(value) {
    if (Array.isArray(value[0])) {
      return this.getTransferArrayType(value[0]);
    }
    switch (value.constructor) {
      case Array:
      case Int32Array:
      case Int16Array:
      case Int8Array:
        return Float32Array;
      case Uint8ClampedArray:
      case Uint8Array:
      case Uint16Array:
      case Uint32Array:
      case Float32Array:
      case Float64Array:
        return value.constructor;
    }
    console.warn('Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros');
    return value.constructor;
  }

  getStringValueHandler() {
    throw new Error(`"getStringValueHandler" not implemented on ${this.constructor.name}`);
  }

  getVariablePrecisionString() {
    return this.kernel.getVariablePrecisionString(this.textureSize || undefined, this.tactic || undefined);
  }

  destroy() {}
}

module.exports = {
  WebGLKernelValue
};
},{"../../../utils":114,"../../kernel-value":35}],57:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueInteger extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const int ${this.id} = ${ parseInt(value) };\n`;
    }
    return `uniform int ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueInteger
};
},{"../../../utils":114,"./index":56}],58:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

const sameError = `Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()`;

class WebGLKernelValueMemoryOptimizedNumberTexture extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const [width, height] = value.size;
    this.checkSize(width, height);
    this.dimensions = value.dimensions;
    this.textureSize = value.size;
    this.uploadValue = value.texture;
    this.forceUploadEachRun = true;
  }

  setup() {
    this.setupTexture();
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName}.texture;\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputTexture) {
    if (inputTexture.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputTexture.constructor);
      return;
    }
    if (this.checkContext && inputTexture.context !== this.context) {
      throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
    }

    const { kernel, context: gl } = this;
    if (kernel.pipeline) {
      if (kernel.immutable) {
        kernel.updateTextureArgumentRefs(this, inputTexture);
      } else {
        if (kernel.texture.texture === inputTexture.texture) {
          throw new Error(sameError);
        } else if (kernel.mappedTextures) {
          const { mappedTextures } = kernel;
          for (let i = 0; i < mappedTextures.length; i++) {
            if (mappedTextures[i].texture === inputTexture.texture) {
              throw new Error(sameError);
            }
          }
        }
      }
    }

    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueMemoryOptimizedNumberTexture,
  sameError
};
},{"../../../utils":114,"./array":40}],59:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');
const { sameError } = require('./memory-optimized-number-texture');

class WebGLKernelValueNumberTexture extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const [width, height] = value.size;
    this.checkSize(width, height);
    const { size: textureSize, dimensions } = value;
    this.bitRatio = this.getBitRatio(value);
    this.dimensions = dimensions;
    this.textureSize = textureSize;
    this.uploadValue = value.texture;
    this.forceUploadEachRun = true;
  }

  setup() {
    this.setupTexture();
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName}.texture;\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputTexture) {
    if (inputTexture.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputTexture.constructor);
      return;
    }
    if (this.checkContext && inputTexture.context !== this.context) {
      throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
    }

    const { kernel, context: gl } = this;
    if (kernel.pipeline) {
      if (kernel.immutable) {
        kernel.updateTextureArgumentRefs(this, inputTexture);
      } else {
        if (kernel.texture.texture === inputTexture.texture) {
          throw new Error(sameError);
        } else if (kernel.mappedTextures) {
          const { mappedTextures } = kernel;
          for (let i = 0; i < mappedTextures.length; i++) {
            if (mappedTextures[i].texture === inputTexture.texture) {
              throw new Error(sameError);
            }
          }
        }
      }
    }

    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueNumberTexture
};
},{"../../../utils":114,"./array":40,"./memory-optimized-number-texture":58}],60:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray
};
},{"../../../utils":114,"./array":40}],61:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray1DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], 1, 1]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten2dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray1DI
};
},{"../../../utils":114,"./array":40}],62:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueSingleArray2 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec2 ${this.id} = vec2(${value[0]},${value[1]});\n`;
    }
    return `uniform vec2 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform2fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueSingleArray2
};
},{"../../../utils":114,"./index":56}],63:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray2DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], 1]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten3dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray2DI
};
},{"../../../utils":114,"./array":40}],64:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueSingleArray3 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec3 ${this.id} = vec3(${value[0]},${value[1]},${value[2]});\n`;
    }
    return `uniform vec3 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform3fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueSingleArray3
};
},{"../../../utils":114,"./index":56}],65:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray3DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], valueDimensions[3]]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten4dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray3DI
};
},{"../../../utils":114,"./array":40}],66:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueSingleArray4 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec4 ${this.id} = vec4(${value[0]},${value[1]},${value[2]},${value[3]});\n`;
    }
    return `uniform vec4 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform4fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueSingleArray4
};
},{"../../../utils":114,"./index":56}],67:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleInput extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}.value, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    if (input.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(input.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(input.value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleInput
};
},{"../../../utils":114,"./array":40}],68:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueUnsignedArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = this.getBitRatio(value);
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.TranserArrayType = this.getTransferArrayType(value);
    this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
      `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
      `flattenTo(${this.varName}, preUploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.preUploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueUnsignedArray
};
},{"../../../utils":114,"./array":40}],69:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueUnsignedInput extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = this.getBitRatio(value);
    const [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.TranserArrayType = this.getTransferArrayType(value.value);
    this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
      `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
      `flattenTo(${this.varName}.value, preUploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    if (input.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(input.value, this.preUploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueUnsignedInput
};
},{"../../../utils":114,"./array":40}],70:[function(require,module,exports){
const { GLKernel } = require('../gl/kernel');
const { FunctionBuilder } = require('../function-builder');
const { WebGLFunctionNode } = require('./function-node');
const { utils } = require('../../utils');
const mrud = require('../../plugins/math-random-uniformly-distributed');
const { fragmentShader } = require('./fragment-shader');
const { vertexShader } = require('./vertex-shader');
const { glKernelString } = require('../gl/kernel-string');
const { lookupKernelValueType } = require('./kernel-value-maps');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;
let features = null;

const plugins = [mrud];
const canvases = [];
const maxTexSizes = {};


class WebGLKernel extends GLKernel {
  static get isSupported() {
    if (isSupported !== null) {
      return isSupported;
    }
    this.setupFeatureChecks();
    isSupported = this.isContextMatch(testContext);
    return isSupported;
  }

  static setupFeatureChecks() {
    if (typeof document !== 'undefined') {
      testCanvas = document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      testCanvas = new OffscreenCanvas(0, 0);
    }
    if (!testCanvas) return;
    testContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
    if (!testContext || !testContext.getExtension) return;
    testExtensions = {
      OES_texture_float: testContext.getExtension('OES_texture_float'),
      OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
    };
    features = this.getFeatures();
  }

  static isContextMatch(context) {
    if (typeof WebGLRenderingContext !== 'undefined') {
      return context instanceof WebGLRenderingContext;
    }
    return false;
  }

  static getIsTextureFloat() {
    return Boolean(testExtensions.OES_texture_float);
  }

  static getIsDrawBuffers() {
    return Boolean(testExtensions.WEBGL_draw_buffers);
  }

  static getChannelCount() {
    return testExtensions.WEBGL_draw_buffers ?
      testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :
      1;
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static lookupKernelValueType(type, dynamic, precision, value) {
    return lookupKernelValueType(type, dynamic, precision, value);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  static get fragmentShader() {
    return fragmentShader;
  }

  static get vertexShader() {
    return vertexShader;
  }

  constructor(source, settings) {
    super(source, settings);
    this.program = null;
    this.pipeline = settings.pipeline;
    this.endianness = utils.systemEndianness();
    this.extensions = {};
    this.argumentTextureCount = 0;
    this.constantTextureCount = 0;
    this.fragShader = null;
    this.vertShader = null;
    this.drawBuffersMap = null;

    this.maxTexSize = null;
    this.onRequestSwitchKernel = null;
    this.removeIstanbulCoverage = true;

    this.texture = null;
    this.mappedTextures = null;
    this.mergeSettings(source.settings || settings);

    this.threadDim = null;
    this.framebuffer = null;
    this.buffer = null;

    this.textureCache = [];
    this.programUniformLocationCache = {};
    this.uniform1fCache = {};
    this.uniform1iCache = {};
    this.uniform2fCache = {};
    this.uniform2fvCache = {};
    this.uniform2ivCache = {};
    this.uniform3fvCache = {};
    this.uniform3ivCache = {};
    this.uniform4fvCache = {};
    this.uniform4ivCache = {};
  }

  initCanvas() {
    if (typeof document !== 'undefined') {
      const canvas = document.createElement('canvas');
      canvas.width = 2;
      canvas.height = 2;
      return canvas;
    } else if (typeof OffscreenCanvas !== 'undefined') {
      return new OffscreenCanvas(0, 0);
    }
  }

  initContext() {
    const settings = {
      alpha: false,
      depth: false,
      antialias: false
    };
    return this.canvas.getContext('webgl', settings) || this.canvas.getContext('experimental-webgl', settings);
  }

  initPlugins(settings) {
    const pluginsToUse = [];
    const { source } = this;
    if (typeof source === 'string') {
      for (let i = 0; i < plugins.length; i++) {
        const plugin = plugins[i];
        if (source.match(plugin.functionMatch)) {
          pluginsToUse.push(plugin);
        }
      }
    } else if (typeof source === 'object') {
      if (settings.pluginNames) { 
        for (let i = 0; i < plugins.length; i++) {
          const plugin = plugins[i];
          const usePlugin = settings.pluginNames.some(pluginName => pluginName === plugin.name);
          if (usePlugin) {
            pluginsToUse.push(plugin);
          }
        }
      }
    }
    return pluginsToUse;
  }

  initExtensions() {
    this.extensions = {
      OES_texture_float: this.context.getExtension('OES_texture_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
      WEBGL_color_buffer_float: this.context.getExtension('WEBGL_color_buffer_float'),
    };
  }

  validateSettings(args) {
    if (!this.validate) {
      this.texSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, this.output);
      return;
    }

    const { features } = this.constructor;

    if (this.optimizeFloatMemory === true && !features.isTextureFloat) {
      throw new Error('Float textures are not supported');
    } else if (this.precision === 'single' && !features.isFloatRead) {
      throw new Error('Single precision not supported');
    } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
      this.precision = features.isFloatRead ? 'single' : 'unsigned';
    }

    if (this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers) {
      throw new Error('could not instantiate draw buffers extension');
    }

    if (this.fixIntegerDivisionAccuracy === null) {
      this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
    } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
      this.fixIntegerDivisionAccuracy = false;
    }

    this.checkOutput();

    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      switch (argType) {
        case 'Array':
          this.output = utils.getDimensions(argType);
          break;
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
          this.output = args[0].output;
          break;
        default:
          throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }

      if (this.precision === 'precision') {
        this.precision = 'unsigned';
        console.warn('Cannot use graphical mode and single precision at the same time');
      }

      this.texSize = utils.clone(this.output);
      return;
    } else if (this.precision === null && features.isTextureFloat) {
      this.precision = 'single';
    }

    this.texSize = utils.getKernelTextureSize({
      optimizeFloatMemory: this.optimizeFloatMemory,
      precision: this.precision,
    }, this.output);

    this.checkTextureSize();
  }

  updateMaxTexSize() {
    const { texSize, canvas } = this;
    if (this.maxTexSize === null) {
      let canvasIndex = canvases.indexOf(canvas);
      if (canvasIndex === -1) {
        canvasIndex = canvases.length;
        canvases.push(canvas);
        maxTexSizes[canvasIndex] = [texSize[0], texSize[1]];
      }
      this.maxTexSize = maxTexSizes[canvasIndex];
    }
    if (this.maxTexSize[0] < texSize[0]) {
      this.maxTexSize[0] = texSize[0];
    }
    if (this.maxTexSize[1] < texSize[1]) {
      this.maxTexSize[1] = texSize[1];
    }
  }

  setupArguments(args) {
    this.kernelArguments = [];
    this.argumentTextureCount = 0;
    const needsArgumentTypes = this.argumentTypes === null;
    if (needsArgumentTypes) {
      this.argumentTypes = [];
    }
    this.argumentSizes = [];
    this.argumentBitRatios = [];

    if (args.length < this.argumentNames.length) {
      throw new Error('not enough arguments for kernel');
    } else if (args.length > this.argumentNames.length) {
      throw new Error('too many arguments for kernel');
    }

    const { context: gl } = this;
    let textureIndexes = 0;

    const onRequestTexture = () => {
      return this.createTexture();
    };
    const onRequestIndex = () => {
      return textureIndexes++;
    };
    const onUpdateValueMismatch = (constructor) => {
      this.switchKernels({
        type: 'argumentMismatch',
        needed: constructor
      });
    };
    const onRequestContextHandle = () => {
      return gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount++;
    };

    for (let index = 0; index < args.length; index++) {
      const value = args[index];
      const name = this.argumentNames[index];
      let type;
      if (needsArgumentTypes) {
        type = utils.getVariableType(value, this.strictIntegers);
        this.argumentTypes.push(type);
      } else {
        type = this.argumentTypes[index];
      }
      const KernelValue = this.constructor.lookupKernelValueType(type, this.dynamicArguments ? 'dynamic' : 'static', this.precision, args[index]);
      if (KernelValue === null) {
        return this.requestFallback(args);
      }
      const kernelArgument = new KernelValue(value, {
        name,
        type,
        tactic: this.tactic,
        origin: 'user',
        context: gl,
        checkContext: this.checkContext,
        kernel: this,
        strictIntegers: this.strictIntegers,
        onRequestTexture,
        onRequestIndex,
        onUpdateValueMismatch,
        onRequestContextHandle,
      });
      this.kernelArguments.push(kernelArgument);
      kernelArgument.setup();
      this.argumentSizes.push(kernelArgument.textureSize);
      this.argumentBitRatios[index] = kernelArgument.bitRatio;
    }
  }

  createTexture() {
    const texture = this.context.createTexture();
    this.textureCache.push(texture);
    return texture;
  }

  setupConstants(args) {
    const { context: gl } = this;
    this.kernelConstants = [];
    this.forceUploadKernelConstants = [];
    let needsConstantTypes = this.constantTypes === null;
    if (needsConstantTypes) {
      this.constantTypes = {};
    }
    this.constantBitRatios = {};
    let textureIndexes = 0;
    for (const name in this.constants) {
      const value = this.constants[name];
      let type;
      if (needsConstantTypes) {
        type = utils.getVariableType(value, this.strictIntegers);
        this.constantTypes[name] = type;
      } else {
        type = this.constantTypes[name];
      }
      const KernelValue = this.constructor.lookupKernelValueType(type, 'static', this.precision, value);
      if (KernelValue === null) {
        return this.requestFallback(args);
      }
      const kernelValue = new KernelValue(value, {
        name,
        type,
        tactic: this.tactic,
        origin: 'constants',
        context: this.context,
        checkContext: this.checkContext,
        kernel: this,
        strictIntegers: this.strictIntegers,
        onRequestTexture: () => {
          return this.createTexture();
        },
        onRequestIndex: () => {
          return textureIndexes++;
        },
        onRequestContextHandle: () => {
          return gl.TEXTURE0 + this.constantTextureCount++;
        }
      });
      this.constantBitRatios[name] = kernelValue.bitRatio;
      this.kernelConstants.push(kernelValue);
      kernelValue.setup();
      if (kernelValue.forceUploadEachRun) {
        this.forceUploadKernelConstants.push(kernelValue);
      }
    }
  }

  build() {
    if (this.built) return;
    this.initExtensions();
    this.validateSettings(arguments);
    this.setupConstants(arguments);
    if (this.fallbackRequested) return;
    this.setupArguments(arguments);
    if (this.fallbackRequested) return;
    this.updateMaxTexSize();
    this.translateSource();
    const failureResult = this.pickRenderStrategy(arguments);
    if (failureResult) {
      return failureResult;
    }
    const { texSize, context: gl, canvas } = this;
    gl.enable(gl.SCISSOR_TEST);
    if (this.pipeline && this.precision === 'single') {
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      canvas.width = this.maxTexSize[0];
      canvas.height = this.maxTexSize[1];
    } else {
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      canvas.width = this.maxTexSize[0];
      canvas.height = this.maxTexSize[1];
    }
    const threadDim = this.threadDim = Array.from(this.output);
    while (threadDim.length < 3) {
      threadDim.push(1);
    }

    const compiledVertexShader = this.getVertexShader(arguments);
    const vertShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertShader, compiledVertexShader);
    gl.compileShader(vertShader);
    this.vertShader = vertShader;

    const compiledFragmentShader = this.getFragmentShader(arguments);
    const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragShader, compiledFragmentShader);
    gl.compileShader(fragShader);
    this.fragShader = fragShader;

    if (this.debug) {
      console.log('GLSL Shader Output:');
      console.log(compiledFragmentShader);
    }

    if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
      throw new Error('Error compiling vertex shader: ' + gl.getShaderInfoLog(vertShader));
    }
    if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
      throw new Error('Error compiling fragment shader: ' + gl.getShaderInfoLog(fragShader));
    }

    const program = this.program = gl.createProgram();
    gl.attachShader(program, vertShader);
    gl.attachShader(program, fragShader);
    gl.linkProgram(program);
    this.framebuffer = gl.createFramebuffer();
    this.framebuffer.width = texSize[0];
    this.framebuffer.height = texSize[1];

    const vertices = new Float32Array([-1, -1,
      1, -1, -1, 1,
      1, 1
    ]);
    const texCoords = new Float32Array([
      0, 0,
      1, 0,
      0, 1,
      1, 1
    ]);

    const texCoordOffset = vertices.byteLength;

    let buffer = this.buffer;
    if (!buffer) {
      buffer = this.buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices.byteLength + texCoords.byteLength, gl.STATIC_DRAW);
    } else {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    }

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
    gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);

    const aPosLoc = gl.getAttribLocation(this.program, 'aPos');
    gl.enableVertexAttribArray(aPosLoc);
    gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);
    const aTexCoordLoc = gl.getAttribLocation(this.program, 'aTexCoord');
    gl.enableVertexAttribArray(aTexCoordLoc);
    gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, false, 0, texCoordOffset);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);

    let i = 0;
    gl.useProgram(this.program);
    for (let p in this.constants) {
      this.kernelConstants[i++].updateValue(this.constants[p]);
    }

    this._setupOutputTexture();
    if (
      this.subKernels !== null &&
      this.subKernels.length > 0
    ) {
      this._mappedTextureSwitched = {};
      this._setupSubOutputTextures();
    }
    this.buildSignature(arguments);
    this.built = true;
  }

  translateSource() {
    const functionBuilder = FunctionBuilder.fromKernel(this, WebGLFunctionNode, {
      fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
    });
    this.translatedSource = functionBuilder.getPrototypeString('kernel');
    this.setupReturnTypes(functionBuilder);
  }

  setupReturnTypes(functionBuilder) {
    if (!this.graphical && !this.returnType) {
      this.returnType = functionBuilder.getKernelResultType();
    }

    if (this.subKernels && this.subKernels.length > 0) {
      for (let i = 0; i < this.subKernels.length; i++) {
        const subKernel = this.subKernels[i];
        if (!subKernel.returnType) {
          subKernel.returnType = functionBuilder.getSubKernelResultType(i);
        }
      }
    }
  }

  run() {
    const { kernelArguments, texSize, forceUploadKernelConstants, context: gl } = this;

    gl.useProgram(this.program);
    gl.scissor(0, 0, texSize[0], texSize[1]);
    if (this.dynamicOutput) {
      this.setUniform3iv('uOutputDim', new Int32Array(this.threadDim));
      this.setUniform2iv('uTexSize', texSize);
    }

    this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);

    for (let i = 0; i < forceUploadKernelConstants.length; i++) {
      const constant = forceUploadKernelConstants[i];
      constant.updateValue(this.constants[constant.name]);
      if (this.switchingKernels) return;
    }
    for (let i = 0; i < kernelArguments.length; i++) {
      kernelArguments[i].updateValue(arguments[i]);
      if (this.switchingKernels) return;
    }

    if (this.plugins) {
      for (let i = 0; i < this.plugins.length; i++) {
        const plugin = this.plugins[i];
        if (plugin.onBeforeRun) {
          plugin.onBeforeRun(this);
        }
      }
    }

    if (this.graphical) {
      if (this.pipeline) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        if (this.immutable) {
          this._replaceOutputTexture();
        }
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        return this.immutable ? this.texture.clone() : this.texture;
      }
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      return;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    if (this.immutable) {
      this._replaceOutputTexture();
    }

    if (this.subKernels !== null) {
      if (this.immutable) {
        this._replaceSubOutputTextures();
      }
      this.drawBuffers();
    }

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  drawBuffers() {
    this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);
  }

  getInternalFormat() {
    return this.context.RGBA;
  }
  getTextureFormat() {
    const { context: gl } = this;
    switch (this.getInternalFormat()) {
      case gl.RGBA:
        return gl.RGBA;
      default:
        throw new Error('Unknown internal format');
    }
  }

  _replaceOutputTexture() {
    if (this.texture.beforeMutate() || this._textureSwitched) {
      const gl = this.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      this._textureSwitched = false;
    }
  }

  _setupOutputTexture() {
    const gl = this.context;
    const texSize = this.texSize;
    if (this.texture) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      return;
    }
    const texture = this.createTexture();
    gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    const format = this.getInternalFormat();
    if (this.precision === 'single') {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    this.texture = new this.TextureConstructor({
      texture,
      size: texSize,
      dimensions: this.threadDim,
      output: this.output,
      context: this.context,
      internalFormat: this.getInternalFormat(),
      textureFormat: this.getTextureFormat(),
      kernel: this,
    });
  }

  _replaceSubOutputTextures() {
    const gl = this.context;
    for (let i = 0; i < this.mappedTextures.length; i++) {
      const mappedTexture = this.mappedTextures[i];
      if (mappedTexture.beforeMutate() || this._mappedTextureSwitched[i]) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, mappedTexture.texture, 0);
        this._mappedTextureSwitched[i] = false;
      }
    }
  }

  _setupSubOutputTextures() {
    const gl = this.context;
    if (this.mappedTextures) {
      for (let i = 0; i < this.subKernels.length; i++) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);
      }
      return;
    }
    const texSize = this.texSize;
    this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
    this.mappedTextures = [];
    for (let i = 0; i < this.subKernels.length; i++) {
      const texture = this.createTexture();
      this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
      gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      if (this.precision === 'single') {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);

      this.mappedTextures.push(new this.TextureConstructor({
        texture,
        size: texSize,
        dimensions: this.threadDim,
        output: this.output,
        context: this.context,
        internalFormat: this.getInternalFormat(),
        textureFormat: this.getTextureFormat(),
        kernel: this,
      }));
    }
  }

  setUniform1f(name, value) {
    if (this.uniform1fCache.hasOwnProperty(name)) {
      const cache = this.uniform1fCache[name];
      if (value === cache) {
        return;
      }
    }
    this.uniform1fCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform1f(loc, value);
  }

  setUniform1i(name, value) {
    if (this.uniform1iCache.hasOwnProperty(name)) {
      const cache = this.uniform1iCache[name];
      if (value === cache) {
        return;
      }
    }
    this.uniform1iCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform1i(loc, value);
  }

  setUniform2f(name, value1, value2) {
    if (this.uniform2fCache.hasOwnProperty(name)) {
      const cache = this.uniform2fCache[name];
      if (
        value1 === cache[0] &&
        value2 === cache[1]
      ) {
        return;
      }
    }
    this.uniform2fCache[name] = [value1, value2];
    const loc = this.getUniformLocation(name);
    this.context.uniform2f(loc, value1, value2);
  }

  setUniform2fv(name, value) {
    if (this.uniform2fvCache.hasOwnProperty(name)) {
      const cache = this.uniform2fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1]
      ) {
        return;
      }
    }
    this.uniform2fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform2fv(loc, value);
  }

  setUniform2iv(name, value) {
    if (this.uniform2ivCache.hasOwnProperty(name)) {
      const cache = this.uniform2ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1]
      ) {
        return;
      }
    }
    this.uniform2ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform2iv(loc, value);
  }

  setUniform3fv(name, value) {
    if (this.uniform3fvCache.hasOwnProperty(name)) {
      const cache = this.uniform3fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2]
      ) {
        return;
      }
    }
    this.uniform3fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform3fv(loc, value);
  }

  setUniform3iv(name, value) {
    if (this.uniform3ivCache.hasOwnProperty(name)) {
      const cache = this.uniform3ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2]
      ) {
        return;
      }
    }
    this.uniform3ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform3iv(loc, value);
  }

  setUniform4fv(name, value) {
    if (this.uniform4fvCache.hasOwnProperty(name)) {
      const cache = this.uniform4fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2] &&
        value[3] === cache[3]
      ) {
        return;
      }
    }
    this.uniform4fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform4fv(loc, value);
  }

  setUniform4iv(name, value) {
    if (this.uniform4ivCache.hasOwnProperty(name)) {
      const cache = this.uniform4ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2] &&
        value[3] === cache[3]
      ) {
        return;
      }
    }
    this.uniform4ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform4iv(loc, value);
  }

  getUniformLocation(name) {
    if (this.programUniformLocationCache.hasOwnProperty(name)) {
      return this.programUniformLocationCache[name];
    }
    return this.programUniformLocationCache[name] = this.context.getUniformLocation(this.program, name);
  }

  _getFragShaderArtifactMap(args) {
    return {
      HEADER: this._getHeaderString(),
      LOOP_MAX: this._getLoopMaxString(),
      PLUGINS: this._getPluginsString(),
      CONSTANTS: this._getConstantsString(),
      DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),
      ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),
      DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),
      INJECTED_NATIVE: this._getInjectedNative(),
      MAIN_CONSTANTS: this._getMainConstantsString(),
      MAIN_ARGUMENTS: this._getMainArgumentsString(args),
      KERNEL: this.getKernelString(),
      MAIN_RESULT: this.getMainResultString(),
      FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
      INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
      SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
      SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),
    };
  }

  _getVertShaderArtifactMap(args) {
    return {
      FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
      INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
      SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
      SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),
    };
  }

  _getHeaderString() {
    return (
      this.subKernels !== null ?
      '#extension GL_EXT_draw_buffers : require\n' :
      ''
    );
  }

  _getLoopMaxString() {
    return (
      this.loopMaxIterations ?
      ` ${parseInt(this.loopMaxIterations)};\n` :
      ' 1000;\n'
    );
  }

  _getPluginsString() {
    if (!this.plugins) return '\n';
    return this.plugins.map(plugin => plugin.source && this.source.match(plugin.functionMatch) ? plugin.source : '').join('\n');
  }

  _getConstantsString() {
    const result = [];
    const { threadDim, texSize } = this;
    if (this.dynamicOutput) {
      result.push(
        'uniform ivec3 uOutputDim',
        'uniform ivec2 uTexSize'
      );
    } else {
      result.push(
        `ivec3 uOutputDim = ivec3(${threadDim[0]}, ${threadDim[1]}, ${threadDim[2]})`,
        `ivec2 uTexSize = ivec2(${texSize[0]}, ${texSize[1]})`
      );
    }
    return utils.linesToString(result);
  }

  _getTextureCoordinate() {
    const subKernels = this.subKernels;
    if (subKernels === null || subKernels.length < 1) {
      return 'varying vec2 vTexCoord;\n';
    } else {
      return 'out vec2 vTexCoord;\n';
    }
  }

  _getDecode32EndiannessString() {
    return (
      this.endianness === 'LE' ?
      '' :
      '  texel.rgba = texel.abgr;\n'
    );
  }

  _getEncode32EndiannessString() {
    return (
      this.endianness === 'LE' ?
      '' :
      '  texel.rgba = texel.abgr;\n'
    );
  }

  _getDivideWithIntegerCheckString() {
    return this.fixIntegerDivisionAccuracy ?
      `float divWithIntCheck(float x, float y) {
  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {
    return float(int(x) / int(y));
  }
  return x / y;
}

float integerCorrectionModulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -(number - (divisor * floor(divWithIntCheck(number, divisor))));
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return number - (divisor * floor(divWithIntCheck(number, divisor)));
}` :
      '';
  }

  _getMainArgumentsString(args) {
    const results = [];
    const { argumentNames } = this;
    for (let i = 0; i < argumentNames.length; i++) {
      results.push(this.kernelArguments[i].getSource(args[i]));
    }
    return results.join('');
  }

  _getInjectedNative() {
    return this.injectedNative || '';
  }

  _getMainConstantsString() {
    const result = [];
    const { constants } = this;
    if (constants) {
      let i = 0;
      for (const name in constants) {
        if (!this.constants.hasOwnProperty(name)) continue;
        result.push(this.kernelConstants[i++].getSource(this.constants[name]));
      }
    }
    return result.join('');
  }

  getKernelResultDeclaration() {
    switch (this.returnType) {
      case 'Array(2)':
        return 'vec2 kernelResult';
      case 'Array(3)':
        return 'vec3 kernelResult';
      case 'Array(4)':
        return 'vec4 kernelResult';
      case 'LiteralInteger':
      case 'Float':
      case 'Number':
      case 'Integer':
        return 'float kernelResult';
      default:
        if (this.graphical) {
          return 'float kernelResult';
        } else {
          throw new Error(`unrecognized output type "${ this.returnType }"`);
        }
    }
  }
  getKernelString() {
    const result = [this.getKernelResultDeclaration()];
    const { subKernels } = this;
    if (subKernels !== null) {
      switch (this.returnType) {
        case 'Number':
        case 'Float':
        case 'Integer':
          for (let i = 0; i < subKernels.length; i++) {
            const subKernel = subKernels[i];
            result.push(
              subKernel.returnType === 'Integer' ?
              `int subKernelResult_${ subKernel.name } = 0` :
              `float subKernelResult_${ subKernel.name } = 0.0`
            );
          }
          break;
        case 'Array(2)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec2 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
        case 'Array(3)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec3 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
        case 'Array(4)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec4 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
      }
    }

    return utils.linesToString(result) + this.translatedSource;
  }

  getMainResultGraphical() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragColor = actualColor',
    ]);
  }

  getMainResultPackedPixels() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return this.getMainResultKernelPackedPixels() +
          this.getMainResultSubKernelPackedPixels();
      default:
        throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
    }
  }

  getMainResultKernelPackedPixels() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  gl_FragData[0] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`
    ]);
  }

  getMainResultSubKernelPackedPixels() {
    const result = [];
    if (!this.subKernels) return '';
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`
        );
      }
    }
    return utils.linesToString(result);
  }

  getMainResultMemoryOptimizedFloats() {
    const result = [
      '  index *= 4',
    ];

    switch (this.returnType) {
      case 'Number':
      case 'Integer':
      case 'Float':
        const channels = ['r', 'g', 'b', 'a'];
        for (let i = 0; i < channels.length; i++) {
          const channel = channels[i];
          this.getMainResultKernelMemoryOptimizedFloats(result, channel);
          this.getMainResultSubKernelMemoryOptimizedFloats(result, channel);
          if (i + 1 < channels.length) {
            result.push('  index += 1');
          }
        }
        break;
      default:
        throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`);
    }

    return utils.linesToString(result);
  }

  getMainResultKernelMemoryOptimizedFloats(result, channel) {
    result.push(
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  gl_FragData[0].${channel} = kernelResult`,
    );
  }

  getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}].${channel} = float(subKernelResult_${this.subKernels[i].name})`,
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}].${channel} = subKernelResult_${this.subKernels[i].name}`,
        );
      }
    }
  }

  getMainResultKernelNumberTexture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult',
    ];
  }

  getMainResultSubKernelNumberTexture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}][0] = float(subKernelResult_${subKernel.name})`,
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}][0] = subKernelResult_${subKernel.name}`,
        );
      }
    }
    return result;
  }

  getMainResultKernelArray2Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult[0]',
      '  gl_FragData[0][1] = kernelResult[1]',
    ];
  }

  getMainResultSubKernelArray2Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
        `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
      );
    }
    return result;
  }

  getMainResultKernelArray3Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult[0]',
      '  gl_FragData[0][1] = kernelResult[1]',
      '  gl_FragData[0][2] = kernelResult[2]',
    ];
  }

  getMainResultSubKernelArray3Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
        `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
        `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,
      );
    }
    return result;
  }

  getMainResultKernelArray4Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0] = kernelResult',
    ];
  }

  getMainResultSubKernelArray4Texture() {
    const result = [];
    if (!this.subKernels) return result;
    switch (this.returnType) {
      case 'Number':
      case 'Float':
      case 'Integer':
        for (let i = 0; i < this.subKernels.length; ++i) {
          const subKernel = this.subKernels[i];
          if (subKernel.returnType === 'Integer') {
            result.push(
              `  gl_FragData[${i + 1}] = float(subKernelResult_${this.subKernels[i].name})`,
            );
          } else {
            result.push(
              `  gl_FragData[${i + 1}] = subKernelResult_${this.subKernels[i].name}`,
            );
          }
        }
        break;
      case 'Array(2)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
          );
        }
        break;
      case 'Array(3)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
            `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,
          );
        }
        break;
      case 'Array(4)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
            `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,
            `  gl_FragData[${i + 1}][3] = subKernelResult_${this.subKernels[i].name}[3]`,
          );
        }
        break;
    }

    return result;
  }

  replaceArtifacts(src, map) {
    return src.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\n/g, (match, artifact) => {
      if (map.hasOwnProperty(artifact)) {
        return map[artifact];
      }
      throw `unhandled artifact ${artifact}`;
    });
  }

  getFragmentShader(args) {
    if (this.compiledFragmentShader !== null) {
      return this.compiledFragmentShader;
    }
    return this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(args));
  }

  getVertexShader(args) {
    if (this.compiledVertexShader !== null) {
      return this.compiledVertexShader;
    }
    return this.compiledVertexShader = this.replaceArtifacts(this.constructor.vertexShader, this._getVertShaderArtifactMap(args));
  }

  toString() {
    const setupContextString = utils.linesToString([
      `const gl = context`,
    ]);
    return glKernelString(this.constructor, arguments, this, setupContextString);
  }

  destroy(removeCanvasReferences) {
    if (!this.context) return;
    if (this.buffer) {
      this.context.deleteBuffer(this.buffer);
    }
    if (this.framebuffer) {
      this.context.deleteFramebuffer(this.framebuffer);
    }
    if (this.vertShader) {
      this.context.deleteShader(this.vertShader);
    }
    if (this.fragShader) {
      this.context.deleteShader(this.fragShader);
    }
    if (this.program) {
      this.context.deleteProgram(this.program);
    }
    if (this.texture) {
      this.texture.delete();
      const textureCacheIndex = this.textureCache.indexOf(this.texture.texture);
      if (textureCacheIndex > -1) {
        this.textureCache.splice(textureCacheIndex, 1);
      }
      this.texture = null;
    }
    if (this.mappedTextures && this.mappedTextures.length) {
      for (let i = 0; i < this.mappedTextures.length; i++) {
        const mappedTexture = this.mappedTextures[i];
        mappedTexture.delete();
        const textureCacheIndex = this.textureCache.indexOf(mappedTexture.texture);
        if (textureCacheIndex > -1) {
          this.textureCache.splice(textureCacheIndex, 1);
        }
      }
      this.mappedTextures = null;
    }
    if (this.kernelArguments) {
      for (let i = 0; i < this.kernelArguments.length; i++) {
        this.kernelArguments[i].destroy();
      }
    }
    if (this.kernelConstants) {
      for (let i = 0; i < this.kernelConstants.length; i++) {
        this.kernelConstants[i].destroy();
      }
    }
    while (this.textureCache.length > 0) {
      const texture = this.textureCache.pop();
      this.context.deleteTexture(texture);
    }
    if (removeCanvasReferences) {
      const idx = canvases.indexOf(this.canvas);
      if (idx >= 0) {
        canvases[idx] = null;
        maxTexSizes[idx] = null;
      }
    }
    this.destroyExtensions();
    delete this.context;
    delete this.canvas;
    if (!this.gpu) return;
    const i = this.gpu.kernels.indexOf(this);
    if (i === -1) return;
    this.gpu.kernels.splice(i, 1);
  }

  destroyExtensions() {
    this.extensions.OES_texture_float = null;
    this.extensions.OES_texture_float_linear = null;
    this.extensions.OES_element_index_uint = null;
    this.extensions.WEBGL_draw_buffers = null;
  }

  static destroyContext(context) {
    const extension = context.getExtension('WEBGL_lose_context');
    if (extension) {
      extension.loseContext();
    }
  }

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, WebGLFunctionNode).toJSON();
    json.settings.threadDim = this.threadDim;
    return json;
  }
}

module.exports = {
  WebGLKernel
};
},{"../../plugins/math-random-uniformly-distributed":112,"../../utils":114,"../function-builder":9,"../gl/kernel":13,"../gl/kernel-string":12,"./fragment-shader":37,"./function-node":38,"./kernel-value-maps":39,"./vertex-shader":71}],71:[function(require,module,exports){
const vertexShader = `__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

attribute vec2 aPos;
attribute vec2 aTexCoord;

varying vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;

module.exports = {
  vertexShader
};
},{}],72:[function(require,module,exports){
const fragmentShader = `#version 300 es
__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;
__SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

in vec2 vTexCoord;

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float _round(float x) {
  return floor(x + 0.5);
}


const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x/y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  return texel[channel] * 255.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  index = index / 4;
  vec4 texel = texture(tex, st / vec2(texSize));
  return texel[channel];
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, st / vec2(texSize));
}

vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, vec3(st / vec2(texSize), z));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));

  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;

module.exports = {
  fragmentShader
};
},{}],73:[function(require,module,exports){
const { utils } = require('../../utils');
const { WebGLFunctionNode } = require('../web-gl/function-node');

class WebGL2FunctionNode extends WebGLFunctionNode {

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput(
        'IdentifierExpression - not an Identifier',
        idtNode
      );
    }

    const type = this.getType(idtNode);

    const name = utils.sanitizeName(idtNode.name);
    if (idtNode.name === 'Infinity') {
      retArr.push('intBitsToFloat(2139095039)');
    } else if (type === 'Boolean') {
      if (this.argumentNames.indexOf(name) > -1) {
        retArr.push(`bool(user_${name})`);
      } else {
        retArr.push(`user_${name}`);
      }
    } else {
      retArr.push(`user_${name}`);
    }

    return retArr;
  }
}

module.exports = {
  WebGL2FunctionNode
};
},{"../../utils":114,"../web-gl/function-node":38}],74:[function(require,module,exports){
const { WebGL2KernelValueBoolean } = require('./kernel-value/boolean');
const { WebGL2KernelValueFloat } = require('./kernel-value/float');
const { WebGL2KernelValueInteger } = require('./kernel-value/integer');

const { WebGL2KernelValueHTMLImage } = require('./kernel-value/html-image');
const { WebGL2KernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');

const { WebGL2KernelValueHTMLImageArray } = require('./kernel-value/html-image-array');
const { WebGL2KernelValueDynamicHTMLImageArray } = require('./kernel-value/dynamic-html-image-array');

const { WebGL2KernelValueHTMLVideo } = require('./kernel-value/html-video');
const { WebGL2KernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');

const { WebGL2KernelValueSingleInput } = require('./kernel-value/single-input');
const { WebGL2KernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');

const { WebGL2KernelValueUnsignedInput } = require('./kernel-value/unsigned-input');
const { WebGL2KernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');

const { WebGL2KernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');
const { WebGL2KernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');

const { WebGL2KernelValueNumberTexture } = require('./kernel-value/number-texture');
const { WebGL2KernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');

const { WebGL2KernelValueSingleArray } = require('./kernel-value/single-array');
const { WebGL2KernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');

const { WebGL2KernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');
const { WebGL2KernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');

const { WebGL2KernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');
const { WebGL2KernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');

const { WebGL2KernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');
const { WebGL2KernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');

const { WebGL2KernelValueSingleArray2 } = require('./kernel-value/single-array2');
const { WebGL2KernelValueSingleArray3 } = require('./kernel-value/single-array3');
const { WebGL2KernelValueSingleArray4 } = require('./kernel-value/single-array4');

const { WebGL2KernelValueUnsignedArray } = require('./kernel-value/unsigned-array');
const { WebGL2KernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');

const kernelValueMaps = {
  unsigned: {
    dynamic: {
      'Boolean': WebGL2KernelValueBoolean,
      'Integer': WebGL2KernelValueInteger,
      'Float': WebGL2KernelValueFloat,
      'Array': WebGL2KernelValueDynamicUnsignedArray,
      'Array(2)': false,
      'Array(3)': false,
      'Array(4)': false,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGL2KernelValueDynamicUnsignedInput,
      'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGL2KernelValueBoolean,
      'Float': WebGL2KernelValueFloat,
      'Integer': WebGL2KernelValueInteger,
      'Array': WebGL2KernelValueUnsignedArray,
      'Array(2)': false,
      'Array(3)': false,
      'Array(4)': false,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGL2KernelValueUnsignedInput,
      'NumberTexture': WebGL2KernelValueNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueHTMLImage,
      'HTMLImage': WebGL2KernelValueHTMLImage,
      'HTMLImageArray': WebGL2KernelValueHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueHTMLVideo,
    }
  },
  single: {
    dynamic: {
      'Boolean': WebGL2KernelValueBoolean,
      'Integer': WebGL2KernelValueInteger,
      'Float': WebGL2KernelValueFloat,
      'Array': WebGL2KernelValueDynamicSingleArray,
      'Array(2)': WebGL2KernelValueSingleArray2,
      'Array(3)': WebGL2KernelValueSingleArray3,
      'Array(4)': WebGL2KernelValueSingleArray4,
      'Array1D(2)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array1D(3)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array1D(4)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array2D(2)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array2D(3)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array2D(4)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array3D(2)': WebGL2KernelValueDynamicSingleArray3DI,
      'Array3D(3)': WebGL2KernelValueDynamicSingleArray3DI,
      'Array3D(4)': WebGL2KernelValueDynamicSingleArray3DI,
      'Input': WebGL2KernelValueDynamicSingleInput,
      'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGL2KernelValueBoolean,
      'Float': WebGL2KernelValueFloat,
      'Integer': WebGL2KernelValueInteger,
      'Array': WebGL2KernelValueSingleArray,
      'Array(2)': WebGL2KernelValueSingleArray2,
      'Array(3)': WebGL2KernelValueSingleArray3,
      'Array(4)': WebGL2KernelValueSingleArray4,
      'Array1D(2)': WebGL2KernelValueSingleArray1DI,
      'Array1D(3)': WebGL2KernelValueSingleArray1DI,
      'Array1D(4)': WebGL2KernelValueSingleArray1DI,
      'Array2D(2)': WebGL2KernelValueSingleArray2DI,
      'Array2D(3)': WebGL2KernelValueSingleArray2DI,
      'Array2D(4)': WebGL2KernelValueSingleArray2DI,
      'Array3D(2)': WebGL2KernelValueSingleArray3DI,
      'Array3D(3)': WebGL2KernelValueSingleArray3DI,
      'Array3D(4)': WebGL2KernelValueSingleArray3DI,
      'Input': WebGL2KernelValueSingleInput,
      'NumberTexture': WebGL2KernelValueNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueHTMLImage,
      'HTMLImage': WebGL2KernelValueHTMLImage,
      'HTMLImageArray': WebGL2KernelValueHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueHTMLVideo,
    }
  },
};

function lookupKernelValueType(type, dynamic, precision, value) {
  if (!type) {
    throw new Error('type missing');
  }
  if (!dynamic) {
    throw new Error('dynamic missing');
  }
  if (!precision) {
    throw new Error('precision missing');
  }
  if (value.type) {
    type = value.type;
  }
  const types = kernelValueMaps[precision][dynamic];
  if (types[type] === false) {
    return null;
  } else if (types[type] === undefined) {
    throw new Error(`Could not find a KernelValue for ${ type }`);
  }
  return types[type];
}

module.exports = {
  kernelValueMaps,
  lookupKernelValueType
};
},{"./kernel-value/boolean":75,"./kernel-value/dynamic-html-image":77,"./kernel-value/dynamic-html-image-array":76,"./kernel-value/dynamic-html-video":78,"./kernel-value/dynamic-memory-optimized-number-texture":79,"./kernel-value/dynamic-number-texture":80,"./kernel-value/dynamic-single-array":81,"./kernel-value/dynamic-single-array1d-i":82,"./kernel-value/dynamic-single-array2d-i":83,"./kernel-value/dynamic-single-array3d-i":84,"./kernel-value/dynamic-single-input":85,"./kernel-value/dynamic-unsigned-array":86,"./kernel-value/dynamic-unsigned-input":87,"./kernel-value/float":88,"./kernel-value/html-image":90,"./kernel-value/html-image-array":89,"./kernel-value/html-video":91,"./kernel-value/integer":92,"./kernel-value/memory-optimized-number-texture":93,"./kernel-value/number-texture":94,"./kernel-value/single-array":95,"./kernel-value/single-array1d-i":96,"./kernel-value/single-array2":97,"./kernel-value/single-array2d-i":98,"./kernel-value/single-array3":99,"./kernel-value/single-array3d-i":100,"./kernel-value/single-array4":101,"./kernel-value/single-input":102,"./kernel-value/unsigned-array":103,"./kernel-value/unsigned-input":104}],75:[function(require,module,exports){
const { WebGLKernelValueBoolean } = require('../../web-gl/kernel-value/boolean');

class WebGL2KernelValueBoolean extends WebGLKernelValueBoolean {}

module.exports = {
  WebGL2KernelValueBoolean
};
},{"../../web-gl/kernel-value/boolean":41}],76:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueHTMLImageArray } = require('./html-image-array');

class WebGL2KernelValueDynamicHTMLImageArray extends WebGL2KernelValueHTMLImageArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2DArray ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(images) {
    const { width, height } = images[0];
    this.checkSize(width, height);
    this.dimensions = [width, height, images.length];
    this.textureSize = [width, height];
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(images);
  }
}

module.exports = {
  WebGL2KernelValueDynamicHTMLImageArray
};
},{"../../../utils":114,"./html-image-array":89}],77:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicHTMLImage } = require('../../web-gl/kernel-value/dynamic-html-image');

class WebGL2KernelValueDynamicHTMLImage extends WebGLKernelValueDynamicHTMLImage {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicHTMLImage
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-html-image":42}],78:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueDynamicHTMLImage } = require('./dynamic-html-image');

class WebGL2KernelValueDynamicHTMLVideo extends WebGL2KernelValueDynamicHTMLImage {}

module.exports = {
  WebGL2KernelValueDynamicHTMLVideo
};
},{"../../../utils":114,"./dynamic-html-image":77}],79:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/dynamic-memory-optimized-number-texture');

class WebGL2KernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueDynamicMemoryOptimizedNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture":44}],80:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicNumberTexture } = require('../../web-gl/kernel-value/dynamic-number-texture');

class WebGL2KernelValueDynamicNumberTexture extends WebGLKernelValueDynamicNumberTexture {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-number-texture":45}],81:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray } = require('../../web-gl2/kernel-value/single-array');

class WebGL2KernelValueDynamicSingleArray extends WebGL2KernelValueSingleArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array":95}],82:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray1DI } = require('../../web-gl2/kernel-value/single-array1d-i');

class WebGL2KernelValueDynamicSingleArray1DI extends WebGL2KernelValueSingleArray1DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray1DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array1d-i":96}],83:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray2DI } = require('../../web-gl2/kernel-value/single-array2d-i');

class WebGL2KernelValueDynamicSingleArray2DI extends WebGL2KernelValueSingleArray2DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray2DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array2d-i":98}],84:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray3DI } = require('../../web-gl2/kernel-value/single-array3d-i');

class WebGL2KernelValueDynamicSingleArray3DI extends WebGL2KernelValueSingleArray3DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray3DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array3d-i":100}],85:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleInput } = require('../../web-gl2/kernel-value/single-input');

class WebGL2KernelValueDynamicSingleInput extends WebGL2KernelValueSingleInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleInput
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-input":102}],86:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicUnsignedArray } = require('../../web-gl/kernel-value/dynamic-unsigned-array');

class WebGL2KernelValueDynamicUnsignedArray extends WebGLKernelValueDynamicUnsignedArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicUnsignedArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-array":51}],87:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicUnsignedInput } = require('../../web-gl/kernel-value/dynamic-unsigned-input');

class WebGL2KernelValueDynamicUnsignedInput extends WebGLKernelValueDynamicUnsignedInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicUnsignedInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-input":52}],88:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueFloat } = require('../../web-gl/kernel-value/float');

class WebGL2KernelValueFloat extends WebGLKernelValueFloat {}

module.exports = {
  WebGL2KernelValueFloat
};
},{"../../../utils":114,"../../web-gl/kernel-value/float":53}],89:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('../../web-gl/kernel-value/array');

class WebGL2KernelValueHTMLImageArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.checkSize(value[0].width, value[0].height);
    this.dimensions = [value[0].width, value[0].height, value.length];
    this.textureSize = [value[0].width, value[0].height];
  }
  defineTexture() {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2DArray ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(images) {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage3D(
      gl.TEXTURE_2D_ARRAY,
      0,
      gl.RGBA,
      images[0].width,
      images[0].height,
      images.length,
      0,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      null
    );
    for (let i = 0; i < images.length; i++) {
      const xOffset = 0;
      const yOffset = 0;
      const imageDepth = 1;
      gl.texSubImage3D(
        gl.TEXTURE_2D_ARRAY,
        0,
        xOffset,
        yOffset,
        i,
        images[i].width,
        images[i].height,
        imageDepth,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        this.uploadValue = images[i]
      );
    }
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueHTMLImageArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/array":40}],90:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueHTMLImage } = require('../../web-gl/kernel-value/html-image');

class WebGL2KernelValueHTMLImage extends WebGLKernelValueHTMLImage {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueHTMLImage
};
},{"../../../utils":114,"../../web-gl/kernel-value/html-image":54}],91:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueHTMLImage } = require('./html-image');

class WebGL2KernelValueHTMLVideo extends WebGL2KernelValueHTMLImage {}

module.exports = {
  WebGL2KernelValueHTMLVideo
};
},{"../../../utils":114,"./html-image":90}],92:[function(require,module,exports){
const { WebGLKernelValueInteger } = require('../../web-gl/kernel-value/integer');

class WebGL2KernelValueInteger extends WebGLKernelValueInteger {
  getSource(value) {
    const variablePrecision = this.getVariablePrecisionString();
    if (this.origin === 'constants') {
      return `const ${ variablePrecision } int ${this.id} = ${ parseInt(value) };\n`;
    }
    return `uniform ${ variablePrecision } int ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGL2KernelValueInteger
};
},{"../../web-gl/kernel-value/integer":57}],93:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/memory-optimized-number-texture');

class WebGL2KernelValueMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {
  getSource() {
    const { id, sizeId, textureSize, dimensionsId, dimensions } = this;
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform sampler2D ${id}`,
      `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,
      `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/memory-optimized-number-texture":58}],94:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueNumberTexture } = require('../../web-gl/kernel-value/number-texture');

class WebGL2KernelValueNumberTexture extends WebGLKernelValueNumberTexture {
  getSource() {
    const { id, sizeId, textureSize, dimensionsId, dimensions } = this;
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${id}`,
      `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,
      `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/number-texture":59}],95:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray } = require('../../web-gl/kernel-value/single-array');

class WebGL2KernelValueSingleArray extends WebGLKernelValueSingleArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array":60}],96:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray1DI } = require('../../web-gl/kernel-value/single-array1d-i');

class WebGL2KernelValueSingleArray1DI extends WebGLKernelValueSingleArray1DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray1DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array1d-i":61}],97:[function(require,module,exports){
const { WebGLKernelValueSingleArray2 } = require('../../web-gl/kernel-value/single-array2');

class WebGL2KernelValueSingleArray2 extends WebGLKernelValueSingleArray2 {}

module.exports = {
  WebGL2KernelValueSingleArray2
};
},{"../../web-gl/kernel-value/single-array2":62}],98:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray2DI } = require('../../web-gl/kernel-value/single-array2d-i');

class WebGL2KernelValueSingleArray2DI extends WebGLKernelValueSingleArray2DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray2DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array2d-i":63}],99:[function(require,module,exports){
const { WebGLKernelValueSingleArray3 } = require('../../web-gl/kernel-value/single-array3');

class WebGL2KernelValueSingleArray3 extends WebGLKernelValueSingleArray3 {}

module.exports = {
  WebGL2KernelValueSingleArray3
};
},{"../../web-gl/kernel-value/single-array3":64}],100:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray3DI } = require('../../web-gl/kernel-value/single-array3d-i');

class WebGL2KernelValueSingleArray3DI extends WebGLKernelValueSingleArray3DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray3DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array3d-i":65}],101:[function(require,module,exports){
const { WebGLKernelValueSingleArray4 } = require('../../web-gl/kernel-value/single-array4');

class WebGL2KernelValueSingleArray4 extends WebGLKernelValueSingleArray4 {}

module.exports = {
  WebGL2KernelValueSingleArray4
};
},{"../../web-gl/kernel-value/single-array4":66}],102:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleInput } = require('../../web-gl/kernel-value/single-input');

class WebGL2KernelValueSingleInput extends WebGLKernelValueSingleInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    const { context: gl } = this;
    utils.flattenTo(input.value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-input":67}],103:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedArray } = require('../../web-gl/kernel-value/unsigned-array');

class WebGL2KernelValueUnsignedArray extends WebGLKernelValueUnsignedArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueUnsignedArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-array":68}],104:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedInput } = require('../../web-gl/kernel-value/unsigned-input');

class WebGL2KernelValueUnsignedInput extends WebGLKernelValueUnsignedInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueUnsignedInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-input":69}],105:[function(require,module,exports){
const { WebGLKernel } = require('../web-gl/kernel');
const { WebGL2FunctionNode } = require('./function-node');
const { FunctionBuilder } = require('../function-builder');
const { utils } = require('../../utils');
const { fragmentShader } = require('./fragment-shader');
const { vertexShader } = require('./vertex-shader');
const { lookupKernelValueType } = require('./kernel-value-maps');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;

let features = null;

class WebGL2Kernel extends WebGLKernel {
  static get isSupported() {
    if (isSupported !== null) {
      return isSupported;
    }
    this.setupFeatureChecks();
    isSupported = this.isContextMatch(testContext);
    return isSupported;
  }

  static setupFeatureChecks() {
    if (typeof document !== 'undefined') {
      testCanvas = document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      testCanvas = new OffscreenCanvas(0, 0);
    }
    if (!testCanvas) return;
    testContext = testCanvas.getContext('webgl2');
    if (!testContext || !testContext.getExtension) return;
    testExtensions = {
      EXT_color_buffer_float: testContext.getExtension('EXT_color_buffer_float'),
      OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
    };
    features = this.getFeatures();
  }

  static isContextMatch(context) {
    if (typeof WebGL2RenderingContext !== 'undefined') {
      return context instanceof WebGL2RenderingContext;
    }
    return false;
  }

  static getFeatures() {
    const gl = this.testContext;
    return Object.freeze({
      isFloatRead: this.getIsFloatRead(),
      isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
      isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
      kernelMap: true,
      isTextureFloat: true,
      isDrawBuffers: true,
      channelCount: this.getChannelCount(),
      maxTextureSize: this.getMaxTextureSize(),
      lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),
      lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),
      mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),
      mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),
      highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),
      highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
    });
  }

  static getIsTextureFloat() {
    return true;
  }

  static getChannelCount() {
    return testContext.getParameter(testContext.MAX_DRAW_BUFFERS);
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static lookupKernelValueType(type, dynamic, precision, value) {
    return lookupKernelValueType(type, dynamic, precision, value);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  static get fragmentShader() {
    return fragmentShader;
  }
  static get vertexShader() {
    return vertexShader;
  }

  initContext() {
    const settings = {
      alpha: false,
      depth: false,
      antialias: false
    };
    return this.canvas.getContext('webgl2', settings);
  }

  initExtensions() {
    this.extensions = {
      EXT_color_buffer_float: this.context.getExtension('EXT_color_buffer_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
    };
  }

  validateSettings(args) {
    if (!this.validate) {
      this.texSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, this.output);
      return;
    }

    const { features } = this.constructor;
    if (this.precision === 'single' && !features.isFloatRead) {
      throw new Error('Float texture outputs are not supported');
    } else if (!this.graphical && this.precision === null) {
      this.precision = features.isFloatRead ? 'single' : 'unsigned';
    }

    if (this.fixIntegerDivisionAccuracy === null) {
      this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
    } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
      this.fixIntegerDivisionAccuracy = false;
    }

    this.checkOutput();

    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      switch (argType) {
        case 'Array':
          this.output = utils.getDimensions(argType);
          break;
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
          this.output = args[0].output;
          break;
        default:
          throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }

      if (this.precision === 'single') {
        console.warn('Cannot use graphical mode and single precision at the same time');
        this.precision = 'unsigned';
      }

      this.texSize = utils.clone(this.output);
      return;
    } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
      this.precision = 'single';
    }

    this.texSize = utils.getKernelTextureSize({
      optimizeFloatMemory: this.optimizeFloatMemory,
      precision: this.precision,
    }, this.output);

    this.checkTextureSize();
  }

  translateSource() {
    const functionBuilder = FunctionBuilder.fromKernel(this, WebGL2FunctionNode, {
      fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
    });
    this.translatedSource = functionBuilder.getPrototypeString('kernel');
    this.setupReturnTypes(functionBuilder);
  }

  drawBuffers() {
    this.context.drawBuffers(this.drawBuffersMap);
  }

  getTextureFormat() {
    const { context: gl } = this;
    switch (this.getInternalFormat()) {
      case gl.R32F:
        return gl.RED;
      case gl.RG32F:
        return gl.RG;
      case gl.RGBA32F:
        return gl.RGBA;
      case gl.RGBA:
        return gl.RGBA;
      default:
        throw new Error('Unknown internal format');
    }
  }
  getInternalFormat() {
    const { context: gl } = this;

    if (this.precision === 'single') {
      if (this.pipeline) {
        switch (this.returnType) {
          case 'Number':
          case 'Float':
          case 'Integer':
            if (this.optimizeFloatMemory) {
              return gl.RGBA32F;
            } else {
              return gl.R32F;
            }
            case 'Array(2)':
              return gl.RG32F;
            case 'Array(3)': 
            case 'Array(4)':
              return gl.RGBA32F;
            default:
              throw new Error('Unhandled return type');
        }
      }
      return gl.RGBA32F;
    }
    return gl.RGBA;
  }

  _setupOutputTexture() {
    const gl = this.context;
    if (this.texture) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      return;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    const texture = gl.createTexture();
    const texSize = this.texSize;
    gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    const format = this.getInternalFormat();
    if (this.precision === 'single') {
      gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    this.texture = new this.TextureConstructor({
      texture,
      size: texSize,
      dimensions: this.threadDim,
      output: this.output,
      context: this.context,
      internalFormat: this.getInternalFormat(),
      textureFormat: this.getTextureFormat(),
      kernel: this,
    });
  }

  _setupSubOutputTextures() {
    const gl = this.context;
    if (this.mappedTextures) {
      for (let i = 0; i < this.subKernels.length; i++) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);
      }
      return;
    }
    const texSize = this.texSize;
    this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
    this.mappedTextures = [];
    for (let i = 0; i < this.subKernels.length; i++) {
      const texture = this.createTexture();
      this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
      gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      const format = this.getInternalFormat();
      if (this.precision === 'single') {
        gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);

      this.mappedTextures.push(new this.TextureConstructor({
        texture,
        size: texSize,
        dimensions: this.threadDim,
        output: this.output,
        context: this.context,
        internalFormat: this.getInternalFormat(),
        textureFormat: this.getTextureFormat(),
        kernel: this,
      }));
    }
  }

  _getHeaderString() {
    return '';
  }

  _getTextureCoordinate() {
    const subKernels = this.subKernels;
    const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);
    if (subKernels === null || subKernels.length < 1) {
      return `in ${ variablePrecision } vec2 vTexCoord;\n`;
    } else {
      return `out ${ variablePrecision } vec2 vTexCoord;\n`;
    }
  }

  _getMainArgumentsString(args) {
    const result = [];
    const argumentNames = this.argumentNames;
    for (let i = 0; i < argumentNames.length; i++) {
      result.push(this.kernelArguments[i].getSource(args[i]));
    }
    return result.join('');
  }

  getKernelString() {
    const result = [this.getKernelResultDeclaration()];
    const subKernels = this.subKernels;
    if (subKernels !== null) {
      result.push(
        'layout(location = 0) out vec4 data0'
      );
      switch (this.returnType) {
        case 'Number':
        case 'Float':
        case 'Integer':
          for (let i = 0; i < subKernels.length; i++) {
            const subKernel = subKernels[i];
            result.push(
              subKernel.returnType === 'Integer' ?
              `int subKernelResult_${ subKernel.name } = 0` :
              `float subKernelResult_${ subKernel.name } = 0.0`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(2)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec2 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(3)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec3 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(4)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec4 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
      }
    } else {
      result.push(
        'out vec4 data0'
      );
    }

    return utils.linesToString(result) + this.translatedSource;
  }

  getMainResultGraphical() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0 = actualColor',
    ]);
  }

  getMainResultPackedPixels() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return this.getMainResultKernelPackedPixels() +
          this.getMainResultSubKernelPackedPixels();
      default:
        throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
    }
  }

  getMainResultKernelPackedPixels() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  data0 = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`
    ]);
  }

  getMainResultSubKernelPackedPixels() {
    const result = [];
    if (!this.subKernels) return '';
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`
        );
      } else {
        result.push(
          `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`
        );
      }
    }
    return utils.linesToString(result);
  }

  getMainResultKernelMemoryOptimizedFloats(result, channel) {
    result.push(
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  data0.${channel} = kernelResult`,
    );
  }

  getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1}.${channel} = float(subKernelResult_${subKernel.name})`,
        );
      } else {
        result.push(
          `  data${i + 1}.${channel} = subKernelResult_${subKernel.name}`,
        );
      }
    }
  }

  getMainResultKernelNumberTexture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult',
    ];
  }

  getMainResultSubKernelNumberTexture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1}[0] = float(subKernelResult_${subKernel.name})`,
        );
      } else {
        result.push(
          `  data${i + 1}[0] = subKernelResult_${subKernel.name}`,
        );
      }
    }
    return result;
  }

  getMainResultKernelArray2Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult[0]',
      '  data0[1] = kernelResult[1]',
    ];
  }

  getMainResultSubKernelArray2Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      result.push(
        `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,
        `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`,
      );
    }
    return result;
  }

  getMainResultKernelArray3Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult[0]',
      '  data0[1] = kernelResult[1]',
      '  data0[2] = kernelResult[2]',
    ];
  }

  getMainResultSubKernelArray3Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      result.push(
        `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,
        `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`,
        `  data${i + 1}[2] = subKernelResult_${subKernel.name}[2]`,
      );
    }
    return result;
  }

  getMainResultKernelArray4Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0 = kernelResult',
    ];
  }

  getMainResultSubKernelArray4Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  data${i + 1} = subKernelResult_${this.subKernels[i].name}`,
      );
    }
    return result;
  }

  destroyExtensions() {
    this.extensions.EXT_color_buffer_float = null;
    this.extensions.OES_texture_float_linear = null;
  }

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, WebGL2FunctionNode).toJSON();
    json.settings.threadDim = this.threadDim;
    return json;
  }
}

module.exports = {
  WebGL2Kernel
};
},{"../../utils":114,"../function-builder":9,"../web-gl/kernel":70,"./fragment-shader":72,"./function-node":73,"./kernel-value-maps":74,"./vertex-shader":106}],106:[function(require,module,exports){
const vertexShader = `#version 300 es
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

in vec2 aPos;
in vec2 aTexCoord;

out vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;

module.exports = {
  vertexShader
};
},{}],107:[function(require,module,exports){
const lib = require('./index');
const GPU = lib.GPU;
for (const p in lib) {
  if (!lib.hasOwnProperty(p)) continue;
  if (p === 'GPU') continue; 
  GPU[p] = lib[p];
}

if (typeof window !== 'undefined') {
  bindTo(window);
}
if (typeof self !== 'undefined') {
  bindTo(self);
}

function bindTo(target) {
  if (target.GPU) return;
  Object.defineProperty(target, 'GPU', {
    get() {
      return GPU;
    }
  });
}

module.exports = lib;
},{"./index":109}],108:[function(require,module,exports){
const { gpuMock } = require('gpu-mock.js');
const { utils } = require('./utils');
const { Kernel } = require('./backend/kernel');
const { CPUKernel } = require('./backend/cpu/kernel');
const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');
const { WebGL2Kernel } = require('./backend/web-gl2/kernel');
const { WebGLKernel } = require('./backend/web-gl/kernel');
const { kernelRunShortcut } = require('./kernel-run-shortcut');


const kernelOrder = [HeadlessGLKernel, WebGL2Kernel, WebGLKernel];

const kernelTypes = ['gpu', 'cpu'];

const internalKernels = {
  'headlessgl': HeadlessGLKernel,
  'webgl2': WebGL2Kernel,
  'webgl': WebGLKernel,
};

let validate = true;

class GPU {
  static disableValidation() {
    validate = false;
  }

  static enableValidation() {
    validate = true;
  }

  static get isGPUSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported);
  }

  static get isKernelMapSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.kernelMap);
  }

  static get isOffscreenCanvasSupported() {
    return (typeof Worker !== 'undefined' && typeof OffscreenCanvas !== 'undefined') || typeof importScripts !== 'undefined';
  }

  static get isWebGLSupported() {
    return WebGLKernel.isSupported;
  }

  static get isWebGL2Supported() {
    return WebGL2Kernel.isSupported;
  }

  static get isHeadlessGLSupported() {
    return HeadlessGLKernel.isSupported;
  }

  static get isCanvasSupported() {
    return typeof HTMLCanvasElement !== 'undefined';
  }

  static get isGPUHTMLImageArraySupported() {
    return WebGL2Kernel.isSupported;
  }

  static get isSinglePrecisionSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.isFloatRead && Kernel.features.isTextureFloat);
  }

  constructor(settings) {
    settings = settings || {};
    this.canvas = settings.canvas || null;
    this.context = settings.context || null;
    this.mode = settings.mode;
    this.Kernel = null;
    this.kernels = [];
    this.functions = [];
    this.nativeFunctions = [];
    this.injectedNative = null;
    this.onIstanbulCoverageVariable = settings.onIstanbulCoverageVariable || null;
    this.removeIstanbulCoverage = settings.hasOwnProperty('removeIstanbulCoverage') ? settings.removeIstanbulCoverage : null;
    if (this.mode === 'dev') return;
    this.chooseKernel();
    if (settings.functions) {
      for (let i = 0; i < settings.functions.length; i++) {
        this.addFunction(settings.functions[i]);
      }
    }

    if (settings.nativeFunctions) {
      for (const p in settings.nativeFunctions) {
        if (!settings.nativeFunctions.hasOwnProperty(p)) continue;
        const s = settings.nativeFunctions[p];
        const { name, source } = s;
        this.addNativeFunction(name, source, s);
      }
    }
  }

  chooseKernel() {
    if (this.Kernel) return;

    let Kernel = null;

    if (this.context) {
      for (let i = 0; i < kernelOrder.length; i++) {
        const ExternalKernel = kernelOrder[i];
        if (ExternalKernel.isContextMatch(this.context)) {
          if (!ExternalKernel.isSupported) {
            throw new Error(`Kernel type ${ExternalKernel.name} not supported`);
          }
          Kernel = ExternalKernel;
          break;
        }
      }
      if (Kernel === null) {
        throw new Error('unknown Context');
      }
    } else if (this.mode) {
      if (this.mode in internalKernels) {
        if (!validate || internalKernels[this.mode].isSupported) {
          Kernel = internalKernels[this.mode];
        }
      } else if (this.mode === 'gpu') {
        for (let i = 0; i < kernelOrder.length; i++) {
          if (kernelOrder[i].isSupported) {
            Kernel = kernelOrder[i];
            break;
          }
        }
      } else if (this.mode === 'cpu') {
        Kernel = CPUKernel;
      }
      if (!Kernel) {
        throw new Error(`A requested mode of "${this.mode}" and is not supported`);
      }
    } else {
      for (let i = 0; i < kernelOrder.length; i++) {
        if (kernelOrder[i].isSupported) {
          Kernel = kernelOrder[i];
          break;
        }
      }
      if (!Kernel) {
        Kernel = CPUKernel;
      }
    }

    if (!this.mode) {
      this.mode = Kernel.mode;
    }
    this.Kernel = Kernel;
  }

  createKernel(source, settings) {
    if (typeof source === 'undefined') {
      throw new Error('Missing source parameter');
    }
    if (typeof source !== 'object' && !utils.isFunction(source) && typeof source !== 'string') {
      throw new Error('source parameter not a function');
    }

    const kernels = this.kernels;
    if (this.mode === 'dev') {
      const devKernel = gpuMock(source, upgradeDeprecatedCreateKernelSettings(settings));
      kernels.push(devKernel);
      return devKernel;
    }

    source = typeof source === 'function' ? source.toString() : source;
    const switchableKernels = {};
    const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings) || {};
    if (settings && typeof settings.argumentTypes === 'object') {
      settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);
    }

    function onRequestFallback(args) {
      console.warn('Falling back to CPU');
      const fallbackKernel = new CPUKernel(source, {
        argumentTypes: kernelRun.argumentTypes,
        constantTypes: kernelRun.constantTypes,
        graphical: kernelRun.graphical,
        loopMaxIterations: kernelRun.loopMaxIterations,
        constants: kernelRun.constants,
        dynamicOutput: kernelRun.dynamicOutput,
        dynamicArgument: kernelRun.dynamicArguments,
        output: kernelRun.output,
        precision: kernelRun.precision,
        pipeline: kernelRun.pipeline,
        immutable: kernelRun.immutable,
        optimizeFloatMemory: kernelRun.optimizeFloatMemory,
        fixIntegerDivisionAccuracy: kernelRun.fixIntegerDivisionAccuracy,
        functions: kernelRun.functions,
        nativeFunctions: kernelRun.nativeFunctions,
        injectedNative: kernelRun.injectedNative,
        subKernels: kernelRun.subKernels,
        strictIntegers: kernelRun.strictIntegers,
        debug: kernelRun.debug,
      });
      fallbackKernel.build.apply(fallbackKernel, args);
      const result = fallbackKernel.run.apply(fallbackKernel, args);
      kernelRun.replaceKernel(fallbackKernel);
      return result;
    }

    function onRequestSwitchKernel(reasons, args, _kernel) {
      if (_kernel.debug) {
        console.warn('Switching kernels');
      }
      let newOutput = null;
      if (_kernel.signature && !switchableKernels[_kernel.signature]) {
        switchableKernels[_kernel.signature] = _kernel;
      }
      if (_kernel.dynamicOutput) {
        for (let i = reasons.length - 1; i >= 0; i--) {
          const reason = reasons[i];
          if (reason.type === 'outputPrecisionMismatch') {
            newOutput = reason.needed;
          }
        }
      }

      const Constructor = _kernel.constructor;
      const argumentTypes = Constructor.getArgumentTypes(_kernel, args);
      const signature = Constructor.getSignature(_kernel, argumentTypes);
      const existingKernel = switchableKernels[signature];
      if (existingKernel) {
        existingKernel.onActivate(_kernel);
        return existingKernel;
      }

      const newKernel = switchableKernels[signature] = new Constructor(source, {
        argumentTypes,
        constantTypes: _kernel.constantTypes,
        graphical: _kernel.graphical,
        loopMaxIterations: _kernel.loopMaxIterations,
        constants: _kernel.constants,
        dynamicOutput: _kernel.dynamicOutput,
        dynamicArgument: _kernel.dynamicArguments,
        context: _kernel.context,
        canvas: _kernel.canvas,
        output: newOutput || _kernel.output,
        precision: _kernel.precision,
        pipeline: _kernel.pipeline,
        immutable: _kernel.immutable,
        optimizeFloatMemory: _kernel.optimizeFloatMemory,
        fixIntegerDivisionAccuracy: _kernel.fixIntegerDivisionAccuracy,
        functions: _kernel.functions,
        nativeFunctions: _kernel.nativeFunctions,
        injectedNative: _kernel.injectedNative,
        subKernels: _kernel.subKernels,
        strictIntegers: _kernel.strictIntegers,
        debug: _kernel.debug,
        gpu: _kernel.gpu,
        validate,
        returnType: _kernel.returnType,
        onIstanbulCoverageVariable: _kernel.onIstanbulCoverageVariable,
        removeIstanbulCoverage: _kernel.removeIstanbulCoverage,
        tactic: _kernel.tactic,
        onRequestFallback,
        onRequestSwitchKernel,
        texture: _kernel.texture,
        mappedTextures: _kernel.mappedTextures,
        drawBuffersMap: _kernel.drawBuffersMap,
      });
      newKernel.build.apply(newKernel, args);
      kernelRun.replaceKernel(newKernel);
      kernels.push(newKernel);
      return newKernel;
    }
    const mergedSettings = Object.assign({
      context: this.context,
      canvas: this.canvas,
      functions: this.functions,
      nativeFunctions: this.nativeFunctions,
      injectedNative: this.injectedNative,
      onIstanbulCoverageVariable: this.onIstanbulCoverageVariable,
      removeIstanbulCoverage: this.removeIstanbulCoverage,
      gpu: this,
      validate,
      onRequestFallback,
      onRequestSwitchKernel
    }, settingsCopy);

    const kernel = new this.Kernel(source, mergedSettings);
    const kernelRun = kernelRunShortcut(kernel);

    if (!this.canvas) {
      this.canvas = kernel.canvas;
    }

    if (!this.context) {
      this.context = kernel.context;
    }

    kernels.push(kernel);

    return kernelRun;
  }

  createKernelMap() {
    let fn;
    let settings;
    const argument2Type = typeof arguments[arguments.length - 2];
    if (argument2Type === 'function' || argument2Type === 'string') {
      fn = arguments[arguments.length - 2];
      settings = arguments[arguments.length - 1];
    } else {
      fn = arguments[arguments.length - 1];
    }

    if (this.mode !== 'dev') {
      if (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) {
        if (this.mode && kernelTypes.indexOf(this.mode) < 0) {
          throw new Error(`kernelMap not supported on ${this.Kernel.name}`);
        }
      }
    }

    const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings);
    if (settings && typeof settings.argumentTypes === 'object') {
      settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);
    }

    if (Array.isArray(arguments[0])) {
      settingsCopy.subKernels = [];
      const functions = arguments[0];
      for (let i = 0; i < functions.length; i++) {
        const source = functions[i].toString();
        const name = utils.getFunctionNameFromString(source);
        settingsCopy.subKernels.push({
          name,
          source,
          property: i,
        });
      }
    } else {
      settingsCopy.subKernels = [];
      const functions = arguments[0];
      for (let p in functions) {
        if (!functions.hasOwnProperty(p)) continue;
        const source = functions[p].toString();
        const name = utils.getFunctionNameFromString(source);
        settingsCopy.subKernels.push({
          name: name || p,
          source,
          property: p,
        });
      }
    }
    return this.createKernel(fn, settingsCopy);
  }

  combineKernels() {
    const firstKernel = arguments[0];
    const combinedKernel = arguments[arguments.length - 1];
    if (firstKernel.kernel.constructor.mode === 'cpu') return combinedKernel;
    const canvas = arguments[0].canvas;
    const context = arguments[0].context;
    const max = arguments.length - 1;
    for (let i = 0; i < max; i++) {
      arguments[i]
        .setCanvas(canvas)
        .setContext(context)
        .setPipeline(true);
    }

    return function() {
      const texture = combinedKernel.apply(this, arguments);
      if (texture.toArray) {
        return texture.toArray();
      }
      return texture;
    };
  }

  setFunctions(functions) {
    this.functions = functions;
    return this;
  }

  setNativeFunctions(nativeFunctions) {
    this.nativeFunctions = nativeFunctions;
    return this;
  }

  addFunction(source, settings) {
    this.functions.push({ source, settings });
    return this;
  }

  addNativeFunction(name, source, settings) {
    if (this.kernels.length > 0) {
      throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');
    }
    this.nativeFunctions.push(Object.assign({ name, source }, settings));
    return this;
  }

  injectNative(source) {
    this.injectedNative = source;
    return this;
  }

  destroy() {
    return new Promise((resolve, reject) => {
      if (!this.kernels) {
        resolve();
      }
      setTimeout(() => {
        try {
          for (let i = 0; i < this.kernels.length; i++) {
            this.kernels[i].destroy(true); 
          }
          let firstKernel = this.kernels[0];
          if (firstKernel) {
            if (firstKernel.kernel) {
              firstKernel = firstKernel.kernel;
            }
            if (firstKernel.constructor.destroyContext) {
              firstKernel.constructor.destroyContext(this.context);
            }
          }
        } catch (e) {
          reject(e);
        }
        resolve();
      }, 0);
    });
  }
}


function upgradeDeprecatedCreateKernelSettings(settings) {
  if (!settings) {
    return {};
  }
  const upgradedSettings = Object.assign({}, settings);

  if (settings.hasOwnProperty('floatOutput')) {
    utils.warnDeprecated('setting', 'floatOutput', 'precision');
    upgradedSettings.precision = settings.floatOutput ? 'single' : 'unsigned';
  }
  if (settings.hasOwnProperty('outputToTexture')) {
    utils.warnDeprecated('setting', 'outputToTexture', 'pipeline');
    upgradedSettings.pipeline = Boolean(settings.outputToTexture);
  }
  if (settings.hasOwnProperty('outputImmutable')) {
    utils.warnDeprecated('setting', 'outputImmutable', 'immutable');
    upgradedSettings.immutable = Boolean(settings.outputImmutable);
  }
  if (settings.hasOwnProperty('floatTextures')) {
    utils.warnDeprecated('setting', 'floatTextures', 'optimizeFloatMemory');
    upgradedSettings.optimizeFloatMemory = Boolean(settings.floatTextures);
  }
  return upgradedSettings;
}

module.exports = {
  GPU,
  kernelOrder,
  kernelTypes
};
},{"./backend/cpu/kernel":8,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/kernel":70,"./backend/web-gl2/kernel":105,"./kernel-run-shortcut":111,"./utils":114,"gpu-mock.js":4}],109:[function(require,module,exports){
const { GPU } = require('./gpu');
const { alias } = require('./alias');
const { utils } = require('./utils');
const { Input, input } = require('./input');
const { Texture } = require('./texture');
const { FunctionBuilder } = require('./backend/function-builder');
const { FunctionNode } = require('./backend/function-node');
const { CPUFunctionNode } = require('./backend/cpu/function-node');
const { CPUKernel } = require('./backend/cpu/kernel');

const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');

const { WebGLFunctionNode } = require('./backend/web-gl/function-node');
const { WebGLKernel } = require('./backend/web-gl/kernel');
const { kernelValueMaps: webGLKernelValueMaps } = require('./backend/web-gl/kernel-value-maps');

const { WebGL2FunctionNode } = require('./backend/web-gl2/function-node');
const { WebGL2Kernel } = require('./backend/web-gl2/kernel');
const { kernelValueMaps: webGL2KernelValueMaps } = require('./backend/web-gl2/kernel-value-maps');

const { GLKernel } = require('./backend/gl/kernel');

const { Kernel } = require('./backend/kernel');

const { FunctionTracer } = require('./backend/function-tracer');

const mathRandom = require('./plugins/math-random-uniformly-distributed');

module.exports = {
  alias,
  CPUFunctionNode,
  CPUKernel,
  GPU,
  FunctionBuilder,
  FunctionNode,
  HeadlessGLKernel,
  Input,
  input,
  Texture,
  utils,

  WebGL2FunctionNode,
  WebGL2Kernel,
  webGL2KernelValueMaps,

  WebGLFunctionNode,
  WebGLKernel,
  webGLKernelValueMaps,

  GLKernel,
  Kernel,
  FunctionTracer,

  plugins: {
    mathRandom
  }
};
},{"./alias":5,"./backend/cpu/function-node":6,"./backend/cpu/kernel":8,"./backend/function-builder":9,"./backend/function-node":10,"./backend/function-tracer":11,"./backend/gl/kernel":13,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/function-node":38,"./backend/web-gl/kernel":70,"./backend/web-gl/kernel-value-maps":39,"./backend/web-gl2/function-node":73,"./backend/web-gl2/kernel":105,"./backend/web-gl2/kernel-value-maps":74,"./gpu":108,"./input":110,"./plugins/math-random-uniformly-distributed":112,"./texture":113,"./utils":114}],110:[function(require,module,exports){
class Input {
  constructor(value, size) {
    this.value = value;
    if (Array.isArray(size)) {
      this.size = size;
    } else {
      this.size = new Int32Array(3);
      if (size.z) {
        this.size = new Int32Array([size.x, size.y, size.z]);
      } else if (size.y) {
        this.size = new Int32Array([size.x, size.y]);
      } else {
        this.size = new Int32Array([size.x]);
      }
    }

    const [w, h, d] = this.size;
    if (d) {
      if (this.value.length !== (w * h * d)) {
        throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} * ${d} = ${(h * w * d)}`);
      }
    } else if (h) {
      if (this.value.length !== (w * h)) {
        throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} = ${(h * w)}`);
      }
    } else {
      if (this.value.length !== w) {
        throw new Error(`Input size ${this.value.length} does not match ${w}`);
      }
    }

  }

  toArray() {
    const { utils } = require('./utils');
    const [w, h, d] = this.size;
    if (d) {
      return utils.erectMemoryOptimized3DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h, d);
    } else if (h) {
      return utils.erectMemoryOptimized2DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h);
    } else {
      return this.value;
    }
  }
}

function input(value, size) {
  return new Input(value, size);
}

module.exports = {
  Input,
  input
};
},{"./utils":114}],111:[function(require,module,exports){
const { utils } = require('./utils');

function kernelRunShortcut(kernel) {
  let run = function() {
    kernel.build.apply(kernel, arguments);
    run = function() {
      let result = kernel.run.apply(kernel, arguments);
      if (kernel.switchingKernels) {
        const reasons = kernel.resetSwitchingKernels();
        const newKernel = kernel.onRequestSwitchKernel(reasons, arguments, kernel);
        shortcut.kernel = kernel = newKernel;
        result = newKernel.run.apply(newKernel, arguments);
      }
      if (kernel.renderKernels) {
        return kernel.renderKernels();
      } else if (kernel.renderOutput) {
        return kernel.renderOutput();
      } else {
        return result;
      }
    };
    return run.apply(kernel, arguments);
  };
  const shortcut = function() {
    return run.apply(kernel, arguments);
  };
  shortcut.exec = function() {
    return new Promise((accept, reject) => {
      try {
        accept(run.apply(this, arguments));
      } catch (e) {
        reject(e);
      }
    });
  };
  shortcut.replaceKernel = function(replacementKernel) {
    kernel = replacementKernel;
    bindKernelToShortcut(kernel, shortcut);
  };

  bindKernelToShortcut(kernel, shortcut);
  return shortcut;
}

function bindKernelToShortcut(kernel, shortcut) {
  if (shortcut.kernel) {
    shortcut.kernel = kernel;
    return;
  }
  const properties = utils.allPropertiesOf(kernel);
  for (let i = 0; i < properties.length; i++) {
    const property = properties[i];
    if (property[0] === '_' && property[1] === '_') continue;
    if (typeof kernel[property] === 'function') {
      if (property.substring(0, 3) === 'add' || property.substring(0, 3) === 'set') {
        shortcut[property] = function() {
          shortcut.kernel[property].apply(shortcut.kernel, arguments);
          return shortcut;
        };
      } else {
        shortcut[property] = function() {
          return shortcut.kernel[property].apply(shortcut.kernel, arguments);
        };
      }
    } else {
      shortcut.__defineGetter__(property, () => shortcut.kernel[property]);
      shortcut.__defineSetter__(property, (value) => {
        shortcut.kernel[property] = value;
      });
    }
  }
  shortcut.kernel = kernel;
}
module.exports = {
  kernelRunShortcut
};
},{"./utils":114}],112:[function(require,module,exports){
const source = `// https://www.shadertoy.com/view/4t2SDh
//note: uniformly distributed, normalized rand, [0,1]
highp float randomSeedShift = 1.0;
highp float slide = 1.0;
uniform highp float randomSeed1;
uniform highp float randomSeed2;

highp float nrand(highp vec2 n) {
  highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);
  randomSeedShift = result;
  if (randomSeedShift > 0.5) {
    slide += 0.00009; 
  } else {
    slide += 0.0009;
  }
  return result;
}`;

const name = 'math-random-uniformly-distributed';

const functionMatch = `Math.random()`;

const functionReplace = `nrand(vTexCoord)`;

const functionReturnType = 'Number';
const onBeforeRun = (kernel) => {
  kernel.setUniform1f('randomSeed1', Math.random());
  kernel.setUniform1f('randomSeed2', Math.random());
};

const plugin = {
  name,
  onBeforeRun,
  functionMatch,
  functionReplace,
  functionReturnType,
  source
};

module.exports = plugin;
},{}],113:[function(require,module,exports){
class Texture {
  constructor(settings) {
    const {
      texture,
      size,
      dimensions,
      output,
      context,
      type = 'NumberTexture',
      kernel,
      internalFormat,
      textureFormat
    } = settings;
    if (!output) throw new Error('settings property "output" required.');
    if (!context) throw new Error('settings property "context" required.');
    if (!texture) throw new Error('settings property "texture" required.');
    if (!kernel) throw new Error('settings property "kernel" required.');
    this.texture = texture;
    if (texture._refs) {
      texture._refs++;
    } else {
      texture._refs = 1;
    }
    this.size = size;
    this.dimensions = dimensions;
    this.output = output;
    this.context = context;
    this.kernel = kernel;
    this.type = type;
    this._deleted = false;
    this.internalFormat = internalFormat;
    this.textureFormat = textureFormat;
  }

  toArray() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  clone() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  delete() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  clear() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }
}

module.exports = {
  Texture
};
},{}],114:[function(require,module,exports){
const acorn = require('acorn');
const { Input } = require('./input');
const { Texture } = require('./texture');

const FUNCTION_NAME = /function ([^(]*)/;
const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
const ARGUMENT_NAMES = /([^\s,]+)/g;

const utils = {
  systemEndianness() {
    return _systemEndianness;
  },
  getSystemEndianness() {
    const b = new ArrayBuffer(4);
    const a = new Uint32Array(b);
    const c = new Uint8Array(b);
    a[0] = 0xdeadbeef;
    if (c[0] === 0xef) return 'LE';
    if (c[0] === 0xde) return 'BE';
    throw new Error('unknown endianness');
  },

  isFunction(funcObj) {
    return typeof(funcObj) === 'function';
  },

  isFunctionString(fn) {
    if (typeof fn === 'string') {
      return (fn
        .slice(0, 'function'.length)
        .toLowerCase() === 'function');
    }
    return false;
  },

  getFunctionNameFromString(funcStr) {
    const result = FUNCTION_NAME.exec(funcStr);
    if (!result || result.length === 0) return null;
    return result[1].trim();
  },

  getFunctionBodyFromString(funcStr) {
    return funcStr.substring(funcStr.indexOf('{') + 1, funcStr.lastIndexOf('}'));
  },

  getArgumentNamesFromString(fn) {
    const fnStr = fn.replace(STRIP_COMMENTS, '');
    let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
    if (result === null) {
      result = [];
    }
    return result;
  },

  clone(obj) {
    if (obj === null || typeof obj !== 'object' || obj.hasOwnProperty('isActiveClone')) return obj;

    const temp = obj.constructor(); 

    for (let key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        obj.isActiveClone = null;
        temp[key] = utils.clone(obj[key]);
        delete obj.isActiveClone;
      }
    }

    return temp;
  },

  isArray(array) {
    return !isNaN(array.length);
  },

  getVariableType(value, strictIntegers) {
    if (utils.isArray(value)) {
      if (value.length > 0 && value[0].nodeName === 'IMG') {
        return 'HTMLImageArray';
      }
      return 'Array';
    }

    switch (value.constructor) {
      case Boolean:
        return 'Boolean';
      case Number:
        if (strictIntegers && Number.isInteger(value)) {
          return 'Integer';
        }
        return 'Float';
      case Texture:
        return value.type;
      case Input:
        return 'Input';
    }
    switch (value.nodeName) {
      case 'IMG':
        return 'HTMLImage';
      case 'CANVAS':
        return 'HTMLImage';
      case 'VIDEO':
        return 'HTMLVideo';
    }
    if (value.hasOwnProperty('type')) {
      return value.type;
    }
    return 'Unknown';
  },

  getKernelTextureSize(settings, dimensions) {
    let [w, h, d] = dimensions;
    let texelCount = (w || 1) * (h || 1) * (d || 1);

    if (settings.optimizeFloatMemory && settings.precision === 'single') {
      w = texelCount = Math.ceil(texelCount / 4);
    }
    if (h > 1 && w * h === texelCount) {
      return new Int32Array([w, h]);
    }
    return utils.closestSquareDimensions(texelCount);
  },

  closestSquareDimensions(length) {
    const sqrt = Math.sqrt(length);
    let high = Math.ceil(sqrt);
    let low = Math.floor(sqrt);
    while (high * low < length) {
      high--;
      low = Math.ceil(length / high);
    }
    return new Int32Array([low, Math.ceil(length / low)]);
  },

  getMemoryOptimizedFloatTextureSize(dimensions, bitRatio) {
    const totalArea = utils.roundTo((dimensions[0] || 1) * (dimensions[1] || 1) * (dimensions[2] || 1) * (dimensions[3] || 1), 4);
    const texelCount = totalArea / bitRatio;
    return utils.closestSquareDimensions(texelCount);
  },

  getMemoryOptimizedPackedTextureSize(dimensions, bitRatio) {
    const [w, h, d] = dimensions;
    const totalArea = utils.roundTo((w || 1) * (h || 1) * (d || 1), 4);
    const texelCount = totalArea / (4 / bitRatio);
    return utils.closestSquareDimensions(texelCount);
  },

  roundTo(n, d) {
    return Math.floor((n + d - 1) / d) * d;
  },
  getDimensions(x, pad) {
    let ret;
    if (utils.isArray(x)) {
      const dim = [];
      let temp = x;
      while (utils.isArray(temp)) {
        dim.push(temp.length);
        temp = temp[0];
      }
      ret = dim.reverse();
    } else if (x instanceof Texture) {
      ret = x.output;
    } else if (x instanceof Input) {
      ret = x.size;
    } else {
      throw new Error(`Unknown dimensions of ${x}`);
    }

    if (pad) {
      ret = Array.from(ret);
      while (ret.length < 3) {
        ret.push(1);
      }
    }

    return new Int32Array(ret);
  },

  flatten2dArrayTo(array, target) {
    let offset = 0;
    for (let y = 0; y < array.length; y++) {
      target.set(array[y], offset);
      offset += array[y].length;
    }
  },

  flatten3dArrayTo(array, target) {
    let offset = 0;
    for (let z = 0; z < array.length; z++) {
      for (let y = 0; y < array[z].length; y++) {
        target.set(array[z][y], offset);
        offset += array[z][y].length;
      }
    }
  },

  flatten4dArrayTo(array, target) {
    let offset = 0;
    for (let l = 0; l < array.length; l++) {
      for (let z = 0; z < array[l].length; z++) {
        for (let y = 0; y < array[l][z].length; y++) {
          target.set(array[l][z][y], offset);
          offset += array[l][z][y].length;
        }
      }
    }
  },

  flattenTo(array, target) {
    if (utils.isArray(array[0])) {
      if (utils.isArray(array[0][0])) {
        if (utils.isArray(array[0][0][0])) {
          utils.flatten4dArrayTo(array, target);
        } else {
          utils.flatten3dArrayTo(array, target);
        }
      } else {
        utils.flatten2dArrayTo(array, target);
      }
    } else {
      target.set(array);
    }
  },

  splitArray(array, part) {
    const result = [];
    for (let i = 0; i < array.length; i += part) {
      result.push(new array.constructor(array.buffer, i * 4 + array.byteOffset, part));
    }
    return result;
  },

  getAstString(source, ast) {
    const lines = Array.isArray(source) ? source : source.split(/\r?\n/g);
    const start = ast.loc.start;
    const end = ast.loc.end;
    const result = [];
    if (start.line === end.line) {
      result.push(lines[start.line - 1].substring(start.column, end.column));
    } else {
      result.push(lines[start.line - 1].slice(start.column));
      for (let i = start.line; i < end.line; i++) {
        result.push(lines[i]);
      }
      result.push(lines[end.line - 1].slice(0, end.column));
    }
    return result.join('\n');
  },

  allPropertiesOf(obj) {
    const props = [];

    do {
      props.push.apply(props, Object.getOwnPropertyNames(obj));
    } while (obj = Object.getPrototypeOf(obj));

    return props;
  },

  linesToString(lines) {
    if (lines.length > 0) {
      return lines.join(';\n') + ';\n';
    } else {
      return '\n';
    }
  },
  warnDeprecated(type, oldName, newName) {
    if (newName) {
      console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been replaced with "${ newName }". Fixing, but please upgrade as it will soon be removed.`);
    } else {
      console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been removed. Fixing, but please upgrade as it will soon be removed.`);
    }
  },
  flipPixels: (pixels, width, height) => {
    const halfHeight = height / 2 | 0; 
    const bytesPerRow = width * 4;
    const temp = new Uint8ClampedArray(width * 4);
    const result = pixels.slice(0);
    for (let y = 0; y < halfHeight; ++y) {
      const topOffset = y * bytesPerRow;
      const bottomOffset = (height - y - 1) * bytesPerRow;

      temp.set(result.subarray(topOffset, topOffset + bytesPerRow));

      result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);

      result.set(temp, bottomOffset);
    }
    return result;
  },
  erectPackedFloat: (array, width) => {
    return array.subarray(0, width);
  },
  erect2DPackedFloat: (array, width, height) => {
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xStart = y * width;
      const xEnd = xStart + width;
      yResults[y] = array.subarray(xStart, xEnd);
    }
    return yResults;
  },
  erect3DPackedFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xStart = (z * height * width) + y * width;
        const xEnd = xStart + width;
        yResults[y] = array.subarray(xStart, xEnd);
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectMemoryOptimizedFloat: (array, width) => {
    return array.subarray(0, width);
  },
  erectMemoryOptimized2DFloat: (array, width, height) => {
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const offset = y * width;
      yResults[y] = array.subarray(offset, offset + width);
    }
    return yResults;
  },
  erectMemoryOptimized3DFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const offset = (z * height * width) + (y * width);
        yResults[y] = array.subarray(offset, offset + width);
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectFloat: (array, width) => {
    const xResults = new Float32Array(width);
    let i = 0;
    for (let x = 0; x < width; x++) {
      xResults[x] = array[i];
      i += 4;
    }
    return xResults;
  },
  erect2DFloat: (array, width, height) => {
    const yResults = new Array(height);
    let i = 0;
    for (let y = 0; y < height; y++) {
      const xResults = new Float32Array(width);
      for (let x = 0; x < width; x++) {
        xResults[x] = array[i];
        i += 4;
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    let i = 0;
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Float32Array(width);
        for (let x = 0; x < width; x++) {
          xResults[x] = array[i];
          i += 4;
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray2: (array, width) => {
    const xResults = new Array(width);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 2);
    }
    return xResults;
  },
  erect2DArray2: (array, width, height) => {
    const yResults = new Array(height);
    const XResultsMax = width * 4;
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * XResultsMax;
      let i = 0;
      for (let x = 0; x < XResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 2);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray2: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 2);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray3: (array, width) => {
    const xResults = new Array(width);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 3);
    }
    return xResults;
  },
  erect2DArray3: (array, width, height) => {
    const xResultsMax = width * 4;
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * xResultsMax;
      let i = 0;
      for (let x = 0; x < xResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 3);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray3: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 3);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray4: (array, width) => {
    const xResults = new Array(array);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 4);
    }
    return xResults;
  },
  erect2DArray4: (array, width, height) => {
    const xResultsMax = width * 4;
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * xResultsMax;
      let i = 0;
      for (let x = 0; x < xResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 4);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray4: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 4);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },

  flattenFunctionToString: (source, settings) => {
    const { findDependency, thisLookup, doNotDefine } = settings;
    let flattened = settings.flattened;
    if (!flattened) {
      flattened = settings.flattened = {};
    }
    const ast = acorn.parse(source);
    const functionDependencies = [];
    let indent = 0;

    function flatten(ast) {
      if (Array.isArray(ast)) {
        const results = [];
        for (let i = 0; i < ast.length; i++) {
          results.push(flatten(ast[i]));
        }
        return results.join('');
      }
      switch (ast.type) {
        case 'Program':
          return flatten(ast.body) + (ast.body[0].type === 'VariableDeclaration' ? ';' : '');
        case 'FunctionDeclaration':
          return `function ${ast.id.name}(${ast.params.map(flatten).join(', ')}) ${ flatten(ast.body) }`;
        case 'BlockStatement': {
          const result = [];
          indent += 2;
          for (let i = 0; i < ast.body.length; i++) {
            const flat = flatten(ast.body[i]);
            if (flat) {
              result.push(' '.repeat(indent) + flat, ';\n');
            }
          }
          indent -= 2;
          return `{\n${result.join('')}}`;
        }
        case 'VariableDeclaration':
          const declarations = utils.normalizeDeclarations(ast)
            .map(flatten)
            .filter(r => r !== null);
          if (declarations.length < 1) {
            return '';
          } else {
            return `${ast.kind} ${declarations.join(',')}`;
          }
          case 'VariableDeclarator':
            if (ast.init.object && ast.init.object.type === 'ThisExpression') {
              const lookup = thisLookup(ast.init.property.name, true);
              if (lookup) {
                return `${ast.id.name} = ${flatten(ast.init)}`;
              } else {
                return null;
              }
            } else {
              return `${ast.id.name} = ${flatten(ast.init)}`;
            }
            case 'CallExpression': {
              if (ast.callee.property.name === 'subarray') {
                return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              }
              if (ast.callee.object.name === 'gl' || ast.callee.object.name === 'context') {
                return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              }
              if (ast.callee.object.type === 'ThisExpression') {
                functionDependencies.push(findDependency('this', ast.callee.property.name));
                return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              } else if (ast.callee.object.name) {
                const foundSource = findDependency(ast.callee.object.name, ast.callee.property.name);
                if (foundSource === null) {
                  return `${ast.callee.object.name}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                } else {
                  functionDependencies.push(foundSource);
                  return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                }
              } else if (ast.callee.object.type === 'MemberExpression') {
                return `${flatten(ast.callee.object)}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              } else {
                throw new Error('unknown ast.callee');
              }
            }
            case 'ReturnStatement':
              return `return ${flatten(ast.argument)}`;
            case 'BinaryExpression':
              return `(${flatten(ast.left)}${ast.operator}${flatten(ast.right)})`;
            case 'UnaryExpression':
              if (ast.prefix) {
                return `${ast.operator} ${flatten(ast.argument)}`;
              } else {
                return `${flatten(ast.argument)} ${ast.operator}`;
              }
              case 'ExpressionStatement':
                return `${flatten(ast.expression)}`;
              case 'SequenceExpression':
                return `(${flatten(ast.expressions)})`;
              case 'ArrowFunctionExpression':
                return `(${ast.params.map(flatten).join(', ')}) => ${flatten(ast.body)}`;
              case 'Literal':
                return ast.raw;
              case 'Identifier':
                return ast.name;
              case 'MemberExpression':
                if (ast.object.type === 'ThisExpression') {
                  return thisLookup(ast.property.name);
                }
                if (ast.computed) {
                  return `${flatten(ast.object)}[${flatten(ast.property)}]`;
                }
                return flatten(ast.object) + '.' + flatten(ast.property);
              case 'ThisExpression':
                return 'this';
              case 'NewExpression':
                return `new ${flatten(ast.callee)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              case 'ForStatement':
                return `for (${flatten(ast.init)};${flatten(ast.test)};${flatten(ast.update)}) ${flatten(ast.body)}`;
              case 'AssignmentExpression':
                return `${flatten(ast.left)}${ast.operator}${flatten(ast.right)}`;
              case 'UpdateExpression':
                return `${flatten(ast.argument)}${ast.operator}`;
              case 'IfStatement':
                return `if (${flatten(ast.test)}) ${flatten(ast.consequent)}`;
              case 'ThrowStatement':
                return `throw ${flatten(ast.argument)}`;
              case 'ObjectPattern':
                return ast.properties.map(flatten).join(', ');
              case 'ArrayPattern':
                return ast.elements.map(flatten).join(', ');
              case 'DebuggerStatement':
                return 'debugger;';
              case 'ConditionalExpression':
                return `${flatten(ast.test)}?${flatten(ast.consequent)}:${flatten(ast.alternate)}`;
              case 'Property':
                if (ast.kind === 'init') {
                  return flatten(ast.key);
                }
      }
      throw new Error(`unhandled ast.type of ${ ast.type }`);
    }
    const result = flatten(ast);
    if (functionDependencies.length > 0) {
      const flattenedFunctionDependencies = [];
      for (let i = 0; i < functionDependencies.length; i++) {
        const functionDependency = functionDependencies[i];
        if (!flattened[functionDependency]) {
          flattened[functionDependency] = true;
        }
        flattenedFunctionDependencies.push(utils.flattenFunctionToString(functionDependency, settings) + '\n');
      }
      return flattenedFunctionDependencies.join('') + result;
    }
    return result;
  },

  normalizeDeclarations: (ast) => {
    if (ast.type !== 'VariableDeclaration') throw new Error('Ast is not of type "VariableDeclaration"');
    const normalizedDeclarations = [];
    for (let declarationIndex = 0; declarationIndex < ast.declarations.length; declarationIndex++) {
      const declaration = ast.declarations[declarationIndex];
      if (declaration.id && declaration.id.type === 'ObjectPattern' && declaration.id.properties) {
        const { properties } = declaration.id;
        for (let propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {
          const property = properties[propertyIndex];
          if (property.value.type === 'ObjectPattern' && property.value.properties) {
            for (let subPropertyIndex = 0; subPropertyIndex < property.value.properties.length; subPropertyIndex++) {
              const subProperty = property.value.properties[subPropertyIndex];
              if (subProperty.type === 'Property') {
                normalizedDeclarations.push({
                  type: 'VariableDeclarator',
                  id: {
                    type: 'Identifier',
                    name: subProperty.key.name
                  },
                  init: {
                    type: 'MemberExpression',
                    object: {
                      type: 'MemberExpression',
                      object: declaration.init,
                      property: {
                        type: 'Identifier',
                        name: property.key.name
                      },
                      computed: false
                    },
                    property: {
                      type: 'Identifier',
                      name: subProperty.key.name
                    },
                    computed: false
                  }
                });
              } else {
                throw new Error('unexpected state');
              }
            }
          } else if (property.value.type === 'Identifier') {
            normalizedDeclarations.push({
              type: 'VariableDeclarator',
              id: {
                type: 'Identifier',
                name: property.value && property.value.name ? property.value.name : property.key.name
              },
              init: {
                type: 'MemberExpression',
                object: declaration.init,
                property: {
                  type: 'Identifier',
                  name: property.key.name
                },
                computed: false
              }
            });
          } else {
            throw new Error('unexpected state');
          }
        }
      } else if (declaration.id && declaration.id.type === 'ArrayPattern' && declaration.id.elements) {
        const { elements } = declaration.id;
        for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {
          const element = elements[elementIndex];
          if (element.type === 'Identifier') {
            normalizedDeclarations.push({
              type: 'VariableDeclarator',
              id: {
                type: 'Identifier',
                name: element.name
              },
              init: {
                type: 'MemberExpression',
                object: declaration.init,
                property: {
                  type: 'Literal',
                  value: elementIndex,
                  raw: elementIndex.toString(),
                  start: element.start,
                  end: element.end
                },
                computed: true
              }
            });
          } else {
            throw new Error('unexpected state');
          }
        }
      } else {
        normalizedDeclarations.push(declaration);
      }
    }
    return normalizedDeclarations;
  },

  splitHTMLImageToRGB: (gpu, image) => {
    const rKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.r * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const gKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.g * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const bKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.b * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const aKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.a * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const result = [
      rKernel(image),
      gKernel(image),
      bKernel(image),
      aKernel(image),
    ];
    result.rKernel = rKernel;
    result.gKernel = gKernel;
    result.bKernel = bKernel;
    result.aKernel = aKernel;
    result.gpu = gpu;
    return result;
  },

  splitRGBAToCanvases: (gpu, rgba, width, height) => {
    const visualKernelR = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(pixel.r / 255, 0, 0, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelR(rgba);

    const visualKernelG = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(0, pixel.g / 255, 0, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelG(rgba);

    const visualKernelB = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(0, 0, pixel.b / 255, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelB(rgba);

    const visualKernelA = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(255, 255, 255, pixel.a / 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelA(rgba);
    return [
      visualKernelR.canvas,
      visualKernelG.canvas,
      visualKernelB.canvas,
      visualKernelA.canvas,
    ];
  },

  getMinifySafeName: (fn) => {
    try {
      const ast = acorn.parse(`const value = ${fn.toString()}`);
      const { init } = ast.body[0].declarations[0];
      return init.body.name || init.body.body[0].argument.name;
    } catch (e) {
      throw new Error('Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }');
    }
  },
  sanitizeName: function(name) {
    if (dollarSign.test(name)) {
      name = name.replace(dollarSign, 'S_S');
    }
    if (doubleUnderscore.test(name)) {
      name = name.replace(doubleUnderscore, 'U_U');
    } else if (singleUnderscore.test(name)) {
      name = name.replace(singleUnderscore, 'u_u');
    }
    return name;
  }
};

const dollarSign = /\$/;
const doubleUnderscore = /__/;
const singleUnderscore = /_/;

const _systemEndianness = utils.getSystemEndianness();

module.exports = {
  utils
};
},{"./input":110,"./texture":113,"acorn":1}]},{},[107])(107)
});


/***/ }),

/***/ "./node_modules/is-any-array/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/is-any-array/src/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const toString = Object.prototype.toString;

function isAnyArray(object) {
  return toString.call(object).endsWith('Array]');
}

module.exports = isAnyArray;


/***/ }),

/***/ "./node_modules/ml-array-max/lib-es6/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ml-array-max/lib-es6/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ "./node_modules/is-any-array/src/index.js");
/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(is_any_array__WEBPACK_IMPORTED_MODULE_0__);


/**
 * Computes the maximum of the given values
 * @param {Array<number>} input
 * @return {number}
 */

function max(input) {
  if (!is_any_array__WEBPACK_IMPORTED_MODULE_0___default()(input)) {
    throw new TypeError('input must be an array');
  }

  if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  var maxValue = input[0];

  for (var i = 1; i < input.length; i++) {
    if (input[i] > maxValue) maxValue = input[i];
  }

  return maxValue;
}

/* harmony default export */ __webpack_exports__["default"] = (max);


/***/ }),

/***/ "./node_modules/ml-array-min/lib-es6/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ml-array-min/lib-es6/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ "./node_modules/is-any-array/src/index.js");
/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(is_any_array__WEBPACK_IMPORTED_MODULE_0__);


/**
 * Computes the minimum of the given values
 * @param {Array<number>} input
 * @return {number}
 */

function min(input) {
  if (!is_any_array__WEBPACK_IMPORTED_MODULE_0___default()(input)) {
    throw new TypeError('input must be an array');
  }

  if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  var minValue = input[0];

  for (var i = 1; i < input.length; i++) {
    if (input[i] < minValue) minValue = input[i];
  }

  return minValue;
}

/* harmony default export */ __webpack_exports__["default"] = (min);


/***/ }),

/***/ "./node_modules/ml-array-rescale/lib-es6/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ml-array-rescale/lib-es6/index.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ "./node_modules/is-any-array/src/index.js");
/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(is_any_array__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ml_array_max__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ml-array-max */ "./node_modules/ml-array-max/lib-es6/index.js");
/* harmony import */ var ml_array_min__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ml-array-min */ "./node_modules/ml-array-min/lib-es6/index.js");




/**
 *
 * @param {Array} input
 * @param {object} [options={}]
 * @param {Array} [options.output=[]] specify the output array, can be the input array for in place modification
 */

function rescale(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!is_any_array__WEBPACK_IMPORTED_MODULE_0___default()(input)) {
    throw new TypeError('input must be an array');
  } else if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  var output;

  if (options.output !== undefined) {
    if (!is_any_array__WEBPACK_IMPORTED_MODULE_0___default()(options.output)) {
      throw new TypeError('output option must be an array if specified');
    }

    output = options.output;
  } else {
    output = new Array(input.length);
  }

  var currentMin = Object(ml_array_min__WEBPACK_IMPORTED_MODULE_2__["default"])(input);
  var currentMax = Object(ml_array_max__WEBPACK_IMPORTED_MODULE_1__["default"])(input);

  if (currentMin === currentMax) {
    throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');
  }

  var _options$min = options.min,
      minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,
      _options$max = options.max,
      maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;

  if (minValue >= maxValue) {
    throw new RangeError('min option must be smaller than max option');
  }

  var factor = (maxValue - minValue) / (currentMax - currentMin);

  for (var i = 0; i < input.length; i++) {
    output[i] = (input[i] - currentMin) * factor + minValue;
  }

  return output;
}

/* harmony default export */ __webpack_exports__["default"] = (rescale);


/***/ }),

/***/ "./node_modules/ml-matrix/src/correlation.js":
/*!***************************************************!*\
  !*** ./node_modules/ml-matrix/src/correlation.js ***!
  \***************************************************/
/*! exports provided: correlation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "correlation", function() { return correlation; });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix */ "./node_modules/ml-matrix/src/matrix.js");


function correlation(xMatrix, yMatrix = xMatrix, options = {}) {
  xMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](xMatrix);
  let yIsSame = false;
  if (
    typeof yMatrix === 'object' &&
    !_matrix__WEBPACK_IMPORTED_MODULE_0__["default"].isMatrix(yMatrix) &&
    !Array.isArray(yMatrix)
  ) {
    options = yMatrix;
    yMatrix = xMatrix;
    yIsSame = true;
  } else {
    yMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](yMatrix);
  }
  if (xMatrix.rows !== yMatrix.rows) {
    throw new TypeError('Both matrices must have the same number of rows');
  }

  const { center = true, scale = true } = options;
  if (center) {
    xMatrix.center('column');
    if (!yIsSame) {
      yMatrix.center('column');
    }
  }
  if (scale) {
    xMatrix.scale('column');
    if (!yIsSame) {
      yMatrix.scale('column');
    }
  }

  const sdx = xMatrix.standardDeviation('column', { unbiased: true });
  const sdy = yIsSame
    ? sdx
    : yMatrix.standardDeviation('column', { unbiased: true });

  const corr = xMatrix.transpose().mmul(yMatrix);
  for (let i = 0; i < corr.rows; i++) {
    for (let j = 0; j < corr.columns; j++) {
      corr.set(
        i,
        j,
        corr.get(i, j) * (1 / (sdx[i] * sdy[j])) * (1 / (xMatrix.rows - 1)),
      );
    }
  }
  return corr;
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/covariance.js":
/*!**************************************************!*\
  !*** ./node_modules/ml-matrix/src/covariance.js ***!
  \**************************************************/
/*! exports provided: covariance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "covariance", function() { return covariance; });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix */ "./node_modules/ml-matrix/src/matrix.js");


function covariance(xMatrix, yMatrix = xMatrix, options = {}) {
  xMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](xMatrix);
  let yIsSame = false;
  if (
    typeof yMatrix === 'object' &&
    !_matrix__WEBPACK_IMPORTED_MODULE_0__["default"].isMatrix(yMatrix) &&
    !Array.isArray(yMatrix)
  ) {
    options = yMatrix;
    yMatrix = xMatrix;
    yIsSame = true;
  } else {
    yMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](yMatrix);
  }
  if (xMatrix.rows !== yMatrix.rows) {
    throw new TypeError('Both matrices must have the same number of rows');
  }
  const { center = true } = options;
  if (center) {
    xMatrix = xMatrix.center('column');
    if (!yIsSame) {
      yMatrix = yMatrix.center('column');
    }
  }
  const cov = xMatrix.transpose().mmul(yMatrix);
  for (let i = 0; i < cov.rows; i++) {
    for (let j = 0; j < cov.columns; j++) {
      cov.set(i, j, cov.get(i, j) * (1 / (xMatrix.rows - 1)));
    }
  }
  return cov;
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/cholesky.js":
/*!***************************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/cholesky.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CholeskyDecomposition; });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ "./node_modules/ml-matrix/src/matrix.js");
/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wrap/WrapperMatrix2D */ "./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js");



class CholeskyDecomposition {
  constructor(value) {
    value = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__["default"].checkMatrix(value);
    if (!value.isSymmetric()) {
      throw new Error('Matrix is not symmetric');
    }

    let a = value;
    let dimension = a.rows;
    let l = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](dimension, dimension);
    let positiveDefinite = true;
    let i, j, k;

    for (j = 0; j < dimension; j++) {
      let d = 0;
      for (k = 0; k < j; k++) {
        let s = 0;
        for (i = 0; i < k; i++) {
          s += l.get(k, i) * l.get(j, i);
        }
        s = (a.get(j, k) - s) / l.get(k, k);
        l.set(j, k, s);
        d = d + s * s;
      }

      d = a.get(j, j) - d;

      positiveDefinite &= d > 0;
      l.set(j, j, Math.sqrt(Math.max(d, 0)));
      for (k = j + 1; k < dimension; k++) {
        l.set(j, k, 0);
      }
    }

    this.L = l;
    this.positiveDefinite = Boolean(positiveDefinite);
  }

  isPositiveDefinite() {
    return this.positiveDefinite;
  }

  solve(value) {
    value = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__["default"].checkMatrix(value);

    let l = this.L;
    let dimension = l.rows;

    if (value.rows !== dimension) {
      throw new Error('Matrix dimensions do not match');
    }
    if (this.isPositiveDefinite() === false) {
      throw new Error('Matrix is not positive definite');
    }

    let count = value.columns;
    let B = value.clone();
    let i, j, k;

    for (k = 0; k < dimension; k++) {
      for (j = 0; j < count; j++) {
        for (i = 0; i < k; i++) {
          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(k, i));
        }
        B.set(k, j, B.get(k, j) / l.get(k, k));
      }
    }

    for (k = dimension - 1; k >= 0; k--) {
      for (j = 0; j < count; j++) {
        for (i = k + 1; i < dimension; i++) {
          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(i, k));
        }
        B.set(k, j, B.get(k, j) / l.get(k, k));
      }
    }

    return B;
  }

  get lowerTriangularMatrix() {
    return this.L;
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/evd.js":
/*!**********************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/evd.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EigenvalueDecomposition; });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ "./node_modules/ml-matrix/src/matrix.js");
/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wrap/WrapperMatrix2D */ "./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/ml-matrix/src/dc/util.js");





class EigenvalueDecomposition {
  constructor(matrix, options = {}) {
    const { assumeSymmetric = false } = options;

    matrix = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__["default"].checkMatrix(matrix);
    if (!matrix.isSquare()) {
      throw new Error('Matrix is not a square matrix');
    }

    let n = matrix.columns;
    let V = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](n, n);
    let d = new Float64Array(n);
    let e = new Float64Array(n);
    let value = matrix;
    let i, j;

    let isSymmetric = false;
    if (assumeSymmetric) {
      isSymmetric = true;
    } else {
      isSymmetric = matrix.isSymmetric();
    }

    if (isSymmetric) {
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          V.set(i, j, value.get(i, j));
        }
      }
      tred2(n, e, d, V);
      tql2(n, e, d, V);
    } else {
      let H = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](n, n);
      let ort = new Float64Array(n);
      for (j = 0; j < n; j++) {
        for (i = 0; i < n; i++) {
          H.set(i, j, value.get(i, j));
        }
      }
      orthes(n, H, ort, V);
      hqr2(n, e, d, V, H);
    }

    this.n = n;
    this.e = e;
    this.d = d;
    this.V = V;
  }

  get realEigenvalues() {
    return Array.from(this.d);
  }

  get imaginaryEigenvalues() {
    return Array.from(this.e);
  }

  get eigenvectorMatrix() {
    return this.V;
  }

  get diagonalMatrix() {
    let n = this.n;
    let e = this.e;
    let d = this.d;
    let X = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](n, n);
    let i, j;
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        X.set(i, j, 0);
      }
      X.set(i, i, d[i]);
      if (e[i] > 0) {
        X.set(i, i + 1, e[i]);
      } else if (e[i] < 0) {
        X.set(i, i - 1, e[i]);
      }
    }
    return X;
  }
}

function tred2(n, e, d, V) {
  let f, g, h, i, j, k, hh, scale;

  for (j = 0; j < n; j++) {
    d[j] = V.get(n - 1, j);
  }

  for (i = n - 1; i > 0; i--) {
    scale = 0;
    h = 0;
    for (k = 0; k < i; k++) {
      scale = scale + Math.abs(d[k]);
    }

    if (scale === 0) {
      e[i] = d[i - 1];
      for (j = 0; j < i; j++) {
        d[j] = V.get(i - 1, j);
        V.set(i, j, 0);
        V.set(j, i, 0);
      }
    } else {
      for (k = 0; k < i; k++) {
        d[k] /= scale;
        h += d[k] * d[k];
      }

      f = d[i - 1];
      g = Math.sqrt(h);
      if (f > 0) {
        g = -g;
      }

      e[i] = scale * g;
      h = h - f * g;
      d[i - 1] = f - g;
      for (j = 0; j < i; j++) {
        e[j] = 0;
      }

      for (j = 0; j < i; j++) {
        f = d[j];
        V.set(j, i, f);
        g = e[j] + V.get(j, j) * f;
        for (k = j + 1; k <= i - 1; k++) {
          g += V.get(k, j) * d[k];
          e[k] += V.get(k, j) * f;
        }
        e[j] = g;
      }

      f = 0;
      for (j = 0; j < i; j++) {
        e[j] /= h;
        f += e[j] * d[j];
      }

      hh = f / (h + h);
      for (j = 0; j < i; j++) {
        e[j] -= hh * d[j];
      }

      for (j = 0; j < i; j++) {
        f = d[j];
        g = e[j];
        for (k = j; k <= i - 1; k++) {
          V.set(k, j, V.get(k, j) - (f * e[k] + g * d[k]));
        }
        d[j] = V.get(i - 1, j);
        V.set(i, j, 0);
      }
    }
    d[i] = h;
  }

  for (i = 0; i < n - 1; i++) {
    V.set(n - 1, i, V.get(i, i));
    V.set(i, i, 1);
    h = d[i + 1];
    if (h !== 0) {
      for (k = 0; k <= i; k++) {
        d[k] = V.get(k, i + 1) / h;
      }

      for (j = 0; j <= i; j++) {
        g = 0;
        for (k = 0; k <= i; k++) {
          g += V.get(k, i + 1) * V.get(k, j);
        }
        for (k = 0; k <= i; k++) {
          V.set(k, j, V.get(k, j) - g * d[k]);
        }
      }
    }

    for (k = 0; k <= i; k++) {
      V.set(k, i + 1, 0);
    }
  }

  for (j = 0; j < n; j++) {
    d[j] = V.get(n - 1, j);
    V.set(n - 1, j, 0);
  }

  V.set(n - 1, n - 1, 1);
  e[0] = 0;
}

function tql2(n, e, d, V) {
  let g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2, iter;

  for (i = 1; i < n; i++) {
    e[i - 1] = e[i];
  }

  e[n - 1] = 0;

  let f = 0;
  let tst1 = 0;
  let eps = Number.EPSILON;

  for (l = 0; l < n; l++) {
    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
    m = l;
    while (m < n) {
      if (Math.abs(e[m]) <= eps * tst1) {
        break;
      }
      m++;
    }

    if (m > l) {
      iter = 0;
      do {
        iter = iter + 1;

        g = d[l];
        p = (d[l + 1] - g) / (2 * e[l]);
        r = Object(_util__WEBPACK_IMPORTED_MODULE_2__["hypotenuse"])(p, 1);
        if (p < 0) {
          r = -r;
        }

        d[l] = e[l] / (p + r);
        d[l + 1] = e[l] * (p + r);
        dl1 = d[l + 1];
        h = g - d[l];
        for (i = l + 2; i < n; i++) {
          d[i] -= h;
        }

        f = f + h;

        p = d[m];
        c = 1;
        c2 = c;
        c3 = c;
        el1 = e[l + 1];
        s = 0;
        s2 = 0;
        for (i = m - 1; i >= l; i--) {
          c3 = c2;
          c2 = c;
          s2 = s;
          g = c * e[i];
          h = c * p;
          r = Object(_util__WEBPACK_IMPORTED_MODULE_2__["hypotenuse"])(p, e[i]);
          e[i + 1] = s * r;
          s = e[i] / r;
          c = p / r;
          p = c * d[i] - s * g;
          d[i + 1] = h + s * (c * g + s * d[i]);

          for (k = 0; k < n; k++) {
            h = V.get(k, i + 1);
            V.set(k, i + 1, s * V.get(k, i) + c * h);
            V.set(k, i, c * V.get(k, i) - s * h);
          }
        }

        p = (-s * s2 * c3 * el1 * e[l]) / dl1;
        e[l] = s * p;
        d[l] = c * p;
      } while (Math.abs(e[l]) > eps * tst1);
    }
    d[l] = d[l] + f;
    e[l] = 0;
  }

  for (i = 0; i < n - 1; i++) {
    k = i;
    p = d[i];
    for (j = i + 1; j < n; j++) {
      if (d[j] < p) {
        k = j;
        p = d[j];
      }
    }

    if (k !== i) {
      d[k] = d[i];
      d[i] = p;
      for (j = 0; j < n; j++) {
        p = V.get(j, i);
        V.set(j, i, V.get(j, k));
        V.set(j, k, p);
      }
    }
  }
}

function orthes(n, H, ort, V) {
  let low = 0;
  let high = n - 1;
  let f, g, h, i, j, m;
  let scale;

  for (m = low + 1; m <= high - 1; m++) {
    scale = 0;
    for (i = m; i <= high; i++) {
      scale = scale + Math.abs(H.get(i, m - 1));
    }

    if (scale !== 0) {
      h = 0;
      for (i = high; i >= m; i--) {
        ort[i] = H.get(i, m - 1) / scale;
        h += ort[i] * ort[i];
      }

      g = Math.sqrt(h);
      if (ort[m] > 0) {
        g = -g;
      }

      h = h - ort[m] * g;
      ort[m] = ort[m] - g;

      for (j = m; j < n; j++) {
        f = 0;
        for (i = high; i >= m; i--) {
          f += ort[i] * H.get(i, j);
        }

        f = f / h;
        for (i = m; i <= high; i++) {
          H.set(i, j, H.get(i, j) - f * ort[i]);
        }
      }

      for (i = 0; i <= high; i++) {
        f = 0;
        for (j = high; j >= m; j--) {
          f += ort[j] * H.get(i, j);
        }

        f = f / h;
        for (j = m; j <= high; j++) {
          H.set(i, j, H.get(i, j) - f * ort[j]);
        }
      }

      ort[m] = scale * ort[m];
      H.set(m, m - 1, scale * g);
    }
  }

  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
      V.set(i, j, i === j ? 1 : 0);
    }
  }

  for (m = high - 1; m >= low + 1; m--) {
    if (H.get(m, m - 1) !== 0) {
      for (i = m + 1; i <= high; i++) {
        ort[i] = H.get(i, m - 1);
      }

      for (j = m; j <= high; j++) {
        g = 0;
        for (i = m; i <= high; i++) {
          g += ort[i] * V.get(i, j);
        }

        g = g / ort[m] / H.get(m, m - 1);
        for (i = m; i <= high; i++) {
          V.set(i, j, V.get(i, j) + g * ort[i]);
        }
      }
    }
  }
}

function hqr2(nn, e, d, V, H) {
  let n = nn - 1;
  let low = 0;
  let high = nn - 1;
  let eps = Number.EPSILON;
  let exshift = 0;
  let norm = 0;
  let p = 0;
  let q = 0;
  let r = 0;
  let s = 0;
  let z = 0;
  let iter = 0;
  let i, j, k, l, m, t, w, x, y;
  let ra, sa, vr, vi;
  let notlast, cdivres;

  for (i = 0; i < nn; i++) {
    if (i < low || i > high) {
      d[i] = H.get(i, i);
      e[i] = 0;
    }

    for (j = Math.max(i - 1, 0); j < nn; j++) {
      norm = norm + Math.abs(H.get(i, j));
    }
  }

  while (n >= low) {
    l = n;
    while (l > low) {
      s = Math.abs(H.get(l - 1, l - 1)) + Math.abs(H.get(l, l));
      if (s === 0) {
        s = norm;
      }
      if (Math.abs(H.get(l, l - 1)) < eps * s) {
        break;
      }
      l--;
    }

    if (l === n) {
      H.set(n, n, H.get(n, n) + exshift);
      d[n] = H.get(n, n);
      e[n] = 0;
      n--;
      iter = 0;
    } else if (l === n - 1) {
      w = H.get(n, n - 1) * H.get(n - 1, n);
      p = (H.get(n - 1, n - 1) - H.get(n, n)) / 2;
      q = p * p + w;
      z = Math.sqrt(Math.abs(q));
      H.set(n, n, H.get(n, n) + exshift);
      H.set(n - 1, n - 1, H.get(n - 1, n - 1) + exshift);
      x = H.get(n, n);

      if (q >= 0) {
        z = p >= 0 ? p + z : p - z;
        d[n - 1] = x + z;
        d[n] = d[n - 1];
        if (z !== 0) {
          d[n] = x - w / z;
        }
        e[n - 1] = 0;
        e[n] = 0;
        x = H.get(n, n - 1);
        s = Math.abs(x) + Math.abs(z);
        p = x / s;
        q = z / s;
        r = Math.sqrt(p * p + q * q);
        p = p / r;
        q = q / r;

        for (j = n - 1; j < nn; j++) {
          z = H.get(n - 1, j);
          H.set(n - 1, j, q * z + p * H.get(n, j));
          H.set(n, j, q * H.get(n, j) - p * z);
        }

        for (i = 0; i <= n; i++) {
          z = H.get(i, n - 1);
          H.set(i, n - 1, q * z + p * H.get(i, n));
          H.set(i, n, q * H.get(i, n) - p * z);
        }

        for (i = low; i <= high; i++) {
          z = V.get(i, n - 1);
          V.set(i, n - 1, q * z + p * V.get(i, n));
          V.set(i, n, q * V.get(i, n) - p * z);
        }
      } else {
        d[n - 1] = x + p;
        d[n] = x + p;
        e[n - 1] = z;
        e[n] = -z;
      }

      n = n - 2;
      iter = 0;
    } else {
      x = H.get(n, n);
      y = 0;
      w = 0;
      if (l < n) {
        y = H.get(n - 1, n - 1);
        w = H.get(n, n - 1) * H.get(n - 1, n);
      }

      if (iter === 10) {
        exshift += x;
        for (i = low; i <= n; i++) {
          H.set(i, i, H.get(i, i) - x);
        }
        s = Math.abs(H.get(n, n - 1)) + Math.abs(H.get(n - 1, n - 2));
        x = y = 0.75 * s;
        w = -0.4375 * s * s;
      }

      if (iter === 30) {
        s = (y - x) / 2;
        s = s * s + w;
        if (s > 0) {
          s = Math.sqrt(s);
          if (y < x) {
            s = -s;
          }
          s = x - w / ((y - x) / 2 + s);
          for (i = low; i <= n; i++) {
            H.set(i, i, H.get(i, i) - s);
          }
          exshift += s;
          x = y = w = 0.964;
        }
      }

      iter = iter + 1;

      m = n - 2;
      while (m >= l) {
        z = H.get(m, m);
        r = x - z;
        s = y - z;
        p = (r * s - w) / H.get(m + 1, m) + H.get(m, m + 1);
        q = H.get(m + 1, m + 1) - z - r - s;
        r = H.get(m + 2, m + 1);
        s = Math.abs(p) + Math.abs(q) + Math.abs(r);
        p = p / s;
        q = q / s;
        r = r / s;
        if (m === l) {
          break;
        }
        if (
          Math.abs(H.get(m, m - 1)) * (Math.abs(q) + Math.abs(r)) <
          eps *
            (Math.abs(p) *
              (Math.abs(H.get(m - 1, m - 1)) +
                Math.abs(z) +
                Math.abs(H.get(m + 1, m + 1))))
        ) {
          break;
        }
        m--;
      }

      for (i = m + 2; i <= n; i++) {
        H.set(i, i - 2, 0);
        if (i > m + 2) {
          H.set(i, i - 3, 0);
        }
      }

      for (k = m; k <= n - 1; k++) {
        notlast = k !== n - 1;
        if (k !== m) {
          p = H.get(k, k - 1);
          q = H.get(k + 1, k - 1);
          r = notlast ? H.get(k + 2, k - 1) : 0;
          x = Math.abs(p) + Math.abs(q) + Math.abs(r);
          if (x !== 0) {
            p = p / x;
            q = q / x;
            r = r / x;
          }
        }

        if (x === 0) {
          break;
        }

        s = Math.sqrt(p * p + q * q + r * r);
        if (p < 0) {
          s = -s;
        }

        if (s !== 0) {
          if (k !== m) {
            H.set(k, k - 1, -s * x);
          } else if (l !== m) {
            H.set(k, k - 1, -H.get(k, k - 1));
          }

          p = p + s;
          x = p / s;
          y = q / s;
          z = r / s;
          q = q / p;
          r = r / p;

          for (j = k; j < nn; j++) {
            p = H.get(k, j) + q * H.get(k + 1, j);
            if (notlast) {
              p = p + r * H.get(k + 2, j);
              H.set(k + 2, j, H.get(k + 2, j) - p * z);
            }

            H.set(k, j, H.get(k, j) - p * x);
            H.set(k + 1, j, H.get(k + 1, j) - p * y);
          }

          for (i = 0; i <= Math.min(n, k + 3); i++) {
            p = x * H.get(i, k) + y * H.get(i, k + 1);
            if (notlast) {
              p = p + z * H.get(i, k + 2);
              H.set(i, k + 2, H.get(i, k + 2) - p * r);
            }

            H.set(i, k, H.get(i, k) - p);
            H.set(i, k + 1, H.get(i, k + 1) - p * q);
          }

          for (i = low; i <= high; i++) {
            p = x * V.get(i, k) + y * V.get(i, k + 1);
            if (notlast) {
              p = p + z * V.get(i, k + 2);
              V.set(i, k + 2, V.get(i, k + 2) - p * r);
            }

            V.set(i, k, V.get(i, k) - p);
            V.set(i, k + 1, V.get(i, k + 1) - p * q);
          }
        }
      }
    }
  }

  if (norm === 0) {
    return;
  }

  for (n = nn - 1; n >= 0; n--) {
    p = d[n];
    q = e[n];

    if (q === 0) {
      l = n;
      H.set(n, n, 1);
      for (i = n - 1; i >= 0; i--) {
        w = H.get(i, i) - p;
        r = 0;
        for (j = l; j <= n; j++) {
          r = r + H.get(i, j) * H.get(j, n);
        }

        if (e[i] < 0) {
          z = w;
          s = r;
        } else {
          l = i;
          if (e[i] === 0) {
            H.set(i, n, w !== 0 ? -r / w : -r / (eps * norm));
          } else {
            x = H.get(i, i + 1);
            y = H.get(i + 1, i);
            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
            t = (x * s - z * r) / q;
            H.set(i, n, t);
            H.set(
              i + 1,
              n,
              Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z,
            );
          }

          t = Math.abs(H.get(i, n));
          if (eps * t * t > 1) {
            for (j = i; j <= n; j++) {
              H.set(j, n, H.get(j, n) / t);
            }
          }
        }
      }
    } else if (q < 0) {
      l = n - 1;

      if (Math.abs(H.get(n, n - 1)) > Math.abs(H.get(n - 1, n))) {
        H.set(n - 1, n - 1, q / H.get(n, n - 1));
        H.set(n - 1, n, -(H.get(n, n) - p) / H.get(n, n - 1));
      } else {
        cdivres = cdiv(0, -H.get(n - 1, n), H.get(n - 1, n - 1) - p, q);
        H.set(n - 1, n - 1, cdivres[0]);
        H.set(n - 1, n, cdivres[1]);
      }

      H.set(n, n - 1, 0);
      H.set(n, n, 1);
      for (i = n - 2; i >= 0; i--) {
        ra = 0;
        sa = 0;
        for (j = l; j <= n; j++) {
          ra = ra + H.get(i, j) * H.get(j, n - 1);
          sa = sa + H.get(i, j) * H.get(j, n);
        }

        w = H.get(i, i) - p;

        if (e[i] < 0) {
          z = w;
          r = ra;
          s = sa;
        } else {
          l = i;
          if (e[i] === 0) {
            cdivres = cdiv(-ra, -sa, w, q);
            H.set(i, n - 1, cdivres[0]);
            H.set(i, n, cdivres[1]);
          } else {
            x = H.get(i, i + 1);
            y = H.get(i + 1, i);
            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
            vi = (d[i] - p) * 2 * q;
            if (vr === 0 && vi === 0) {
              vr =
                eps *
                norm *
                (Math.abs(w) +
                  Math.abs(q) +
                  Math.abs(x) +
                  Math.abs(y) +
                  Math.abs(z));
            }
            cdivres = cdiv(
              x * r - z * ra + q * sa,
              x * s - z * sa - q * ra,
              vr,
              vi,
            );
            H.set(i, n - 1, cdivres[0]);
            H.set(i, n, cdivres[1]);
            if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
              H.set(
                i + 1,
                n - 1,
                (-ra - w * H.get(i, n - 1) + q * H.get(i, n)) / x,
              );
              H.set(
                i + 1,
                n,
                (-sa - w * H.get(i, n) - q * H.get(i, n - 1)) / x,
              );
            } else {
              cdivres = cdiv(
                -r - y * H.get(i, n - 1),
                -s - y * H.get(i, n),
                z,
                q,
              );
              H.set(i + 1, n - 1, cdivres[0]);
              H.set(i + 1, n, cdivres[1]);
            }
          }

          t = Math.max(Math.abs(H.get(i, n - 1)), Math.abs(H.get(i, n)));
          if (eps * t * t > 1) {
            for (j = i; j <= n; j++) {
              H.set(j, n - 1, H.get(j, n - 1) / t);
              H.set(j, n, H.get(j, n) / t);
            }
          }
        }
      }
    }
  }

  for (i = 0; i < nn; i++) {
    if (i < low || i > high) {
      for (j = i; j < nn; j++) {
        V.set(i, j, H.get(i, j));
      }
    }
  }

  for (j = nn - 1; j >= low; j--) {
    for (i = low; i <= high; i++) {
      z = 0;
      for (k = low; k <= Math.min(j, high); k++) {
        z = z + V.get(i, k) * H.get(k, j);
      }
      V.set(i, j, z);
    }
  }
}

function cdiv(xr, xi, yr, yi) {
  let r, d;
  if (Math.abs(yr) > Math.abs(yi)) {
    r = yi / yr;
    d = yr + r * yi;
    return [(xr + r * xi) / d, (xi - r * xr) / d];
  } else {
    r = yr / yi;
    d = yi + r * yr;
    return [(r * xr + xi) / d, (r * xi - xr) / d];
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/lu.js":
/*!*********************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/lu.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LuDecomposition; });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ "./node_modules/ml-matrix/src/matrix.js");
/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wrap/WrapperMatrix2D */ "./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js");



class LuDecomposition {
  constructor(matrix) {
    matrix = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__["default"].checkMatrix(matrix);

    let lu = matrix.clone();
    let rows = lu.rows;
    let columns = lu.columns;
    let pivotVector = new Float64Array(rows);
    let pivotSign = 1;
    let i, j, k, p, s, t, v;
    let LUcolj, kmax;

    for (i = 0; i < rows; i++) {
      pivotVector[i] = i;
    }

    LUcolj = new Float64Array(rows);

    for (j = 0; j < columns; j++) {
      for (i = 0; i < rows; i++) {
        LUcolj[i] = lu.get(i, j);
      }

      for (i = 0; i < rows; i++) {
        kmax = Math.min(i, j);
        s = 0;
        for (k = 0; k < kmax; k++) {
          s += lu.get(i, k) * LUcolj[k];
        }
        LUcolj[i] -= s;
        lu.set(i, j, LUcolj[i]);
      }

      p = j;
      for (i = j + 1; i < rows; i++) {
        if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
          p = i;
        }
      }

      if (p !== j) {
        for (k = 0; k < columns; k++) {
          t = lu.get(p, k);
          lu.set(p, k, lu.get(j, k));
          lu.set(j, k, t);
        }

        v = pivotVector[p];
        pivotVector[p] = pivotVector[j];
        pivotVector[j] = v;

        pivotSign = -pivotSign;
      }

      if (j < rows && lu.get(j, j) !== 0) {
        for (i = j + 1; i < rows; i++) {
          lu.set(i, j, lu.get(i, j) / lu.get(j, j));
        }
      }
    }

    this.LU = lu;
    this.pivotVector = pivotVector;
    this.pivotSign = pivotSign;
  }

  isSingular() {
    let data = this.LU;
    let col = data.columns;
    for (let j = 0; j < col; j++) {
      if (data.get(j, j) === 0) {
        return true;
      }
    }
    return false;
  }

  solve(value) {
    value = _matrix__WEBPACK_IMPORTED_MODULE_0__["default"].checkMatrix(value);

    let lu = this.LU;
    let rows = lu.rows;

    if (rows !== value.rows) {
      throw new Error('Invalid matrix dimensions');
    }
    if (this.isSingular()) {
      throw new Error('LU matrix is singular');
    }

    let count = value.columns;
    let X = value.subMatrixRow(this.pivotVector, 0, count - 1);
    let columns = lu.columns;
    let i, j, k;

    for (k = 0; k < columns; k++) {
      for (i = k + 1; i < columns; i++) {
        for (j = 0; j < count; j++) {
          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));
        }
      }
    }
    for (k = columns - 1; k >= 0; k--) {
      for (j = 0; j < count; j++) {
        X.set(k, j, X.get(k, j) / lu.get(k, k));
      }
      for (i = 0; i < k; i++) {
        for (j = 0; j < count; j++) {
          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));
        }
      }
    }
    return X;
  }

  get determinant() {
    let data = this.LU;
    if (!data.isSquare()) {
      throw new Error('Matrix must be square');
    }
    let determinant = this.pivotSign;
    let col = data.columns;
    for (let j = 0; j < col; j++) {
      determinant *= data.get(j, j);
    }
    return determinant;
  }

  get lowerTriangularMatrix() {
    let data = this.LU;
    let rows = data.rows;
    let columns = data.columns;
    let X = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        if (i > j) {
          X.set(i, j, data.get(i, j));
        } else if (i === j) {
          X.set(i, j, 1);
        } else {
          X.set(i, j, 0);
        }
      }
    }
    return X;
  }

  get upperTriangularMatrix() {
    let data = this.LU;
    let rows = data.rows;
    let columns = data.columns;
    let X = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        if (i <= j) {
          X.set(i, j, data.get(i, j));
        } else {
          X.set(i, j, 0);
        }
      }
    }
    return X;
  }

  get pivotPermutationVector() {
    return Array.from(this.pivotVector);
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/nipals.js":
/*!*************************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/nipals.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return nipals; });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ "./node_modules/ml-matrix/src/matrix.js");
/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wrap/WrapperMatrix2D */ "./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js");



class nipals {
  constructor(X, options = {}) {
    X = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__["default"].checkMatrix(X);
    let { Y } = options;
    const {
      scaleScores = false,
      maxIterations = 1000,
      terminationCriteria = 1e-10,
    } = options;

    let u;
    if (Y) {
      if (Array.isArray(Y) && typeof Y[0] === 'number') {
        Y = _matrix__WEBPACK_IMPORTED_MODULE_0__["default"].columnVector(Y);
      } else {
        Y = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__["default"].checkMatrix(Y);
      }
      if (!Y.isColumnVector() || Y.rows !== X.rows) {
        throw new Error('Y must be a column vector of length X.rows');
      }
      u = Y;
    } else {
      u = X.getColumnVector(0);
    }

    let diff = 1;
    let t, q, w, tOld;

    for (
      let counter = 0;
      counter < maxIterations && diff > terminationCriteria;
      counter++
    ) {
      w = X.transpose().mmul(u).div(u.transpose().mmul(u).get(0, 0));
      w = w.div(w.norm());

      t = X.mmul(w).div(w.transpose().mmul(w).get(0, 0));

      if (counter > 0) {
        diff = t.clone().sub(tOld).pow(2).sum();
      }
      tOld = t.clone();

      if (Y) {
        q = Y.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
        q = q.div(q.norm());

        u = Y.mmul(q).div(q.transpose().mmul(q).get(0, 0));
      } else {
        u = t;
      }
    }

    if (Y) {
      let p = X.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
      p = p.div(p.norm());
      let xResidual = X.clone().sub(t.clone().mmul(p.transpose()));
      let residual = u.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
      let yResidual = Y.clone().sub(
        t.clone().mulS(residual.get(0, 0)).mmul(q.transpose()),
      );

      this.t = t;
      this.p = p.transpose();
      this.w = w.transpose();
      this.q = q;
      this.u = u;
      this.s = t.transpose().mmul(t);
      this.xResidual = xResidual;
      this.yResidual = yResidual;
      this.betas = residual;
    } else {
      this.w = w.transpose();
      this.s = t.transpose().mmul(t).sqrt();
      if (scaleScores) {
        this.t = t.clone().div(this.s.get(0, 0));
      } else {
        this.t = t;
      }
      this.xResidual = X.sub(t.mmul(w.transpose()));
    }
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/qr.js":
/*!*********************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/qr.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return QrDecomposition; });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ "./node_modules/ml-matrix/src/matrix.js");
/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wrap/WrapperMatrix2D */ "./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/ml-matrix/src/dc/util.js");





class QrDecomposition {
  constructor(value) {
    value = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__["default"].checkMatrix(value);

    let qr = value.clone();
    let m = value.rows;
    let n = value.columns;
    let rdiag = new Float64Array(n);
    let i, j, k, s;

    for (k = 0; k < n; k++) {
      let nrm = 0;
      for (i = k; i < m; i++) {
        nrm = Object(_util__WEBPACK_IMPORTED_MODULE_2__["hypotenuse"])(nrm, qr.get(i, k));
      }
      if (nrm !== 0) {
        if (qr.get(k, k) < 0) {
          nrm = -nrm;
        }
        for (i = k; i < m; i++) {
          qr.set(i, k, qr.get(i, k) / nrm);
        }
        qr.set(k, k, qr.get(k, k) + 1);
        for (j = k + 1; j < n; j++) {
          s = 0;
          for (i = k; i < m; i++) {
            s += qr.get(i, k) * qr.get(i, j);
          }
          s = -s / qr.get(k, k);
          for (i = k; i < m; i++) {
            qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));
          }
        }
      }
      rdiag[k] = -nrm;
    }

    this.QR = qr;
    this.Rdiag = rdiag;
  }

  solve(value) {
    value = _matrix__WEBPACK_IMPORTED_MODULE_0__["default"].checkMatrix(value);

    let qr = this.QR;
    let m = qr.rows;

    if (value.rows !== m) {
      throw new Error('Matrix row dimensions must agree');
    }
    if (!this.isFullRank()) {
      throw new Error('Matrix is rank deficient');
    }

    let count = value.columns;
    let X = value.clone();
    let n = qr.columns;
    let i, j, k, s;

    for (k = 0; k < n; k++) {
      for (j = 0; j < count; j++) {
        s = 0;
        for (i = k; i < m; i++) {
          s += qr.get(i, k) * X.get(i, j);
        }
        s = -s / qr.get(k, k);
        for (i = k; i < m; i++) {
          X.set(i, j, X.get(i, j) + s * qr.get(i, k));
        }
      }
    }
    for (k = n - 1; k >= 0; k--) {
      for (j = 0; j < count; j++) {
        X.set(k, j, X.get(k, j) / this.Rdiag[k]);
      }
      for (i = 0; i < k; i++) {
        for (j = 0; j < count; j++) {
          X.set(i, j, X.get(i, j) - X.get(k, j) * qr.get(i, k));
        }
      }
    }

    return X.subMatrix(0, n - 1, 0, count - 1);
  }

  isFullRank() {
    let columns = this.QR.columns;
    for (let i = 0; i < columns; i++) {
      if (this.Rdiag[i] === 0) {
        return false;
      }
    }
    return true;
  }

  get upperTriangularMatrix() {
    let qr = this.QR;
    let n = qr.columns;
    let X = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](n, n);
    let i, j;
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        if (i < j) {
          X.set(i, j, qr.get(i, j));
        } else if (i === j) {
          X.set(i, j, this.Rdiag[i]);
        } else {
          X.set(i, j, 0);
        }
      }
    }
    return X;
  }

  get orthogonalMatrix() {
    let qr = this.QR;
    let rows = qr.rows;
    let columns = qr.columns;
    let X = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](rows, columns);
    let i, j, k, s;

    for (k = columns - 1; k >= 0; k--) {
      for (i = 0; i < rows; i++) {
        X.set(i, k, 0);
      }
      X.set(k, k, 1);
      for (j = k; j < columns; j++) {
        if (qr.get(k, k) !== 0) {
          s = 0;
          for (i = k; i < rows; i++) {
            s += qr.get(i, k) * X.get(i, j);
          }

          s = -s / qr.get(k, k);

          for (i = k; i < rows; i++) {
            X.set(i, j, X.get(i, j) + s * qr.get(i, k));
          }
        }
      }
    }
    return X;
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/svd.js":
/*!**********************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/svd.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SingularValueDecomposition; });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ "./node_modules/ml-matrix/src/matrix.js");
/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wrap/WrapperMatrix2D */ "./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/ml-matrix/src/dc/util.js");





class SingularValueDecomposition {
  constructor(value, options = {}) {
    value = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__["default"].checkMatrix(value);

    let m = value.rows;
    let n = value.columns;

    const {
      computeLeftSingularVectors = true,
      computeRightSingularVectors = true,
      autoTranspose = false,
    } = options;

    let wantu = Boolean(computeLeftSingularVectors);
    let wantv = Boolean(computeRightSingularVectors);

    let swapped = false;
    let a;
    if (m < n) {
      if (!autoTranspose) {
        a = value.clone();
        // eslint-disable-next-line no-console
        console.warn(
          'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose',
        );
      } else {
        a = value.transpose();
        m = a.rows;
        n = a.columns;
        swapped = true;
        let aux = wantu;
        wantu = wantv;
        wantv = aux;
      }
    } else {
      a = value.clone();
    }

    let nu = Math.min(m, n);
    let ni = Math.min(m + 1, n);
    let s = new Float64Array(ni);
    let U = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](m, nu);
    let V = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](n, n);

    let e = new Float64Array(n);
    let work = new Float64Array(m);

    let si = new Float64Array(ni);
    for (let i = 0; i < ni; i++) si[i] = i;

    let nct = Math.min(m - 1, n);
    let nrt = Math.max(0, Math.min(n - 2, m));
    let mrc = Math.max(nct, nrt);

    for (let k = 0; k < mrc; k++) {
      if (k < nct) {
        s[k] = 0;
        for (let i = k; i < m; i++) {
          s[k] = Object(_util__WEBPACK_IMPORTED_MODULE_2__["hypotenuse"])(s[k], a.get(i, k));
        }
        if (s[k] !== 0) {
          if (a.get(k, k) < 0) {
            s[k] = -s[k];
          }
          for (let i = k; i < m; i++) {
            a.set(i, k, a.get(i, k) / s[k]);
          }
          a.set(k, k, a.get(k, k) + 1);
        }
        s[k] = -s[k];
      }

      for (let j = k + 1; j < n; j++) {
        if (k < nct && s[k] !== 0) {
          let t = 0;
          for (let i = k; i < m; i++) {
            t += a.get(i, k) * a.get(i, j);
          }
          t = -t / a.get(k, k);
          for (let i = k; i < m; i++) {
            a.set(i, j, a.get(i, j) + t * a.get(i, k));
          }
        }
        e[j] = a.get(k, j);
      }

      if (wantu && k < nct) {
        for (let i = k; i < m; i++) {
          U.set(i, k, a.get(i, k));
        }
      }

      if (k < nrt) {
        e[k] = 0;
        for (let i = k + 1; i < n; i++) {
          e[k] = Object(_util__WEBPACK_IMPORTED_MODULE_2__["hypotenuse"])(e[k], e[i]);
        }
        if (e[k] !== 0) {
          if (e[k + 1] < 0) {
            e[k] = 0 - e[k];
          }
          for (let i = k + 1; i < n; i++) {
            e[i] /= e[k];
          }
          e[k + 1] += 1;
        }
        e[k] = -e[k];
        if (k + 1 < m && e[k] !== 0) {
          for (let i = k + 1; i < m; i++) {
            work[i] = 0;
          }
          for (let i = k + 1; i < m; i++) {
            for (let j = k + 1; j < n; j++) {
              work[i] += e[j] * a.get(i, j);
            }
          }
          for (let j = k + 1; j < n; j++) {
            let t = -e[j] / e[k + 1];
            for (let i = k + 1; i < m; i++) {
              a.set(i, j, a.get(i, j) + t * work[i]);
            }
          }
        }
        if (wantv) {
          for (let i = k + 1; i < n; i++) {
            V.set(i, k, e[i]);
          }
        }
      }
    }

    let p = Math.min(n, m + 1);
    if (nct < n) {
      s[nct] = a.get(nct, nct);
    }
    if (m < p) {
      s[p - 1] = 0;
    }
    if (nrt + 1 < p) {
      e[nrt] = a.get(nrt, p - 1);
    }
    e[p - 1] = 0;

    if (wantu) {
      for (let j = nct; j < nu; j++) {
        for (let i = 0; i < m; i++) {
          U.set(i, j, 0);
        }
        U.set(j, j, 1);
      }
      for (let k = nct - 1; k >= 0; k--) {
        if (s[k] !== 0) {
          for (let j = k + 1; j < nu; j++) {
            let t = 0;
            for (let i = k; i < m; i++) {
              t += U.get(i, k) * U.get(i, j);
            }
            t = -t / U.get(k, k);
            for (let i = k; i < m; i++) {
              U.set(i, j, U.get(i, j) + t * U.get(i, k));
            }
          }
          for (let i = k; i < m; i++) {
            U.set(i, k, -U.get(i, k));
          }
          U.set(k, k, 1 + U.get(k, k));
          for (let i = 0; i < k - 1; i++) {
            U.set(i, k, 0);
          }
        } else {
          for (let i = 0; i < m; i++) {
            U.set(i, k, 0);
          }
          U.set(k, k, 1);
        }
      }
    }

    if (wantv) {
      for (let k = n - 1; k >= 0; k--) {
        if (k < nrt && e[k] !== 0) {
          for (let j = k + 1; j < n; j++) {
            let t = 0;
            for (let i = k + 1; i < n; i++) {
              t += V.get(i, k) * V.get(i, j);
            }
            t = -t / V.get(k + 1, k);
            for (let i = k + 1; i < n; i++) {
              V.set(i, j, V.get(i, j) + t * V.get(i, k));
            }
          }
        }
        for (let i = 0; i < n; i++) {
          V.set(i, k, 0);
        }
        V.set(k, k, 1);
      }
    }

    let pp = p - 1;
    let iter = 0;
    let eps = Number.EPSILON;
    while (p > 0) {
      let k, kase;
      for (k = p - 2; k >= -1; k--) {
        if (k === -1) {
          break;
        }
        const alpha =
          Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
        if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
          e[k] = 0;
          break;
        }
      }
      if (k === p - 2) {
        kase = 4;
      } else {
        let ks;
        for (ks = p - 1; ks >= k; ks--) {
          if (ks === k) {
            break;
          }
          let t =
            (ks !== p ? Math.abs(e[ks]) : 0) +
            (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
          if (Math.abs(s[ks]) <= eps * t) {
            s[ks] = 0;
            break;
          }
        }
        if (ks === k) {
          kase = 3;
        } else if (ks === p - 1) {
          kase = 1;
        } else {
          kase = 2;
          k = ks;
        }
      }

      k++;

      switch (kase) {
        case 1: {
          let f = e[p - 2];
          e[p - 2] = 0;
          for (let j = p - 2; j >= k; j--) {
            let t = Object(_util__WEBPACK_IMPORTED_MODULE_2__["hypotenuse"])(s[j], f);
            let cs = s[j] / t;
            let sn = f / t;
            s[j] = t;
            if (j !== k) {
              f = -sn * e[j - 1];
              e[j - 1] = cs * e[j - 1];
            }
            if (wantv) {
              for (let i = 0; i < n; i++) {
                t = cs * V.get(i, j) + sn * V.get(i, p - 1);
                V.set(i, p - 1, -sn * V.get(i, j) + cs * V.get(i, p - 1));
                V.set(i, j, t);
              }
            }
          }
          break;
        }
        case 2: {
          let f = e[k - 1];
          e[k - 1] = 0;
          for (let j = k; j < p; j++) {
            let t = Object(_util__WEBPACK_IMPORTED_MODULE_2__["hypotenuse"])(s[j], f);
            let cs = s[j] / t;
            let sn = f / t;
            s[j] = t;
            f = -sn * e[j];
            e[j] = cs * e[j];
            if (wantu) {
              for (let i = 0; i < m; i++) {
                t = cs * U.get(i, j) + sn * U.get(i, k - 1);
                U.set(i, k - 1, -sn * U.get(i, j) + cs * U.get(i, k - 1));
                U.set(i, j, t);
              }
            }
          }
          break;
        }
        case 3: {
          const scale = Math.max(
            Math.abs(s[p - 1]),
            Math.abs(s[p - 2]),
            Math.abs(e[p - 2]),
            Math.abs(s[k]),
            Math.abs(e[k]),
          );
          const sp = s[p - 1] / scale;
          const spm1 = s[p - 2] / scale;
          const epm1 = e[p - 2] / scale;
          const sk = s[k] / scale;
          const ek = e[k] / scale;
          const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
          const c = sp * epm1 * (sp * epm1);
          let shift = 0;
          if (b !== 0 || c !== 0) {
            if (b < 0) {
              shift = 0 - Math.sqrt(b * b + c);
            } else {
              shift = Math.sqrt(b * b + c);
            }
            shift = c / (b + shift);
          }
          let f = (sk + sp) * (sk - sp) + shift;
          let g = sk * ek;
          for (let j = k; j < p - 1; j++) {
            let t = Object(_util__WEBPACK_IMPORTED_MODULE_2__["hypotenuse"])(f, g);
            if (t === 0) t = Number.MIN_VALUE;
            let cs = f / t;
            let sn = g / t;
            if (j !== k) {
              e[j - 1] = t;
            }
            f = cs * s[j] + sn * e[j];
            e[j] = cs * e[j] - sn * s[j];
            g = sn * s[j + 1];
            s[j + 1] = cs * s[j + 1];
            if (wantv) {
              for (let i = 0; i < n; i++) {
                t = cs * V.get(i, j) + sn * V.get(i, j + 1);
                V.set(i, j + 1, -sn * V.get(i, j) + cs * V.get(i, j + 1));
                V.set(i, j, t);
              }
            }
            t = Object(_util__WEBPACK_IMPORTED_MODULE_2__["hypotenuse"])(f, g);
            if (t === 0) t = Number.MIN_VALUE;
            cs = f / t;
            sn = g / t;
            s[j] = t;
            f = cs * e[j] + sn * s[j + 1];
            s[j + 1] = -sn * e[j] + cs * s[j + 1];
            g = sn * e[j + 1];
            e[j + 1] = cs * e[j + 1];
            if (wantu && j < m - 1) {
              for (let i = 0; i < m; i++) {
                t = cs * U.get(i, j) + sn * U.get(i, j + 1);
                U.set(i, j + 1, -sn * U.get(i, j) + cs * U.get(i, j + 1));
                U.set(i, j, t);
              }
            }
          }
          e[p - 2] = f;
          iter = iter + 1;
          break;
        }
        case 4: {
          if (s[k] <= 0) {
            s[k] = s[k] < 0 ? -s[k] : 0;
            if (wantv) {
              for (let i = 0; i <= pp; i++) {
                V.set(i, k, -V.get(i, k));
              }
            }
          }
          while (k < pp) {
            if (s[k] >= s[k + 1]) {
              break;
            }
            let t = s[k];
            s[k] = s[k + 1];
            s[k + 1] = t;
            if (wantv && k < n - 1) {
              for (let i = 0; i < n; i++) {
                t = V.get(i, k + 1);
                V.set(i, k + 1, V.get(i, k));
                V.set(i, k, t);
              }
            }
            if (wantu && k < m - 1) {
              for (let i = 0; i < m; i++) {
                t = U.get(i, k + 1);
                U.set(i, k + 1, U.get(i, k));
                U.set(i, k, t);
              }
            }
            k++;
          }
          iter = 0;
          p--;
          break;
        }
        // no default
      }
    }

    if (swapped) {
      let tmp = V;
      V = U;
      U = tmp;
    }

    this.m = m;
    this.n = n;
    this.s = s;
    this.U = U;
    this.V = V;
  }

  solve(value) {
    let Y = value;
    let e = this.threshold;
    let scols = this.s.length;
    let Ls = _matrix__WEBPACK_IMPORTED_MODULE_0__["default"].zeros(scols, scols);

    for (let i = 0; i < scols; i++) {
      if (Math.abs(this.s[i]) <= e) {
        Ls.set(i, i, 0);
      } else {
        Ls.set(i, i, 1 / this.s[i]);
      }
    }

    let U = this.U;
    let V = this.rightSingularVectors;

    let VL = V.mmul(Ls);
    let vrows = V.rows;
    let urows = U.rows;
    let VLU = _matrix__WEBPACK_IMPORTED_MODULE_0__["default"].zeros(vrows, urows);

    for (let i = 0; i < vrows; i++) {
      for (let j = 0; j < urows; j++) {
        let sum = 0;
        for (let k = 0; k < scols; k++) {
          sum += VL.get(i, k) * U.get(j, k);
        }
        VLU.set(i, j, sum);
      }
    }

    return VLU.mmul(Y);
  }

  solveForDiagonal(value) {
    return this.solve(_matrix__WEBPACK_IMPORTED_MODULE_0__["default"].diag(value));
  }

  inverse() {
    let V = this.V;
    let e = this.threshold;
    let vrows = V.rows;
    let vcols = V.columns;
    let X = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](vrows, this.s.length);

    for (let i = 0; i < vrows; i++) {
      for (let j = 0; j < vcols; j++) {
        if (Math.abs(this.s[j]) > e) {
          X.set(i, j, V.get(i, j) / this.s[j]);
        }
      }
    }

    let U = this.U;

    let urows = U.rows;
    let ucols = U.columns;
    let Y = new _matrix__WEBPACK_IMPORTED_MODULE_0__["default"](vrows, urows);

    for (let i = 0; i < vrows; i++) {
      for (let j = 0; j < urows; j++) {
        let sum = 0;
        for (let k = 0; k < ucols; k++) {
          sum += X.get(i, k) * U.get(j, k);
        }
        Y.set(i, j, sum);
      }
    }

    return Y;
  }

  get condition() {
    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
  }

  get norm2() {
    return this.s[0];
  }

  get rank() {
    let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
    let r = 0;
    let s = this.s;
    for (let i = 0, ii = s.length; i < ii; i++) {
      if (s[i] > tol) {
        r++;
      }
    }
    return r;
  }

  get diagonal() {
    return Array.from(this.s);
  }

  get threshold() {
    return (Number.EPSILON / 2) * Math.max(this.m, this.n) * this.s[0];
  }

  get leftSingularVectors() {
    return this.U;
  }

  get rightSingularVectors() {
    return this.V;
  }

  get diagonalMatrix() {
    return _matrix__WEBPACK_IMPORTED_MODULE_0__["default"].diag(this.s);
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/util.js":
/*!***********************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/util.js ***!
  \***********************************************/
/*! exports provided: hypotenuse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hypotenuse", function() { return hypotenuse; });
function hypotenuse(a, b) {
  let r = 0;
  if (Math.abs(a) > Math.abs(b)) {
    r = b / a;
    return Math.abs(a) * Math.sqrt(1 + r * r);
  }
  if (b !== 0) {
    r = a / b;
    return Math.abs(b) * Math.sqrt(1 + r * r);
  }
  return 0;
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/decompositions.js":
/*!******************************************************!*\
  !*** ./node_modules/ml-matrix/src/decompositions.js ***!
  \******************************************************/
/*! exports provided: inverse, solve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solve", function() { return solve; });
/* harmony import */ var _dc_lu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dc/lu */ "./node_modules/ml-matrix/src/dc/lu.js");
/* harmony import */ var _dc_qr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dc/qr */ "./node_modules/ml-matrix/src/dc/qr.js");
/* harmony import */ var _dc_svd__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dc/svd */ "./node_modules/ml-matrix/src/dc/svd.js");
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matrix */ "./node_modules/ml-matrix/src/matrix.js");
/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wrap/WrapperMatrix2D */ "./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js");






function inverse(matrix, useSVD = false) {
  matrix = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_4__["default"].checkMatrix(matrix);
  if (useSVD) {
    return new _dc_svd__WEBPACK_IMPORTED_MODULE_2__["default"](matrix).inverse();
  } else {
    return solve(matrix, _matrix__WEBPACK_IMPORTED_MODULE_3__["default"].eye(matrix.rows));
  }
}

function solve(leftHandSide, rightHandSide, useSVD = false) {
  leftHandSide = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_4__["default"].checkMatrix(leftHandSide);
  rightHandSide = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_4__["default"].checkMatrix(rightHandSide);
  if (useSVD) {
    return new _dc_svd__WEBPACK_IMPORTED_MODULE_2__["default"](leftHandSide).solve(rightHandSide);
  } else {
    return leftHandSide.isSquare()
      ? new _dc_lu__WEBPACK_IMPORTED_MODULE_0__["default"](leftHandSide).solve(rightHandSide)
      : new _dc_qr__WEBPACK_IMPORTED_MODULE_1__["default"](leftHandSide).solve(rightHandSide);
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/determinant.js":
/*!***************************************************!*\
  !*** ./node_modules/ml-matrix/src/determinant.js ***!
  \***************************************************/
/*! exports provided: determinant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony import */ var _dc_lu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dc/lu */ "./node_modules/ml-matrix/src/dc/lu.js");
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix */ "./node_modules/ml-matrix/src/matrix.js");
/* harmony import */ var _views_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./views/selection */ "./node_modules/ml-matrix/src/views/selection.js");




function determinant(matrix) {
  matrix = _matrix__WEBPACK_IMPORTED_MODULE_1__["default"].checkMatrix(matrix);
  if (matrix.isSquare()) {
    let a, b, c, d;
    if (matrix.columns === 2) {
      // 2 x 2 matrix
      a = matrix.get(0, 0);
      b = matrix.get(0, 1);
      c = matrix.get(1, 0);
      d = matrix.get(1, 1);

      return a * d - b * c;
    } else if (matrix.columns === 3) {
      // 3 x 3 matrix
      let subMatrix0, subMatrix1, subMatrix2;
      subMatrix0 = new _views_selection__WEBPACK_IMPORTED_MODULE_2__["default"](matrix, [1, 2], [1, 2]);
      subMatrix1 = new _views_selection__WEBPACK_IMPORTED_MODULE_2__["default"](matrix, [1, 2], [0, 2]);
      subMatrix2 = new _views_selection__WEBPACK_IMPORTED_MODULE_2__["default"](matrix, [1, 2], [0, 1]);
      a = matrix.get(0, 0);
      b = matrix.get(0, 1);
      c = matrix.get(0, 2);

      return (
        a * determinant(subMatrix0) -
        b * determinant(subMatrix1) +
        c * determinant(subMatrix2)
      );
    } else {
      // general purpose determinant using the LU decomposition
      return new _dc_lu__WEBPACK_IMPORTED_MODULE_0__["default"](matrix).determinant;
    }
  } else {
    throw Error('determinant can only be calculated for a square matrix');
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ml-matrix/src/index.js ***!
  \*********************************************/
/*! exports provided: AbstractMatrix, default, Matrix, MatrixColumnView, MatrixColumnSelectionView, MatrixFlipColumnView, MatrixFlipRowView, MatrixRowView, MatrixRowSelectionView, MatrixSelectionView, MatrixSubView, MatrixTransposeView, wrap, WrapperMatrix1D, WrapperMatrix2D, solve, inverse, determinant, linearDependencies, pseudoInverse, covariance, correlation, SingularValueDecomposition, SVD, EigenvalueDecomposition, EVD, CholeskyDecomposition, CHO, LuDecomposition, LU, QrDecomposition, QR, Nipals, NIPALS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix */ "./node_modules/ml-matrix/src/matrix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AbstractMatrix", function() { return _matrix__WEBPACK_IMPORTED_MODULE_0__["AbstractMatrix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _matrix__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Matrix", function() { return _matrix__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _views_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./views/index */ "./node_modules/ml-matrix/src/views/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixColumnView", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__["MatrixColumnView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixColumnSelectionView", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__["MatrixColumnSelectionView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixFlipColumnView", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__["MatrixFlipColumnView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixFlipRowView", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__["MatrixFlipRowView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixRowView", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__["MatrixRowView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixRowSelectionView", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__["MatrixRowSelectionView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixSelectionView", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__["MatrixSelectionView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixSubView", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__["MatrixSubView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixTransposeView", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__["MatrixTransposeView"]; });

/* harmony import */ var _wrap_wrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wrap/wrap */ "./node_modules/ml-matrix/src/wrap/wrap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return _wrap_wrap__WEBPACK_IMPORTED_MODULE_2__["wrap"]; });

/* harmony import */ var _wrap_WrapperMatrix1D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wrap/WrapperMatrix1D */ "./node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WrapperMatrix1D", function() { return _wrap_WrapperMatrix1D__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wrap/WrapperMatrix2D */ "./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WrapperMatrix2D", function() { return _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _decompositions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./decompositions */ "./node_modules/ml-matrix/src/decompositions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "solve", function() { return _decompositions__WEBPACK_IMPORTED_MODULE_5__["solve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return _decompositions__WEBPACK_IMPORTED_MODULE_5__["inverse"]; });

/* harmony import */ var _determinant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./determinant */ "./node_modules/ml-matrix/src/determinant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return _determinant__WEBPACK_IMPORTED_MODULE_6__["determinant"]; });

/* harmony import */ var _linearDependencies__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./linearDependencies */ "./node_modules/ml-matrix/src/linearDependencies.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linearDependencies", function() { return _linearDependencies__WEBPACK_IMPORTED_MODULE_7__["linearDependencies"]; });

/* harmony import */ var _pseudoInverse__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./pseudoInverse */ "./node_modules/ml-matrix/src/pseudoInverse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pseudoInverse", function() { return _pseudoInverse__WEBPACK_IMPORTED_MODULE_8__["pseudoInverse"]; });

/* harmony import */ var _covariance__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./covariance */ "./node_modules/ml-matrix/src/covariance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "covariance", function() { return _covariance__WEBPACK_IMPORTED_MODULE_9__["covariance"]; });

/* harmony import */ var _correlation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./correlation */ "./node_modules/ml-matrix/src/correlation.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "correlation", function() { return _correlation__WEBPACK_IMPORTED_MODULE_10__["correlation"]; });

/* harmony import */ var _dc_svd_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dc/svd.js */ "./node_modules/ml-matrix/src/dc/svd.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SingularValueDecomposition", function() { return _dc_svd_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SVD", function() { return _dc_svd_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _dc_evd_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./dc/evd.js */ "./node_modules/ml-matrix/src/dc/evd.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EigenvalueDecomposition", function() { return _dc_evd_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EVD", function() { return _dc_evd_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _dc_cholesky_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dc/cholesky.js */ "./node_modules/ml-matrix/src/dc/cholesky.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CholeskyDecomposition", function() { return _dc_cholesky_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CHO", function() { return _dc_cholesky_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _dc_lu_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./dc/lu.js */ "./node_modules/ml-matrix/src/dc/lu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LuDecomposition", function() { return _dc_lu_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LU", function() { return _dc_lu_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _dc_qr_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./dc/qr.js */ "./node_modules/ml-matrix/src/dc/qr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "QrDecomposition", function() { return _dc_qr_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "QR", function() { return _dc_qr_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _dc_nipals_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./dc/nipals.js */ "./node_modules/ml-matrix/src/dc/nipals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Nipals", function() { return _dc_nipals_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NIPALS", function() { return _dc_nipals_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });























/***/ }),

/***/ "./node_modules/ml-matrix/src/inspect.js":
/*!***********************************************!*\
  !*** ./node_modules/ml-matrix/src/inspect.js ***!
  \***********************************************/
/*! exports provided: inspectMatrix, inspectMatrixWithOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inspectMatrix", function() { return inspectMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inspectMatrixWithOptions", function() { return inspectMatrixWithOptions; });
const indent = ' '.repeat(2);
const indentData = ' '.repeat(4);

function inspectMatrix() {
  return inspectMatrixWithOptions(this);
}

function inspectMatrixWithOptions(matrix, options = {}) {
  const { maxRows = 15, maxColumns = 10, maxNumSize = 8 } = options;
  return `${matrix.constructor.name} {
${indent}[
${indentData}${inspectData(matrix, maxRows, maxColumns, maxNumSize)}
${indent}]
${indent}rows: ${matrix.rows}
${indent}columns: ${matrix.columns}
}`;
}

function inspectData(matrix, maxRows, maxColumns, maxNumSize) {
  const { rows, columns } = matrix;
  const maxI = Math.min(rows, maxRows);
  const maxJ = Math.min(columns, maxColumns);
  const result = [];
  for (let i = 0; i < maxI; i++) {
    let line = [];
    for (let j = 0; j < maxJ; j++) {
      line.push(formatNumber(matrix.get(i, j), maxNumSize));
    }
    result.push(`${line.join(' ')}`);
  }
  if (maxJ !== columns) {
    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;
  }
  if (maxI !== rows) {
    result.push(`... ${rows - maxRows} more rows`);
  }
  return result.join(`\n${indentData}`);
}

function formatNumber(num, maxNumSize) {
  const numStr = String(num);
  if (numStr.length <= maxNumSize) {
    return numStr.padEnd(maxNumSize, ' ');
  }
  const precise = num.toPrecision(maxNumSize - 2);
  if (precise.length <= maxNumSize) {
    return precise;
  }
  const exponential = num.toExponential(maxNumSize - 2);
  const eIndex = exponential.indexOf('e');
  const e = exponential.slice(eIndex);
  return exponential.slice(0, maxNumSize - e.length) + e;
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/linearDependencies.js":
/*!**********************************************************!*\
  !*** ./node_modules/ml-matrix/src/linearDependencies.js ***!
  \**********************************************************/
/*! exports provided: linearDependencies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearDependencies", function() { return linearDependencies; });
/* harmony import */ var _dc_svd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dc/svd */ "./node_modules/ml-matrix/src/dc/svd.js");
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix */ "./node_modules/ml-matrix/src/matrix.js");



function xrange(n, exception) {
  let range = [];
  for (let i = 0; i < n; i++) {
    if (i !== exception) {
      range.push(i);
    }
  }
  return range;
}

function dependenciesOneRow(
  error,
  matrix,
  index,
  thresholdValue = 10e-10,
  thresholdError = 10e-10,
) {
  if (error > thresholdError) {
    return new Array(matrix.rows + 1).fill(0);
  } else {
    let returnArray = matrix.addRow(index, [0]);
    for (let i = 0; i < returnArray.rows; i++) {
      if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {
        returnArray.set(i, 0, 0);
      }
    }
    return returnArray.to1DArray();
  }
}

function linearDependencies(matrix, options = {}) {
  const { thresholdValue = 10e-10, thresholdError = 10e-10 } = options;
  matrix = _matrix__WEBPACK_IMPORTED_MODULE_1__["default"].checkMatrix(matrix);

  let n = matrix.rows;
  let results = new _matrix__WEBPACK_IMPORTED_MODULE_1__["default"](n, n);

  for (let i = 0; i < n; i++) {
    let b = _matrix__WEBPACK_IMPORTED_MODULE_1__["default"].columnVector(matrix.getRow(i));
    let Abis = matrix.subMatrixRow(xrange(n, i)).transpose();
    let svd = new _dc_svd__WEBPACK_IMPORTED_MODULE_0__["default"](Abis);
    let x = svd.solve(b);
    let error = _matrix__WEBPACK_IMPORTED_MODULE_1__["default"].sub(b, Abis.mmul(x)).abs().max();
    results.setRow(
      i,
      dependenciesOneRow(error, x, i, thresholdValue, thresholdError),
    );
  }
  return results;
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/mathOperations.js":
/*!******************************************************!*\
  !*** ./node_modules/ml-matrix/src/mathOperations.js ***!
  \******************************************************/
/*! exports provided: installMathOperations */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "installMathOperations", function() { return installMathOperations; });
function installMathOperations(AbstractMatrix, Matrix) {
  AbstractMatrix.prototype.add = function add(value) {
    if (typeof value === 'number') return this.addS(value);
    return this.addM(value);
  };

  AbstractMatrix.prototype.addS = function addS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.addM = function addM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.add = function add(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.add(value);
  };

  AbstractMatrix.prototype.sub = function sub(value) {
    if (typeof value === 'number') return this.subS(value);
    return this.subM(value);
  };

  AbstractMatrix.prototype.subS = function subS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.subM = function subM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.sub = function sub(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sub(value);
  };
  AbstractMatrix.prototype.subtract = AbstractMatrix.prototype.sub;
  AbstractMatrix.prototype.subtractS = AbstractMatrix.prototype.subS;
  AbstractMatrix.prototype.subtractM = AbstractMatrix.prototype.subM;
  AbstractMatrix.subtract = AbstractMatrix.sub;

  AbstractMatrix.prototype.mul = function mul(value) {
    if (typeof value === 'number') return this.mulS(value);
    return this.mulM(value);
  };

  AbstractMatrix.prototype.mulS = function mulS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.mulM = function mulM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.mul = function mul(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.mul(value);
  };
  AbstractMatrix.prototype.multiply = AbstractMatrix.prototype.mul;
  AbstractMatrix.prototype.multiplyS = AbstractMatrix.prototype.mulS;
  AbstractMatrix.prototype.multiplyM = AbstractMatrix.prototype.mulM;
  AbstractMatrix.multiply = AbstractMatrix.mul;

  AbstractMatrix.prototype.div = function div(value) {
    if (typeof value === 'number') return this.divS(value);
    return this.divM(value);
  };

  AbstractMatrix.prototype.divS = function divS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.divM = function divM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.div = function div(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.div(value);
  };
  AbstractMatrix.prototype.divide = AbstractMatrix.prototype.div;
  AbstractMatrix.prototype.divideS = AbstractMatrix.prototype.divS;
  AbstractMatrix.prototype.divideM = AbstractMatrix.prototype.divM;
  AbstractMatrix.divide = AbstractMatrix.div;

  AbstractMatrix.prototype.mod = function mod(value) {
    if (typeof value === 'number') return this.modS(value);
    return this.modM(value);
  };

  AbstractMatrix.prototype.modS = function modS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) % value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.modM = function modM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) % matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.mod = function mod(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.mod(value);
  };
  AbstractMatrix.prototype.modulus = AbstractMatrix.prototype.mod;
  AbstractMatrix.prototype.modulusS = AbstractMatrix.prototype.modS;
  AbstractMatrix.prototype.modulusM = AbstractMatrix.prototype.modM;
  AbstractMatrix.modulus = AbstractMatrix.mod;

  AbstractMatrix.prototype.and = function and(value) {
    if (typeof value === 'number') return this.andS(value);
    return this.andM(value);
  };

  AbstractMatrix.prototype.andS = function andS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) & value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.andM = function andM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) & matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.and = function and(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.and(value);
  };

  AbstractMatrix.prototype.or = function or(value) {
    if (typeof value === 'number') return this.orS(value);
    return this.orM(value);
  };

  AbstractMatrix.prototype.orS = function orS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) | value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.orM = function orM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) | matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.or = function or(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.or(value);
  };

  AbstractMatrix.prototype.xor = function xor(value) {
    if (typeof value === 'number') return this.xorS(value);
    return this.xorM(value);
  };

  AbstractMatrix.prototype.xorS = function xorS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) ^ value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.xorM = function xorM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) ^ matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.xor = function xor(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.xor(value);
  };

  AbstractMatrix.prototype.leftShift = function leftShift(value) {
    if (typeof value === 'number') return this.leftShiftS(value);
    return this.leftShiftM(value);
  };

  AbstractMatrix.prototype.leftShiftS = function leftShiftS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) << value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.leftShiftM = function leftShiftM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) << matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.leftShift = function leftShift(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.leftShift(value);
  };

  AbstractMatrix.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {
    if (typeof value === 'number') return this.signPropagatingRightShiftS(value);
    return this.signPropagatingRightShiftM(value);
  };

  AbstractMatrix.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >> value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >> matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.signPropagatingRightShift(value);
  };

  AbstractMatrix.prototype.rightShift = function rightShift(value) {
    if (typeof value === 'number') return this.rightShiftS(value);
    return this.rightShiftM(value);
  };

  AbstractMatrix.prototype.rightShiftS = function rightShiftS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >>> value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.rightShiftM = function rightShiftM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >>> matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.rightShift = function rightShift(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.rightShift(value);
  };
  AbstractMatrix.prototype.zeroFillRightShift = AbstractMatrix.prototype.rightShift;
  AbstractMatrix.prototype.zeroFillRightShiftS = AbstractMatrix.prototype.rightShiftS;
  AbstractMatrix.prototype.zeroFillRightShiftM = AbstractMatrix.prototype.rightShiftM;
  AbstractMatrix.zeroFillRightShift = AbstractMatrix.rightShift;

  AbstractMatrix.prototype.not = function not() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, ~(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.not = function not(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.not();
  };

  AbstractMatrix.prototype.abs = function abs() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.abs(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.abs = function abs(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.abs();
  };

  AbstractMatrix.prototype.acos = function acos() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.acos(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.acos = function acos(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.acos();
  };

  AbstractMatrix.prototype.acosh = function acosh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.acosh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.acosh = function acosh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.acosh();
  };

  AbstractMatrix.prototype.asin = function asin() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.asin(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.asin = function asin(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.asin();
  };

  AbstractMatrix.prototype.asinh = function asinh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.asinh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.asinh = function asinh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.asinh();
  };

  AbstractMatrix.prototype.atan = function atan() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.atan(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.atan = function atan(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.atan();
  };

  AbstractMatrix.prototype.atanh = function atanh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.atanh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.atanh = function atanh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.atanh();
  };

  AbstractMatrix.prototype.cbrt = function cbrt() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.cbrt(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.cbrt = function cbrt(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.cbrt();
  };

  AbstractMatrix.prototype.ceil = function ceil() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.ceil(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.ceil = function ceil(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.ceil();
  };

  AbstractMatrix.prototype.clz32 = function clz32() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.clz32(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.clz32 = function clz32(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.clz32();
  };

  AbstractMatrix.prototype.cos = function cos() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.cos(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.cos = function cos(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.cos();
  };

  AbstractMatrix.prototype.cosh = function cosh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.cosh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.cosh = function cosh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.cosh();
  };

  AbstractMatrix.prototype.exp = function exp() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.exp(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.exp = function exp(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.exp();
  };

  AbstractMatrix.prototype.expm1 = function expm1() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.expm1(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.expm1 = function expm1(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.expm1();
  };

  AbstractMatrix.prototype.floor = function floor() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.floor(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.floor = function floor(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.floor();
  };

  AbstractMatrix.prototype.fround = function fround() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.fround(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.fround = function fround(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.fround();
  };

  AbstractMatrix.prototype.log = function log() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log = function log(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log();
  };

  AbstractMatrix.prototype.log1p = function log1p() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log1p(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log1p = function log1p(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log1p();
  };

  AbstractMatrix.prototype.log10 = function log10() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log10(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log10 = function log10(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log10();
  };

  AbstractMatrix.prototype.log2 = function log2() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log2(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log2 = function log2(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log2();
  };

  AbstractMatrix.prototype.round = function round() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.round(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.round = function round(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.round();
  };

  AbstractMatrix.prototype.sign = function sign() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sign(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sign = function sign(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sign();
  };

  AbstractMatrix.prototype.sin = function sin() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sin(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sin = function sin(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sin();
  };

  AbstractMatrix.prototype.sinh = function sinh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sinh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sinh = function sinh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sinh();
  };

  AbstractMatrix.prototype.sqrt = function sqrt() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sqrt(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sqrt = function sqrt(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sqrt();
  };

  AbstractMatrix.prototype.tan = function tan() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.tan(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.tan = function tan(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.tan();
  };

  AbstractMatrix.prototype.tanh = function tanh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.tanh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.tanh = function tanh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.tanh();
  };

  AbstractMatrix.prototype.trunc = function trunc() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.trunc(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.trunc = function trunc(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.trunc();
  };

  AbstractMatrix.pow = function pow(matrix, arg0) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.pow(arg0);
  };

  AbstractMatrix.prototype.pow = function pow(value) {
    if (typeof value === 'number') return this.powS(value);
    return this.powM(value);
  };

  AbstractMatrix.prototype.powS = function powS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.pow(this.get(i, j), value));
      }
    }
    return this;
  };

  AbstractMatrix.prototype.powM = function powM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.pow(this.get(i, j), matrix.get(i, j)));
      }
    }
    return this;
  };
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/matrix.js":
/*!**********************************************!*\
  !*** ./node_modules/ml-matrix/src/matrix.js ***!
  \**********************************************/
/*! exports provided: AbstractMatrix, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractMatrix", function() { return AbstractMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix; });
/* harmony import */ var ml_array_rescale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ml-array-rescale */ "./node_modules/ml-array-rescale/lib-es6/index.js");
/* harmony import */ var _inspect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inspect */ "./node_modules/ml-matrix/src/inspect.js");
/* harmony import */ var _mathOperations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mathOperations */ "./node_modules/ml-matrix/src/mathOperations.js");
/* harmony import */ var _stat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stat */ "./node_modules/ml-matrix/src/stat.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./node_modules/ml-matrix/src/util.js");







class AbstractMatrix {
  static from1DArray(newRows, newColumns, newData) {
    let length = newRows * newColumns;
    if (length !== newData.length) {
      throw new RangeError('data length does not match given dimensions');
    }
    let newMatrix = new Matrix(newRows, newColumns);
    for (let row = 0; row < newRows; row++) {
      for (let column = 0; column < newColumns; column++) {
        newMatrix.set(row, column, newData[row * newColumns + column]);
      }
    }
    return newMatrix;
  }

  static rowVector(newData) {
    let vector = new Matrix(1, newData.length);
    for (let i = 0; i < newData.length; i++) {
      vector.set(0, i, newData[i]);
    }
    return vector;
  }

  static columnVector(newData) {
    let vector = new Matrix(newData.length, 1);
    for (let i = 0; i < newData.length; i++) {
      vector.set(i, 0, newData[i]);
    }
    return vector;
  }

  static zeros(rows, columns) {
    return new Matrix(rows, columns);
  }

  static ones(rows, columns) {
    return new Matrix(rows, columns).fill(1);
  }

  static rand(rows, columns, options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { random = Math.random } = options;
    let matrix = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        matrix.set(i, j, random());
      }
    }
    return matrix;
  }

  static randInt(rows, columns, options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { min = 0, max = 1000, random = Math.random } = options;
    if (!Number.isInteger(min)) throw new TypeError('min must be an integer');
    if (!Number.isInteger(max)) throw new TypeError('max must be an integer');
    if (min >= max) throw new RangeError('min must be smaller than max');
    let interval = max - min;
    let matrix = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        let value = min + Math.round(random() * interval);
        matrix.set(i, j, value);
      }
    }
    return matrix;
  }

  static eye(rows, columns, value) {
    if (columns === undefined) columns = rows;
    if (value === undefined) value = 1;
    let min = Math.min(rows, columns);
    let matrix = this.zeros(rows, columns);
    for (let i = 0; i < min; i++) {
      matrix.set(i, i, value);
    }
    return matrix;
  }

  static diag(data, rows, columns) {
    let l = data.length;
    if (rows === undefined) rows = l;
    if (columns === undefined) columns = rows;
    let min = Math.min(l, rows, columns);
    let matrix = this.zeros(rows, columns);
    for (let i = 0; i < min; i++) {
      matrix.set(i, i, data[i]);
    }
    return matrix;
  }

  static min(matrix1, matrix2) {
    matrix1 = this.checkMatrix(matrix1);
    matrix2 = this.checkMatrix(matrix2);
    let rows = matrix1.rows;
    let columns = matrix1.columns;
    let result = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
      }
    }
    return result;
  }

  static max(matrix1, matrix2) {
    matrix1 = this.checkMatrix(matrix1);
    matrix2 = this.checkMatrix(matrix2);
    let rows = matrix1.rows;
    let columns = matrix1.columns;
    let result = new this(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
      }
    }
    return result;
  }

  static checkMatrix(value) {
    return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);
  }

  static isMatrix(value) {
    return value != null && value.klass === 'Matrix';
  }

  get size() {
    return this.rows * this.columns;
  }

  apply(callback) {
    if (typeof callback !== 'function') {
      throw new TypeError('callback must be a function');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        callback.call(this, i, j);
      }
    }
    return this;
  }

  to1DArray() {
    let array = [];
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        array.push(this.get(i, j));
      }
    }
    return array;
  }

  to2DArray() {
    let copy = [];
    for (let i = 0; i < this.rows; i++) {
      copy.push([]);
      for (let j = 0; j < this.columns; j++) {
        copy[i].push(this.get(i, j));
      }
    }
    return copy;
  }

  toJSON() {
    return this.to2DArray();
  }

  isRowVector() {
    return this.rows === 1;
  }

  isColumnVector() {
    return this.columns === 1;
  }

  isVector() {
    return this.rows === 1 || this.columns === 1;
  }

  isSquare() {
    return this.rows === this.columns;
  }

  isSymmetric() {
    if (this.isSquare()) {
      for (let i = 0; i < this.rows; i++) {
        for (let j = 0; j <= i; j++) {
          if (this.get(i, j) !== this.get(j, i)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }

  isEchelonForm() {
    let i = 0;
    let j = 0;
    let previousColumn = -1;
    let isEchelonForm = true;
    let checked = false;
    while (i < this.rows && isEchelonForm) {
      j = 0;
      checked = false;
      while (j < this.columns && checked === false) {
        if (this.get(i, j) === 0) {
          j++;
        } else if (this.get(i, j) === 1 && j > previousColumn) {
          checked = true;
          previousColumn = j;
        } else {
          isEchelonForm = false;
          checked = true;
        }
      }
      i++;
    }
    return isEchelonForm;
  }

  isReducedEchelonForm() {
    let i = 0;
    let j = 0;
    let previousColumn = -1;
    let isReducedEchelonForm = true;
    let checked = false;
    while (i < this.rows && isReducedEchelonForm) {
      j = 0;
      checked = false;
      while (j < this.columns && checked === false) {
        if (this.get(i, j) === 0) {
          j++;
        } else if (this.get(i, j) === 1 && j > previousColumn) {
          checked = true;
          previousColumn = j;
        } else {
          isReducedEchelonForm = false;
          checked = true;
        }
      }
      for (let k = j + 1; k < this.rows; k++) {
        if (this.get(i, k) !== 0) {
          isReducedEchelonForm = false;
        }
      }
      i++;
    }
    return isReducedEchelonForm;
  }

  echelonForm() {
    let result = this.clone();
    let h = 0;
    let k = 0;
    while (h < result.rows && k < result.columns) {
      let iMax = h;
      for (let i = h; i < result.rows; i++) {
        if (result.get(i, k) > result.get(iMax, k)) {
          iMax = i;
        }
      }
      if (result.get(iMax, k) === 0) {
        k++;
      } else {
        result.swapRows(h, iMax);
        let tmp = result.get(h, k);
        for (let j = k; j < result.columns; j++) {
          result.set(h, j, result.get(h, j) / tmp);
        }
        for (let i = h + 1; i < result.rows; i++) {
          let factor = result.get(i, k) / result.get(h, k);
          result.set(i, k, 0);
          for (let j = k + 1; j < result.columns; j++) {
            result.set(i, j, result.get(i, j) - result.get(h, j) * factor);
          }
        }
        h++;
        k++;
      }
    }
    return result;
  }

  reducedEchelonForm() {
    let result = this.echelonForm();
    let m = result.columns;
    let n = result.rows;
    let h = n - 1;
    while (h >= 0) {
      if (result.maxRow(h) === 0) {
        h--;
      } else {
        let p = 0;
        let pivot = false;
        while (p < n && pivot === false) {
          if (result.get(h, p) === 1) {
            pivot = true;
          } else {
            p++;
          }
        }
        for (let i = 0; i < h; i++) {
          let factor = result.get(i, p);
          for (let j = p; j < m; j++) {
            let tmp = result.get(i, j) - factor * result.get(h, j);
            result.set(i, j, tmp);
          }
        }
        h--;
      }
    }
    return result;
  }

  set() {
    throw new Error('set method is unimplemented');
  }

  get() {
    throw new Error('get method is unimplemented');
  }

  repeat(options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { rows = 1, columns = 1 } = options;
    if (!Number.isInteger(rows) || rows <= 0) {
      throw new TypeError('rows must be a positive integer');
    }
    if (!Number.isInteger(columns) || columns <= 0) {
      throw new TypeError('columns must be a positive integer');
    }
    let matrix = new Matrix(this.rows * rows, this.columns * columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        matrix.setSubMatrix(this, this.rows * i, this.columns * j);
      }
    }
    return matrix;
  }

  fill(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, value);
      }
    }
    return this;
  }

  neg() {
    return this.mulS(-1);
  }

  getRow(index) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowIndex"])(this, index);
    let row = [];
    for (let i = 0; i < this.columns; i++) {
      row.push(this.get(index, i));
    }
    return row;
  }

  getRowVector(index) {
    return Matrix.rowVector(this.getRow(index));
  }

  setRow(index, array) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowIndex"])(this, index);
    array = Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowVector"])(this, array);
    for (let i = 0; i < this.columns; i++) {
      this.set(index, i, array[i]);
    }
    return this;
  }

  swapRows(row1, row2) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowIndex"])(this, row1);
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowIndex"])(this, row2);
    for (let i = 0; i < this.columns; i++) {
      let temp = this.get(row1, i);
      this.set(row1, i, this.get(row2, i));
      this.set(row2, i, temp);
    }
    return this;
  }

  getColumn(index) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnIndex"])(this, index);
    let column = [];
    for (let i = 0; i < this.rows; i++) {
      column.push(this.get(i, index));
    }
    return column;
  }

  getColumnVector(index) {
    return Matrix.columnVector(this.getColumn(index));
  }

  setColumn(index, array) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnIndex"])(this, index);
    array = Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnVector"])(this, array);
    for (let i = 0; i < this.rows; i++) {
      this.set(i, index, array[i]);
    }
    return this;
  }

  swapColumns(column1, column2) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnIndex"])(this, column1);
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnIndex"])(this, column2);
    for (let i = 0; i < this.rows; i++) {
      let temp = this.get(i, column1);
      this.set(i, column1, this.get(i, column2));
      this.set(i, column2, temp);
    }
    return this;
  }

  addRowVector(vector) {
    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowVector"])(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + vector[j]);
      }
    }
    return this;
  }

  subRowVector(vector) {
    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowVector"])(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - vector[j]);
      }
    }
    return this;
  }

  mulRowVector(vector) {
    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowVector"])(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * vector[j]);
      }
    }
    return this;
  }

  divRowVector(vector) {
    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowVector"])(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / vector[j]);
      }
    }
    return this;
  }

  addColumnVector(vector) {
    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnVector"])(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + vector[i]);
      }
    }
    return this;
  }

  subColumnVector(vector) {
    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnVector"])(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - vector[i]);
      }
    }
    return this;
  }

  mulColumnVector(vector) {
    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnVector"])(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * vector[i]);
      }
    }
    return this;
  }

  divColumnVector(vector) {
    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnVector"])(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / vector[i]);
      }
    }
    return this;
  }

  mulRow(index, value) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowIndex"])(this, index);
    for (let i = 0; i < this.columns; i++) {
      this.set(index, i, this.get(index, i) * value);
    }
    return this;
  }

  mulColumn(index, value) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnIndex"])(this, index);
    for (let i = 0; i < this.rows; i++) {
      this.set(i, index, this.get(i, index) * value);
    }
    return this;
  }

  max() {
    let v = this.get(0, 0);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        if (this.get(i, j) > v) {
          v = this.get(i, j);
        }
      }
    }
    return v;
  }

  maxIndex() {
    let v = this.get(0, 0);
    let idx = [0, 0];
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        if (this.get(i, j) > v) {
          v = this.get(i, j);
          idx[0] = i;
          idx[1] = j;
        }
      }
    }
    return idx;
  }

  min() {
    let v = this.get(0, 0);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        if (this.get(i, j) < v) {
          v = this.get(i, j);
        }
      }
    }
    return v;
  }

  minIndex() {
    let v = this.get(0, 0);
    let idx = [0, 0];
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        if (this.get(i, j) < v) {
          v = this.get(i, j);
          idx[0] = i;
          idx[1] = j;
        }
      }
    }
    return idx;
  }

  maxRow(row) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowIndex"])(this, row);
    let v = this.get(row, 0);
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) > v) {
        v = this.get(row, i);
      }
    }
    return v;
  }

  maxRowIndex(row) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowIndex"])(this, row);
    let v = this.get(row, 0);
    let idx = [row, 0];
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) > v) {
        v = this.get(row, i);
        idx[1] = i;
      }
    }
    return idx;
  }

  minRow(row) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowIndex"])(this, row);
    let v = this.get(row, 0);
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) < v) {
        v = this.get(row, i);
      }
    }
    return v;
  }

  minRowIndex(row) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowIndex"])(this, row);
    let v = this.get(row, 0);
    let idx = [row, 0];
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) < v) {
        v = this.get(row, i);
        idx[1] = i;
      }
    }
    return idx;
  }

  maxColumn(column) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnIndex"])(this, column);
    let v = this.get(0, column);
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) > v) {
        v = this.get(i, column);
      }
    }
    return v;
  }

  maxColumnIndex(column) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnIndex"])(this, column);
    let v = this.get(0, column);
    let idx = [0, column];
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) > v) {
        v = this.get(i, column);
        idx[0] = i;
      }
    }
    return idx;
  }

  minColumn(column) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnIndex"])(this, column);
    let v = this.get(0, column);
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) < v) {
        v = this.get(i, column);
      }
    }
    return v;
  }

  minColumnIndex(column) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnIndex"])(this, column);
    let v = this.get(0, column);
    let idx = [0, column];
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) < v) {
        v = this.get(i, column);
        idx[0] = i;
      }
    }
    return idx;
  }

  diag() {
    let min = Math.min(this.rows, this.columns);
    let diag = [];
    for (let i = 0; i < min; i++) {
      diag.push(this.get(i, i));
    }
    return diag;
  }

  norm(type = 'frobenius') {
    let result = 0;
    if (type === 'max') {
      return this.max();
    } else if (type === 'frobenius') {
      for (let i = 0; i < this.rows; i++) {
        for (let j = 0; j < this.columns; j++) {
          result = result + this.get(i, j) * this.get(i, j);
        }
      }
      return Math.sqrt(result);
    } else {
      throw new RangeError(`unknown norm type: ${type}`);
    }
  }

  cumulativeSum() {
    let sum = 0;
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        sum += this.get(i, j);
        this.set(i, j, sum);
      }
    }
    return this;
  }

  dot(vector2) {
    if (AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
    let vector1 = this.to1DArray();
    if (vector1.length !== vector2.length) {
      throw new RangeError('vectors do not have the same size');
    }
    let dot = 0;
    for (let i = 0; i < vector1.length; i++) {
      dot += vector1[i] * vector2[i];
    }
    return dot;
  }

  mmul(other) {
    other = Matrix.checkMatrix(other);

    let m = this.rows;
    let n = this.columns;
    let p = other.columns;

    let result = new Matrix(m, p);

    let Bcolj = new Float64Array(n);
    for (let j = 0; j < p; j++) {
      for (let k = 0; k < n; k++) {
        Bcolj[k] = other.get(k, j);
      }

      for (let i = 0; i < m; i++) {
        let s = 0;
        for (let k = 0; k < n; k++) {
          s += this.get(i, k) * Bcolj[k];
        }

        result.set(i, j, s);
      }
    }
    return result;
  }

  strassen2x2(other) {
    other = Matrix.checkMatrix(other);
    let result = new Matrix(2, 2);
    const a11 = this.get(0, 0);
    const b11 = other.get(0, 0);
    const a12 = this.get(0, 1);
    const b12 = other.get(0, 1);
    const a21 = this.get(1, 0);
    const b21 = other.get(1, 0);
    const a22 = this.get(1, 1);
    const b22 = other.get(1, 1);

    // Compute intermediate values.
    const m1 = (a11 + a22) * (b11 + b22);
    const m2 = (a21 + a22) * b11;
    const m3 = a11 * (b12 - b22);
    const m4 = a22 * (b21 - b11);
    const m5 = (a11 + a12) * b22;
    const m6 = (a21 - a11) * (b11 + b12);
    const m7 = (a12 - a22) * (b21 + b22);

    // Combine intermediate values into the output.
    const c00 = m1 + m4 - m5 + m7;
    const c01 = m3 + m5;
    const c10 = m2 + m4;
    const c11 = m1 - m2 + m3 + m6;

    result.set(0, 0, c00);
    result.set(0, 1, c01);
    result.set(1, 0, c10);
    result.set(1, 1, c11);
    return result;
  }

  strassen3x3(other) {
    other = Matrix.checkMatrix(other);
    let result = new Matrix(3, 3);

    const a00 = this.get(0, 0);
    const a01 = this.get(0, 1);
    const a02 = this.get(0, 2);
    const a10 = this.get(1, 0);
    const a11 = this.get(1, 1);
    const a12 = this.get(1, 2);
    const a20 = this.get(2, 0);
    const a21 = this.get(2, 1);
    const a22 = this.get(2, 2);

    const b00 = other.get(0, 0);
    const b01 = other.get(0, 1);
    const b02 = other.get(0, 2);
    const b10 = other.get(1, 0);
    const b11 = other.get(1, 1);
    const b12 = other.get(1, 2);
    const b20 = other.get(2, 0);
    const b21 = other.get(2, 1);
    const b22 = other.get(2, 2);

    const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
    const m2 = (a00 - a10) * (-b01 + b11);
    const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
    const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
    const m5 = (a10 + a11) * (-b00 + b01);
    const m6 = a00 * b00;
    const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
    const m8 = (-a00 + a20) * (b02 - b12);
    const m9 = (a20 + a21) * (-b00 + b02);
    const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
    const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
    const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
    const m13 = (a02 - a22) * (b11 - b21);
    const m14 = a02 * b20;
    const m15 = (a21 + a22) * (-b20 + b21);
    const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
    const m17 = (a02 - a12) * (b12 - b22);
    const m18 = (a11 + a12) * (-b20 + b22);
    const m19 = a01 * b10;
    const m20 = a12 * b21;
    const m21 = a10 * b02;
    const m22 = a20 * b01;
    const m23 = a22 * b22;

    const c00 = m6 + m14 + m19;
    const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
    const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
    const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
    const c11 = m2 + m4 + m5 + m6 + m20;
    const c12 = m14 + m16 + m17 + m18 + m21;
    const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
    const c21 = m12 + m13 + m14 + m15 + m22;
    const c22 = m6 + m7 + m8 + m9 + m23;

    result.set(0, 0, c00);
    result.set(0, 1, c01);
    result.set(0, 2, c02);
    result.set(1, 0, c10);
    result.set(1, 1, c11);
    result.set(1, 2, c12);
    result.set(2, 0, c20);
    result.set(2, 1, c21);
    result.set(2, 2, c22);
    return result;
  }

  mmulStrassen(y) {
    y = Matrix.checkMatrix(y);
    let x = this.clone();
    let r1 = x.rows;
    let c1 = x.columns;
    let r2 = y.rows;
    let c2 = y.columns;
    if (c1 !== r2) {
      // eslint-disable-next-line no-console
      console.warn(
        `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`,
      );
    }

    // Put a matrix into the top left of a matrix of zeros.
    // `rows` and `cols` are the dimensions of the output matrix.
    function embed(mat, rows, cols) {
      let r = mat.rows;
      let c = mat.columns;
      if (r === rows && c === cols) {
        return mat;
      } else {
        let resultat = AbstractMatrix.zeros(rows, cols);
        resultat = resultat.setSubMatrix(mat, 0, 0);
        return resultat;
      }
    }

    // Make sure both matrices are the same size.
    // This is exclusively for simplicity:
    // this algorithm can be implemented with matrices of different sizes.

    let r = Math.max(r1, r2);
    let c = Math.max(c1, c2);
    x = embed(x, r, c);
    y = embed(y, r, c);

    // Our recursive multiplication function.
    function blockMult(a, b, rows, cols) {
      // For small matrices, resort to naive multiplication.
      if (rows <= 512 || cols <= 512) {
        return a.mmul(b); // a is equivalent to this
      }

      // Apply dynamic padding.
      if (rows % 2 === 1 && cols % 2 === 1) {
        a = embed(a, rows + 1, cols + 1);
        b = embed(b, rows + 1, cols + 1);
      } else if (rows % 2 === 1) {
        a = embed(a, rows + 1, cols);
        b = embed(b, rows + 1, cols);
      } else if (cols % 2 === 1) {
        a = embed(a, rows, cols + 1);
        b = embed(b, rows, cols + 1);
      }

      let halfRows = parseInt(a.rows / 2, 10);
      let halfCols = parseInt(a.columns / 2, 10);
      // Subdivide input matrices.
      let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);
      let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);

      let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);
      let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);

      let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);
      let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);

      let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);
      let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);

      // Compute intermediate values.
      let m1 = blockMult(
        AbstractMatrix.add(a11, a22),
        AbstractMatrix.add(b11, b22),
        halfRows,
        halfCols,
      );
      let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);
      let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);
      let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);
      let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);
      let m6 = blockMult(
        AbstractMatrix.sub(a21, a11),
        AbstractMatrix.add(b11, b12),
        halfRows,
        halfCols,
      );
      let m7 = blockMult(
        AbstractMatrix.sub(a12, a22),
        AbstractMatrix.add(b21, b22),
        halfRows,
        halfCols,
      );

      // Combine intermediate values into the output.
      let c11 = AbstractMatrix.add(m1, m4);
      c11.sub(m5);
      c11.add(m7);
      let c12 = AbstractMatrix.add(m3, m5);
      let c21 = AbstractMatrix.add(m2, m4);
      let c22 = AbstractMatrix.sub(m1, m2);
      c22.add(m3);
      c22.add(m6);

      // Crop output to the desired size (undo dynamic padding).
      let resultat = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);
      resultat = resultat.setSubMatrix(c11, 0, 0);
      resultat = resultat.setSubMatrix(c12, c11.rows, 0);
      resultat = resultat.setSubMatrix(c21, 0, c11.columns);
      resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);
      return resultat.subMatrix(0, rows - 1, 0, cols - 1);
    }
    return blockMult(x, y, r, c);
  }

  scaleRows(options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { min = 0, max = 1 } = options;
    if (!Number.isFinite(min)) throw new TypeError('min must be a number');
    if (!Number.isFinite(max)) throw new TypeError('max must be a number');
    if (min >= max) throw new RangeError('min must be smaller than max');
    let newMatrix = new Matrix(this.rows, this.columns);
    for (let i = 0; i < this.rows; i++) {
      const row = this.getRow(i);
      Object(ml_array_rescale__WEBPACK_IMPORTED_MODULE_0__["default"])(row, { min, max, output: row });
      newMatrix.setRow(i, row);
    }
    return newMatrix;
  }

  scaleColumns(options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { min = 0, max = 1 } = options;
    if (!Number.isFinite(min)) throw new TypeError('min must be a number');
    if (!Number.isFinite(max)) throw new TypeError('max must be a number');
    if (min >= max) throw new RangeError('min must be smaller than max');
    let newMatrix = new Matrix(this.rows, this.columns);
    for (let i = 0; i < this.columns; i++) {
      const column = this.getColumn(i);
      Object(ml_array_rescale__WEBPACK_IMPORTED_MODULE_0__["default"])(column, {
        min: min,
        max: max,
        output: column,
      });
      newMatrix.setColumn(i, column);
    }
    return newMatrix;
  }

  flipRows() {
    const middle = Math.ceil(this.columns / 2);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < middle; j++) {
        let first = this.get(i, j);
        let last = this.get(i, this.columns - 1 - j);
        this.set(i, j, last);
        this.set(i, this.columns - 1 - j, first);
      }
    }
    return this;
  }

  flipColumns() {
    const middle = Math.ceil(this.rows / 2);
    for (let j = 0; j < this.columns; j++) {
      for (let i = 0; i < middle; i++) {
        let first = this.get(i, j);
        let last = this.get(this.rows - 1 - i, j);
        this.set(i, j, last);
        this.set(this.rows - 1 - i, j, first);
      }
    }
    return this;
  }

  kroneckerProduct(other) {
    other = Matrix.checkMatrix(other);

    let m = this.rows;
    let n = this.columns;
    let p = other.rows;
    let q = other.columns;

    let result = new Matrix(m * p, n * q);
    for (let i = 0; i < m; i++) {
      for (let j = 0; j < n; j++) {
        for (let k = 0; k < p; k++) {
          for (let l = 0; l < q; l++) {
            result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));
          }
        }
      }
    }
    return result;
  }

  transpose() {
    let result = new Matrix(this.columns, this.rows);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        result.set(j, i, this.get(i, j));
      }
    }
    return result;
  }

  sortRows(compareFunction = compareNumbers) {
    for (let i = 0; i < this.rows; i++) {
      this.setRow(i, this.getRow(i).sort(compareFunction));
    }
    return this;
  }

  sortColumns(compareFunction = compareNumbers) {
    for (let i = 0; i < this.columns; i++) {
      this.setColumn(i, this.getColumn(i).sort(compareFunction));
    }
    return this;
  }

  subMatrix(startRow, endRow, startColumn, endColumn) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRange"])(this, startRow, endRow, startColumn, endColumn);
    let newMatrix = new Matrix(
      endRow - startRow + 1,
      endColumn - startColumn + 1,
    );
    for (let i = startRow; i <= endRow; i++) {
      for (let j = startColumn; j <= endColumn; j++) {
        newMatrix.set(i - startRow, j - startColumn, this.get(i, j));
      }
    }
    return newMatrix;
  }

  subMatrixRow(indices, startColumn, endColumn) {
    if (startColumn === undefined) startColumn = 0;
    if (endColumn === undefined) endColumn = this.columns - 1;
    if (
      startColumn > endColumn ||
      startColumn < 0 ||
      startColumn >= this.columns ||
      endColumn < 0 ||
      endColumn >= this.columns
    ) {
      throw new RangeError('Argument out of range');
    }

    let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);
    for (let i = 0; i < indices.length; i++) {
      for (let j = startColumn; j <= endColumn; j++) {
        if (indices[i] < 0 || indices[i] >= this.rows) {
          throw new RangeError(`Row index out of range: ${indices[i]}`);
        }
        newMatrix.set(i, j - startColumn, this.get(indices[i], j));
      }
    }
    return newMatrix;
  }

  subMatrixColumn(indices, startRow, endRow) {
    if (startRow === undefined) startRow = 0;
    if (endRow === undefined) endRow = this.rows - 1;
    if (
      startRow > endRow ||
      startRow < 0 ||
      startRow >= this.rows ||
      endRow < 0 ||
      endRow >= this.rows
    ) {
      throw new RangeError('Argument out of range');
    }

    let newMatrix = new Matrix(endRow - startRow + 1, indices.length);
    for (let i = 0; i < indices.length; i++) {
      for (let j = startRow; j <= endRow; j++) {
        if (indices[i] < 0 || indices[i] >= this.columns) {
          throw new RangeError(`Column index out of range: ${indices[i]}`);
        }
        newMatrix.set(j - startRow, i, this.get(j, indices[i]));
      }
    }
    return newMatrix;
  }

  setSubMatrix(matrix, startRow, startColumn) {
    matrix = Matrix.checkMatrix(matrix);
    let endRow = startRow + matrix.rows - 1;
    let endColumn = startColumn + matrix.columns - 1;
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRange"])(this, startRow, endRow, startColumn, endColumn);
    for (let i = 0; i < matrix.rows; i++) {
      for (let j = 0; j < matrix.columns; j++) {
        this.set(startRow + i, startColumn + j, matrix.get(i, j));
      }
    }
    return this;
  }

  selection(rowIndices, columnIndices) {
    let indices = Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkIndices"])(this, rowIndices, columnIndices);
    let newMatrix = new Matrix(rowIndices.length, columnIndices.length);
    for (let i = 0; i < indices.row.length; i++) {
      let rowIndex = indices.row[i];
      for (let j = 0; j < indices.column.length; j++) {
        let columnIndex = indices.column[j];
        newMatrix.set(i, j, this.get(rowIndex, columnIndex));
      }
    }
    return newMatrix;
  }

  trace() {
    let min = Math.min(this.rows, this.columns);
    let trace = 0;
    for (let i = 0; i < min; i++) {
      trace += this.get(i, i);
    }
    return trace;
  }

  clone() {
    let newMatrix = new Matrix(this.rows, this.columns);
    for (let row = 0; row < this.rows; row++) {
      for (let column = 0; column < this.columns; column++) {
        newMatrix.set(row, column, this.get(row, column));
      }
    }
    return newMatrix;
  }

  sum(by) {
    switch (by) {
      case 'row':
        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__["sumByRow"])(this);
      case 'column':
        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__["sumByColumn"])(this);
      case undefined:
        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__["sumAll"])(this);
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  product(by) {
    switch (by) {
      case 'row':
        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__["productByRow"])(this);
      case 'column':
        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__["productByColumn"])(this);
      case undefined:
        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__["productAll"])(this);
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  mean(by) {
    const sum = this.sum(by);
    switch (by) {
      case 'row': {
        for (let i = 0; i < this.rows; i++) {
          sum[i] /= this.columns;
        }
        return sum;
      }
      case 'column': {
        for (let i = 0; i < this.columns; i++) {
          sum[i] /= this.rows;
        }
        return sum;
      }
      case undefined:
        return sum / this.size;
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  variance(by, options = {}) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { unbiased = true, mean = this.mean(by) } = options;
    if (typeof unbiased !== 'boolean') {
      throw new TypeError('unbiased must be a boolean');
    }
    switch (by) {
      case 'row': {
        if (!Array.isArray(mean)) {
          throw new TypeError('mean must be an array');
        }
        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__["varianceByRow"])(this, unbiased, mean);
      }
      case 'column': {
        if (!Array.isArray(mean)) {
          throw new TypeError('mean must be an array');
        }
        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__["varianceByColumn"])(this, unbiased, mean);
      }
      case undefined: {
        if (typeof mean !== 'number') {
          throw new TypeError('mean must be a number');
        }
        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__["varianceAll"])(this, unbiased, mean);
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  standardDeviation(by, options) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    const variance = this.variance(by, options);
    if (by === undefined) {
      return Math.sqrt(variance);
    } else {
      for (let i = 0; i < variance.length; i++) {
        variance[i] = Math.sqrt(variance[i]);
      }
      return variance;
    }
  }

  center(by, options = {}) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { center = this.mean(by) } = options;
    switch (by) {
      case 'row': {
        if (!Array.isArray(center)) {
          throw new TypeError('center must be an array');
        }
        Object(_stat__WEBPACK_IMPORTED_MODULE_3__["centerByRow"])(this, center);
        return this;
      }
      case 'column': {
        if (!Array.isArray(center)) {
          throw new TypeError('center must be an array');
        }
        Object(_stat__WEBPACK_IMPORTED_MODULE_3__["centerByColumn"])(this, center);
        return this;
      }
      case undefined: {
        if (typeof center !== 'number') {
          throw new TypeError('center must be a number');
        }
        Object(_stat__WEBPACK_IMPORTED_MODULE_3__["centerAll"])(this, center);
        return this;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  scale(by, options = {}) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    let scale = options.scale;
    switch (by) {
      case 'row': {
        if (scale === undefined) {
          scale = Object(_stat__WEBPACK_IMPORTED_MODULE_3__["getScaleByRow"])(this);
        } else if (!Array.isArray(scale)) {
          throw new TypeError('scale must be an array');
        }
        Object(_stat__WEBPACK_IMPORTED_MODULE_3__["scaleByRow"])(this, scale);
        return this;
      }
      case 'column': {
        if (scale === undefined) {
          scale = Object(_stat__WEBPACK_IMPORTED_MODULE_3__["getScaleByColumn"])(this);
        } else if (!Array.isArray(scale)) {
          throw new TypeError('scale must be an array');
        }
        Object(_stat__WEBPACK_IMPORTED_MODULE_3__["scaleByColumn"])(this, scale);
        return this;
      }
      case undefined: {
        if (scale === undefined) {
          scale = Object(_stat__WEBPACK_IMPORTED_MODULE_3__["getScaleAll"])(this);
        } else if (typeof scale !== 'number') {
          throw new TypeError('scale must be a number');
        }
        Object(_stat__WEBPACK_IMPORTED_MODULE_3__["scaleAll"])(this, scale);
        return this;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  toString(options) {
    return Object(_inspect__WEBPACK_IMPORTED_MODULE_1__["inspectMatrixWithOptions"])(this, options);
  }
}

AbstractMatrix.prototype.klass = 'Matrix';
if (typeof Symbol !== 'undefined') {
  AbstractMatrix.prototype[
    Symbol.for('nodejs.util.inspect.custom')
  ] = _inspect__WEBPACK_IMPORTED_MODULE_1__["inspectMatrix"];
}

function compareNumbers(a, b) {
  return a - b;
}

// Synonyms
AbstractMatrix.random = AbstractMatrix.rand;
AbstractMatrix.randomInt = AbstractMatrix.randInt;
AbstractMatrix.diagonal = AbstractMatrix.diag;
AbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;
AbstractMatrix.identity = AbstractMatrix.eye;
AbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;
AbstractMatrix.prototype.tensorProduct =
  AbstractMatrix.prototype.kroneckerProduct;

class Matrix extends AbstractMatrix {
  constructor(nRows, nColumns) {
    super();
    if (Matrix.isMatrix(nRows)) {
      return nRows.clone();
    } else if (Number.isInteger(nRows) && nRows > 0) {
      // Create an empty matrix
      this.data = [];
      if (Number.isInteger(nColumns) && nColumns > 0) {
        for (let i = 0; i < nRows; i++) {
          this.data.push(new Float64Array(nColumns));
        }
      } else {
        throw new TypeError('nColumns must be a positive integer');
      }
    } else if (Array.isArray(nRows)) {
      // Copy the values from the 2D array
      const arrayData = nRows;
      nRows = arrayData.length;
      nColumns = arrayData[0].length;
      if (typeof nColumns !== 'number' || nColumns === 0) {
        throw new TypeError(
          'Data must be a 2D array with at least one element',
        );
      }
      this.data = [];
      for (let i = 0; i < nRows; i++) {
        if (arrayData[i].length !== nColumns) {
          throw new RangeError('Inconsistent array dimensions');
        }
        this.data.push(Float64Array.from(arrayData[i]));
      }
    } else {
      throw new TypeError(
        'First argument must be a positive number or an array',
      );
    }
    this.rows = nRows;
    this.columns = nColumns;
    return this;
  }

  set(rowIndex, columnIndex, value) {
    this.data[rowIndex][columnIndex] = value;
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.data[rowIndex][columnIndex];
  }

  removeRow(index) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowIndex"])(this, index);
    if (this.rows === 1) {
      throw new RangeError('A matrix cannot have less than one row');
    }
    this.data.splice(index, 1);
    this.rows -= 1;
    return this;
  }

  addRow(index, array) {
    if (array === undefined) {
      array = index;
      index = this.rows;
    }
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowIndex"])(this, index, true);
    array = Float64Array.from(Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkRowVector"])(this, array, true));
    this.data.splice(index, 0, array);
    this.rows += 1;
    return this;
  }

  removeColumn(index) {
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnIndex"])(this, index);
    if (this.columns === 1) {
      throw new RangeError('A matrix cannot have less than one column');
    }
    for (let i = 0; i < this.rows; i++) {
      const newRow = new Float64Array(this.columns - 1);
      for (let j = 0; j < index; j++) {
        newRow[j] = this.data[i][j];
      }
      for (let j = index + 1; j < this.columns; j++) {
        newRow[j - 1] = this.data[i][j];
      }
      this.data[i] = newRow;
    }
    this.columns -= 1;
    return this;
  }

  addColumn(index, array) {
    if (typeof array === 'undefined') {
      array = index;
      index = this.columns;
    }
    Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnIndex"])(this, index, true);
    array = Object(_util__WEBPACK_IMPORTED_MODULE_4__["checkColumnVector"])(this, array);
    for (let i = 0; i < this.rows; i++) {
      const newRow = new Float64Array(this.columns + 1);
      let j = 0;
      for (; j < index; j++) {
        newRow[j] = this.data[i][j];
      }
      newRow[j++] = array[i];
      for (; j < this.columns + 1; j++) {
        newRow[j] = this.data[i][j - 1];
      }
      this.data[i] = newRow;
    }
    this.columns += 1;
    return this;
  }
}

Object(_mathOperations__WEBPACK_IMPORTED_MODULE_2__["installMathOperations"])(AbstractMatrix, Matrix);


/***/ }),

/***/ "./node_modules/ml-matrix/src/pseudoInverse.js":
/*!*****************************************************!*\
  !*** ./node_modules/ml-matrix/src/pseudoInverse.js ***!
  \*****************************************************/
/*! exports provided: pseudoInverse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pseudoInverse", function() { return pseudoInverse; });
/* harmony import */ var _dc_svd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dc/svd */ "./node_modules/ml-matrix/src/dc/svd.js");
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix */ "./node_modules/ml-matrix/src/matrix.js");



function pseudoInverse(matrix, threshold = Number.EPSILON) {
  matrix = _matrix__WEBPACK_IMPORTED_MODULE_1__["default"].checkMatrix(matrix);
  let svdSolution = new _dc_svd__WEBPACK_IMPORTED_MODULE_0__["default"](matrix, { autoTranspose: true });

  let U = svdSolution.leftSingularVectors;
  let V = svdSolution.rightSingularVectors;
  let s = svdSolution.diagonal;

  for (let i = 0; i < s.length; i++) {
    if (Math.abs(s[i]) > threshold) {
      s[i] = 1.0 / s[i];
    } else {
      s[i] = 0.0;
    }
  }

  return V.mmul(_matrix__WEBPACK_IMPORTED_MODULE_1__["default"].diag(s).mmul(U.transpose()));
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/stat.js":
/*!********************************************!*\
  !*** ./node_modules/ml-matrix/src/stat.js ***!
  \********************************************/
/*! exports provided: sumByRow, sumByColumn, sumAll, productByRow, productByColumn, productAll, varianceByRow, varianceByColumn, varianceAll, centerByRow, centerByColumn, centerAll, getScaleByRow, scaleByRow, getScaleByColumn, scaleByColumn, getScaleAll, scaleAll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sumByRow", function() { return sumByRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sumByColumn", function() { return sumByColumn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sumAll", function() { return sumAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "productByRow", function() { return productByRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "productByColumn", function() { return productByColumn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "productAll", function() { return productAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "varianceByRow", function() { return varianceByRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "varianceByColumn", function() { return varianceByColumn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "varianceAll", function() { return varianceAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centerByRow", function() { return centerByRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centerByColumn", function() { return centerByColumn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centerAll", function() { return centerAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaleByRow", function() { return getScaleByRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleByRow", function() { return scaleByRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaleByColumn", function() { return getScaleByColumn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleByColumn", function() { return scaleByColumn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaleAll", function() { return getScaleAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAll", function() { return scaleAll; });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/ml-matrix/src/util.js");


function sumByRow(matrix) {
  let sum = Object(_util__WEBPACK_IMPORTED_MODULE_0__["newArray"])(matrix.rows);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[i] += matrix.get(i, j);
    }
  }
  return sum;
}

function sumByColumn(matrix) {
  let sum = Object(_util__WEBPACK_IMPORTED_MODULE_0__["newArray"])(matrix.columns);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[j] += matrix.get(i, j);
    }
  }
  return sum;
}

function sumAll(matrix) {
  let v = 0;
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      v += matrix.get(i, j);
    }
  }
  return v;
}

function productByRow(matrix) {
  let sum = Object(_util__WEBPACK_IMPORTED_MODULE_0__["newArray"])(matrix.rows, 1);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[i] *= matrix.get(i, j);
    }
  }
  return sum;
}

function productByColumn(matrix) {
  let sum = Object(_util__WEBPACK_IMPORTED_MODULE_0__["newArray"])(matrix.columns, 1);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[j] *= matrix.get(i, j);
    }
  }
  return sum;
}

function productAll(matrix) {
  let v = 1;
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      v *= matrix.get(i, j);
    }
  }
  return v;
}

function varianceByRow(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const variance = [];

  for (let i = 0; i < rows; i++) {
    let sum1 = 0;
    let sum2 = 0;
    let x = 0;
    for (let j = 0; j < cols; j++) {
      x = matrix.get(i, j) - mean[i];
      sum1 += x;
      sum2 += x * x;
    }
    if (unbiased) {
      variance.push((sum2 - (sum1 * sum1) / cols) / (cols - 1));
    } else {
      variance.push((sum2 - (sum1 * sum1) / cols) / cols);
    }
  }
  return variance;
}

function varianceByColumn(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const variance = [];

  for (let j = 0; j < cols; j++) {
    let sum1 = 0;
    let sum2 = 0;
    let x = 0;
    for (let i = 0; i < rows; i++) {
      x = matrix.get(i, j) - mean[j];
      sum1 += x;
      sum2 += x * x;
    }
    if (unbiased) {
      variance.push((sum2 - (sum1 * sum1) / rows) / (rows - 1));
    } else {
      variance.push((sum2 - (sum1 * sum1) / rows) / rows);
    }
  }
  return variance;
}

function varianceAll(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const size = rows * cols;

  let sum1 = 0;
  let sum2 = 0;
  let x = 0;
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      x = matrix.get(i, j) - mean;
      sum1 += x;
      sum2 += x * x;
    }
  }
  if (unbiased) {
    return (sum2 - (sum1 * sum1) / size) / (size - 1);
  } else {
    return (sum2 - (sum1 * sum1) / size) / size;
  }
}

function centerByRow(matrix, mean) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) - mean[i]);
    }
  }
}

function centerByColumn(matrix, mean) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) - mean[j]);
    }
  }
}

function centerAll(matrix, mean) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) - mean);
    }
  }
}

function getScaleByRow(matrix) {
  const scale = [];
  for (let i = 0; i < matrix.rows; i++) {
    let sum = 0;
    for (let j = 0; j < matrix.columns; j++) {
      sum += Math.pow(matrix.get(i, j), 2) / (matrix.columns - 1);
    }
    scale.push(Math.sqrt(sum));
  }
  return scale;
}

function scaleByRow(matrix, scale) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) / scale[i]);
    }
  }
}

function getScaleByColumn(matrix) {
  const scale = [];
  for (let j = 0; j < matrix.columns; j++) {
    let sum = 0;
    for (let i = 0; i < matrix.rows; i++) {
      sum += Math.pow(matrix.get(i, j), 2) / (matrix.rows - 1);
    }
    scale.push(Math.sqrt(sum));
  }
  return scale;
}

function scaleByColumn(matrix, scale) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) / scale[j]);
    }
  }
}

function getScaleAll(matrix) {
  const divider = matrix.size - 1;
  let sum = 0;
  for (let j = 0; j < matrix.columns; j++) {
    for (let i = 0; i < matrix.rows; i++) {
      sum += Math.pow(matrix.get(i, j), 2) / divider;
    }
  }
  return Math.sqrt(sum);
}

function scaleAll(matrix, scale) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) / scale);
    }
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/util.js":
/*!********************************************!*\
  !*** ./node_modules/ml-matrix/src/util.js ***!
  \********************************************/
/*! exports provided: checkRowIndex, checkColumnIndex, checkRowVector, checkColumnVector, checkIndices, checkRowIndices, checkColumnIndices, checkRange, newArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkRowIndex", function() { return checkRowIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkColumnIndex", function() { return checkColumnIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkRowVector", function() { return checkRowVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkColumnVector", function() { return checkColumnVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkIndices", function() { return checkIndices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkRowIndices", function() { return checkRowIndices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkColumnIndices", function() { return checkColumnIndices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkRange", function() { return checkRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newArray", function() { return newArray; });
/**
 * @private
 * Check that a row index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkRowIndex(matrix, index, outer) {
  let max = outer ? matrix.rows : matrix.rows - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Row index out of range');
  }
}

/**
 * @private
 * Check that a column index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkColumnIndex(matrix, index, outer) {
  let max = outer ? matrix.columns : matrix.columns - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Column index out of range');
  }
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkRowVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.columns) {
    throw new RangeError(
      'vector size must be the same as the number of columns',
    );
  }
  return vector;
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkColumnVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.rows) {
    throw new RangeError('vector size must be the same as the number of rows');
  }
  return vector;
}

function checkIndices(matrix, rowIndices, columnIndices) {
  return {
    row: checkRowIndices(matrix, rowIndices),
    column: checkColumnIndices(matrix, columnIndices),
  };
}

function checkRowIndices(matrix, rowIndices) {
  if (typeof rowIndices !== 'object') {
    throw new TypeError('unexpected type for row indices');
  }

  let rowOut = rowIndices.some((r) => {
    return r < 0 || r >= matrix.rows;
  });

  if (rowOut) {
    throw new RangeError('row indices are out of range');
  }

  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);

  return rowIndices;
}

function checkColumnIndices(matrix, columnIndices) {
  if (typeof columnIndices !== 'object') {
    throw new TypeError('unexpected type for column indices');
  }

  let columnOut = columnIndices.some((c) => {
    return c < 0 || c >= matrix.columns;
  });

  if (columnOut) {
    throw new RangeError('column indices are out of range');
  }
  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);

  return columnIndices;
}

function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 5) {
    throw new RangeError('expected 4 arguments');
  }
  checkNumber('startRow', startRow);
  checkNumber('endRow', endRow);
  checkNumber('startColumn', startColumn);
  checkNumber('endColumn', endColumn);
  if (
    startRow > endRow ||
    startColumn > endColumn ||
    startRow < 0 ||
    startRow >= matrix.rows ||
    endRow < 0 ||
    endRow >= matrix.rows ||
    startColumn < 0 ||
    startColumn >= matrix.columns ||
    endColumn < 0 ||
    endColumn >= matrix.columns
  ) {
    throw new RangeError('Submatrix indices are out of range');
  }
}

function newArray(length, value = 0) {
  let array = [];
  for (let i = 0; i < length; i++) {
    array.push(value);
  }
  return array;
}

function checkNumber(name, value) {
  if (typeof value !== 'number') {
    throw new TypeError(`${name} must be a number`);
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/views/base.js":
/*!**************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/base.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseView; });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ "./node_modules/ml-matrix/src/matrix.js");


class BaseView extends _matrix__WEBPACK_IMPORTED_MODULE_0__["AbstractMatrix"] {
  constructor(matrix, rows, columns) {
    super();
    this.matrix = matrix;
    this.rows = rows;
    this.columns = columns;
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/views/column.js":
/*!****************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/column.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MatrixColumnView; });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/ml-matrix/src/util.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/ml-matrix/src/views/base.js");




class MatrixColumnView extends _base__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(matrix, column) {
    Object(_util__WEBPACK_IMPORTED_MODULE_0__["checkColumnIndex"])(matrix, column);
    super(matrix, matrix.rows, 1);
    this.column = column;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(rowIndex, this.column, value);
    return this;
  }

  get(rowIndex) {
    return this.matrix.get(rowIndex, this.column);
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/views/columnSelection.js":
/*!*************************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/columnSelection.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MatrixColumnSelectionView; });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/ml-matrix/src/util.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/ml-matrix/src/views/base.js");




class MatrixColumnSelectionView extends _base__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(matrix, columnIndices) {
    columnIndices = Object(_util__WEBPACK_IMPORTED_MODULE_0__["checkColumnIndices"])(matrix, columnIndices);
    super(matrix, matrix.rows, columnIndices.length);
    this.columnIndices = columnIndices;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/views/flipColumn.js":
/*!********************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/flipColumn.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MatrixFlipColumnView; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/ml-matrix/src/views/base.js");


class MatrixFlipColumnView extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(matrix) {
    super(matrix, matrix.rows, matrix.columns);
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/views/flipRow.js":
/*!*****************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/flipRow.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MatrixFlipRowView; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/ml-matrix/src/views/base.js");


class MatrixFlipRowView extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(matrix) {
    super(matrix, matrix.rows, matrix.columns);
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/views/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/index.js ***!
  \***************************************************/
/*! exports provided: MatrixColumnView, MatrixColumnSelectionView, MatrixFlipColumnView, MatrixFlipRowView, MatrixRowView, MatrixRowSelectionView, MatrixSelectionView, MatrixSubView, MatrixTransposeView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _column__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./column */ "./node_modules/ml-matrix/src/views/column.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixColumnView", function() { return _column__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _columnSelection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./columnSelection */ "./node_modules/ml-matrix/src/views/columnSelection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixColumnSelectionView", function() { return _columnSelection__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _flipColumn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flipColumn */ "./node_modules/ml-matrix/src/views/flipColumn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixFlipColumnView", function() { return _flipColumn__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _flipRow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flipRow */ "./node_modules/ml-matrix/src/views/flipRow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixFlipRowView", function() { return _flipRow__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _row__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./row */ "./node_modules/ml-matrix/src/views/row.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixRowView", function() { return _row__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _rowSelection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rowSelection */ "./node_modules/ml-matrix/src/views/rowSelection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixRowSelectionView", function() { return _rowSelection__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./selection */ "./node_modules/ml-matrix/src/views/selection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixSelectionView", function() { return _selection__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _sub__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sub */ "./node_modules/ml-matrix/src/views/sub.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixSubView", function() { return _sub__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./transpose */ "./node_modules/ml-matrix/src/views/transpose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixTransposeView", function() { return _transpose__WEBPACK_IMPORTED_MODULE_8__["default"]; });












/***/ }),

/***/ "./node_modules/ml-matrix/src/views/row.js":
/*!*************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/row.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MatrixRowView; });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/ml-matrix/src/util.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/ml-matrix/src/views/base.js");




class MatrixRowView extends _base__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(matrix, row) {
    Object(_util__WEBPACK_IMPORTED_MODULE_0__["checkRowIndex"])(matrix, row);
    super(matrix, 1, matrix.columns);
    this.row = row;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(this.row, columnIndex, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(this.row, columnIndex);
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/views/rowSelection.js":
/*!**********************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/rowSelection.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MatrixRowSelectionView; });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/ml-matrix/src/util.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/ml-matrix/src/views/base.js");




class MatrixRowSelectionView extends _base__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(matrix, rowIndices) {
    rowIndices = Object(_util__WEBPACK_IMPORTED_MODULE_0__["checkRowIndices"])(matrix, rowIndices);
    super(matrix, rowIndices.length, matrix.columns);
    this.rowIndices = rowIndices;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/views/selection.js":
/*!*******************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/selection.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MatrixSelectionView; });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/ml-matrix/src/util.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/ml-matrix/src/views/base.js");




class MatrixSelectionView extends _base__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(matrix, rowIndices, columnIndices) {
    let indices = Object(_util__WEBPACK_IMPORTED_MODULE_0__["checkIndices"])(matrix, rowIndices, columnIndices);
    super(matrix, indices.row.length, indices.column.length);
    this.rowIndices = indices.row;
    this.columnIndices = indices.column;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(
      this.rowIndices[rowIndex],
      this.columnIndices[columnIndex],
      value,
    );
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(
      this.rowIndices[rowIndex],
      this.columnIndices[columnIndex],
    );
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/views/sub.js":
/*!*************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/sub.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MatrixSubView; });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/ml-matrix/src/util.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/ml-matrix/src/views/base.js");




class MatrixSubView extends _base__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(matrix, startRow, endRow, startColumn, endColumn) {
    Object(_util__WEBPACK_IMPORTED_MODULE_0__["checkRange"])(matrix, startRow, endRow, startColumn, endColumn);
    super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);
    this.startRow = startRow;
    this.startColumn = startColumn;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(
      this.startRow + rowIndex,
      this.startColumn + columnIndex,
      value,
    );
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(
      this.startRow + rowIndex,
      this.startColumn + columnIndex,
    );
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/views/transpose.js":
/*!*******************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/transpose.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MatrixTransposeView; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/ml-matrix/src/views/base.js");


class MatrixTransposeView extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(matrix) {
    super(matrix, matrix.columns, matrix.rows);
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(columnIndex, rowIndex, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(columnIndex, rowIndex);
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js":
/*!************************************************************!*\
  !*** ./node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WrapperMatrix1D; });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ "./node_modules/ml-matrix/src/matrix.js");


class WrapperMatrix1D extends _matrix__WEBPACK_IMPORTED_MODULE_0__["AbstractMatrix"] {
  constructor(data, options = {}) {
    const { rows = 1 } = options;

    if (data.length % rows !== 0) {
      throw new Error('the data length is not divisible by the number of rows');
    }
    super();
    this.rows = rows;
    this.columns = data.length / rows;
    this.data = data;
  }

  set(rowIndex, columnIndex, value) {
    let index = this._calculateIndex(rowIndex, columnIndex);
    this.data[index] = value;
    return this;
  }

  get(rowIndex, columnIndex) {
    let index = this._calculateIndex(rowIndex, columnIndex);
    return this.data[index];
  }

  _calculateIndex(row, column) {
    return row * this.columns + column;
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js":
/*!************************************************************!*\
  !*** ./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WrapperMatrix2D; });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ "./node_modules/ml-matrix/src/matrix.js");


class WrapperMatrix2D extends _matrix__WEBPACK_IMPORTED_MODULE_0__["AbstractMatrix"] {
  constructor(data) {
    super();
    this.data = data;
    this.rows = data.length;
    this.columns = data[0].length;
  }

  set(rowIndex, columnIndex, value) {
    this.data[rowIndex][columnIndex] = value;
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.data[rowIndex][columnIndex];
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/wrap/wrap.js":
/*!*************************************************!*\
  !*** ./node_modules/ml-matrix/src/wrap/wrap.js ***!
  \*************************************************/
/*! exports provided: wrap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return wrap; });
/* harmony import */ var _WrapperMatrix1D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WrapperMatrix1D */ "./node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js");
/* harmony import */ var _WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WrapperMatrix2D */ "./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js");



function wrap(array, options) {
  if (Array.isArray(array)) {
    if (array[0] && Array.isArray(array[0])) {
      return new _WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__["default"](array);
    } else {
      return new _WrapperMatrix1D__WEBPACK_IMPORTED_MODULE_0__["default"](array, options);
    }
  } else {
    throw new Error('the argument is not an array');
  }
}


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/tinyqueue/index.js":
/*!*****************************************!*\
  !*** ./node_modules/tinyqueue/index.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TinyQueue; });

class TinyQueue {
    constructor(data = [], compare = defaultCompare) {
        this.data = data;
        this.length = this.data.length;
        this.compare = compare;

        if (this.length > 0) {
            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
        }
    }

    push(item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
    }

    pop() {
        if (this.length === 0) return undefined;

        const top = this.data[0];
        const bottom = this.data.pop();
        this.length--;

        if (this.length > 0) {
            this.data[0] = bottom;
            this._down(0);
        }

        return top;
    }

    peek() {
        return this.data[0];
    }

    _up(pos) {
        const {data, compare} = this;
        const item = data[pos];

        while (pos > 0) {
            const parent = (pos - 1) >> 1;
            const current = data[parent];
            if (compare(item, current) >= 0) break;
            data[pos] = current;
            pos = parent;
        }

        data[pos] = item;
    }

    _down(pos) {
        const {data, compare} = this;
        const halfLength = this.length >> 1;
        const item = data[pos];

        while (pos < halfLength) {
            let left = (pos << 1) + 1;
            let best = data[left];
            const right = left + 1;

            if (right < this.length && compare(data[right], best) < 0) {
                left = right;
                best = data[right];
            }
            if (compare(best, item) >= 0) break;

            data[pos] = best;
            pos = left;
        }

        data[pos] = item;
    }
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}


/***/ }),

/***/ "./src/compiler.js":
/*!*************************!*\
  !*** ./src/compiler.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Worker = __webpack_require__(/*! ./compiler.worker.js */ "./src/compiler.worker.js");
const {buildImageList} = __webpack_require__(/*! ./image-target/image-list.js */ "./src/image-target/image-list.js");
const msgpack = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/@msgpack/msgpack/dist.es5/msgpack.min.js");
// TODO: better compression method. now grey image saved in pixels, which could be largere than original image

class Compiler {
  constructor() {
    this.data = null;
  }

  // input html Images
  compileImageTargets(images) {
    return new Promise((resolve, reject) => {
      const targetImages = [];
      for (let i = 0; i < images.length; i++) {
        const img = images[i];
        const processCanvas = document.createElement('canvas');
        processCanvas.width = img.width;
        processCanvas.height = img.height;
        const processContext = processCanvas.getContext('2d');
        processContext.drawImage(img, 0, 0, img.width, img.height);
        const processData = processContext.getImageData(0, 0, img.width, img.height);

        const greyImageData = new Uint8Array(img.width * img.height);

        for (let i = 0; i < greyImageData.length; i++) {
          const offset = i * 4;
          greyImageData[i] = Math.floor((processData.data[offset] + processData.data[offset+1] + processData.data[offset+2])/3);
        }
        const targetImage = {data: greyImageData, height: img.height, width: img.width};
        targetImages.push(targetImage);
      }

      const worker = new Worker();
      worker.onmessage = (e) => {
        const {list} = e.data;
        this.data = [];
        for (let i = 0; i < list.length; i++) {
          this.data.push({
            targetImage: list[i].targetImage,
            imageList: list[i].imageList,
            trackingData: list[i].trackingData,
            matchingData: list[i].matchingData
          });
        }
        resolve(this.data);
      };
      worker.postMessage({type: 'compile', targetImages});
    });
  }

  // not exporting imageList because too large. rebuild this using targetImage
  exportData() {
    const dataList = [];
    for (let i = 0; i < this.data.length; i++) {
      dataList.push({
        targetImage: this.data[i].targetImage,
        trackingData: this.data[i].trackingData,
        matchingData: this.data[i].matchingData
      });
    }
    const buffer = msgpack.encode(dataList);
    return buffer;
  }

  importData(buffer) {
    const dataList = msgpack.decode(new Uint8Array(buffer));
    this.data = [];
    for (let i = 0; i < dataList.length; i++) {
      const imageList = buildImageList(dataList[i].targetImage);
      this.data.push({
        imageList: imageList,
        targetImage: dataList[i].targetImage,
        trackingData: dataList[i].trackingData,
        matchingData: dataList[i].matchingData
      });
    }
    return this.data;
  }
}

module.exports = {
  Compiler
}


/***/ }),

/***/ "./src/compiler.worker.js":
/*!********************************!*\
  !*** ./src/compiler.worker.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return new Worker(__webpack_require__.p + "worker.js");
};

/***/ }),

/***/ "./src/controller.js":
/*!***************************!*\
  !*** ./src/controller.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {ImageTarget} = __webpack_require__(/*! ./image-target/index.js */ "./src/image-target/index.js");
const {Detector} = __webpack_require__(/*! ./image-target/detectorGPU/detector.js */ "./src/image-target/detectorGPU/detector.js");
//const {Detector} = require('./image-target/detectorCPU/detector.js');
const {Compiler} = __webpack_require__(/*! ./compiler.js */ "./src/compiler.js");

class Controller {
  constructor(inputWidth, inputHeight) {
    this.inputWidth = inputWidth;
    this.inputHeight = inputHeight;
    this.detector = new Detector(this.inputWidth, this.inputHeight);
    this.imageTargets = [];
    this.trackingIndex = -1;

    const near = 10;
    const far = 10000;
    const fovy = 45.0 * Math.PI / 180; // 45 in radian. field of view vertical
    const f = (this.inputHeight/2) / Math.tan(fovy/2);
    //     [fx  s cx]
    // K = [ 0 fx cy]
    //     [ 0  0  1]
    this.projectionTransform = [
      [f, 0, this.inputWidth / 2],
      [0, f, this.inputHeight / 2],
      [0, 0, 1]
    ];

    this.projectionMatrix = _glProjectionMatrix({
      projectionTransform: this.projectionTransform,
      //width: this.inputWidth - 1, // -1 is not necessary?
      //height: this.inputHeight - 1,
      width: this.inputWidth,
      height: this.inputHeight,
      near: near,
      far: far,
    });
  }

  getProjectionMatrix() {
    return this.projectionMatrix;
  }

  addImageTargets(fileURL) {
    return new Promise(async (resolve, reject) => {
      const compiler = new Compiler();
      const content = await fetch(fileURL);
      const buffer = await content.arrayBuffer();
      const dataList = compiler.importData(buffer);

      for (let i = 0; i < dataList.length; i++) {
        const imageTarget = new ImageTarget({
          projectionTransform: this.projectionTransform,
          imageList: dataList[i].imageList,
          targetImage: dataList[i].targetImage,
          matchingData: dataList[i].matchingData,
          trackingData: dataList[i].trackingData,
        });
        imageTarget.setupQuery(this.inputWidth, this.inputHeight);
        this.imageTargets.push(imageTarget);
      }
      resolve(true);
    });
  }

  // warm up gpu - build kernels is slow
  dummyRun(input) {
    this.detector.detect(input);
    for (let i = 0; i < this.imageTargets.length; i++) {
      this.imageTargets[i].dummyRun(input);
    }
  }

  getImageTargetDimensions() {
    const dimensions = [];
    for (let i = 0; i < this.imageTargets.length; i++) {
      const targetImage = this.imageTargets[i].targetImage;
      dimensions.push([targetImage.width, targetImage.height]);
    }
    return dimensions;
  }

  // input is either HTML video or HTML image
  process(input) {
    logTime("engine process");

    if (this.trackingIndex === -1) {
      let featurePoints = this.detector.detect(input);
      for (let i = 0; i < this.imageTargets.length; i++) {
        const imageTarget = this.imageTargets[i];
        imageTarget.match(featurePoints);
        if (imageTarget.isTracking) {
          this.trackingIndex = i;
          break;
        }
      }
    }

    const result = [];
    for (let i = 0; i < this.imageTargets.length; i++) {
      const imageTarget = this.imageTargets[i];
      let worldMatrix = null;
      if (imageTarget.isTracking) {
        const modelViewTransform = imageTarget.track(input);
        worldMatrix = modelViewTransform === null? null: _glModelViewMatrix({modelViewTransform});
        if (worldMatrix === null) this.trackingIndex = -1;
      }
      result.push({
        worldMatrix: worldMatrix
      })
    }

    return result;
  }
}

// build openGL modelView matrix
const _glModelViewMatrix = ({modelViewTransform}) => {
  const openGLWorldMatrix = [
    modelViewTransform[0][0], -modelViewTransform[1][0], -modelViewTransform[2][0], 0,
    modelViewTransform[0][1], -modelViewTransform[1][1], -modelViewTransform[2][1], 0,
    modelViewTransform[0][2], -modelViewTransform[1][2], -modelViewTransform[2][2], 0,
    modelViewTransform[0][3], -modelViewTransform[1][3], -modelViewTransform[2][3], 1
  ];
  return openGLWorldMatrix;
}

// build openGL projection matrix
const _glProjectionMatrix = ({projectionTransform, width, height, near, far}) => {
  const proj = [
    [2 * projectionTransform[0][0] / width, 0, -(2 * projectionTransform[0][2] / width - 1), 0],
    [0, 2 * projectionTransform[1][1] / height, -(2 * projectionTransform[1][2] / height - 1), 0],
    [0, 0, -(far + near) / (far - near), -2 * far * near / (far - near)],
    [0, 0, -1, 0]
  ];

  const projMatrix = [];
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      projMatrix.push(proj[j][i]);
    }
  }
  return projMatrix;
}

module.exports = {
 Controller
}


/***/ }),

/***/ "./src/image-target/detectorGPU/detector.js":
/*!**************************************************!*\
  !*** ./src/image-target/detectorGPU/detector.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {GPU} = __webpack_require__(/*! gpu.js */ "./node_modules/gpu.js/dist/gpu-browser.js");
//const gpu = new GPU({mode: 'gpu'});
//const gpu = new GPU();
//console.log("gpu", gpu);

const PYRAMID_NUM_SCALES_PER_OCTAVES = 3;
const PYRAMID_MIN_SIZE = 8;

const LAPLACIAN_SQR_THRESHOLD = 3 * 3;
const MAX_SUBPIXEL_DISTANCE_SQR = 3 * 3;
const EDGE_THRESHOLD = 4.0;
const EDGE_HESSIAN_THRESHOLD = ((EDGE_THRESHOLD+1) * (EDGE_THRESHOLD+1) / EDGE_THRESHOLD);

// TODO: can try 20 per dimension and max feature 1 for more efficient computation
const NUM_BUCKETS_PER_DIMENSION = 10;
//const NUM_BUCKETS_PER_DIMENSION = 20;
const NUM_BUCKETS = NUM_BUCKETS_PER_DIMENSION * NUM_BUCKETS_PER_DIMENSION;
const MAX_FEATURES_PER_BUCKET = 5;
//const MAX_FEATURES_PER_BUCKET = 1;
// total max feature points = NUM_BUCKETS * MAX_FEATURES_PER_BUCKET

const ORIENTATION_NUM_BINS = 36;
const ORIENTATION_SMOOTHING_ITERATIONS = 5;

const ORIENTATION_GAUSSIAN_EXPANSION_FACTOR = 3.0;
const ORIENTATION_REGION_EXPANSION_FACTOR = 1.5;
const FREAK_EXPANSION_FACTOR = 7.0;

// 37 points = 6 rings x 6 points per ring + 1 center
const FREAK_RINGS = [
  // ring 5
  {
    sigma: 0.550000,
    points: [
      [-1.000000, 0.000000],
      [-0.500000, -0.866025],
      [0.500000, -0.866025],
      [1.000000, -0.000000],
      [0.500000, 0.866025],
      [-0.500000, 0.866025]
    ]
  },
  // ring 4
  {
    sigma: 0.475000,
    points: [
      [0.000000, 0.930969],
      [-0.806243, 0.465485],
      [-0.806243, -0.465485],
      [-0.000000, -0.930969],
      [0.806243, -0.465485],
      [0.806243, 0.465485]
    ]
  },
  // ring 3
  {
    sigma: 0.400000,
    points: [
      [0.847306, -0.000000],
      [0.423653, 0.733789],
      [-0.423653, 0.733789],
      [-0.847306, 0.000000],
      [-0.423653, -0.733789],
      [0.423653, -0.733789]
    ]
  },
  // ring 2
  {
    sigma: 0.325000,
    points: [
      [-0.000000, -0.741094],
      [0.641806, -0.370547],
      [0.641806, 0.370547],
      [0.000000, 0.741094],
      [-0.641806, 0.370547],
      [-0.641806, -0.370547]
    ]
  },
  // ring 1
  {
    sigma: 0.250000,
    points: [
      [-0.595502, 0.000000],
      [-0.297751, -0.515720],
      [0.297751, -0.515720],
      [0.595502, -0.000000],
      [0.297751, 0.515720],
      [-0.297751, 0.515720]
    ]
  },
  // ring 0
  {
    sigma: 0.175000,
    points: [
      [0.000000, 0.362783],
      [-0.314179, 0.181391],
      [-0.314179, -0.181391],
      [-0.000000, -0.362783],
      [0.314179, -0.181391],
      [0.314179, 0.181391]
    ]
  },
  // center
  {
    sigma: 0.100000,
    points: [
      [0, 0]
    ]
  }
];

const FREAKPOINTS = [];
for (let r = 0; r < FREAK_RINGS.length; r++) {
  const sigma = FREAK_RINGS[r].sigma;
  for (let i = 0; i < FREAK_RINGS[r].points.length; i++) {
    const point = FREAK_RINGS[r].points[i];
    FREAKPOINTS.push([sigma, point[0], point[1]]);
  }
}

const FREAK_CONPARISON_COUNT = (FREAKPOINTS.length-1) * (FREAKPOINTS.length) / 2; // 666

// gpu.js use 32-bit float number. it has 24 significant bit and 8 bit exponent (can confirmed?)
//   therefore, it can only put 24 bits of information with full accuracy
//   any better way to utilize all 32 bits?
const FREAK_24BIT_DESCRIPTOR_COUNT = Math.ceil(FREAK_CONPARISON_COUNT / 24); // ceil(666/24) = 28 numbers

let gpu = null;

class Detector {
  constructor(width, height) {
    this.width = width;
    this.height = height;

    let numOctaves = 0;
    while (width >= PYRAMID_MIN_SIZE && height >= PYRAMID_MIN_SIZE) {
      width /= 2;
      height /= 2;
      numOctaves++;
    }
    this.numOctaves = numOctaves;
    this.kernels = [];
    //this.gpu = new GPU({mode: 'webgl'});
    this.gpu = new GPU();
    gpu = this.gpu;

    this.inputKernel = null;
  }

  detect(input) {
    if (this.inputKernel === null) {
      this.inputKernel = gpu.createKernel(function(inputFrame) {
        const pixel = inputFrame[this.constants.height-1-Math.floor(this.thread.x / this.constants.width)][this.thread.x % this.constants.width];
        return (pixel[0] + pixel[1] + pixel[2]) * 255 / 3;
      }, {
        constants: {width: this.width, height: this.height},
        output: [this.width * this.height],
        pipeline: true,
      })
    }
    const result = this.inputKernel(input);
    return this.detectImageData(result);
  }

  detectImageData(imagedata) {
    this.kernelIndex = 0; // reset kernelIndex

    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      var _start = new Date().getTime();
    }

    const inputImage = {width: this.width, height: this.height, data: imagedata};

    const originalWidth = this.width;
    const originalHeight = this.height;
    const numOctaves = this.numOctaves;

    // Build gaussian pyramid images
    const pyramidImages = [];
    for (let i = 0; i < numOctaves; i++) {
      if (i === 0) {
        pyramidImages.push(this._applyFilter(inputImage));
      } else {
        // first image of each octave, downsample from previous
        pyramidImages.push(this._downsampleBilinear(pyramidImages[pyramidImages.length-1]));
      }

      // remaining images of octave, 4th order binomail from previous
      for (let j = 0; j < PYRAMID_NUM_SCALES_PER_OCTAVES - 1; j++) {
        pyramidImages.push(this._applyFilter(pyramidImages[pyramidImages.length-1]));
      }
    }
    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      console.log('exec time until build gausian', new Date().getTime() - _start);
    }

    // Build difference of gaussian pyramid
    const dogPyramidImages = [];
    for (let i = 0; i < numOctaves; i++) {
      for (let j = 0; j < PYRAMID_NUM_SCALES_PER_OCTAVES - 1; j++) {
        const image1 = pyramidImages[i * PYRAMID_NUM_SCALES_PER_OCTAVES + j];
        const image2 = pyramidImages[i * PYRAMID_NUM_SCALES_PER_OCTAVES + j + 1];
        dogPyramidImages.push(this._differenceImageBinomial(image1, image2));
      }
    }
    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      console.log('exec time until build dog', new Date().getTime() - _start);
    }

    let prunedExtremas = this._initializePrune();

    // Find feature points (i.e. extremas in dog images)
    for (let k = 1; k < dogPyramidImages.length - 1; k++) {
      // Experimental result shows that no extrema is possible for odd number of k
      // I believe it has something to do with how the gaussian pyramid being constructed
      if (k % 2 === 1) continue;

      let image0 = dogPyramidImages[k-1];
      let image1 = dogPyramidImages[k];
      let image2 = dogPyramidImages[k+1];

      const octave = Math.floor(k / (PYRAMID_NUM_SCALES_PER_OCTAVES-1));
      const scale = k % (PYRAMID_NUM_SCALES_PER_OCTAVES-1);

      let hasUpsample = false;
      let hasPadOneWidth = false;
      let hasPadOneHeight = false;

      if ( Math.floor(image0.width/2) == image1.width) {
        image0 = this._downsampleBilinear(image0);
      }
      if ( Math.floor(image1.width/2) == image2.width) {
        hasUpsample = true;
        hasPadOneWidth = image1.width % 2 === 1;
        hasPadOneHeight = image1.height % 2 === 1;
        image2 = this._upsampleBilinear(image2, hasPadOneWidth, hasPadOneHeight);
      }

      // In upsample image, ignore the border
      // it's possible to further pad one more line (i.e. upsacale 2x2 -> 5x5), so ignore one more line
      let startI = hasUpsample? 2: 1;
      let startJ = startI;

      // should it be "image1.width -2" ? but this yield consistent result with artoolkit
      let endI = hasUpsample? image1.width - 3: image1.width - 1;
      let endJ = hasUpsample? image1.height - 3: image1.height - 1;
      if (hasPadOneWidth) endI -= 1;
      if (hasPadOneHeight) endJ -= 1;


      // find all extrema for image1
      const extremasResult = this._buildExtremas(image0, image1, image2, octave, scale, startI, startJ, endI, endJ);

      if (typeof window !== 'undefined' && window.DEBUG_TIME) {
        console.log('exec time until build extremas', k,  new Date().getTime() - _start);
      }

      // combine this extrema with the existing
      prunedExtremas = this._applyPrune(k, prunedExtremas, extremasResult, image1.width, image1.height);

      if (typeof window !== 'undefined' && window.DEBUG_TIME) {
        console.log('exec time until apply prune', k,  new Date().getTime() - _start);
      }
    }

    // compute the orientation angle of the extrema
    //  artoolkit picks mutiple angles (usually 1-3), but we pick one only for simplicity
    let extremaHistograms = this._initializeHistograms();
    for (let k = 1; k < dogPyramidImages.length - 1; k++) {
      const octave = Math.floor(k / (PYRAMID_NUM_SCALES_PER_OCTAVES-1));
      const scale = k % (PYRAMID_NUM_SCALES_PER_OCTAVES-1);
      const gaussianIndex = octave * PYRAMID_NUM_SCALES_PER_OCTAVES + scale;
      const gaussianImage = pyramidImages[gaussianIndex]
      const gradientResult = this._computeGradients(gaussianImage);

      extremaHistograms = this._computeOrientationHistograms(extremaHistograms, gradientResult, prunedExtremas, k, gaussianImage.width, gaussianImage.height);
    }
    extremaHistograms = this._smoothHistograms(extremaHistograms);
    const extremaAngles = this._computeExtremaAngles(extremaHistograms);

    // compute the FREAK descriptors for extremas
    const extremaFreaks = this._computeExtremaFreak(pyramidImages, numOctaves, prunedExtremas, extremaAngles);
    const freakDescriptors = this._computeFreakDescriptors(extremaFreaks);

    // combine all needed data and return to CPU together
    const combinedExtremas = this._combine(prunedExtremas, extremaAngles, freakDescriptors);
    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      console.log('exec time until combine', new Date().getTime() - _start);
    }

    // toArray() is very slow. kind of a performance bottleneck.
    const combinedExtremasArr = combinedExtremas.toArray();

    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      console.log('exec time until combine to array', new Date().getTime() - _start);
    }

    const featurePoints = [];
    for (let i = 0; i < combinedExtremasArr.length; i++) {
      for (let j = 0; j < combinedExtremasArr[i].length; j++) {
        if (combinedExtremasArr[i][j][0] !== 0) {
          const ext = combinedExtremasArr[i][j];

          const descBit24 = ext.slice(5);
          // convert 24-bits encoded to 32-bits encoded. i.e. every 4 numbers to 3 numbers
          //  [24 + 8] [16 + 16] [8 + 24]
          // altogether 28 numbers, so perfectly convert to 21 numbers
          const descriptors = [];
          for (let k = 0; k < descBit24.length; k += 4) {
            const v1 = descBit24[k] * 256 + (descBit24[k+1] >> 16);
            const v2 = (descBit24[k+1] & 65535) * 65536 + (descBit24[k+2] >> 8);
            const v3 = (descBit24[k+2] & 255) * 16777216 + descBit24[k+3];
            descriptors.push(v1);
            descriptors.push(v2);
            descriptors.push(v3);
          }
          // there are 666 freak bits to encode, so the last descriptors only use 26 bits. (666 % 32)
          // for historically reason, it started from the 2nd least significant bits (but not necessary); so now we shift by (32-26-1) bits
          descriptors[descriptors.length-1] = (descriptors[descriptors.length-1] >>> 5);

          featurePoints.push({
            score: ext[0],
            sigma: ext[1],
            x: ext[2],
            y: ext[3],
            angle: ext[4],
            descriptors: descriptors
          });
        }
      }
    }

    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      console.log('exec time until feature points and descriptors', new Date().getTime() - _start);
    }
    return featurePoints;
  }

  _initializePrune() {
    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        gpu.createKernel(function() {
          return 0;
        }, {
          output: [5, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS], // first dimension: [score, sigma, x, y, dogIndex]
          pipeline: true,
        })
      )
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel();
    return result;
  }

  // combine necessary information to return to cpu
  // first dimension: [score, sigma, x, y, angle, freak1, freak2, ..., freak37]
  _combine(prunedExtremas, extremaAngles, freakDescriptors) {
    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        gpu.createKernel(function(prunedExtremas, extremaAngles, freakDescriptors) {
          if (this.thread.x < 4) {
            return prunedExtremas[this.thread.z][this.thread.y][this.thread.x];
          }
          if (this.thread.x < 5) {
            return extremaAngles[this.thread.z][this.thread.y][this.thread.x-4];
          }
          return freakDescriptors[this.thread.z][this.thread.y][this.thread.x-5];
        }, {
          output: [5 + FREAK_24BIT_DESCRIPTOR_COUNT, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      )
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel(prunedExtremas, extremaAngles, freakDescriptors);
    return result;
  }

  _initializeHistograms() {
    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        gpu.createKernel(function() {
          return 0;
        }, {
          output: [ORIENTATION_NUM_BINS, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      )
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel();
    return result;
  }

  _computeOrientationHistograms(extremaHistograms, gradientResult, prunedExtremas, dogIndex, width, height) {
    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        gpu.createKernel(function(extremaHistograms, gradientMags, gradientAngles, prunedExtremas) {
          const dogIndex = this.constants.dogIndex;
          const bucketPointIndex = this.thread.y;
          const bucketIndex = this.thread.z;

          const thisDogIndex = prunedExtremas[bucketIndex][bucketPointIndex][4];
          if (dogIndex !== thisDogIndex) {
            return extremaHistograms[this.thread.z][this.thread.y][this.thread.x];
          }

          const octave = this.constants.octave;
          const scale = this.constants.scale;
          const numBins = this.constants.numBins;
          const width = this.constants.width;
          const height = this.constants.height;
          const oneOver2PI = 0.159154943091895;
          const gaussianExpansionFactor = this.constants.gaussianExpansionFactor;
          const regionExpansionFactor = this.constants.regionExpansionFactor;

          const histogramIndex = this.thread.x;

          const originalSigma = prunedExtremas[bucketIndex][bucketPointIndex][1];
          const originalX = prunedExtremas[bucketIndex][bucketPointIndex][2];
          const originalY = prunedExtremas[bucketIndex][bucketPointIndex][3];

          // x, y, sigma in current octave
          const octaveFactor = 1.0 / Math.pow(2, octave);
          const x = Math.floor(originalX * octaveFactor + 0.5 * octaveFactor);
          const y = Math.floor(originalY * octaveFactor + 0.5 * octaveFactor);
          const sigma = originalSigma * octaveFactor;

          const gwSigma = Math.max(1.0, gaussianExpansionFactor * sigma);
          const gwScale = -1.0 / (2 * gwSigma * gwSigma);

          const radius = regionExpansionFactor * gwSigma;
          const radius2 = Math.ceil(radius * radius - 0.5);

          const x0 = Math.max(0, x - Math.floor(radius + 0.5));
          const x1 = Math.min(width-1, x + Math.floor(radius + 0.5));
          const y0 = Math.max(0, y - Math.floor(radius + 0.5));
          const y1 = Math.min(height-1, y + Math.floor(radius + 0.5));

          let sum = 0;

          for (let yp = y0; yp <= y1; yp++) {
            const dy = yp - y;
            const dy2 = dy * dy;
            for (let xp = x0; xp <= x1; xp++) {
              const dx = xp - x;
              const dx2 = dx * dx;
              const r2 = dx2 + dy2;

              if (r2 <= radius2) {
                const mag = gradientMags[yp * width + xp];
                const angle = gradientAngles[yp * width + xp];
                const _x = r2 * gwScale;

                /**
                 * fast Exp6
                 * 0.01% error at 1.030
                 * 0.10% error at 1.520
                 * 1.00% error at 2.330
                 * 5.00% error at 3.285
                 */
                const w = (720+_x*(720+_x*(360+_x*(120+_x*(30+_x*(6+_x))))))*0.0013888888;

                const fbin  = numBins * angle * oneOver2PI;
                const bin = Math.floor(fbin - 0.5);
                const w2 = fbin - bin - 0.5;
                const w1 = (1.0 - w2);
                const b1 = (bin + numBins) % numBins;
                const b2 = (bin + 1) % numBins;
                const magnitude = w * mag;

                if (b1 === this.thread.x) sum += w1 * magnitude;
                if (b2 === this.thread.x) sum += w2 * magnitude;
              }
            }
          }
          return sum;
        }, {
          constants: {
            dogIndex: dogIndex,
            octave: Math.floor(dogIndex / (PYRAMID_NUM_SCALES_PER_OCTAVES-1)),
            scale: dogIndex % (PYRAMID_NUM_SCALES_PER_OCTAVES-1),
            numBins: ORIENTATION_NUM_BINS,
            width: width,
            height: height,
            gaussianExpansionFactor: ORIENTATION_GAUSSIAN_EXPANSION_FACTOR,
            regionExpansionFactor: ORIENTATION_REGION_EXPANSION_FACTOR
          },
          output: [ORIENTATION_NUM_BINS, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      )
    }
    const kernel = this.kernels[this.kernelIndex++];
    const gradientMags = gradientResult.saveMag;
    const gradientAngles = gradientResult.result;
    const result = kernel(extremaHistograms, gradientMags, gradientAngles, prunedExtremas);
    return result;
  }

  _smoothHistograms(histograms) {
    if (this.kernelIndex === this.kernels.length) {
      const subkernels = [];
      for (let k = 0; k < ORIENTATION_SMOOTHING_ITERATIONS; k++) {
        subkernels.push(
          gpu.createKernel(function(histograms) {
            const numBins = this.constants.numBins;
            // The histogram is smoothed with a Gaussian, with sigma = 1
            return 0.274068619061197 * histograms[this.thread.z][this.thread.y][(this.thread.x - 1 + numBins) % numBins]
                 + 0.451862761877606 * histograms[this.thread.z][this.thread.y][this.thread.x]
                 + 0.274068619061197 * histograms[this.thread.z][this.thread.y][(this.thread.x + 1) % numBins];
          }, {
            constants: {numBins: ORIENTATION_NUM_BINS},
            output: [ORIENTATION_NUM_BINS, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
            pipeline: true,
          })
        );
      }
      this.kernels.push(subkernels);
    }
    const subkernels = this.kernels[this.kernelIndex++];
    for (let k = 0; k < ORIENTATION_SMOOTHING_ITERATIONS; k++) {
      histograms = subkernels[k](histograms);
    }
    return histograms;
  }

  _computeExtremaAngles(histograms) {
    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        gpu.createKernel(function(histograms) {
          const numBins = this.constants.numBins;

          let maxIndex = 0;
          for (let i = 1; i < numBins; i++) {
            if (histograms[this.thread.z][this.thread.y][i] > histograms[this.thread.z][this.thread.y][maxIndex]) {
              maxIndex = i;
            }
          }
          const prev = (maxIndex - 1 + numBins) % numBins;
          const next = (maxIndex + 1) % numBins;

          let fbin = maxIndex; // default if no quadratic fit
          /**
           * Fit a quatratic to 3 points. The system of equations is:
           *
           * y0 = A*x0^2 + B*x0 + C
           * y1 = A*x1^2 + B*x1 + C
           * y2 = A*x2^2 + B*x2 + C
           *
           * This system of equations is solved for A,B,C.
           */
          const p10 = maxIndex-1;
          const p11 = histograms[this.thread.z][this.thread.y][prev];
          const p20 = maxIndex;
          const p21 = histograms[this.thread.z][this.thread.y][maxIndex];
          const p30 = maxIndex+1;
          const p31 = histograms[this.thread.z][this.thread.y][next];

          const d1 = (p30-p20)*(p30-p10);
          const d2 = (p10-p20)*(p30-p10);
          const d3 = p10-p20;

          // If any of the denominators are zero then return FALSE.
          if (d1 != 0 && d2 != 0 && d3 != 0) {
            const a = p10*p10;
            const b = p20*p20;

            // Solve for the coefficients A,B,C
            const A = ((p31-p21)/d1)-((p11-p21)/d2);
            const B = ((p11-p21)+(A*(b-a)))/d3;
            const C = p11-(A*a)-(B*p10);
            fbin = -B / (2 * A);
          }

          let an =  2.0 * Math.PI * ((fbin + 0.5 + numBins) / numBins);
          while (an > 2.0 * Math.PI) { // modula
            an -= 2.0 * Math.PI;
          }
          return an;
        }, {
          constants: {numBins: ORIENTATION_NUM_BINS},
          output: [1, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      );
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel(histograms);
    return result;
  }

  _applyPrune(dogIndex, prunedExtremas, extremasResult, width, height) {
    const extremaScores = extremasResult.result;
    const extremaSigmas = extremasResult.saveSigma;
    const extremaXs = extremasResult.saveX;
    const extremaYs = extremasResult.saveY;

    if (this.kernelIndex === this.kernels.length) {
      const subkernels = [];

      subkernels.push( //dummy
        gpu.createKernel(function() {
          return -1;
        }, {
          output: [1, NUM_BUCKETS],
          pipeline: true,
        })
      );

      // compute the orders one by one, and store the index as:
      //  if maxIndex < 0: it means coming from the existing prunedExtremas. the position is (-maxIndex-1);
      //        e.g. -1 -> 0, -2 -> 1, -3 -> 2
      //  if maxIndex >= 0: it means coming from the new extremas. the position is the pixel index
      for (let i = 0; i < MAX_FEATURES_PER_BUCKET; i++) {
        subkernels.push(
          gpu.createKernel(function(orders, prunedExtremas, extremaScores) {
            const bucketPointIndex = this.thread.x;
            const bucketIndex = this.thread.y;
            const orderIndex = this.constants.orderIndex;
            if (bucketPointIndex < orderIndex) return orders[this.thread.y][this.thread.x];

            const width = this.constants.width;
            const height= this.constants.height;
            const numBucketsPerDimension = this.constants.numBucketsPerDimension;
            const dx = this.constants.bucketWidth;
            const dy = this.constants.bucketHeight;

            const bucketX = bucketIndex % numBucketsPerDimension;
            const bucketY = Math.floor(bucketIndex / numBucketsPerDimension);

            let currentPrunedMaxIndex = -1;
            for (let i = 0; i < orderIndex; i++) {
              if (orders[bucketIndex][i] < 0) currentPrunedMaxIndex -= 1;
            }
            let maxIndex = currentPrunedMaxIndex;
            let maxScore = Math.abs(prunedExtremas[bucketIndex][-1 * currentPrunedMaxIndex - 1][0]); // score at propertyIndex 0
            maxScore = Math.max(maxScore, 0.0001); // safeguard, but probably not needed

            let startX = Math.floor(bucketX * dx);
            let endX = Math.floor((bucketX + 1) * dx);
            let startY = Math.floor(bucketY * dy);
            let endY = Math.floor((bucketY + 1) * dy);

            //for (let i = bucketX * dx; i < bucketX * dx + dx; i++) {
            //  for (let j = bucketY * dy; j < bucketY * dy + dy; j++) {
            for (let i = startX; i < endX; i++) {
              for (let j = startY; j < endY; j++) {
                const pointIndex = j * width + i;
                const pointScore = Math.abs(extremaScores[pointIndex]);
                if (pointScore > maxScore) {
                  let selected = false;
                  for (let k = 0; k < orderIndex; k++) {
                    if (orders[bucketIndex][k] === pointIndex) selected = true;
                  }
                  if (!selected) {
                    maxScore = pointScore;
                    maxIndex = pointIndex;
                  }
                }
              }
            }
            return maxIndex;
          }, {
            constants: {
              //bucketWidth: Math.ceil(width / NUM_BUCKETS_PER_DIMENSION),
              //bucketHeight: Math.ceil(height / NUM_BUCKETS_PER_DIMENSION),
              bucketWidth: width / NUM_BUCKETS_PER_DIMENSION,
              bucketHeight: height / NUM_BUCKETS_PER_DIMENSION,
              width: width,
              height: height,
              numBucketsPerDimension: NUM_BUCKETS_PER_DIMENSION,
              orderIndex: i
            },
            output: [i+1, NUM_BUCKETS],
            pipeline: true,
          })
        )
      }
      subkernels.push(
        gpu.createKernel(function(orders, prunedExtremas, extremaScores, extremaSigmas, extremaXs, extremaYs) {
          const dogIndex = this.constants.dogIndex;
          const propertyIndex = this.thread.x;
          const bucketPointIndex = this.thread.y;
          const bucketIndex = this.thread.z;
          const maxIndex = orders[bucketIndex][bucketPointIndex];
          if (maxIndex < 0) {
            return prunedExtremas[bucketIndex][-1 * maxIndex -1][propertyIndex];
          } else {
            if (propertyIndex === 0) return extremaScores[maxIndex];
            if (propertyIndex === 1) return extremaSigmas[maxIndex];
            if (propertyIndex === 2) return extremaXs[maxIndex];
            if (propertyIndex === 3) return extremaYs[maxIndex];
            if (propertyIndex === 4) return dogIndex;
          }
        }, {
          constants: {
            dogIndex: dogIndex,
          },
          output: [5, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS], // first dimension: [score, sigma, x, y, dogIndex]
          pipeline: true,
        })
      );
      this.kernels.push(subkernels);
    }

    const subkernels = this.kernels[this.kernelIndex++];
    let c = 0;
    let orders = subkernels[c++](); // dummy
    for (let i = 0; i < MAX_FEATURES_PER_BUCKET; i++) {
      orders = subkernels[c++](orders, prunedExtremas, extremaScores); // build max index one by one
    }
    // pack the result
    const result = subkernels[c++](orders, prunedExtremas, extremaScores, extremaSigmas, extremaXs, extremaYs);
    return result;
  }

  _computeGradients(image) {
    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        gpu.createKernelMap({
          saveMag: function(a) {return a}
        },
        function(data) {
          const width = this.constants.width;
          const height = this.constants.height;

          const i = this.thread.x % width;
          const j = Math.floor(this.thread.x / width);
          const prevJ = j > 0? j - 1: j;
          const nextJ = j < height - 1? j + 1: j;
          const prevI = i > 0? i - 1: i;
          const nextI = i < width - 1? i + 1: i;
          const dx = data[j * width + nextI] - data[j * width + prevI];
          const dy = data[nextJ * width + i] - data[prevJ * width + i];

          // seems like gpu atan2 doesn't handle dx === 0 well
          // angle = Math.atan2(dy, dx); can someone verify correctness?
          let angle = 0;
          if (dx === 0 && dy === 0) angle = 0;
          else if (dy === 0) {
            if (dx < 0) angle = Math.PI;
            else angle = 0;
          }
          else if (dx === 0) {
            if (dy < 0) angle = -Math.PI / 2;
            else angle = Math.PI / 2;
          }
          else {
            angle = Math.atan2(Math.abs(dy), Math.abs(dx));
            if (dx < 0 && dy > 0) angle = Math.PI - angle;
            else if (dx < 0 && dy < 0) angle = -(Math.PI - angle);
            else if (dx > 0 && dy < 0) angle = -angle;
          }
          angle += Math.PI;

          const mag = Math.sqrt(dx * dx + dy * dy);
          saveMag(mag);
          return angle;
        }, {
          constants: {width: image.width, height: image.height},
          output: [image.width * image.height],
          pipeline: true,
        })
      )
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel(image.data);
    return result;
  }

  _computeFreakDescriptors(freakResult) {
    if (this.kernelIndex === this.kernels.length) {
      const subkernels = [];
      subkernels.push(
        gpu.createKernel(function(freakResult) {
          const numFreakPoints = this.constants.numFreakPoints;
          const x = this.thread.x;

          // binary search first point index
          let l = 0;
          let r = numFreakPoints - 1;
          let startAt = 0;
          const maxloop = 7; // l=0, r=36. max num of loops = m = 18,9,5,3,2,1,
          for (let i = 0; i < maxloop; i++) {
            if (l !== r) {
              let m = Math.ceil((l + r) / 2);
              startAt = (numFreakPoints-m + numFreakPoints-1) * m / 2;
              if (x < startAt) {
                r = m - 1;
              } else {
                l = m;
              }
            }
          }
          startAt = (numFreakPoints-l + numFreakPoints-1) * l / 2;
          const p1 = l;
          const p2 = x - startAt + (p1+1);

          if (freakResult[this.thread.z][this.thread.y][p1] < freakResult[this.thread.z][this.thread.y][p2] + 0.0001) return 1;
          return 0;
        }, {
          constants: {
            numFreakPoints: FREAKPOINTS.length
          },
          output: [FREAK_CONPARISON_COUNT, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      )

      subkernels.push(
        gpu.createKernel(function(freakValues) {
          const comparisonCount = this.constants.comparisonCount;
          const x = this.thread.x;
          const start = 24 * x;
          const end = start + 24;
          let temp = 0;
          for (let i = start; i < end; i++) {
            if (i < comparisonCount && freakValues[this.thread.z][this.thread.y][i] === 1) {
              temp += 1;
            }
            temp = temp * 2;
          }
          temp /= 2;

          return temp;
        }, {
          constants: {
            comparisonCount: FREAK_CONPARISON_COUNT,
            numFreakPoints: FREAKPOINTS.length
          },
          output: [FREAK_24BIT_DESCRIPTOR_COUNT, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      );

      this.kernels.push(subkernels);
    }
    const subkernels = this.kernels[this.kernelIndex++];
    const result = subkernels[0](freakResult);
    const result2 = subkernels[1](result);
    return result2;
  }

  _computeExtremaFreak(pyramidImages, gaussianNumOctaves, prunedExtremas, prunedExtremasAngles) {
    if (this.kernelIndex === this.kernels.length) {
      const subkernels = [];

      subkernels.push(
        gpu.createKernelMap({
          saveXp: function(a) {return a},
          saveYp: function(a) {return a}
        },
        function(prunedExtremas, prunedExtremasAngles, freakPoints) {
          const gaussianNumOctaves = this.constants.gaussianNumOctaves;
          const gaussianNumScalesPerOctaves = this.constants.gaussianNumScalesPerOctaves;
          const expansionFactor = this.constants.expansionFactor;

          const bucketPointIndex = this.thread.y;
          const bucketIndex = this.thread.z;

          const mK = Math.pow(2, 1.0 / (gaussianNumScalesPerOctaves-1));
          const oneOverLogK = 1.0 / Math.log(mK);

          const inputX = prunedExtremas[bucketIndex][bucketPointIndex][2];
          const inputY = prunedExtremas[bucketIndex][bucketPointIndex][3];
          const inputSigma = prunedExtremas[bucketIndex][bucketPointIndex][1];
          const inputAngle = prunedExtremasAngles[bucketIndex][bucketPointIndex][0];

          const freakSigma = freakPoints[this.thread.x][0];
          const freakX = freakPoints[this.thread.x][1];
          const freakY = freakPoints[this.thread.x][2];

          // Ensure the scale of the similarity transform is at least "1".
          const transformScale = Math.max(1, inputSigma * expansionFactor);
          const c = transformScale * Math.cos(inputAngle);
          const s = transformScale * Math.sin(inputAngle);
          // similarity matrix
          // const S = [
          //  c, -s, x,
          //  s, c, y,
          //  0, 0, 1
          //]
          const S0 = c;
          const S1 = -s;
          const S2 = inputX;
          const S3 = s;
          const S4 = c;
          const S5 = inputY;

          const sigma = transformScale * freakSigma;
          let octave = Math.floor(Math.log2(sigma));
          const fscale = Math.log(sigma / Math.pow(2, octave)) * oneOverLogK;
          let scale = Math.round(fscale);

          // sgima of last scale = sigma of the first scale in next octave
          // prefer coarser octaves for efficiency
          if (scale === gaussianNumScalesPerOctaves - 1) {
            octave = octave + 1;
            scale = 0;
          }
          // clip octave and scale
          if (octave < 0) {
            octave = 0;
            scale = 0;
          }
          if (octave >= gaussianNumOctaves) {
            octave = gaussianNumOctaves - 1;
            scale = gaussianNumScalesPerOctaves - 1;
          }

          // for downsample point
          const imageIndex = octave * gaussianNumScalesPerOctaves + scale;
          const a = 1.0 / (Math.pow(2, octave));
          const b = 0.5 * a - 0.5;

          const x = S0 * freakX + S1 * freakY + S2;
          const y = S3 * freakX + S4 * freakY + S5;
          let xp = x * a + b; // x in octave
          let yp = y * a + b; // y in octave

          saveXp(xp);
          saveYp(yp);
          return imageIndex;
        }, {
          constants: {
            gaussianNumOctaves: gaussianNumOctaves,
            gaussianNumScalesPerOctaves: PYRAMID_NUM_SCALES_PER_OCTAVES,
            expansionFactor: FREAK_EXPANSION_FACTOR
          },
          output: [FREAKPOINTS.length, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      )

      subkernels.push(
        gpu.createKernel(function() {
          return 0;
        }, {
          output: [FREAKPOINTS.length, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
          pipeline: true,
        })
      );

      for (let i = 0; i < pyramidImages.length; i++) {
        subkernels.push(
          gpu.createKernel(function(freakResult, imageData, xps, yps, imageIndexes) {
            const gaussianIndex = this.constants.gaussianIndex;
            const width = this.constants.width;
            const height = this.constants.height;

            if (imageIndexes[this.thread.z][this.thread.y][this.thread.x] !== gaussianIndex) {
              return freakResult[this.thread.z][this.thread.y][this.thread.x];
            }

            let xp = xps[this.thread.z][this.thread.y][this.thread.x];
            let yp = yps[this.thread.z][this.thread.y][this.thread.x];

            // bilinear interpolation
            xp = Math.max(0, Math.min(xp, width - 2));
            yp = Math.max(0, Math.min(yp, height - 2));

            const x0 = Math.floor(xp);
            const x1 = x0 + 1;
            const y0 = Math.floor(yp);
            const y1 = y0 + 1;
            const value = (x1-xp) * (y1-yp) * imageData[y0 * width + x0]
                        + (xp-x0) * (y1-yp) * imageData[y0 * width + x1]
                        + (x1-xp) * (yp-y0) * imageData[y1 * width + x0]
                        + (xp-x0) * (yp-y0) * imageData[y1 * width + x1];
            return value;
          }, {
            constants: {
              gaussianIndex: i,
              width: pyramidImages[i].width,
              height: pyramidImages[i].height
            },
            output: [FREAKPOINTS.length, MAX_FEATURES_PER_BUCKET, NUM_BUCKETS],
            pipeline: true,
          })
        )
      }
      this.kernels.push(subkernels);
    }
    const subkernels = this.kernels[this.kernelIndex++];

    // compute the locations of all freak points
    const result = subkernels[0](prunedExtremas, prunedExtremasAngles, FREAKPOINTS);
    const imageIndexes = result.result;
    const xps = result.saveXp;
    const yps = result.saveYp;

    // compute the interpolated values of each freak coordinates (this values is used to build the freak descriptors)
    let freakResult = subkernels[1]();
    for (let i = 0; i < pyramidImages.length; i++) {
      freakResult = subkernels[i+2](freakResult, pyramidImages[i].data, xps, yps, imageIndexes);
    }
    return freakResult;
  }

  _buildExtremas(image0, image1, image2, octave, scale, startI, startJ, endI, endJ) {
    const originalWidth = this.width;
    const originalHeight = this.height;
    const dogNumScalesPerOctaves = PYRAMID_NUM_SCALES_PER_OCTAVES - 1;

    if (this.kernelIndex === this.kernels.length) {
      this.kernels2 = [];
      this.kernels2.push(
        gpu.createKernelMap([
          function saveX(a) {return a}
        ],
        function(data0, data1, data2, startI, startJ, endI, endJ) {
          saveX(0);
          return 0;
        }, {
          constants: {
            LAPLACIAN_SQR_THRESHOLD: LAPLACIAN_SQR_THRESHOLD,
            MAX_SUBPIXEL_DISTANCE_SQR: MAX_SUBPIXEL_DISTANCE_SQR,
            EDGE_HESSIAN_THRESHOLD: EDGE_HESSIAN_THRESHOLD,
            originalWidth: originalWidth,
            originalHeight: originalHeight,
            width: image1.width,
            height: image1.height,
            octave: octave,
            scale: scale,
            dogNumScalesPerOctaves: dogNumScalesPerOctaves,
          },
          output: [image1.width * image1.height],
          pipeline: true,
        })
      );
      this.kernels.push(
        // return
        //  1. score: how strong is the extrema. (the larger the difference of gaussian value, the stronger)
        //      score can be positive (maxima) or negative (minima)
        //  2. x, y: the effective x, y coordinate in the original image
        //  3. sigma: the effective sigma in the original image (I'm not sure what sigma is. any educational reference?)
        gpu.createKernelMap({
          saveSigma: function(a) {return a;},
          saveX: function(a) {return a;},
          saveY: function(a) {return a;}
        },
        function(data0, data1, data2, startI, startJ, endI, endJ) {
          const LAPLACIAN_SQR_THRESHOLD = this.constants.LAPLACIAN_SQR_THRESHOLD;
          const MAX_SUBPIXEL_DISTANCE_SQR = this.constants.MAX_SUBPIXEL_DISTANCE_SQR;
          const EDGE_HESSIAN_THRESHOLD = this.constants.EDGE_HESSIAN_THRESHOLD;
          const originalWidth = this.constants.originalWidth;
          const originalHeight = this.constants.originalHeight;
          const width = this.constants.width;
          const height = this.constants.height;
          const octave = this.constants.octave;
          const scale = this.constants.scale;
          const dogNumScalesPerOctaves = this.constants.dogNumScalesPerOctaves;

          const pos = this.thread.x;
          const posI = pos % width;
          const posJ = Math.floor(pos / width);
          if (posI < startI || posI > endI || posJ < startJ || posJ > endJ) return 0;

          const v = data1[pos];
          if (v * v < LAPLACIAN_SQR_THRESHOLD) return 0;

          let isMax = true;
          for (let d = 0; d < 9; d++) {
            const i = d % 3;
            const j = Math.floor(d / 3);
            const pos2 = pos + (j-1) * width + (i-1);
            if (data1[pos] <= data0[pos2]) {isMax = false; break;};
            if (data1[pos] <= data2[pos2]) {isMax = false; break;};
            if (pos !== pos2 && data1[pos] <= data1[pos2]) {isMax = false; break;};
          }

          let isMin = false;
          if (!isMax) {
            isMin = true;
            for (let d = 0; d < 9; d++) {
              const i = d % 3;
              const j = Math.floor(d / 3);
              const pos2 = pos + (j-1) * width + (i-1);
              if (data1[pos] >= data0[pos2]) {isMin = false; break};
              if (data1[pos] >= data2[pos2]) {isMin = false; break};
              if (pos !== pos2 && data1[pos] >= data1[pos2]) {isMin = false; break};
            }
          }
          if (!isMax && !isMin) return 0;

          // Step 2: sub-pixel refinement (I'm not sure what that means. Any educational ref?)

          // Compute spatial derivatives
          const dx = 0.5 * (data1[pos + 1] - data1[pos - 1]);
          const dy = 0.5 * (data1[pos + width] - data1[pos - width]);
          const dxx = data1[pos + 1] + data1[pos - 1] - 2 * data1[pos];
          const dyy = data1[pos + width] + data1[pos - width] - 2 * data1[pos];
          const dxy = 0.25 * (data1[pos - width -1] + data1[pos + width + 1] - data1[pos - width +1] - data1[pos + width - 1]);

          // Compute scale derivates
          const ds = 0.5 * (data2[pos] - data0[pos]);
          const dss = data2[pos] + data0[pos] - 2 * data1[pos];
          const dxs = 0.25 * ((data0[pos-1] - data0[pos+1]) + (-data2[pos-1] + data2[pos+1]));
          const dys = 0.25 * ((data0[pos-width] - data0[pos+width]) + (-data2[pos-width] + data2[pos+width]));

          // Solve Hessian A * u = b;
          const A0 = dxx;
          const A1 = dxy;
          const A2 = dxs;
          const A3 = dxy;
          const A4 = dyy;
          const A5 = dys;
          const A6 = dxs;
          const A7 = dys;
          const A8 = dss;
          const b0 = -dx;
          const b1 = -dy;
          const b2 = -ds;

          const detA = A0 * A4 * A8
                    - A0 * A5 * A5
                    - A4 * A2 * A2
                    - A8 * A1 * A1
                    + 2 * A1 * A2 * A5;

          if ( Math.abs(detA) < 0.0000001) return 0; // determinant undefined. no solution

          // B = inverse of A
          const B0 = A4 * A8 - A5 * A7;
          const B1 = A2 * A7 - A1 * A8;
          const B2 = A1 * A5 - A2 * A4;
          const B3 = B1;
          const B4 = A0 * A8 - A2 * A6;
          const B5 = A2 * A3 - A0 * A5;
          const B6 = B2;
          const B7 = B5;
          const B8 = A0 * A4 - A1 * A3;

          const u0 = (B0 * b0 + B1 * b1 + B2 * b2) / detA;
          const u1 = (B3 * b0 + B4 * b1 + B5 * b2) / detA;
          const u2 = (B6 * b0 + B7 * b1 + B8 * b2) / detA;

          // If points move too much in the sub-pixel update, then the point probably unstable.
          if (u0 * u0 + u1 * u1 > MAX_SUBPIXEL_DISTANCE_SQR) return 0;

          // compute edge score
          const det = (dxx * dyy) - (dxy * dxy);
          if (det === 0) return 0;

          const edgeScore = (dxx + dyy) * (dxx + dyy) / det;
          if (Math.abs(edgeScore) >= EDGE_HESSIAN_THRESHOLD ) return 0;

          const score = v - (b0 * u0 + b1 * u1 + b2 * u2);
          if (score * score < LAPLACIAN_SQR_THRESHOLD) return 0;

          // original x = x*2^n + 2^(n-1) - 0.5
          // original y = y*2^n + 2^(n-1) - 0.5
          let originalX = posI * Math.pow(2, octave) + Math.pow(2, octave-1) - 0.5;
          let originalY = posJ * Math.pow(2, octave) + Math.pow(2, octave-1) - 0.5;
          originalX = originalX + u0 * Math.pow(2, octave);
          originalY = originalY + u1 * Math.pow(2, octave);
          if (originalX < 0 || originalX >= originalWidth || originalY < 0 || originalY >= originalHeight) return 0;

          const spScale = Math.min(Math.max(0, scale + u2), dogNumScalesPerOctaves);
          const mK = Math.pow(2, 1.0 / dogNumScalesPerOctaves);
          const newSigma = Math.pow(mK, spScale) * (1 << octave);

          saveSigma(newSigma);
          saveX(originalX);
          saveY(originalY);
          return score;
        }, {
          constants: {
            LAPLACIAN_SQR_THRESHOLD: LAPLACIAN_SQR_THRESHOLD,
            MAX_SUBPIXEL_DISTANCE_SQR: MAX_SUBPIXEL_DISTANCE_SQR,
            EDGE_HESSIAN_THRESHOLD: EDGE_HESSIAN_THRESHOLD,
            originalWidth: originalWidth,
            originalHeight: originalHeight,
            width: image1.width,
            height: image1.height,
            octave: octave,
            scale: scale,
            dogNumScalesPerOctaves: dogNumScalesPerOctaves,
          },
          output: [image1.width * image1.height],
          pipeline: true,
        })
      );
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel(image0.data, image1.data, image2.data, startI, startJ, endI, endJ);
    return result;
  }

  _downsampleBilinear(image) {
    const dstWidth = Math.floor(image.width / 2);
    const dstHeight = Math.floor(image.height / 2);

    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        gpu.createKernel(function(data) {
          const width = this.constants.width;
          const srcWidth = this.constants.srcWidth;
          const j = Math.floor(this.thread.x / width);
          const i = this.thread.x % width;
          const srcPos = j * 2 * srcWidth + i * 2;
          const v = (data[srcPos] + data[srcPos+1] + data[srcPos+srcWidth] + data[srcPos+srcWidth+1]) * 0.25;
          return v;
        }, {
          constants: {srcWidth: image.width, width: dstWidth},
          output: [dstWidth * dstHeight],
          pipeline: true,
        })
      );
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel(image.data);
    return {width: dstWidth, height: dstHeight, data: result};
  }

  _upsampleBilinear(image, padOneWidth, padOneHeight) {
    const dstWidth = image.width * 2 + (padOneWidth?1:0);
    const dstHeight = image.height * 2 + (padOneHeight?1:0);

    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        gpu.createKernel(function(data) {
          const width = this.constants.width;
          const height = this.constants.height;

          const srcWidth = Math.floor(width / 2);
          const srcHeight = Math.floor(height / 2);

          const j = Math.floor(this.thread.x / width);
          const i = this.thread.x % width;
          const si = 0.5 * i - 0.25;
          const sj = 0.5 * j - 0.25;
          const si0 = Math.max(0, Math.floor(si));
          const si1 = Math.min(Math.ceil(si), srcWidth-1);
          const sj0 = Math.max(0, Math.floor(sj));
          const sj1 = Math.min(Math.ceil(sj), srcHeight-1);
          const value = (si1 - si) * (sj1 - sj) * data[ sj0 * width + si0 ] +
                        (si1 - si) * (sj - sj0) * data[ sj1 * width + si0 ] +
                        (si - si0) * (sj1 - sj) * data[ sj0 * width + si1 ] +
                        (si - si0) * (sj - sj0) * data[ sj1 * width + si1 ];
          return value;
        }, {
          constants: {width: dstWidth, height: dstHeight},
          output: [dstWidth * dstHeight],
          pipeline: true,
        })
      );
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel(image.data);
    return {width: dstWidth, height: dstHeight, data: result};
  }

  // 4th order binomail filter
  _applyFilter(image) {
    if (this.kernelIndex === this.kernels.length) {
      const f1 = gpu.createKernel(function(data) {
        const width = this.constants.width;
        const j = Math.floor(this.thread.x / width);
        const i = this.thread.x % width;
        const joffset = j * width;
        const v = data[joffset + Math.max(i-2,0)] +
                  data[joffset + Math.max(i-1,0)] * 4 +
                  data[joffset + i] * 6 +
                  data[joffset + Math.min(i+1,width-1)] * 4 +
                  data[joffset + Math.min(i+2,width-1)];
        return v;
      }, {
        constants: {width: image.width},
        output: [image.width * image.height],
        pipeline: true
      });

      const f2 = gpu.createKernel(function(data) {
        const width = this.constants.width;
        const height = this.constants.height;
        const j = Math.floor(this.thread.x / width);
        const i = this.thread.x % width;
        const v = data[Math.max(j-2,0) * width + i] +
                  data[Math.max(j-1,0) * width + i] * 4 +
                  data[j * width + i] * 6 +
                  data[Math.min(j+1,height-1) * width + i] * 4 +
                  data[Math.min(j+2,height-1) * width + i];

        return v / 256; // altogether (1+4+6+4+1) * (1+4+6+4+1) numbers
      }, {
        constants: {width: image.width, height: image.height},
        output: [image.width * image.height],
        pipeline: true,
      });
      this.kernels.push({f1, f2});
    }
    const {f1, f2} = this.kernels[this.kernelIndex++];
    const result = f2(f1(image.data));
    return {width: image.width, height: image.height, data: result};
  }

  _differenceImageBinomial(image1, image2) {
    if (this.kernelIndex === this.kernels.length) {
      this.kernels.push(
        gpu.createKernel(function(data1, data2) {
          return data1[this.thread.x] - data2[this.thread.x];
        }, {
          output: [image1.width * image1.height],
          pipeline: true,
        })
      );
    }
    const kernel = this.kernels[this.kernelIndex++];
    const result = kernel(image1.data, image2.data);
    return {width: image1.width, height: image1.height, data: result};
  }
}

module.exports = {
  Detector
};


/***/ }),

/***/ "./src/image-target/icp/estimate_homography.js":
/*!*****************************************************!*\
  !*** ./src/image-target/icp/estimate_homography.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {Matrix, inverse} = __webpack_require__(/*! ml-matrix */ "./node_modules/ml-matrix/src/index.js");
const {applyModelViewProjectionTransform, buildModelViewProjectionTransform, computeScreenCoordiate} = __webpack_require__(/*! ./utils.js */ "./src/image-target/icp/utils.js");

// build world matrix with list of matching worldCoords|screenCoords
//
// Step 1. estimate homography with list of pairs
// Ref: https://www.uio.no/studier/emner/matnat/its/TEK5030/v19/lect/lecture_4_3-estimating-homographies-from-feature-correspondences.pdf  (Basic homography estimation from points)
//
// Step 2. decompose homography into rotation and translation matrixes (i.e. world matrix)
// Ref: can anyone provide reference?
const estimateHomography = ({screenCoords, worldCoords, projectionTransform}) => {
  const num = screenCoords.length;
  const AData = [];
  const BData = [];
  for (let j = 0; j < num; j++) {
    const row1 = [
      worldCoords[j].x,
      worldCoords[j].y,
      1,
      0,
      0,
      0,
      -(worldCoords[j].x * screenCoords[j].x),
      -(worldCoords[j].y * screenCoords[j].x),
    ];
    const row2 = [
      0,
      0,
      0,
      worldCoords[j].x,
      worldCoords[j].y,
      1,
      -(worldCoords[j].x * screenCoords[j].y),
      -(worldCoords[j].y * screenCoords[j].y),
    ];
    AData.push(row1);
    AData.push(row2);

    BData.push([screenCoords[j].x]);
    BData.push([screenCoords[j].y]);
  }

  const A = new Matrix(AData);
  const B = new Matrix(BData);
  const AT = A.transpose();
  const ATA = AT.mmul(A);
  const ATB = AT.mmul(B);
  const ATAInv = inverse(ATA);
  const C = ATAInv.mmul(ATB).to1DArray();

  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
    for (let j = 0; j < A.data.length; j++) {
      for (let i = 0; i < A.data[j].length; i++) {
        if (!window.cmp(A.data[j][i], window.debugMatch.matA[j][i], 0.1)) {
          console.log("INCORRECT A", j, i, A.data[j][i], window.debugMatch.matA[j][i]);
        }
      }
    }
    for (let j = 0; j < C.length; j++) {
      if (!window.cmp(C[j], window.debugMatch.matC[j], 0.001)) {
        console.log("INCORRECT C", j, C[j], window.debugMatch.matC[j]);
      }
    }
  }

  const H = new Matrix([
    [C[0], C[1], C[2]],
    [C[3], C[4], C[5]],
    [C[6], C[7], 1]
  ]);

  const K = new Matrix(projectionTransform);
  const KInv = inverse(K);

  const _KInvH = KInv.mmul(H);
  const KInvH = _KInvH.to1DArray();

  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
    const dv = window.debugMatch.v;
    const dt = window.debugMatch.t;
    const dKInvH = [
      [dv[0][0],dv[1][0],dt[0]],
      [dv[0][1],dv[1][1],dt[1]],
      [dv[0][2],dv[1][2],dt[2]]
    ];
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        if(!window.cmp(_KInvH.data[i][j], dKInvH[i][j])) {
          console.log("INCORRECT KInvH", i, j, KInvH.data, dKInvH);
          break;
        }
      }
    }
  }

  const norm1 = Math.sqrt( KInvH[0] * KInvH[0] + KInvH[3] * KInvH[3] + KInvH[6] * KInvH[6]);
  const norm2 = Math.sqrt( KInvH[1] * KInvH[1] + KInvH[4] * KInvH[4] + KInvH[7] * KInvH[7]);
  const tnorm = (norm1 + norm2) / 2;

  const rotate = [];
  rotate[0] = KInvH[0] / norm1;
  rotate[3] = KInvH[3] / norm1;
  rotate[6] = KInvH[6] / norm1;

  rotate[1] = KInvH[1] / norm2;
  rotate[4] = KInvH[4] / norm2;
  rotate[7] = KInvH[7] / norm2;

  rotate[2] = rotate[3] * rotate[7] - rotate[6] * rotate[4];
  rotate[5] = rotate[6] * rotate[1] - rotate[0] * rotate[7];
  rotate[8] = rotate[0] * rotate[4] - rotate[1] * rotate[3];

  const norm3 = Math.sqrt(rotate[2] * rotate[2] + rotate[5] * rotate[5] + rotate[8] * rotate[8]);
  rotate[2] /= norm3;
  rotate[5] /= norm3;
  rotate[8] /= norm3;

  // TODO: artoolkit has check_rotation() that somehow switch the rotate vector. not sure what that does. Can anyone advice?
  // https://github.com/artoolkitx/artoolkit5/blob/5bf0b671ff16ead527b9b892e6aeb1a2771f97be/lib/SRC/ARICP/icpUtil.c#L215

  const tran = []
  tran[0] = KInvH[2] / tnorm;
  tran[1] = KInvH[5] / tnorm;
  tran[2] = KInvH[8] / tnorm;

  let initialModelViewTransform = [
    [rotate[0], rotate[1], rotate[2], tran[0]],
    [rotate[3], rotate[4], rotate[5], tran[1]],
    [rotate[6], rotate[7], rotate[8], tran[2]]
  ];

  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
    console.log("initialModelViewTransform", initialModelViewTransform, window.debugMatch.initMatXw2Xc);
    for (let j = 0; j < initialModelViewTransform.length; j++) {
      for (let i = 0; i < initialModelViewTransform[j].length; i++) {
        if (!window.cmp(initialModelViewTransform[j][i], window.debugMatch.initMatXw2Xc[j][i], 0.0001)) {
          console.log("INCORRECT initialModelViewTransform", j, i, initialModelViewTransform[j][i], window.debugMatch.initMatXw2Xc[j][i]);
        }
      }
    }
  }

  return initialModelViewTransform;
};

module.exports = {
  estimateHomography
}


/***/ }),

/***/ "./src/image-target/icp/refine_homography.js":
/*!***************************************************!*\
  !*** ./src/image-target/icp/refine_homography.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {Matrix, inverse} = __webpack_require__(/*! ml-matrix */ "./node_modules/ml-matrix/src/index.js");
const {getProjectionTransform, applyModelViewProjectionTransform, buildModelViewProjectionTransform, computeScreenCoordiate} = __webpack_require__(/*! ./utils.js */ "./src/image-target/icp/utils.js");

// TODO: the error computation seems problematic. should it be relative to the size of detection?
//       now the values are hardcoded, e.g. K2_Factor = 4

const K2_FACTOR = 4.0;
const ICP_MAX_LOOP = 10;
const ICP_BREAK_LOOP_ERROR_THRESH = 0.1;
const ICP_BREAK_LOOP_ERROR_RATIO_THRESH = 0.99;
const ICP_BREAK_LOOP_ERROR_THRESH2 = 4.0;

// ICP iteration with points
// Can someone provide theoretical reference?
const refineHomography = ({initialModelViewTransform, projectionTransform, worldCoords, screenCoords, isRobustMode, inlierProb}) => {
  let modelViewTransform = initialModelViewTransform;

  let err0 = 0.0;
  let err1 = 0.0;
  for (let l = 0; l <= ICP_MAX_LOOP; l++) {

    const modelViewProjectionTransform = buildModelViewProjectionTransform(projectionTransform, modelViewTransform);

    if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
      //console.log("projectionTransform", projectionTransform);
      if (!window.cmp2DArray(modelViewTransform, window.debugMatch.icp_matXw2Xc[l])) {
        console.log("INCORRECT ICP modelViewTransform", l, modelViewTransform, window.debugMatch.icp_matXw2Xc[l]);
      }

      if (!window.cmp2DArray(modelViewProjectionTransform, window.debugMatch.icp_matXw2U[l])) {
        console.log("INCORRECT ICP modelViewProjectionTransform", l, modelViewProjectionTransform, window.debugMatch.icp_matXw2U[l]);
      }
    }

    const E = [];
    const dxs = [];
    const dys = [];
    for (let n = 0; n < worldCoords.length; n++) {
      const u = computeScreenCoordiate(modelViewProjectionTransform, worldCoords[n].x, worldCoords[n].y, worldCoords[n].z);
      const dx = screenCoords[n].x - u.x;
      const dy = screenCoords[n].y - u.y;
      dxs.push(dx);
      dys.push(dy);
      E.push(dx * dx + dy * dy);
    }

    if (typeof window !== 'undefined' && window.DEBUG_TRACK && isRobustMode) {
      const dr = window.debugMatch.icp_robust[window.debug.icprobustIndex][l];
      //console.log("icp E", E, dr.E);
    }

    let K2; // robust mode only
    err1 = 0.0;
    if (isRobustMode) {
      const inlierNum = Math.max(3, Math.floor(worldCoords.length * inlierProb) - 1);
      const E2 = []; // for robust mode only
      for (let n = 0; n < worldCoords.length; n++) {
        E2.push(E[n]);
      }
      E2.sort((a, b) => {return a-b;});

      if (typeof window !== 'undefined' && window.DEBUG_TRACK && isRobustMode) {
        const dr = window.debugMatch.icp_robust[window.debug.icprobustIndex][l];
        //console.log("icp E", E2, dr.E2);
      }

      K2 = Math.max(E2[inlierNum] * K2_FACTOR, 16.0);
      for (let n = 0; n < worldCoords.length; n++) {
        if (E2[n] > K2) err1 += K2/ 6;
        else err1 +=  K2/6.0 * (1.0 - (1.0-E2[n]/K2)*(1.0-E2[n]/K2)*(1.0-E2[n]/K2));
      }
    } else {
      for (let n = 0; n < worldCoords.length; n++) {
        err1 += E[n];
      }
    }
    //console.log("err1 before", err1, err1/worldCoords.length);
    err1 /= worldCoords.length;

    if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
      //if (!window.cmp(err1, window.debugMatch.icp_err1[l])) {
      //  console.log("INCORRECT ICP err1", l, err1, window.debugMatch.icp_err1[l]);
      //}
    }

    if (err1 < ICP_BREAK_LOOP_ERROR_THRESH) break;
    if (l > 0 && err1 < ICP_BREAK_LOOP_ERROR_THRESH2 && err1/err0 > ICP_BREAK_LOOP_ERROR_RATIO_THRESH) break;
    if (l === ICP_MAX_LOOP) break;

    err0 = err1;

    const dU = [];
    const allJ_U_S = [];
    for (let n = 0; n < worldCoords.length; n++) {
      if (isRobustMode && E[n] > K2) {
        continue;
      }

      const J_U_S = _getJ_U_S({modelViewProjectionTransform, modelViewTransform, projectionTransform, worldCoord: worldCoords[n]});

      if (isRobustMode) {
        const W = (1.0 - E[n]/K2)*(1.0 - E[n]/K2);

        if (typeof window !== 'undefined' && window.DEBUG_TRACK && isRobustMode) {
          const dr = window.debugMatch.icp_robust[window.debug.icprobustIndex][l];
          //console.log("icp W", W, dr.W);
        }

        for (let j = 0; j < 2; j++) {
          for (let i = 0; i < 6; i++) {
            J_U_S[j][i] *= W;
          }
        }
        dU.push([dxs[n] * W]);
        dU.push([dys[n] * W]);
      } else {
        dU.push([dxs[n]]);
        dU.push([dys[n]]);
      }

      //console.log("J_U_S", J_U_S, debugContent.icp_J_U_S[l][n]);
      for (let i = 0; i < J_U_S.length; i++) {
        allJ_U_S.push(J_U_S[i]);
      }
    }

    if (typeof window !== 'undefined' && window.DEBUG_TRACK && isRobustMode) {
      const dr = window.debugMatch.icp_robust[window.debug.icprobustIndex][l];
      //console.log("icp du", dU, dr.dU);
    }

    if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
      if (!window.cmpArray(dU, window.debugMatch.icp_dU[l], 0.001)) {
        console.log("INCORRECT ICP dU", l, dU, window.debugMatch.icp_dU[l]);
      }
    }
    if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
      const dJUS = [];
      for (let i = 0; i < window.debugMatch.icp_J_U_S[l].length; i++) {
        dJUS.push(window.debugMatch.icp_J_U_S[l][i][0]);
        dJUS.push(window.debugMatch.icp_J_U_S[l][i][1]);
      }

      if (!window.cmp2DArray(allJ_U_S, dJUS, 0.001)) {
        console.log("INCORRECT ICP J_U_S", l, allJ_U_S, dJUS);
      }
    }

    const dS = _getDeltaS({dU, J_U_S: allJ_U_S});
    if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
      if (!window.cmpArray(dS, window.debugMatch.icp_dS[l], 0.001)) {
        console.log("INCORRECT ICP dS", l, dS, window.debugMatch.icp_dS[l]);
      }
    }

    if (dS === null) break;
    modelViewTransform = _updateModelViewTransform({modelViewTransform, dS});
  }
  return {modelViewTransform, err: err1};
}

_updateModelViewTransform = ({modelViewTransform, dS}) => {
  const q = [];
  let ra = dS[0] * dS[0] + dS[1] * dS[1] + dS[2] * dS[2];
  if( ra < 0.000001 ) {
    q[0] = 1.0;
    q[1] = 0.0;
    q[2] = 0.0;
    q[3] = 0.0;
  } else {
    ra = Math.sqrt(ra);
    q[0] = dS[0] / ra;
    q[1] = dS[1] / ra;
    q[2] = dS[2] / ra;
    q[3] = ra;
  }
  q[4] = dS[3];
  q[5] = dS[4];
  q[6] = dS[5];

  const cra = Math.cos(q[3]);
  const one_cra = 1.0 - cra;
  const sra = Math.sin(q[3]);
  const mat = [[],[],[]];

  mat[0][0] = q[0]*q[0]*one_cra + cra;
  mat[0][1] = q[0]*q[1]*one_cra - q[2]*sra;
  mat[0][2] = q[0]*q[2]*one_cra + q[1]*sra;
  mat[0][3] = q[4];
  mat[1][0] = q[1]*q[0]*one_cra + q[2]*sra;
  mat[1][1] = q[1]*q[1]*one_cra + cra;
  mat[1][2] = q[1]*q[2]*one_cra - q[0]*sra;
  mat[1][3] = q[5];
  mat[2][0] = q[2]*q[0]*one_cra - q[1]*sra;
  mat[2][1] = q[2]*q[1]*one_cra + q[0]*sra;
  mat[2][2] = q[2]*q[2]*one_cra + cra;
  mat[2][3] = q[6];

  const mat2 = [[],[],[]];
  for (let j = 0; j < 3; j++ ) {
    for (let i = 0; i < 4; i++ ) {
      mat2[j][i] = modelViewTransform[j][0] * mat[0][i]
                   + modelViewTransform[j][1] * mat[1][i]
                   + modelViewTransform[j][2] * mat[2][i];
    }
    mat2[j][3] += modelViewTransform[j][3];
  }
  return mat2;
}

_getDeltaS = ({dU, J_U_S}) => {
  const J = new Matrix(J_U_S);
  const U = new Matrix(dU);

  const JT = J.transpose();
  const JTJ = JT.mmul(J);
  const JTU = JT.mmul(U);

  let JTJInv;
  try {
    JTJInv = inverse(JTJ);
  } catch (e) {
    return null;
  }

  const S = JTJInv.mmul(JTU);
  return S.to1DArray();
}

_getJ_U_S = ({modelViewProjectionTransform, modelViewTransform, projectionTransform, worldCoord}) => {
  const T = modelViewTransform;
  const {x, y, z} = worldCoord;

  const u = applyModelViewProjectionTransform(modelViewProjectionTransform, x, y, z);
  //console.log("u", u);
  //if (Math.abs(u.z) < 0.000001) return null;

  const z2 = u.z * u.z;
  const J_U_Xc = [[],[]];
  J_U_Xc[0][0] = (projectionTransform[0][0] * u.z - projectionTransform[2][0] * u.x) / z2;
  J_U_Xc[0][1] = (projectionTransform[0][1] * u.z - projectionTransform[2][1] * u.x) / z2;
  J_U_Xc[0][2] = (projectionTransform[0][2] * u.z - projectionTransform[2][2] * u.x) / z2;
  J_U_Xc[1][0] = (projectionTransform[1][0] * u.z - projectionTransform[2][0] * u.y) / z2;
  J_U_Xc[1][1] = (projectionTransform[1][1] * u.z - projectionTransform[2][1] * u.y) / z2;
  J_U_Xc[1][2] = (projectionTransform[1][2] * u.z - projectionTransform[2][2] * u.y) / z2;

  const J_Xc_S = [
    [T[0][2] * y - T[0][1] * z, T[0][0] * z - T[0][2] * x, T[0][1] * x - T[0][0] * y, T[0][0], T[0][1], T[0][2]],
    [T[1][2] * y - T[1][1] * z, T[1][0] * z - T[1][2] * x, T[1][1] * x - T[1][0] * y, T[1][0], T[1][1], T[1][2]],
    [T[2][2] * y - T[2][1] * z, T[2][0] * z - T[2][2] * x, T[2][1] * x - T[2][0] * y, T[2][0], T[2][1], T[2][2]],
  ];

  //console.log("J_Xc_S", J_Xc_S, '--vs--', '0.', debugContent.icp_J_Xc_S[0], '1.', debugContent.icp_J_Xc_S[1]);
  //console.log("J_U_Xc", J_U_Xc, '--vs--', '0.', debugContent.icp_J_U_Xc[0], '1.', debugContent.icp_J_U_Xc[1]);

  const J_U_S = [[], []];
  for (let j = 0; j < 2; j++) {
    for (let i = 0; i < 6; i++) {
      J_U_S[j][i] = 0.0;
      for (let k = 0; k < 3; k++ ) {
        J_U_S[j][i] += J_U_Xc[j][k] * J_Xc_S[k][i];
      }
    }
  }
  return J_U_S;
}

module.exports = {
  refineHomography
}


/***/ }),

/***/ "./src/image-target/icp/utils.js":
/*!***************************************!*\
  !*** ./src/image-target/icp/utils.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
const getProjectionTransform = () => {
  // TODO: non-hardcoded camera matrix?
  //     [fx  s cx]
  // K = [ 0 fx cy]
  //     [ 0  0  1]
  const KData = [
    [ 304.68270459335025, 0, 161.7239532470703],
    [ 0, 303.2606118015537, 118.80326843261719],
    [ 0, 0, 1.0]
  ];
  return KData;
}
*/

const buildModelViewProjectionTransform = (projectionTransform, modelViewTransform) => {
  const modelViewProjectionTransform = [[],[],[]];
  for (let j = 0; j < 3; j++ ) {
    for (let i = 0; i < 4; i++) {
      modelViewProjectionTransform[j][i] = projectionTransform[j][0] * modelViewTransform[0][i]
                                         + projectionTransform[j][1] * modelViewTransform[1][i]
                                         + projectionTransform[j][2] * modelViewTransform[2][i];
    }
  }
  return modelViewProjectionTransform;
}

const applyModelViewProjectionTransform = (modelViewProjectionTransform, x, y, z) => {
  const ux = modelViewProjectionTransform[0][0] * x + modelViewProjectionTransform[0][1] * y
     + modelViewProjectionTransform[0][2] * z + modelViewProjectionTransform[0][3];
  const uy = modelViewProjectionTransform[1][0] * x + modelViewProjectionTransform[1][1] * y
     + modelViewProjectionTransform[1][2] * z + modelViewProjectionTransform[1][3];
  const uz  = modelViewProjectionTransform[2][0] * x + modelViewProjectionTransform[2][1] * y
     + modelViewProjectionTransform[2][2] * z + modelViewProjectionTransform[2][3];
  return {x: ux, y: uy, z: uz};
}

const computeScreenCoordiate = (modelViewProjectionTransform, x, y, z) => {
  const {x: ux, y: uy, z: uz} = applyModelViewProjectionTransform(modelViewProjectionTransform, x, y, z);
  //console.log("x, y, z", ux, uy, uz);
  if( Math.abs(uz) < 0.000001 ) return null;
  return {x: ux/uz, y: uy/uz};
}

const screenToMarkerCoordinate = (modelViewProjectionTransform, sx, sy) => {
  const c11 = modelViewProjectionTransform[2][0] * sx - modelViewProjectionTransform[0][0];
  const c12 = modelViewProjectionTransform[2][1] * sx - modelViewProjectionTransform[0][1];
  const c21 = modelViewProjectionTransform[2][0] * sy - modelViewProjectionTransform[1][0];
  const c22 = modelViewProjectionTransform[2][1] * sy - modelViewProjectionTransform[1][1];
  const b1  = modelViewProjectionTransform[0][3] - modelViewProjectionTransform[2][3] * sx;
  const b2  = modelViewProjectionTransform[1][3] - modelViewProjectionTransform[2][3] * sy;

  const m = c11 * c22 - c12 * c21;
  return {
    x: (c22 * b1 - c12 * b2) / m,
    y: (c11 * b2 - c21 * b1) / m
  }
}

module.exports = {
  screenToMarkerCoordinate,
  //getProjectionTransform,
  buildModelViewProjectionTransform,
  applyModelViewProjectionTransform,
  computeScreenCoordiate
}


/***/ }),

/***/ "./src/image-target/image-list.js":
/*!****************************************!*\
  !*** ./src/image-target/image-list.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {resize} = __webpack_require__(/*! ./utils/images.js */ "./src/image-target/utils/images.js");

//const DEFAULT_DPI = 72;
const DEFAULT_DPI = 1;
const MIN_IMAGE_PIXEL_SIZE = 28;

// return list of {data, width, height, dpi}
const buildImageList = (inputImage) => {
  const dpi = DEFAULT_DPI;
  const minDpi = Math.floor(1.0 * MIN_IMAGE_PIXEL_SIZE / Math.min(inputImage.width, inputImage.height) * dpi * 1000) / 1000;
  const dpiList = [];

  let c = minDpi;
  while (true) {
    dpiList.push(c);
    c *= Math.pow(2.0, 1.0/3.0);
    c = Math.fround(c); // can remove this line in production. trying to reproduce the same result as artoolkit, which use float.
    if (c >= dpi * 0.95) {
      c = dpi;
      break;
    }
  }
  dpiList.push(c);
  dpiList.reverse();

  const imageList = []; // list of {data: [width x height], width, height}
  for (let i = 0; i < dpiList.length; i++) {
    const w = inputImage.width * dpiList[i] / dpi;
    const h = inputImage.height * dpiList[i] / dpi;
    imageList.push(Object.assign(resize({image: inputImage, ratio: dpiList[i]/dpi}), {dpi: dpiList[i]}));
  }

  //return [imageList[0]];

  return imageList;
}

module.exports = {
  buildImageList
}


/***/ }),

/***/ "./src/image-target/index.js":
/*!***********************************!*\
  !*** ./src/image-target/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {resize} = __webpack_require__(/*! ./utils/images.js */ "./src/image-target/utils/images.js");
const {buildImageList} = __webpack_require__(/*! ./image-list.js */ "./src/image-target/image-list.js");
const {Matcher} = __webpack_require__(/*! ./matching/matcher.js */ "./src/image-target/matching/matcher.js");
//const {Tracker: Tracker} = require('./tracking/tracker.js');
const {Tracker: Tracker} = __webpack_require__(/*! ./trackingGPU/tracker.js */ "./src/image-target/trackingGPU/tracker.js");
const {estimateHomography} = __webpack_require__(/*! ./icp/estimate_homography.js */ "./src/image-target/icp/estimate_homography.js");
const {refineHomography} = __webpack_require__(/*! ./icp/refine_homography */ "./src/image-target/icp/refine_homography.js");

class ImageTarget {
  constructor({projectionTransform, imageList, matchingData, trackingData, targetImage}) {
    this.imageList = imageList;
    this.matchingData = matchingData;
    this.trackingData = trackingData;
    this.targetImage = targetImage;
    this.projectionTransform = projectionTransform;

    this.matcher = new Matcher(matchingData);
    this.tracker = new Tracker(trackingData, imageList, projectionTransform);
    this.isTracking = false;
  }

  setupQuery(queryWidth, queryHeight) {
    this.queryWidth = queryWidth;
    this.queryHeight = queryHeight;
    this.tracker.setupQuery(queryWidth, queryHeight);
  }

  match(featurePoints) {
    const matchResult = this.matcher.matchDetection(this.queryWidth, this.queryHeight, featurePoints);
    if (matchResult === null) return null;

    const {screenCoords, worldCoords} = matchResult;

    const initialModelViewTransform = estimateHomography({screenCoords, worldCoords, projectionTransform: this.projectionTransform});
    console.log("initial matched model view transform", initialModelViewTransform);

    if (initialModelViewTransform === null) return null;
    //return initialModelViewTransform;

    // TODO: maybe don't this refineHomography. result seems worse when the detected size is big
    const {modelViewTransform: refinedModelViewTransform, err} = refineHomography({initialModelViewTransform, projectionTransform: this.projectionTransform, worldCoords, screenCoords});

    this.isTracking = true;
    this.tracker.detected(refinedModelViewTransform);
  }

  track(input) {
    const updatedModelViewTransform = this.tracker.track(input);
    if (updatedModelViewTransform === null) {
      this.isTracking = false;
    }
    return updatedModelViewTransform;
  }

  dummyRun(input) {
    this.tracker.detected([[0,0,0,0], [0,0,0,0], [0,0,0,0]]);
    this.tracker.track(input);
  }
}

module.exports = {
  ImageTarget,
}


/***/ }),

/***/ "./src/image-target/matching/hamming-distance.js":
/*!*******************************************************!*\
  !*** ./src/image-target/matching/hamming-distance.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Fast computation on number of bit sets
// Ref: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel
const compute = (options) => {
  const {v1, v2} = options;
  let d = 0;
  for (let i = 0; i < v1.length; i++) {
    let x = (v1[i] ^ v2[i]) >>> 0;
    d += bitCount(x);
  }
  return d;
}

const bitCount = (v) => {
  var c = v - ((v >> 1) & 0x55555555);
  c = ((c >> 2) & 0x33333333) + (c & 0x33333333);
  c = ((c >> 4) + c) & 0x0F0F0F0F;
  c = ((c >> 8) + c) & 0x00FF00FF;
  c = ((c >> 16) + c) & 0x0000FFFF;
  return c;
}

module.exports = {
  compute
};


/***/ }),

/***/ "./src/image-target/matching/hierarchical-clustering.js":
/*!**************************************************************!*\
  !*** ./src/image-target/matching/hierarchical-clustering.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {compute: hammingCompute} = __webpack_require__(/*! ./hamming-distance.js */ "./src/image-target/matching/hamming-distance.js");
const {createRandomizer} = __webpack_require__(/*! ../utils/randomizer.js */ "./src/image-target/utils/randomizer.js");

const MIN_FEATURE_PER_NODE = 16;
const NUM_ASSIGNMENT_HYPOTHESES =  128;
const NUM_CENTERS = 8;

// kmedoids clustering of points, with hamming distance of FREAK descriptor
//
// node = {
//   isLeaf: bool,
//   children: [], list of children node
//   pointIndexes: [], list of int, point indexes
//   centerPointIndex: int
// }
const build = ({points}) => {
  const pointIndexes = [];
  for (let i = 0; i < points.length; i++) {
    pointIndexes.push(i);
  }

  const randomizer = createRandomizer();

  const rootNode = _build({points: points, pointIndexes: pointIndexes, centerPointIndex: null, randomizer});
  return {rootNode};
}

// recursive build hierarchy clusters
const _build = (options) => {
  const {points, pointIndexes, centerPointIndex, randomizer} = options;

  let isLeaf = false;

  if (pointIndexes.length <= NUM_CENTERS || pointIndexes.length <= MIN_FEATURE_PER_NODE) {
    isLeaf = true;
  }

  const clusters = {};
  if (!isLeaf) {
    // compute clusters
    const assignment = _computeKMedoids({points, pointIndexes, randomizer});

    for (let i = 0; i < assignment.length; i++) {
      if (clusters[pointIndexes[assignment[i]]] === undefined) {
        clusters[pointIndexes[assignment[i]]] = [];
      }
      clusters[pointIndexes[assignment[i]]].push(pointIndexes[i]);
    }
  }
  if (Object.keys(clusters).length === 1) {
    isLeaf = true;
  }

  const node = {
    centerPointIndex: centerPointIndex
  }

  if (isLeaf) {
    node.leaf = true;
    node.pointIndexes = [];
    for (let i = 0; i < pointIndexes.length; i++) {
      node.pointIndexes.push(pointIndexes[i]);
    }
    return node;
  }

  // recursive build children
  node.leaf = false;
  node.children = [];

  Object.keys(clusters).forEach((centerIndex) => {
    node.children.push(_build({points: points, pointIndexes: clusters[centerIndex], centerPointIndex: centerIndex, randomizer}));
  });
  return node;
}

_computeKMedoids = (options) => {
  const {points, pointIndexes, randomizer} = options;

  const randomPointIndexes = [];
  for (let i = 0; i < pointIndexes.length; i++) {
    randomPointIndexes.push(i);
  }

  let bestSumD = Number.MAX_SAFE_INTEGER;
  let bestAssignmentIndex = -1;

  const assignments = [];
  for (let i = 0; i < NUM_ASSIGNMENT_HYPOTHESES; i++) {
    randomizer.arrayShuffle({arr: randomPointIndexes, sampleSize: NUM_CENTERS});

    let sumD = 0;
    const assignment = [];
    for (let j = 0; j < pointIndexes.length; j++) {
      let bestD = Number.MAX_SAFE_INTEGER;
      for (let k = 0; k < NUM_CENTERS; k++) {
        const centerIndex = pointIndexes[randomPointIndexes[k]];
        const d = hammingCompute({v1: points[pointIndexes[j]].descriptors, v2: points[centerIndex].descriptors});
        if (d < bestD) {
          assignment[j] = randomPointIndexes[k];
          bestD = d;
        }
      }
      sumD += bestD;
    }
    assignments.push(assignment);

    if (sumD < bestSumD) {
      bestSumD = sumD;
      bestAssignmentIndex = i;
    }
  }
  return assignments[bestAssignmentIndex];
}

module.exports = {
  build,
};



/***/ }),

/***/ "./src/image-target/matching/homography.js":
/*!*************************************************!*\
  !*** ./src/image-target/matching/homography.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {createRandomizer} = __webpack_require__(/*! ../utils/randomizer.js */ "./src/image-target/utils/randomizer.js");
const {quadrilateralConvex, matrixInverse33, smallestTriangleArea, multiplyPointHomographyInhomogenous, checkThreePointsConsistent, checkFourPointsConsistent, determinant} = __webpack_require__(/*! ../utils/geometry.js */ "./src/image-target/utils/geometry.js");

const EPSILON = 0.0000000000001;
const SQRT2 = 1.41421356237309504880;
const HOMOGRAPHY_DEFAULT_CAUCHY_SCALE = 0.01;
const HOMOGRAPHY_DEFAULT_NUM_HYPOTHESES = 1024;
const HOMOGRAPHY_DEFAULT_MAX_TRIALS = 1064;
const HOMOGRAPHY_DEFAULT_CHUNK_SIZE = 50;

// testPoints is four corners of keyframe
const computeHomography = (options) => {
  const {srcPoints, dstPoints, keyframe} = options;

  const testPoints = [
    [0, 0],
    [keyframe.width, 0],
    [keyframe.width, keyframe.height],
    [0, keyframe.height]
  ]

  const sampleSize = 4; // use four points to compute homography
  if (srcPoints.length < sampleSize) return null;

  const scale = HOMOGRAPHY_DEFAULT_CAUCHY_SCALE;
  const oneOverScale2 = 1.0 / (scale * scale);
  const chuckSize = Math.min(HOMOGRAPHY_DEFAULT_CHUNK_SIZE, srcPoints.length);

  const randomizer = createRandomizer();

  const perm = [];
  for (let i = 0; i < srcPoints.length; i++) {
    perm[i] = i;
  }

  randomizer.arrayShuffle({arr: perm, sampleSize: perm.length});

  // build numerous hypotheses by randoming draw four points
  // TODO: optimize: if number of points is less than certain number, can brute force all combinations
  let trial = 0;
  const Hs = [];
  while (trial < HOMOGRAPHY_DEFAULT_MAX_TRIALS && Hs.length < HOMOGRAPHY_DEFAULT_NUM_HYPOTHESES) {

    randomizer.arrayShuffle({arr: perm, sampleSize: sampleSize});

    trial +=1;

    if (!checkFourPointsConsistent(
      srcPoints[perm[0]], srcPoints[perm[1]], srcPoints[perm[2]], srcPoints[perm[3]],
      dstPoints[perm[0]], dstPoints[perm[1]], dstPoints[perm[2]], dstPoints[perm[3]])) {
      continue;
    }

    const H = _solveHomographyFourPoints({
      srcPoints: [srcPoints[perm[0]], srcPoints[perm[1]], srcPoints[perm[2]], srcPoints[perm[3]]],
      dstPoints: [dstPoints[perm[0]], dstPoints[perm[1]], dstPoints[perm[2]], dstPoints[perm[3]]],
    });

    if (H === null) continue;

    if(!_checkHomographyPointsGeometricallyConsistent({H, testPoints})) {
      continue;
    }

    Hs.push(H);
  }

  if (Hs.length === 0) return null;

  // pick the best hypothesis
  const hypotheses = [];
  for (let i = 0; i < Hs.length; i++) {
    hypotheses.push({
      H: Hs[i],
      cost: 0
    })
  }

  let curChuckSize = chuckSize;
  for (let i = 0; i < srcPoints.length && hypotheses.length > 2; i += curChuckSize) {
    curChuckSize = Math.min(chuckSize, srcPoints.length - i);
    let chuckEnd = i + curChuckSize;

    for (let j = 0; j < hypotheses.length; j++) {
      for (let k = i; k < chuckEnd; k++) {
        const cost = _cauchyProjectiveReprojectionCost({H: hypotheses[j].H, srcPoint: srcPoints[k], dstPoint: dstPoints[k], oneOverScale2});
        hypotheses[j].cost += cost;
      }
    }

    hypotheses.sort((h1, h2) => {return h1.cost - h2.cost});
    hypotheses.splice(-Math.floor((hypotheses.length+1)/2)); // keep the best half
  }

  let bestIndex = 0;
  for (let i = 1; i < hypotheses.length; i++) {
    if (hypotheses[i].cost < hypotheses[bestIndex].cost) bestIndex = i;
  }

  const finalH = _normalizeHomography({inH: hypotheses[bestIndex].H});

  if (!_checkHeuristics({H: finalH, testPoints, keyframe})) return null;
  return finalH;
}

const _checkHeuristics = ({H, testPoints, keyframe}) => {
  const HInv = matrixInverse33(H, 0.00001);
  // console.log("final H Inv: ", HInv);
  if (HInv === null) return false;

  const mp = []
  for (let i = 0; i < testPoints.length; i++) { // 4 test points, corner of keyframe
    mp.push(multiplyPointHomographyInhomogenous(testPoints[i], HInv));
  }
  const smallArea = smallestTriangleArea(mp[0], mp[1], mp[2], mp[3]);

  if (smallArea < keyframe.width * keyframe.height * 0.0001) return false;

  if (!quadrilateralConvex(mp[0], mp[1], mp[2], mp[3])) return false;

  return true;
}

const _normalizeHomography = ({inH}) => {
  const oneOver = 1.0 / inH[8];

  const H = [];
  for (let i = 0; i < 8; i++) {
    H[i] = inH[i] * oneOver;
  }
  H[8] = 1.0;
  return H;
}

const _cauchyProjectiveReprojectionCost = ({H, srcPoint, dstPoint, oneOverScale2}) => {
  const x = multiplyPointHomographyInhomogenous(srcPoint, H);
  const f =[
    x[0] - dstPoint[0],
    x[1] - dstPoint[1]
  ];
  return Math.log(1 + (f[0]*f[0]+f[1]*f[1]) * oneOverScale2);
}

const _checkHomographyPointsGeometricallyConsistent = ({H, testPoints}) => {
  const mappedPoints = [];
  for (let i = 0; i < testPoints.length; i++) {
    mappedPoints[i] = multiplyPointHomographyInhomogenous(testPoints[i], H);
    //console.log("map", testPoints[i], mappedPoints[i], H);
  }
  for (let i = 0; i < testPoints.length; i++) {
    const i1 = i;
    const i2 = (i+1) % testPoints.length;
    const i3 = (i+2) % testPoints.length;
    if (!checkThreePointsConsistent(
      testPoints[i1], testPoints[i2], testPoints[i3],
      mappedPoints[i1], mappedPoints[i2], mappedPoints[i3])) return false;
  }
  return true;
}

// Condition four 2D points such that the mean is zero and the standard deviation is sqrt(2).
const _condition4Points2d = ({x1, x2, x3, x4}) => {
  const mu = [];
  const d1 = [];
  const d2 = [];
  const d3 = [];
  const d4 = [];

  mu[0] = (x1[0]+x2[0]+x3[0]+x4[0])/4;
  mu[1] = (x1[1]+x2[1]+x3[1]+x4[1])/4;

  d1[0] = x1[0]-mu[0];
  d1[1] = x1[1]-mu[1];
  d2[0] = x2[0]-mu[0];
  d2[1] = x2[1]-mu[1];
  d3[0] = x3[0]-mu[0];
  d3[1] = x3[1]-mu[1];
  d4[0] = x4[0]-mu[0];
  d4[1] = x4[1]-mu[1];

  const ds1 = Math.sqrt(d1[0]*d1[0]+d1[1]*d1[1]);
  const ds2 = Math.sqrt(d2[0]*d2[0]+d2[1]*d2[1]);
  const ds3 = Math.sqrt(d3[0]*d3[0]+d3[1]*d3[1]);
  const ds4 = Math.sqrt(d4[0]*d4[0]+d4[1]*d4[1]);
  const d = (ds1+ds2+ds3+ds4)/4;

  if (d == 0) return null;

  const s = (1.0/d)*SQRT2;

  const xp1 = [];
  const xp2 = [];
  const xp3 = [];
  const xp4 = [];

  xp1[0] = d1[0]*s;
  xp1[1] = d1[1]*s;
  xp2[0] = d2[0]*s;
  xp2[1] = d2[1]*s;
  xp3[0] = d3[0]*s;
  xp3[1] = d3[1]*s;
  xp4[0] = d4[0]*s;
  xp4[1] = d4[1]*s;

  return {xp1, xp2, xp3, xp4, s, t: mu};
}

const _solveHomographyFourPoints = ({srcPoints, dstPoints}) => {
  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
    window.debug.homographyIndex += 1;
    const dHomography = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex];
    const {x1, x2, x3, x4, xp1, xp2, xp3, xp4} = dHomography;
    const l1 = [srcPoints[0],srcPoints[1],srcPoints[2],srcPoints[3],dstPoints[0],dstPoints[1],dstPoints[2],dstPoints[3]];
    const l2 = [x1, x2, x3, x4, xp1, xp2, xp3, xp4];
    for (let i = 0; i < l1.length; i++) {
      if (!window.cmp(l1[i][0], l2[i][0]) || !window.cmp(l1[i][1], l2[i][1])) {
        console.log('INCORRECT homography points', window.debug.homographyIndex, i, l1[i], l2[i]);
      }
    }
  }

  const res1 = _condition4Points2d({x1: srcPoints[0], x2: srcPoints[1], x3: srcPoints[2], x4: srcPoints[3]});

  if (res1 === null) return null;

  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
    const dHomography = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex];
    const {x1p, x2p, x3p, x4p, t, s} = dHomography;
    const l1 = [res1.xp1, res1.xp2, res1.xp3, res1.xp4, res1.t];
    const l2 = [x1p, x2p, x3p, x4p, t];
    for (let i = 0; i < l1.length; i++) {
      if (!window.cmp(l1[i][0], l2[i][0]) || !window.cmp(l1[i][1], l2[i][1])) {
        console.log('INCORRECT homography res1', window.debug.homographyIndex, i, l1[i], l2[i]);
      }
    }
    if (!window.cmp(res1.s, s)) {
      console.log('INCORRECT homography res1 S', window.debug.homographyIndex, res1.s, s);
    }
  }

  const res2 = _condition4Points2d({x1: dstPoints[0], x2: dstPoints[1], x3: dstPoints[2], x4: dstPoints[3]});
  if (res2 === null) return null;

  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
    const dHomography = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex];
    const {xp1p, xp2p, xp3p, xp4p, tp, sp} = dHomography;
    const l1 = [res2.xp1, res2.xp2, res2.xp3, res2.xp4, res2.t];
    const l2 = [xp1p, xp2p, xp3p, xp4p, tp];
    for (let i = 0; i < l1.length; i++) {
      if (!window.cmp(l1[i][0], l2[i][0]) || !window.cmp(l1[i][1], l2[i][1])) {
        console.log('INCORRECT homography res1', window.debug.homographyIndex, i, l1[i], l2[i]);
      }
    }
    if (!window.cmp(res2.s, sp)) {
      console.log('INCORRECT homography res1 S', window.debug.homographyIndex, i, res2.s, sp);
    }
  }

  const Hn = _solveHomography4PointsInhomogenous({
    x1: res1.xp1, x2: res1.xp2, x3: res1.xp3, x4: res1.xp4,
    xp1: res2.xp1, xp2: res2.xp2, xp3: res2.xp3, xp4: res2.xp4,
  });

  if (Hn === null) return null;

  if (Math.abs(determinant(Hn)) < 0.00001) return null;

  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
    const dHomography = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex];
    const dHn = dHomography.Hn;
    if (!window.cmpArray(Hn, dHn, 0.001)) {
      console.log("INCORRECT Hn", window.debug.querykeyframeIndex, window.debug.homographyIndex, Hn, dHn);
    }
    const dDetH = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex].detH;
    if (!window.cmp(determinant(Hn), dDetH)) {
      console.log("INCORRECT determinant", determinant(Hn), dDetH);
    }
  }

  const H = _denomalizeHomography({H: Hn, s: res1.s, t: res1.t, sp: res2.s, tp: res2.t});

  return H;
}

// denormalize homography
// Hp = inv(Tp)*H*T
const _denomalizeHomography = ({H, s, t, sp, tp}) => {
  const a = H[6]*tp[0];
  const b = H[7]*tp[0];
  const c = H[0]/sp;
  const d = H[1]/sp;
  const apc = a+c;
  const bpd = b+d;

  const e = H[6]*tp[1];
  const f = H[7]*tp[1];
  const g = H[3]/sp;
  const h = H[4]/sp;
  const epg = e+g;
  const fph = f+h;

  const stx = s*t[0];
  const sty = s*t[1];

  const Hp = [];
  Hp[0] = s*apc;
  Hp[1] = s*bpd;
  Hp[2] = H[8]*tp[0] + H[2]/sp - stx*apc - sty*bpd;

  Hp[3] = s*epg;
  Hp[4] = s*fph;
  Hp[5] = H[8]*tp[1] + H[5]/sp - stx*epg - sty*fph;

  Hp[6] = H[6]*s;
  Hp[7] = H[7]*s;
  Hp[8] = H[8] - Hp[6]*t[0] - Hp[7]*t[1];

  return Hp;
};

// can someone verify the implementation of this QR decomposition?
const _solveHomography4PointsInhomogenous = ({x1, x2, x3, x4, xp1, xp2, xp3, xp4}) => {
  const xList = [x1, x2, x3, x4];
  const xpList = [xp1, xp2, xp3, xp4];

  const A = []; // 8 x 9
  for (let i = 0; i < 4; i++) {
    const offset = i * 18;
    const x = xList[i];
    const xp = xpList[i];
    A[offset+0] = -x[0];
    A[offset+1] = -x[1];
    A[offset+2] = -1;
    A[offset+3] = 0;
    A[offset+4] = 0;
    A[offset+5] = 0;
    A[offset+6] = xp[0]*x[0];
    A[offset+7] = xp[0]*x[1];
    A[offset+8] = xp[0];
    A[offset+9] = 0;
    A[offset+10] = 0;
    A[offset+11] = 0;
    A[offset+12] = -x[0];
    A[offset+13] = -x[1];
    A[offset+14] = -1;
    A[offset+15] = xp[1]*x[0];
    A[offset+16] = xp[1]*x[1];
    A[offset+17] = xp[1];
  }

  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
    const dA = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex].A;
    if (!window.cmpArray(A, dA)) {
      console.log("INCORRECT A", window.debug.querykeyframeIndex, window.debug.homographyIndex, A, dA);
    }
  }

  const Q = [];
  for (let i = 0; i < 72; i++) {
    Q[i] = A[i];
  }

  // solve x for Ax=0 with QR decomposition with Gram-Schmidt
  for (let row = 0; row < 8; row++) {
    if (row > 0) {
      for (let j = row; j < 8; j++) {
        // project a vector "a" onto a normalized basis vector "e".
        // x = x - dot(a,e)*e

        let d = 0; // dot(a, e);
        for (let i = 0; i < 9; i++) {
          d += Q[(row-1) * 9 + i] * A[j * 9 + i];
        }

        for (let i = 0; i < 9; i++) {
          Q[j * 9 + i] -= d * Q[ (row-1) * 9 + i];
        }
      }
    }

    let maxValue = -1;
    let maxRow = -1;
    const ss = [];
    for (let j = row; j < 8; j++) {
      ss[j] = 0;
      for (let i = 0; i < 9; i++) {
        ss[j] += (Q[j*9+i] * Q[j*9+i]);
      }
      if (ss[j] > maxValue) {
        maxValue = ss[j];
        maxRow = j;
      }
    }
    if ( Math.abs(ss[maxRow]) < EPSILON) {
      return null; // no solution
    }

    // swap current row with maxindex row
    if (row !== maxRow) {
      for (let i = 0; i < 9; i++) {
        let tmp = A[row * 9 + i];
        A[row * 9 + i] = A[maxRow * 9 + i];
        A[maxRow * 9 + i] = tmp;

        let tmp2 = Q[row * 9 + i];
        Q[row * 9 + i] = Q[maxRow * 9 + i];
        Q[maxRow * 9 + i] = tmp2;
      }
    }

    for (let i = 0; i < 9; i++) {
      Q[row * 9 + i] = 1.0 * Q[row * 9 + i] / Math.sqrt(ss[maxRow]);
    }
  }

  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
    const dQ = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex].Q8;
    if (!window.cmpArray(Q, dQ, 0.001)) {
      console.log("INCORRECT Q8", window.debug.querykeyframeIndex, window.debug.homographyIndex, Q, dQ);
    }
  }

  // compute x from Q
  const w = [];
  const X = [];
  for (let row = 0; row < 9; row++) {
    for (let i = 0; i < 9; i++) {
      X[row * 9 + i] = (Q[i] * -Q[row]);
    }
    X[row * 9 + row] = 1 + X[row * 9 + row];

    for (let j = 1; j < 8; j++) {
      for(let i = 0; i < 9; i++) {
        X[row * 9 + i] += (Q[j * 9 + i] * -Q[j * 9 + row]);
      }
    }

    let ss = 0;
    for (let i = 0; i < 9; i++) {
      ss += (X[row * 9 + i] * X[row * 9 + i]);
    }
    if (Math.abs(ss) < EPSILON) {
      w[row] = 0;
      continue;
    }

    w[row] = Math.sqrt(ss);
    for (let i = 0; i < 9; i++) {
      X[row * 9 + i] = X[row * 9 + i] / w[row];
    }
  }

  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
    const dX = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex].X;
    const dw = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex].w;
    if (!window.cmpArray(X, dX, 0.01)) {
      console.log("INCORRECT X", window.debug.querykeyframeIndex, window.debug.homographyIndex, JSON.parse(JSON.stringify(X)), dX);
    }
    if (!window.cmpArray(w, dw, 0.01)) {
      console.log("INCORRECT w", window.debug.querykeyframeIndex, window.debug.homographyIndex, JSON.parse(JSON.stringify(w)), dw);
    }
  }

  let maxRow = -1;
  let maxValue = -1;
  for (let j = 0; j < 9; j++) {
    if (w[j] > maxValue) {
      maxRow = j;
      maxValue = w[j];
    }
  }


  if (maxValue == 0) return null; // no solution

  const x = [];
  for (let i = 0; i < 9; i++) {
    x[i] = X[maxRow * 9 + i];
  }

  return x;
}

module.exports = {
  computeHomography,
}



/***/ }),

/***/ "./src/image-target/matching/hough.js":
/*!********************************************!*\
  !*** ./src/image-target/matching/hough.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

const kHoughBinDelta = 1;

// mathces [querypointIndex:x, keypointIndex: x]
const computeHoughMatches = (options) => {
  const {keypoints, querypoints, keywidth, keyheight, querywidth, queryheight, matches} = options;

  const maxX = querywidth * 1.2;
  const minX = -maxX;
  const maxY = queryheight * 1.2;
  const minY = -maxY;
  const numAngleBins = 12;
  const numScaleBins = 10;
  const minScale = -1;
  const maxScale = 1;
  const scaleK = 10.0;
  const scaleOneOverLogK = 1.0 / Math.log(scaleK);
  const maxDim = Math.max(keywidth, keyheight);
  const keycenterX = Math.floor(keywidth / 2);
  const keycenterY = Math.floor(keyheight / 2);

  // compute numXBins and numYBins based on matches
  const projectedDims = [];
  for (let i = 0; i < matches.length; i++) {
    const queryscale = querypoints[matches[i].querypointIndex].scale;
    const keyscale = keypoints[matches[i].keypointIndex].scale;
    if (keyscale == 0) console.log("ERROR divide zero");
    const scale = queryscale / keyscale;
    projectedDims.push( scale * maxDim );
  }

  // TODO optimize median
  //   weird. median should be [Math.floor(projectedDims.length/2) - 1] ?
  projectedDims.sort((a1, a2) => {return a1 - a2});
  const medianProjectedDim = projectedDims[ Math.floor(projectedDims.length/2) - (projectedDims.length%2==0?1:0) -1 ];

  const binSize = 0.25 * medianProjectedDim;
  const numXBins = Math.max(5, Math.ceil((maxX - minX) / binSize));
  const numYBins = Math.max(5, Math.ceil((maxY - minY) / binSize));

  const numXYBins = numXBins * numYBins;
  const numXYAngleBins = numXYBins * numAngleBins;

  // do voting
  const querypointValids = [];
  const querypointBinLocations = [];
  const votes = {};
  for (let i = 0; i < matches.length; i++) {
    const querypoint = querypoints[matches[i].querypointIndex];
    const keypoint = keypoints[matches[i].keypointIndex];

    const {x, y, scale, angle} = _mapCorrespondence({querypoint, keypoint, keycenterX, keycenterY, scaleOneOverLogK});

    // Check that the vote is within range
    if (x < minX || x >= maxX || y < minY || y >= maxY || angle <= -Math.PI || angle > Math.PI || scale < minScale || scale >= maxScale) {
      querypointValids[i] = false;
      continue;
    }

    // map properties to bins
    let fbinX = numXBins * (x - minX) / (maxX - minX);
    let fbinY = numYBins * (y - minY) / (maxY - minY);
    let fbinAngle = numAngleBins * (angle + Math.PI) / (2.0 * Math.PI);
    let fbinScale = numScaleBins * (scale - minScale) / (maxScale - minScale);

    querypointBinLocations[i] = {binX: fbinX, binY: fbinY, binAngle: fbinAngle, binScale: fbinScale};

    let binX = Math.floor(fbinX - 0.5);
    let binY = Math.floor(fbinY - 0.5);
    let binScale = Math.floor(fbinScale - 0.5);
    let binAngle = (Math.floor(fbinAngle - 0.5) + numAngleBins) % numAngleBins;

    // check can vote all 16 bins
    if (binX < 0 || binX + 1 >= numXBins || binY < 0 || binY + 1 >= numYBins || binScale < 0 || binScale +1 >= numScaleBins) {
      querypointValids[i] = false;
      continue;
    }

    for (let dx = 0; dx < 2; dx++) {
      let binX2 = binX + dx;

      for (let dy = 0; dy < 2; dy++) {
        let binY2 = binY + dy;

        for (let dangle = 0; dangle < 2; dangle++) {
          let binAngle2 = (binAngle + dangle) % numAngleBins;

          for (let dscale = 0; dscale < 2; dscale++) {
            let binScale2 = binScale + dscale;

            const binIndex = binX2 + binY2 * numXBins + binAngle2 * numXYBins + binScale2 * numXYAngleBins;

            if (votes[binIndex] === undefined) votes[binIndex] = 0;
            votes[binIndex] += 1;
          }
        }
      }
    }
    querypointValids[i] = true;
  }

  let maxVotes = 0;
  let maxVoteIndex = -1;
  Object.keys(votes).forEach((index) => {
    if (votes[index] > maxVotes) {
      maxVotes = votes[index];
      maxVoteIndex = index;
    }
  });

  if (maxVotes < 3) return [];

  // get back bins from vote index
  const binX = Math.floor(((maxVoteIndex % numXYAngleBins) % numXYBins) % numXBins);
  const binY = Math.floor((((maxVoteIndex - binX) % numXYAngleBins) % numXYBins) / numXBins);
  const binAngle = Math.floor(((maxVoteIndex - binX - (binY * numXBins)) % numXYAngleBins) / numXYBins);
  const binScale = Math.floor((maxVoteIndex - binX - (binY * numXBins) - (binAngle * numXYBins)) / numXYAngleBins);

  //console.log("hough voted: ", {binX, binY, binAngle, binScale, maxVoteIndex});

  const houghMatches = [];
  for (let i = 0; i < matches.length; i++) {
    if (!querypointValids[i]) continue;

    const queryBins = querypointBinLocations[i];
    // compute bin difference
    const distBinX = Math.abs(queryBins.binX - (binX+0.5));
    if (distBinX >= kHoughBinDelta) continue;

    const distBinY = Math.abs(queryBins.binY - (binY+0.5));
    if (distBinY >= kHoughBinDelta) continue;

    const distBinScale = Math.abs(queryBins.binScale - (binScale+0.5));
    if (distBinScale >= kHoughBinDelta) continue;

    const temp = Math.abs(queryBins.binAngle - (binAngle+0.5));
    const distBinAngle = Math.min(temp, numAngleBins - temp);
    if (distBinAngle >= kHoughBinDelta) continue;

    houghMatches.push(matches[i]);
  }
  return houghMatches;
}

const _mapCorrespondence = ({querypoint, keypoint, keycenterX, keycenterY, scaleOneOverLogK}) => {
  // map angle to (-pi, pi]
  let angle = querypoint.angle - keypoint.angle;
  if (angle <= -Math.PI) angle += 2*Math.PI;
  else if (angle > Math.PI) angle -= 2*Math.PI;

  const scale = querypoint.scale / keypoint.scale;

  // 2x2 similarity
  const cos = scale * Math.cos(angle);
  const sin = scale * Math.sin(angle);
  const S = [cos, -sin, sin, cos];

  const tp = [
    S[0] * keypoint.x2D + S[1] * keypoint.y2D,
    S[2] * keypoint.x2D + S[3] * keypoint.y2D
  ];
  const tx = querypoint.x2D - tp[0];
  const ty = querypoint.y2D - tp[1];

  return {
    x: S[0] * keycenterX + S[1] * keycenterY + tx,
    y: S[2] * keycenterX + S[3] * keycenterY + ty,
    angle: angle,
    scale: Math.log(scale) * scaleOneOverLogK
  }
}

module.exports = {
  computeHoughMatches
}



/***/ }),

/***/ "./src/image-target/matching/matcher.js":
/*!**********************************************!*\
  !*** ./src/image-target/matching/matcher.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {build: hierarchicalClusteringBuild} = __webpack_require__(/*! ./hierarchical-clustering.js */ "./src/image-target/matching/hierarchical-clustering.js");
const {match} = __webpack_require__(/*! ./matching */ "./src/image-target/matching/matching.js");

const PYRAMID_NUM_SCALES_PER_OCTAVES = 3;
const PYRAMID_MIN_SIZE = 8;

class Matcher {
  constructor(matchingData) {
    this.keyframes = matchingData;
  }

  matchDetection(queryWidth, queryHeight, featurePoints) {
    const querypoints = [];
    const dpi = 1.0;
    for (let i = 0; i < featurePoints.length; i++) {
      querypoints.push({
        x2D: featurePoints[i].x,
        y2D: featurePoints[i].y,
        x3D: (featurePoints[i].x + 0.5) / dpi,
        y3D: ((queryHeight-0.5) - featurePoints[i].y) / dpi,
        angle: featurePoints[i].angle,
        scale: featurePoints[i].sigma,
        maxima: featurePoints[i].score > 0,
        descriptors: featurePoints[i].descriptors
      })
    }
    const result = match({keyframes: this.keyframes, querypoints: querypoints, querywidth: queryWidth, queryheight: queryHeight});
    if (result === null) return null;

    const screenCoords = [];
    const worldCoords = [];
    const keyframe = this.keyframes[result.keyframeIndex];
    for (let i = 0; i < result.matches.length; i++) {
      const querypointIndex = result.matches[i].querypointIndex;
      const keypointIndex = result.matches[i].keypointIndex;
      screenCoords.push({
        x: querypoints[querypointIndex].x2D,
        y: querypoints[querypointIndex].y2D,
      })
      worldCoords.push({
        x: keyframe.points[keypointIndex].x3D,
        y: keyframe.points[keypointIndex].y3D,
        z: 0,
      })
    }

    return {screenCoords, worldCoords};
  }
}

module.exports = {
  Matcher
}


/***/ }),

/***/ "./src/image-target/matching/matching.js":
/*!***********************************************!*\
  !*** ./src/image-target/matching/matching.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const TinyQueue = __webpack_require__(/*! tinyqueue */ "./node_modules/tinyqueue/index.js").default;
const {compute: hammingCompute} = __webpack_require__(/*! ./hamming-distance.js */ "./src/image-target/matching/hamming-distance.js");
const {computeHoughMatches} = __webpack_require__(/*! ./hough.js */ "./src/image-target/matching/hough.js");
const {computeHomography} = __webpack_require__(/*! ./homography.js */ "./src/image-target/matching/homography.js");
const {multiplyPointHomographyInhomogenous, matrixInverse33} = __webpack_require__(/*! ../utils/geometry.js */ "./src/image-target/utils/geometry.js");

const INLIER_THRESHOLD = 3;
//const MIN_NUM_INLIERS = 8;  //default
const MIN_NUM_INLIERS = 6;
const CLUSTER_MAX_POP = 8;
const HAMMING_THRESHOLD = 0.7;

// match list of querpoints against pre-built list of keyframes
const match = ({keyframes, querypoints, querywidth, queryheight}) => {
  let result = null;

  for (let i = 0; i < keyframes.length; i++) {
    logTime("sm"+i);

    const keyframe = keyframes[i];
    const keypoints = keyframe.points;

    if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
      window.debug.querykeyframeIndex = i;
    }
    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      var _start = new Date().getTime();
    }

    const matches = [];
    for (let j = 0; j < querypoints.length; j++) {
      const rootNode = keyframe.pointsCluster.rootNode;
      const querypoint = querypoints[j];
      const keypointIndexes = [];
      const queue = new TinyQueue([], (a1, a2) => {return a1.d - a2.d});

      _query({node: rootNode, keypoints, querypoint, queue, keypointIndexes, numPop: 0});

      let bestIndex = -1;
      let bestD1 = Number.MAX_SAFE_INTEGER;
      let bestD2 = Number.MAX_SAFE_INTEGER;

      for (let k = 0; k < keypointIndexes.length; k++) {
        const keypoint = keypoints[keypointIndexes[k]];
        if (keypoint.maxima != querypoint.maxima) continue;

        const d = hammingCompute({v1: keypoint.descriptors, v2: querypoint.descriptors});
        if (d < bestD1) {
          bestD2 = bestD1;
          bestD1 = d;
          bestIndex = keypointIndexes[k];
        } else if (d < bestD2) {
          bestD2 = d;
        }
      }
      if (bestIndex !== -1 && (bestD2 === Number.MAX_SAFE_INTEGER || (1.0 * bestD1 / bestD2) < HAMMING_THRESHOLD)) {
        matches.push({querypointIndex: j, keypointIndex: bestIndex});
      }

      if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
        if (!window.debug.queryMatchIndex) window.debug.queryMatchIndex = 0;
        const dMatch = window.debugMatch.matches[window.debug.queryMatchIndex];
        if (bestIndex === -1) {
          if (dMatch && dMatch.bestIndex !== 2147483647) {
            console.log("INCORRECT query match", bestD1, bestD2, bestIndex, 'vs', dMatch.firstBest, dMatch.secondBest, dMatch.bestIndex);
          }
        } else {
          if (bestIndex !== dMatch.bestIndex) {
            console.log("INCORRECT query match", bestD1, bestD2, bestIndex, 'vs', dMatch.firstBest, dMatch.secondBest, dMatch.bestIndex);
          }
        }
        window.debug.queryMatchIndex += 1;
      }
    }

    logTime("em"+i);

    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      console.log('exec time until first match: ', new Date().getTime() - _start);
    }

    if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
      const dMatches = window.debugMatch.querykeyframes[i].matches1;
      console.log("matches 1", matches.length, dMatches.length);
      if (matches.length !== dMatches.length) {
        console.log("INCORRECT matches1 length");
      }
      for (let i = 0; i < matches.length; i++) {
        if (matches[i].querypointIndex !== dMatches[i].ins || matches[i].keypointIndex !== dMatches[i].res) {
          console.log("INCORRECT matches1", i, matches[i], dMatches[i]);
        }
      }
    }

    if (matches.length < MIN_NUM_INLIERS) {
      continue;
    }

    const houghMatches = computeHoughMatches({
      keypoints: keyframe.points,
      querypoints,
      keywidth: keyframe.width,
      keyheight: keyframe.height,
      querywidth,
      queryheight,
      matches,
    });

    logTime("hm"+i);

    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      console.log('exec time until first hough match: ', new Date().getTime() - _start);
    }

    if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
      const dMatches = window.debugMatch.querykeyframes[i].houghMatches1;
      console.log("hough matches 1", houghMatches.length, dMatches.length);
      if (houghMatches.length !== dMatches.length) {
        console.log("INCORRECT matches1 length");
      }
      for (let i = 0; i < houghMatches.length; i++) {
        if (houghMatches[i].querypointIndex !== dMatches[i].ins || houghMatches[i].keypointIndex !== dMatches[i].res) {
          console.log("INCORRECT matches1", i);
        }
      }
    }

    const srcPoints = [];
    const dstPoints = [];
    for (let i = 0; i < houghMatches.length; i++) {
      const querypoint = querypoints[houghMatches[i].querypointIndex];
      const keypoint = keypoints[houghMatches[i].keypointIndex];
      srcPoints.push([ keypoint.x2D, keypoint.y2D ]);
      dstPoints.push([ querypoint.x2D, querypoint.y2D ]);
    }

    if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
      window.debug.homographyIndex = -1; // +1 at start
    }

    const H = computeHomography({
      srcPoints,
      dstPoints,
      keyframe,
    });

    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      console.log('exec time until first Homography: ', new Date().getTime() - _start);
    }

    if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
      const dH = window.debugMatch.querykeyframes[i].H1;
      if (!window.cmpArray(H, dH, 0.001)) {
        console.log("INCORRECT H1", i, H, dH);
      }
    }

    if (H === null) continue;

    const inlierMatches = _findInlierMatches({
      querypoints,
      keypoints: keyframe.points,
      H,
      matches: houghMatches,
      threshold: INLIER_THRESHOLD
    });

    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      console.log('exec time until first inlier matches: ', new Date().getTime() - _start);
    }

    //console.log("inlierMatches", inlierMatches);

    if (inlierMatches.length < MIN_NUM_INLIERS) {
      continue;
    }

    if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
      const dMatches = window.debugMatch.querykeyframes[i].inlierMatches1;
      console.log("inlier matches 1", inlierMatches.length, dMatches.length);
      if (inlierMatches.length !== dMatches.length) {
        console.log("INCORRECT inlierMatches1 length");
      }
      for (let i = 0; i < inlierMatches.length; i++) {
        if (inlierMatches[i].querypointIndex !== dMatches[i].ins || inlierMatches[i].keypointIndex !== dMatches[i].res) {
          console.log("INCORRECT inlierMatches1", i);
        }
      }
    }

    // do another loop of match using the homography
    const HInv = matrixInverse33(H, 0.00001);
    const dThreshold2 = 10 * 10;
    const matches2 = [];
    for (let j = 0; j < querypoints.length; j++) {
      const querypoint = querypoints[j];
      const mapquerypoint = multiplyPointHomographyInhomogenous([querypoint.x2D, querypoint.y2D], HInv);

      let bestIndex = -1;
      let bestD1 = Number.MAX_SAFE_INTEGER;
      let bestD2 = Number.MAX_SAFE_INTEGER;

      for (let k = 0; k < keypoints.length; k++) {
        const keypoint = keypoints[k];
        if (keypoint.maxima != querypoint.maxima) continue;

        // check distance threshold
        const d2 = (keypoint.x2D - mapquerypoint[0]) * (keypoint.x2D - mapquerypoint[0])
                  + (keypoint.y2D - mapquerypoint[1]) * (keypoint.y2D - mapquerypoint[1]);
        if (d2 > dThreshold2) continue;

        const d = hammingCompute({v1: keypoint.descriptors, v2: querypoint.descriptors});
        if (d < bestD1) {
          bestD2 = bestD1;
          bestD1 = d;
          bestIndex = k;
        } else if (d < bestD2) {
          bestD2 = d;
        }
      }

      if (bestIndex !== -1 && (bestD2 === Number.MAX_SAFE_INTEGER || (1.0 * bestD1 / bestD2) < HAMMING_THRESHOLD)) {
        matches2.push({querypointIndex: j, keypointIndex: bestIndex});
      }
    }

    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      console.log('exec time until second matches: ', new Date().getTime() - _start);
    }

    if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
      const dMatches = window.debugMatch.querykeyframes[i].matches2;
      console.log("matches 2", matches2.length, dMatches.length);
      if (matches2.length !== dMatches.length) {
        console.log("INCORRECT matches2 length");
      }
      for (let i = 0; i < matches2.length; i++) {
        if (matches2[i].querypointIndex !== dMatches[i].ins || matches2[i].keypointIndex !== dMatches[i].res) {
          console.log("INCORRECT matches2", i);
        }
      }
    }

    const houghMatches2 = computeHoughMatches({
      keypoints: keyframe.points,
      querypoints,
      keywidth: keyframe.width,
      keyheight: keyframe.height,
      querywidth,
      queryheight,
      matches: matches2,
    });

    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      console.log('exec time until second hough matches: ', new Date().getTime() - _start);
    }

    const srcPoints2 = [];
    const dstPoints2 = [];
    for (let i = 0; i < houghMatches2.length; i++) {
      const querypoint = querypoints[houghMatches2[i].querypointIndex];
      const keypoint = keypoints[houghMatches2[i].keypointIndex];
      srcPoints2.push([ keypoint.x2D, keypoint.y2D ]);
      dstPoints2.push([ querypoint.x2D, querypoint.y2D ]);
    }

    const H2 = computeHomography({
      srcPoints: srcPoints2,
      dstPoints: dstPoints2,
      keyframe
    });

    if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
      const dH = window.debugMatch.querykeyframes[i].H2;
      if (!window.cmpArray(H2, dH, 0.0001)) {
        console.log("INCORRECT H2", i, H2, dH);
      }
    }

    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      console.log('exec time until second homography: ', new Date().getTime() - _start);
    }

    if (H2 === null) continue;

    const inlierMatches2 = _findInlierMatches({
      querypoints,
      keypoints: keyframe.points,
      H: H2,
      matches: houghMatches2,
      threshold: INLIER_THRESHOLD
    });

    if (typeof window !== 'undefined' && window.DEBUG_MATCH) {
      const dMatches = window.debugMatch.querykeyframes[i].inlierMatches2;
      console.log("inlier matches 2", inlierMatches2.length, dMatches.length);
      if (inlierMatches2.length !== dMatches.length) {
        console.log("INCORRECT inlierMatches2 length");
      }
      for (let i = 0; i < inlierMatches2.length; i++) {
        if (inlierMatches2[i].querypointIndex !== dMatches[i].ins || inlierMatches2[i].keypointIndex !== dMatches[i].res) {
          console.log("INCORRECT inlierMatches2", i);
        }
      }
    }

    if (typeof window !== 'undefined' && window.DEBUG_TIME) {
      console.log('exec time until second inlier matches: ', new Date().getTime() - _start);
    }

    if (inlierMatches2.length < MIN_NUM_INLIERS) {
      continue;
    }

    if (result === null || result.matches.length < inlierMatches2.length) {
      result = {
        keyframeIndex: i,
        matches: inlierMatches2,
        H: H2,
      }
    }

    logTime("mathcing end"+i);
  }

  return result;
};

const _query = ({node, keypoints, querypoint, queue, keypointIndexes, numPop}) => {
  if (node.leaf) {
    for (let i = 0; i < node.pointIndexes.length; i++) {
      keypointIndexes.push(node.pointIndexes[i]);
    }
    return;
  }

  const distances = [];
  for (let i = 0; i < node.children.length; i++) {
    const childNode = node.children[i];
    const centerPointIndex = childNode.centerPointIndex;
    const d = hammingCompute({v1: keypoints[centerPointIndex].descriptors, v2: querypoint.descriptors});
    distances.push(d);
  }

  let minD = Number.MAX_SAFE_INTEGER;
  for (let i = 0; i < node.children.length; i++) {
    minD = Math.min(minD, distances[i]);
  }

  for (let i = 0; i < node.children.length; i++) {
    if (distances[i] !== minD) {
      queue.push({node: node.children[i], d: distances[i]});
    }
  }
  for (let i = 0; i < node.children.length; i++) {
    if (distances[i] === minD) {
      _query({node: node.children[i], keypoints, querypoint, queue, keypointIndexes, numPop});
    }
  }

  if (numPop < CLUSTER_MAX_POP && queue.length > 0) {
    const {node, d} = queue.pop();
    numPop += 1;
    _query({node, keypoints, querypoint, queue, keypointIndexes, numPop});
  }
};

const _findInlierMatches = (options) => {
  const {keypoints, querypoints, H, matches, threshold} = options;

  const threshold2 = threshold * threshold;

  const goodMatches = [];
  for (let i = 0; i < matches.length; i++) {
    const querypoint = querypoints[matches[i].querypointIndex];
    const keypoint = keypoints[matches[i].keypointIndex];
    const mp = multiplyPointHomographyInhomogenous([keypoint.x2D, keypoint.y2D], H);
    const d2 = (mp[0] - querypoint.x2D) * (mp[0] - querypoint.x2D) + (mp[1] - querypoint.y2D) * (mp[1] - querypoint.y2D);
    if (d2 <= threshold2) {
      goodMatches.push( matches[i] );
    }
  }
  return goodMatches;
}

module.exports = {
  match
}


/***/ }),

/***/ "./src/image-target/trackingGPU/tracker.js":
/*!*************************************************!*\
  !*** ./src/image-target/trackingGPU/tracker.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {refineHomography} = __webpack_require__(/*! ../icp/refine_homography.js */ "./src/image-target/icp/refine_homography.js");
const {GPU} = __webpack_require__(/*! gpu.js */ "./node_modules/gpu.js/dist/gpu-browser.js");

const AR2_DEFAULT_SEARCH_FEATURE_NUM = 16;
const AR2_DEFAULT_TS = 6;
const AR2_SEARCH_SIZE = 6;

const AR2_SIM_THRESH = 0.5; // default
//const AR2_SIM_THRESH = 0.2; // 0.5 is default. 0.2 for debug

const AR2_TRACKING_THRESH = 5.0; // default
//const AR2_TRACKING_THRESH = 100; //

const PREV_KEEP = 3;

class Tracker {
  constructor(trackingData, imageList, projectionTransform) {
    this.gpu = new GPU();
    this._initializeGPU(this.gpu);

    this.featureSets = trackingData;
    this.projectionTransformCPU = projectionTransform;
    this.lastModelViewTransformCPU = null;

    this.featurePoints = this._buildFeaturePoints(this.featureSets);

    const {imagePixels, imageProperties} = this._combineImageList(imageList);
    this.imagePixels = imagePixels;
    this.imageProperties = imageProperties; // [ [width, height, dpi] ]

    this.projectionTransform = this._initializeProjectionTransform(projectionTransform);

    this.videoKernel = null;
    this.detectedKernel = null;
    this.updatePrevResultsKernel = null;
    this.kernels = [];
  }

  _initializeProjectionTransform(projectionTransform) {
    const kernel = this.gpu.createKernel(function(data) {
      return data[this.thread.y][this.thread.x];
    }, {
      pipeline: true,
      output: [4, 3]
    });
    const result = kernel(projectionTransform);
    return result;
  }

  _initializeGPU(gpu) {
    gpu.addFunction(function computeScreenCoordiate(modelViewProjectionTransforms, t, x, y, z) {
      const ux = modelViewProjectionTransforms[t][0][0] * x + modelViewProjectionTransforms[t][0][1] * y
         + modelViewProjectionTransforms[t][0][2] * z + modelViewProjectionTransforms[t][0][3];
      const uy = modelViewProjectionTransforms[t][1][0] * x + modelViewProjectionTransforms[t][1][1] * y
         + modelViewProjectionTransforms[t][1][2] * z + modelViewProjectionTransforms[t][1][3];
      const uz = modelViewProjectionTransforms[t][2][0] * x + modelViewProjectionTransforms[t][2][1] * y
         + modelViewProjectionTransforms[t][2][2] * z + modelViewProjectionTransforms[t][2][3];
      if( Math.abs(uz) < 0.000001 ) return [0, 0, 0];
      // first number indicates has valid result
      return [1, ux/uz, uy/uz];
    });

    gpu.addFunction(function screenToMarkerCoordinate(modelViewProjectionTransform, t, sx, sy) {
      const c11 = modelViewProjectionTransform[t][2][0] * sx - modelViewProjectionTransform[t][0][0];
      const c12 = modelViewProjectionTransform[t][2][1] * sx - modelViewProjectionTransform[t][0][1];
      const c21 = modelViewProjectionTransform[t][2][0] * sy - modelViewProjectionTransform[t][1][0];
      const c22 = modelViewProjectionTransform[t][2][1] * sy - modelViewProjectionTransform[t][1][1];
      const b1  = modelViewProjectionTransform[t][0][3] - modelViewProjectionTransform[t][2][3] * sx;
      const b2  = modelViewProjectionTransform[t][1][3] - modelViewProjectionTransform[t][2][3] * sy;

      const m = c11 * c22 - c12 * c21;
      return [
        (c22 * b1 - c12 * b2) / m,
        (c11 * b2 - c21 * b1) / m
      ]
    });

    gpu.addFunction(function getVectorAngle(p1, p2) {
      const l = Math.sqrt( (p2[0]-p1[0])*(p2[0]-p1[0]) + (p2[1]-p1[1])*(p2[1]-p1[1]) );
      return [
        (p2[1] - p1[1]) / l, //sin
        (p2[0] - p1[0]) / l  //cos
      ];
    });

    gpu.addFunction(function getTriangleArea(p1, p2, p3) {
      const x1 = p2[0] - p1[0];
      const y1 = p2[1] - p1[1];
      const x2 = p3[0] - p1[0];
      const y2 = p3[1] - p1[1];
      const s = 1.0 * (x1 * y2 - x2 * y1) / 2.0;
      return Math.abs(s);
    });
  }

  _combineImageList(imageList) {
    let totalPixel = 0;
    let propertiesData = [];
    for (let i = 0; i < imageList.length; i++) {
      propertiesData.push([imageList[i].width, imageList[i].height, totalPixel, imageList[i].dpi]);
      totalPixel += imageList[i].width * imageList[i].height;
    }

    const initKernel = this.gpu.createKernel(function() {
      return -1;
    }, {
      output: [totalPixel],
      pipeline: true
    });
    let combined = initKernel();
    //initKernel.destroy();

    let startIndex = 0;
    let endIndex = 0;
    const kernels = [];
    for (let i = 0; i < imageList.length; i++) {
      endIndex = startIndex + imageList[i].width * imageList[i].height;

      const kernel = this.gpu.createKernel(function(data, imageData) {
        const {startIndex, endIndex} = this.constants;
        if (this.thread.x < startIndex || this.thread.x >= endIndex) return data[this.thread.x];
        return imageData[this.thread.x - startIndex];
      }, {
        constants: {startIndex, endIndex},
        output: [totalPixel],
        pipeline: true
      });
      combined = kernel(combined, imageList[i].data);
      kernels.push(kernel);
      startIndex = endIndex;
    }
    for (let i = 0; i < imageList.length-1; i++) {
      //kernels[i].destroy();
    }

    const propertiesKernel = this.gpu.createKernel(function(data) {
      return data[this.thread.y][this.thread.x];
    }, {
      output: [propertiesData[0].length, propertiesData.length],
      pipeline: true
    });
    const properties = propertiesKernel(propertiesData);
    //dimensionKernel.destroy();
    return {imagePixels: combined, imageProperties: properties};
  }

  // first dimension: [x, y, level index, maxdpi, mindpi]
  _buildFeaturePoints(featureSets) {
    const points = [];
    for (let j = 0; j < featureSets.length; j++) {
      const maxdpi = featureSets[j].maxdpi;
      const mindpi = featureSets[j].mindpi;
      for (let k = 0; k < featureSets[j].coords.length; k++) {
        const {mx, my} = featureSets[j].coords[k];
        points.push([mx, my, j, maxdpi, mindpi]);
      }
    }
    const kernel = this.gpu.createKernel(function(data) {
      return data[this.thread.y][this.thread.x];
    }, {
      pipeline: true,
      output: [5, points.length]
    });
    const result = kernel(points);
    //kernel.destroy();
    return result;
  }

  detected(modelViewTransform) {
    this.lastModelViewTransformCPU = modelViewTransform;

    if (this.detectedKernel === null) {
      const buildModelView = this.gpu.createKernel(function(data) {
        return data[this.thread.y][this.thread.x];
      }, {
        pipeline: true,
        output: [4, 3, PREV_KEEP]
      });
      const buildModelViewProjection = this.gpu.createKernel(function(modelViewTransform, projectionTransform) {
        const j = this.thread.y;
        const i = this.thread.x;
        return projectionTransform[j][0] * modelViewTransform[0][i]
             + projectionTransform[j][1] * modelViewTransform[1][i]
             + projectionTransform[j][2] * modelViewTransform[2][i];
      }, {
        pipeline: true,
        output: [4, 3, PREV_KEEP]
      });
      const buildFeatureIndexes = this.gpu.createKernel(function() {
        return -1;
      }, {
        pipeline: true,
        output: [AR2_DEFAULT_SEARCH_FEATURE_NUM, PREV_KEEP]
      });

      this.detectedKernel = [buildModelView, buildModelViewProjection, buildFeatureIndexes];
    }

    this.prevModelViewTransforms = this.detectedKernel[0](modelViewTransform);
    this.prevModelViewProjectionTransforms = this.detectedKernel[1](modelViewTransform, this.projectionTransform);
    this.prevSelectedFeatureIndexes = this.detectedKernel[2]();
  }

  _updatePrevResults(modelViewTransform, selection) {
    this.lastModelViewTransformCPU = modelViewTransform;

    if (this.updatePrevResultsKernel === null) {
      const buildModelView = this.gpu.createKernel(function(modelViewTransforms, newModelViewTransform) {
        if (this.thread.z === 0) return newModelViewTransform[this.thread.y][this.thread.x];
        return modelViewTransforms[this.thread.z-1][this.thread.y][this.thread.x];
      }, {
        pipeline: true,
        output: [4, 3, PREV_KEEP]
      });
      const buildModelViewProjection = this.gpu.createKernel(function(modelViewProjetionTransforms, newModelViewTransform, projectionTransform) {
        if (this.thread.z === 0) {
          const j = this.thread.y;
          const i = this.thread.x;
          return projectionTransform[j][0] * newModelViewTransform[0][i]
               + projectionTransform[j][1] * newModelViewTransform[1][i]
               + projectionTransform[j][2] * newModelViewTransform[2][i];
        }
        return modelViewProjetionTransforms[this.thread.z-1][this.thread.y][this.thread.x];
      }, {
        pipeline: true,
        output: [4, 3, PREV_KEEP]
      });
      const buildFeatureIndexes = this.gpu.createKernel(function(featureIndexes, newSelection) {
        if (this.thread.y === 0) {
          if (newSelection[this.thread.x][5] > this.constants.simThresh) {
            return newSelection[this.thread.x][0];
          }
          return -1;
        }
        return featureIndexes[this.thread.y-1][this.thread.x];
      }, {
        constants: {simThresh: AR2_SIM_THRESH},
        pipeline: true,
        output: [AR2_DEFAULT_SEARCH_FEATURE_NUM, PREV_KEEP]
      });

      const cloneModelView = this.gpu.createKernel(function(modelViewTransforms) {
        return modelViewTransforms[this.thread.z][this.thread.y][this.thread.x];
      }, {
        pipeline: true,
        output: [4, 3, PREV_KEEP]
      });

      const cloneModelViewProjection = this.gpu.createKernel(function(modelViewProjectionTransforms) {
        return modelViewProjectionTransforms[this.thread.z][this.thread.y][this.thread.x];
      }, {
        pipeline: true,
        output: [4, 3, PREV_KEEP]
      });

      const cloneFeatureIndexes = this.gpu.createKernel(function(featureIndexes) {
        return featureIndexes[this.thread.y][this.thread.x];
      }, {
        pipeline: true,
        output: [AR2_DEFAULT_SEARCH_FEATURE_NUM, PREV_KEEP]
      });

      this.updatePrevResultsKernel = [buildModelView, buildModelViewProjection, buildFeatureIndexes,
                                      cloneModelView, cloneModelViewProjection, cloneFeatureIndexes];
    }

    const newPrevModelViewTransforms = this.updatePrevResultsKernel[0](this.prevModelViewTransforms, modelViewTransform);
    const newPrevModelViewProjectionTransforms = this.updatePrevResultsKernel[1](this.prevModelViewProjectionTransforms, modelViewTransform, this.projectionTransform);
    const newPrevSelectedFeatureIndexes = this.updatePrevResultsKernel[2](this.prevSelectedFeatureIndexes, selection);

    // gpu.js doesn't allow input and output are same texture in pipeline. any better way?
    this.prevModelViewTransforms = this.updatePrevResultsKernel[3](newPrevModelViewTransforms);
    this.prevModelViewProjectionTransforms = this.updatePrevResultsKernel[4](newPrevModelViewProjectionTransforms);
    this.prevSelectedFeatureIndexes = this.updatePrevResultsKernel[5](newPrevSelectedFeatureIndexes);
  }

  setupQuery(queryWidth, queryHeight) {
    this.width = queryWidth;
    this.height = queryHeight;
  }

  track(video) {
    if (this.videoKernel === null) {
      this.videoKernel = this.gpu.createKernel(function(videoFrame) {
        const pixel = videoFrame[this.constants.height-1-Math.floor(this.thread.x / this.constants.width)][this.thread.x % this.constants.width];
        return Math.floor((pixel[0] + pixel[1] + pixel[2]) * 255 / 3);
      }, {
        constants: {width: this.width, height: this.height},
        output: [this.width * this.height],
        pipeline: true,
      })
    }
    const targetImage = this.videoKernel(video);

    this.kernelIndex = 0; // reset kernelIndex
    const candidates = this._computeCandidates();

    const candidateTypes = candidates.result;
    const candidateSXs = candidates.saveSX;
    const candidateSYs = candidates.saveSY;

    // select feature one by one
    let i = 0;
    let num = 0;
    let selection = this._initializeSelection();
    for (let i = 0; i < AR2_DEFAULT_SEARCH_FEATURE_NUM; i++) {
      const newSelected = this._selectCandidate(selection, candidateTypes, candidateSXs, candidateSYs);
      const mappedTargetPosition = this._mapCandidate(targetImage, newSelected);
      selection = this._combineSelection(selection, i, newSelected, mappedTargetPosition);
    }

    //var _start = new Date().getTime();
    //const modelViewTransforms = this.prevModelViewTransforms.toArray();
    //console.log("prevModelViewTransforms toarray", new Date().getTime() - _start);
    //console.log("prevModelViewTransforms", this.prevModelViewTransforms, modelViewTransforms);
    //const modelViewTransform = modelViewTransforms[0];

    //var _start = new Date().getTime();
    const finalSelection = selection.toArray();
    //console.log("finalSelection toarray", new Date().getTime() - _start);
    //console.log("finalSelection", selection, finalSelection);

    const selectedFeatures = [];
    for (let i = 0; i < finalSelection.length; i++) {
      if (finalSelection[i][0] !== -1 && finalSelection[i][5] > AR2_SIM_THRESH) {
        selectedFeatures.push({
          pos2D: {x: finalSelection[i][3], y: finalSelection[i][4]},
          pos3D: {x: finalSelection[i][1], y: finalSelection[i][2], z: 0},
          sim: finalSelection[i][5]
        });
      }
    }
    //console.log('selected features', selectedFeatures);
    if (selectedFeatures.length < 4) {
      return null;
    }

    // TODO: translate and run in GPU
    const modelViewTransform = this.lastModelViewTransformCPU;
    const projectionTransform = this.projectionTransformCPU;

    const inlierProbs = [1.0, 0.8, 0.6, 0.4, 0.0];
    let err = null;
    let newModelViewTransform = modelViewTransform;
    let finalModelViewTransform = null;
    for (let i = 0; i < inlierProbs.length; i++) {
      let ret = _computeUpdatedTran({modelViewTransform: newModelViewTransform, selectedFeatures, projectionTransform, inlierProb: inlierProbs[i]});
      err = ret.err;
      newModelViewTransform = ret.newModelViewTransform;
      //console.log("_computeUpdatedTran", err)

      if (err < AR2_TRACKING_THRESH) {
        finalModelViewTransform = newModelViewTransform;
        break;
      }
    }

    if (finalModelViewTransform === null) return null;

    this._updatePrevResults(finalModelViewTransform, finalSelection);

    return finalModelViewTransform;
  }

  // first dimension: [featureIndex, mx, my, ix, iy, similarity]
  _initializeSelection() {
    if (this.kernelIndex === this.kernels.length) {
      const kernel = this.gpu.createKernel(function() {
        return -1;
      }, {
        pipeline: true,
        output: [6, AR2_DEFAULT_SEARCH_FEATURE_NUM]
      });
      this.kernels.push(kernel);
    }
    const kernel = this.kernels[this.kernelIndex++];
    return kernel();
  }

  _combineSelection(selection, selectionIndex, newSelected, mappedTargetPosition) {
    if (this.kernelIndex === this.kernels.length) {
      const kernel = this.gpu.createKernel(function(selection, newSelected, featurePoints, mappedTargetPosition) {
        const {selectionIndex} = this.constants;
        if (this.thread.y !== selectionIndex) return selection[this.thread.y][this.thread.x];

        if (this.thread.x === 0) return newSelected[0];
        if (this.thread.x === 1) return featurePoints[newSelected[0]][0];
        if (this.thread.x === 2) return featurePoints[newSelected[0]][1];
        if (this.thread.x === 3) return mappedTargetPosition[0];
        if (this.thread.x === 4) return mappedTargetPosition[1];
        if (this.thread.x === 5) return mappedTargetPosition[2];
      }, {
        constants: {selectionIndex},
        pipeline: true,
        output: [6, AR2_DEFAULT_SEARCH_FEATURE_NUM]
      });
      this.kernels.push(kernel);
    }
    const kernel = this.kernels[this.kernelIndex++];
    return kernel(selection, newSelected, this.featurePoints, mappedTargetPosition);
  }

  _mapCandidate(targetImage, newSelected) {
    const templateOneSize = AR2_DEFAULT_TS;
    const templateSize = templateOneSize * 2 + 1;
    const searchOneSize = AR2_SEARCH_SIZE;
    const searchSize = searchOneSize * 2 + 1;

    if (this.kernelIndex === this.kernels.length) {
      const k = this.gpu.createKernel(function(imagePixels, imageProperties, featurePoints, newSelected, modelViewProjectionTransforms, modelViewTransforms) {
        const {templateOneSize} = this.constants;

        const featureIndex = newSelected[0];
        const i = this.thread.x;
        const j = this.thread.y;

        const mx = featurePoints[featureIndex][0];
        const my = featurePoints[featureIndex][1];
        const level = featurePoints[featureIndex][2];

        const u = computeScreenCoordiate(modelViewProjectionTransforms, 0, mx, my, 0);
        const sx = Math.floor(u[1] + 0.5);
        const sy = Math.floor(u[2] + 0.5);

        const sx2 = sx + (i - templateOneSize);
        const sy2 = sy + (j - templateOneSize);

        const m = screenToMarkerCoordinate(modelViewProjectionTransforms, 0, sx2, sy2);
        const mx2 = m[0];
        const my2 = m[1];

        const imageWidth = imageProperties[level][0];
        const imageHeight = imageProperties[level][1];
        const imagePixelOffset = imageProperties[level][2];
        const imageDPI = imageProperties[level][3];

        const ix = Math.floor(mx2 * imageDPI + 0.5);
        const iy = Math.floor(imageHeight - my2 * imageDPI + 0.5);

        if (ix < 0 || ix >= imageWidth) {
          return -1;
        }
        if (iy < 0 || iy >= imageHeight) {
          return -1;
        }
        return imagePixels[imagePixelOffset + iy * imageWidth + ix];
      }, {
        constants: {templateOneSize},
        pipeline: true,
        output: [templateSize, templateSize]
      });

      const k2 = this.gpu.createKernel(function(featurePoints, newSelected, modelViewProjectionTransforms) {
        const prevKeep = this.constants.prevKeep;

        const featureIndex = newSelected[0];
        const mx = featurePoints[featureIndex][0];
        const my = featurePoints[featureIndex][1];

        if (this.thread.y === 0) {
          const u = computeScreenCoordiate(modelViewProjectionTransforms, this.thread.y, mx, my, 0);
          return Math.floor(u[this.thread.x+1]);
        } else if (this.thread.y === 1) {
          const u1 = computeScreenCoordiate(modelViewProjectionTransforms, this.thread.y-1, mx, my, 0);
          const u = computeScreenCoordiate(modelViewProjectionTransforms, this.thread.y, mx, my, 0);
          if (u[0] === u1[0] && u[1] === u1[1]) return -1;
          return Math.floor(2 * u1[this.thread.x+1] - u[this.thread.x+1]);
        } else {
          const u1 = computeScreenCoordiate(modelViewProjectionTransforms, this.thread.y-2, mx, my, 0);
          const u2 = computeScreenCoordiate(modelViewProjectionTransforms, this.thread.y-1, mx, my, 0);
          const u = computeScreenCoordiate(modelViewProjectionTransforms, this.thread.y, mx, my, 0);
          if (u[0] === u2[0] && u[1] === u2[1]) return -1;
          return Math.floor(3 * u1[this.thread.x+1] - 3 * u2[this.thread.x+1] + u[this.thread.x+1]);
        }
      }, {
        constants: {prevKeep: PREV_KEEP},
        pipeline: true,
        output: [2, PREV_KEEP]
      });

      // compute similartiy with template of all neighbour points within search points
      const k3 = this.gpu.createKernel(function(targetImage, searchPoints, tem) {
        const {searchOneSize, templateSize, templateOneSize, targetWidth, targetHeight} = this.constants;

        if (searchPoints[this.thread.z][0] === -1) return -1;

        const px = searchPoints[this.thread.z][0] - searchOneSize + this.thread.x;
        const py = searchPoints[this.thread.z][1] - searchOneSize + this.thread.y;
        if (px < 0 || px >= targetWidth) return -1;
        if (py < 0 || py >= targetHeight) return -1;

        let sumPoint = 0;
        let sumPointSquare = 0;
        let sumTemplate = 0;
        let sumTemplateSquare = 0;
        let sumPointTemplate = 0;
        let validCount = 0;
        let templateValidCount = 0;
        for (let j = 0; j < templateSize; j++) {
          for (let i = 0; i < templateSize; i++) {
            if (tem[j][i] !== -1) {
              const py2 = py - templateOneSize + j;
              const px2 = px - templateOneSize + i;

              sumTemplate += tem[j][i];
              sumTemplateSquare += tem[j][i] * tem[j][i];
              templateValidCount += 1;

              if (px2 >= 0 && px2 < targetWidth && py2 >=0 && py2 < targetHeight) {
                validCount += 1;
                sumPoint += targetImage[py2 * targetWidth + px2];
                sumPointSquare += targetImage[py2 * targetWidth + px2] * targetImage[py2 * targetWidth + px2];
                sumPointTemplate += targetImage[py2 * targetWidth + px2] * tem[j][i];
              }
            }
          }
        }
        // TODO: maybe just sum template only when point is also valid?
        sumPointTemplate -= sumPoint * sumTemplate / templateValidCount;

        const pointVar = Math.sqrt(sumPointSquare - sumPoint * sumPoint / templateValidCount);
        if (pointVar == 0) return -1;
        const templateVar = Math.sqrt(sumTemplateSquare - sumTemplate * sumTemplate / templateValidCount);
        const coVar = sumPointTemplate / templateVar / pointVar;

        return coVar;
      }, {
        constants: {
          searchOneSize,
          templateSize,
          templateOneSize,
          targetWidth: this.width,
          targetHeight: this.height
        },
        pipeline: true,
        output: [searchSize, searchSize, PREV_KEEP],
      });

      const k4 = this.gpu.createKernel(function(searchPoints, coVars) {
        const {prevKeep, searchOneSize, searchSize} = this.constants;

        let max = -1;
        let maxIndexI = -1;
        let maxIndexJ = -1;
        let maxIndexK = -1;
        for (let k = 0; k < prevKeep; k++) {
          for (let j = 0; j < searchSize; j++) {
            for (let i = 0; i < searchSize; i++) {
              if (coVars[k][j][i] > max) {
                max = coVars[k][j][i];
                maxIndexI = i;
                maxIndexJ = j;
                maxIndexK = k;
              }
            }
          }
        }
        if (max === -1) return -1;

        if (this.thread.x === 0) return searchPoints[maxIndexK][0] - searchOneSize + maxIndexI;
        if (this.thread.x === 1) return searchPoints[maxIndexK][1] - searchOneSize + maxIndexJ;
        return max;
      }, {
        constants: {
          prevKeep: PREV_KEEP,
          searchOneSize,
          searchSize,
        },
        pipeline: true,
        output: [3], // [x, y, coVar]
      });

      this.kernels.push([k, k2, k3, k4]);
    };
    const kernels = this.kernels[this.kernelIndex++];
    const template = kernels[0](this.imagePixels, this.imageProperties, this.featurePoints, newSelected, this.prevModelViewProjectionTransforms, this.prevModelViewTransforms);

    const searchPoints = kernels[1](this.featurePoints, newSelected, this.prevModelViewProjectionTransforms);
    const coVars = kernels[2](targetImage, searchPoints, template);
    const result = kernels[3](searchPoints, coVars);
    //console.log("template", template.toArray());
    //console.log("search points", JSON.stringify(searchPoints.toArray()));
    //console.log("coVars", coVars.toArray());
    //console.log("result", result.toArray());
    return result;
  }

  _selectCandidate(selection, candidateTypes, candidateSXs, candidateSYs) {
    if (this.kernelIndex === this.kernels.length) {
      const kernel = this.gpu.createKernel(function(selection, candidateTypes, candidateSXs, candidateSYs, prevSelectedFeatureIndexes) {
        const {prevKeep, selectionLength, candidateLength, targetWidth, targetHeight, simThreshold} = this.constants;

        let selected1 = -1;
        let selected2 = -1;
        let selected3 = -1;
        let selected4 = -1;
        for (let i = 0; i < selectionLength; i++) {
          if (selection[i][0] !== -1 && selection[i][5] > simThreshold) {

            if (selected1 === -1) selected1 = selection[i][0];
            else if (selected2 === -1) selected2 = selection[i][0];
            else if (selected3 === -1) selected3 = selection[i][0];
            else if (selected4 === -1) selected4 = selection[i][0];
          }
        }

        if (selected1 === -1) {
          let dmax1 = 0.0;
          let index1 = -1;
          let dmax2 = 0.0;
          let index2 = -1;

          for (let i = 0; i < candidateLength; i++) {
            if (candidateTypes[i] !== 0) {
              let used = false;
              for (let j = 0; j < selectionLength; j++) {
                if (selection[j][0] === i) used = true;
              }
              if (!used
                && candidateSXs[i] >= targetWidth/8 && candidateSXs[i] <= targetWidth * 7 / 8
                && candidateSYs[i] >= targetHeight/8 && candidateSYs[i] <= targetHeight * 7 / 8) {

                // distancce from center
                const d = (candidateSXs[i] - targetWidth/2) * (candidateSXs[i] - targetWidth/2)
                        + (candidateSYs[i] - targetHeight/2) * (candidateSYs[i] - targetHeight/2);

                if (candidateTypes[i] === 1 && d > dmax1) {
                  dmax1 = d;
                  index1 = i;
                }
                else if (candidateTypes[i] === 2 && d > dmax2) {
                  dmax2 = d;
                  index2 = i;
                }
              }
            }
          }
          if (index1 !== -1) return index1;
          if (index2 !== -1) return index2;
          return -1;
        }
        else if (selected2 === -1) {
          let dmax1 = 0.0;
          let index1 = -1;
          let dmax2 = 0.0;
          let index2 = -1;

          for (let i = 0; i < candidateLength; i++) {
            if (candidateTypes[i] !== 0) {
              let used = false;
              for (let j = 0; j < selectionLength; j++) {
                if (selection[j][0] === i) used = true;
              }
              if (!used
                && candidateSXs[i] >= targetWidth/8 && candidateSXs[i] <= targetWidth * 7 / 8
                && candidateSYs[i] >= targetHeight/8 && candidateSYs[i] <= targetHeight * 7 / 8) {

                // distancce from selection one
                const d = (candidateSXs[i] - candidateSXs[selected1]) * (candidateSXs[i] - candidateSXs[selected1])
                        + (candidateSYs[i] - candidateSYs[selected1]) * (candidateSYs[i] - candidateSYs[selected1]);

                if (candidateTypes[i] === 1 && d > dmax1) {
                  dmax1 = d;
                  index1 = i;
                }
                else if (candidateTypes[i] === 2 && d > dmax2) {
                  dmax2 = d;
                  index2 = i;
                }
              }
            }
          }
          if (index1 !== -1) return index1;
          if (index2 !== -1) return index2;
          return -1;
        }
        else if (selected3 === -1) {
          let dmax1 = 0.0;
          let index1 = -1;
          let dmax2 = 0.0;
          let index2 = -1;

          for (let i = 0; i < candidateLength; i++) {
            if (candidateTypes[i] !== 0) {
              let used = false;
              for (let j = 0; j < selectionLength; j++) {
                if (selection[j][0] === i) used = true;
              }
              if (!used
                && candidateSXs[i] >= targetWidth/8 && candidateSXs[i] <= targetWidth * 7 / 8
                && candidateSYs[i] >= targetHeight/8 && candidateSYs[i] <= targetHeight * 7 / 8) {

                // farest from the first two?
                let d = (candidateSXs[i] - candidateSXs[selected1]) * (candidateSYs[selected2] - candidateSYs[selected1])
                      - (candidateSYs[i] - candidateSYs[selected1]) * (candidateSXs[selected2] - candidateSXs[selected1]);
                d = d * d;

                if (candidateTypes[i] === 1 && d > dmax1) {
                  dmax1 = d;
                  index1 = i;
                }
                else if (candidateTypes[i] === 2 && d > dmax2) {
                  dmax2 = d;
                  index2 = i;
                }
              }
            }
          }
          if (index1 !== -1) return index1;
          if (index2 !== -1) return index2;
          return -1;
        }
        else if (selected4 === -1) {
          const pos0 = [candidateSXs[selected1], candidateSYs[selected1]];
          const pos1 = [candidateSXs[selected2], candidateSYs[selected2]];
          const pos2 = [candidateSXs[selected3], candidateSYs[selected3]];

          const [p2sin, p2cos] = getVectorAngle(pos0, pos1);
          const [p3sin, p3cos] = getVectorAngle(pos0, pos2);

          let dmax1 = 0.0;
          let index1 = -1;
          let dmax2 = 0.0;
          let index2 = -1;
          for (let i = 0; i < candidateLength; i++) {
            if (candidateTypes[i] !== 0) {
              let used = false;
              for (let j = 0; j < selectionLength; j++) {
                if (selection[j][0] === i) used = true;
              }
              if (!used
                && candidateSXs[i] >= targetWidth/8 && candidateSXs[i] <= targetWidth * 7 / 8
                && candidateSYs[i] >= targetHeight/8 && candidateSYs[i] <= targetHeight * 7 / 8) {

                const cPos = [candidateSXs[i], candidateSYs[i]];
                const [p4sin, p4cos] = getVectorAngle(pos0, cPos);

                let q1 = [-1, -1];
                let r1 = [-1, -1];
                let r2 = [-1, -1];
                if(((p3sin*p2cos - p3cos*p2sin) >= 0.0) && ((p4sin*p2cos - p4cos*p2sin) >= 0.0)) {
                  if( p4sin*p3cos - p4cos*p3sin >= 0.0 ) {
                    q1 = pos1; r1 = pos2; r2 = cPos;
                  }
                  else {
                    q1 = pos1; r1 = cPos; r2 = pos2;
                  }
                }
                else if(((p4sin*p3cos - p4cos*p3sin) >= 0.0) && ((p2sin*p3cos - p2cos*p3sin) >= 0.0)) {
                  if( p4sin*p2cos - p4cos*p2sin >= 0.0 ) {
                    q1 = pos2; r1 = pos1; r2 = cPos;
                  }
                  else {
                    q1 = pos2; r1 = cPos; r2 = pos1;
                  }
                }
                else if(((p2sin*p4cos - p2cos*p4sin) >= 0.0) && ((p3sin*p4cos - p3cos*p4sin) >= 0.0)) {
                  if( p3sin*p2cos - p3cos*p2sin >= 0.0 ) {
                    q1 = cPos; r1 = pos1; r2 = pos2;
                  }
                  else {
                    q1 = cPos; r1 = pos2; r2 = pos1;
                  }
                }

                const d = getTriangleArea(pos0, q1, r1)
                        + getTriangleArea(pos0, r1, r2);

                if (candidateTypes[i] === 1 && d > dmax1) {
                  dmax1 = d;
                  index1 = i;
                }
                else if (candidateTypes[i] === 2 && d > dmax2) {
                  dmax2 = d;
                  index2 = i;
                }
              }
            }
          }
          if (index1 !== -1) return index1;
          if (index2 !== -1) return index2;
          return -1;
        }
        else {
          // use previous selected features
          //for (let p = 0; p < prevKeep; p++) {
          for (let p = 0; p < 1; p++) {
            for (let i = 0; i < selectionLength; i++) {
              const featureIndex = prevSelectedFeatureIndexes[p][i];
              if (featureIndex !== -1 && candidateTypes[featureIndex] === 1) { // prefer candidate type 1 over 2
                let used = false;
                for (let j = 0; j < selectionLength; j++) {
                  if (selection[j][0] === featureIndex) used = true;
                }
                if (!used) {
                  return featureIndex;
                }
              }
            }
          }

          // maybe select random better?
          for (let i = 0; i < candidateLength; i++) {
            if (candidateTypes[i] === 1) { // prefer candidate type 1 over 2
              let used = false;
              for (let j = 0; j < selectionLength; j++) {
                if (selection[j][0] === i) used = true;
              }
              if (!used) return i;
            }
          }
        }

        return -1;
      }, {
        constants: {
          prevKeep: PREV_KEEP,
          simThreshold: AR2_SIM_THRESH,
          selectionLength: AR2_DEFAULT_SEARCH_FEATURE_NUM,
          candidateLength: candidateSXs.output[0],
          targetWidth: this.width,
          targetHeight: this.height
        },
        pipeline: true,
        output: [1]
      });
      this.kernels.push(kernel);
    }
    const kernel = this.kernels[this.kernelIndex++];
    const newSelected = kernel(selection, candidateTypes, candidateSXs, candidateSYs, this.prevSelectedFeatureIndexes);
    return newSelected;
  }

  //  first dimension [level, sx, sy, mx, my]
  _computeCandidates() {
    if (this.kernelIndex === this.kernels.length) {
      const kernel = this.gpu.createKernelMap({
        saveSX: function(a) {return a},
        saveSY: function(a) {return a},
      }, function(featurePoints, modelViewProjectionTransforms, modelViewTransforms) {
        const {targetWidth, targetHeight} = this.constants;
        const mx = featurePoints[this.thread.x][0];
        const my = featurePoints[this.thread.x][1];
        const level = featurePoints[this.thread.x][2];
        const maxdpi = featurePoints[this.thread.x][3];
        const mindpi = featurePoints[this.thread.x][4];

        // compute screen coordinate
        const u = computeScreenCoordiate(modelViewProjectionTransforms, 0, mx, my, 0);
        const valid = u[0];
        if (valid === 0) return -1;

        const sx = u[1];
        const sy = u[2];

        if (sx < 0 || sx >= targetWidth) return -1;
        if (sy < 0 || sy >= targetHeight) return -1;

        const vdir = [0, 0, 0];
        vdir[0] = modelViewTransforms[0][0][0] * mx
                + modelViewTransforms[0][0][1] * my
                + modelViewTransforms[0][0][3];
        vdir[1] = modelViewTransforms[0][1][0] * mx
                + modelViewTransforms[0][1][1] * my
                + modelViewTransforms[0][1][3];
        vdir[2] = modelViewTransforms[0][2][0] * mx
                + modelViewTransforms[0][2][1] * my
                + modelViewTransforms[0][2][3];
        const vlen = Math.sqrt(vdir[0]*vdir[0] + vdir[1]*vdir[1] + vdir[2]*vdir[2]);
        vdir[0] /= vlen;
        vdir[1] /= vlen;
        vdir[2] /= vlen;
        const vdirValue = vdir[0]*modelViewTransforms[0][0][2] + vdir[1]*modelViewTransforms[0][1][2] + vdir[2]*modelViewTransforms[0][2][2];

        if (vdirValue > -0.1) return -1;

        // get resolution
        const u1 = computeScreenCoordiate(modelViewProjectionTransforms, 0, mx+10, my, 0);
        const u2 = computeScreenCoordiate(modelViewProjectionTransforms, 0, mx, my+10, 0);
        const d1 = (u1[1] - u[1]) * (u1[1] - u[1]) + (u1[2] - u[2]) * (u1[2] - u[2]);
        const d2 = (u2[1] - u[1]) * (u2[1] - u[1]) + (u2[2] - u[2]) * (u2[2] - u[2]);
        // 10 pixel in marker -> d mm in screen (screen scale in mm)
        const dpi = [0, 0];
        if (d1 < d2) {
          dpi[0] = Math.sqrt(d2) / 10;
          dpi[1] = Math.sqrt(d1) / 10;
        } else {
          dpi[0] = Math.sqrt(d1) / 10;
          dpi[1] = Math.sqrt(d2) / 10;
        }

        saveSX(u[1]);
        saveSY(u[2]);

        if (dpi[1] <= maxdpi && dpi[1] >= mindpi) {
          return 1;
        } else if (dpi[1] <= maxdpi * 2 && dpi[1] >= mindpi / 2) {
          return 2;
        }
        return 0;
      }, {
        constants: {targetWidth: this.width, targetHeight: this.height},
        output: [this.featurePoints.output[1]],
        pipeline: true
      });
      this.kernels.push(kernel);
    }
    const kernel = this.kernels[this.kernelIndex++];
    return kernel(this.featurePoints, this.prevModelViewProjectionTransforms, this.prevModelViewTransforms);
  }
}

const _computeUpdatedTran = ({modelViewTransform, projectionTransform, selectedFeatures, inlierProb}) => {
  let dx = 0;
  let dy = 0;
  let dz = 0;
  for (let i = 0; i < selectedFeatures.length; i++) {
    dx += selectedFeatures[i].pos3D.x;
    dy += selectedFeatures[i].pos3D.y;
    dz += selectedFeatures[i].pos3D.z;
  }
  dx /= selectedFeatures.length;
  dy /= selectedFeatures.length;
  dz /= selectedFeatures.length;

  const worldCoords = [];
  const screenCoords = [];
  for (let i = 0; i < selectedFeatures.length; i++) {
    screenCoords.push({x: selectedFeatures[i].pos2D.x, y: selectedFeatures[i].pos2D.y});
    worldCoords.push({x: selectedFeatures[i].pos3D.x - dx, y: selectedFeatures[i].pos3D.y - dy, z: selectedFeatures[i].pos3D.z - dz});
  }

  const diffModelViewTransform = [[],[],[]];
  for (let j = 0; j < 3; j++) {
    for (let i = 0; i < 3; i++) {
      diffModelViewTransform[j][i] = modelViewTransform[j][i];
    }
  }
  diffModelViewTransform[0][3] = modelViewTransform[0][0] * dx + modelViewTransform[0][1] * dy + modelViewTransform[0][2] * dz + modelViewTransform[0][3];
  diffModelViewTransform[1][3] = modelViewTransform[1][0] * dx + modelViewTransform[1][1] * dy + modelViewTransform[1][2] * dz + modelViewTransform[1][3];
  diffModelViewTransform[2][3] = modelViewTransform[2][0] * dx + modelViewTransform[2][1] * dy + modelViewTransform[2][2] * dz + modelViewTransform[2][3];

  let ret;
  if (inlierProb < 1) {
     ret = refineHomography({initialModelViewTransform: diffModelViewTransform, projectionTransform, worldCoords, screenCoords, isRobustMode: true, inlierProb});
  } else {
     ret = refineHomography({initialModelViewTransform: diffModelViewTransform, projectionTransform, worldCoords, screenCoords, isRobustMode: false});
  }

  const newModelViewTransform = [[],[],[]];
  for (let j = 0; j < 3; j++) {
    for (let i = 0; i < 3; i++) {
      newModelViewTransform[j][i] = ret.modelViewTransform[j][i];
    }
  }
  newModelViewTransform[0][3] = ret.modelViewTransform[0][3] - ret.modelViewTransform[0][0] * dx - ret.modelViewTransform[0][1] * dy - ret.modelViewTransform[0][2] * dz;
  newModelViewTransform[1][3] = ret.modelViewTransform[1][3] - ret.modelViewTransform[1][0] * dx - ret.modelViewTransform[1][1] * dy - ret.modelViewTransform[1][2] * dz;
  newModelViewTransform[2][3] = ret.modelViewTransform[2][3] - ret.modelViewTransform[2][0] * dx - ret.modelViewTransform[2][1] * dy - ret.modelViewTransform[2][2] * dz;


  return {err: ret.err, newModelViewTransform};
};

module.exports = {
  Tracker,
}


/***/ }),

/***/ "./src/image-target/utils/geometry.js":
/*!********************************************!*\
  !*** ./src/image-target/utils/geometry.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// check which side point C on the line from A to B
const linePointSide = (A, B, C) => {
  return ((B[0]-A[0])*(C[1]-A[1])-(B[1]-A[1])*(C[0]-A[0]));
}

// srcPoints, dstPoints: array of four elements [x, y]
const checkFourPointsConsistent = (x1, x2, x3, x4, x1p, x2p, x3p, x4p) => {
  if ((linePointSide(x1, x2, x3) > 0) !== (linePointSide(x1p, x2p, x3p) > 0)) return false;
  if ((linePointSide(x2, x3, x4) > 0) !== (linePointSide(x2p, x3p, x4p) > 0)) return false;
  if ((linePointSide(x3, x4, x1) > 0) !== (linePointSide(x3p, x4p, x1p) > 0)) return false;
  if ((linePointSide(x4, x1, x2) > 0) !== (linePointSide(x4p, x1p, x2p) > 0)) return false;
  return true;
}

const checkThreePointsConsistent = (x1, x2, x3, x1p, x2p, x3p) => {
  if ((linePointSide(x1, x2, x3) > 0) !== (linePointSide(x1p, x2p, x3p) > 0)) return false;
  return true;
}

const determinant = (A) => {
  const C1 =  A[4] * A[8] - A[5] * A[7];
  const C2 =  A[3] * A[8] - A[5] * A[6];
  const C3 =  A[3] * A[7] - A[4] * A[6];
  return A[0] * C1 - A[1] * C2 + A[2] * C3;
}

const matrixInverse33 = (A, threshold) => {
  const det = determinant(A);
  if (Math.abs(det) <= threshold) return null;
  const oneOver = 1.0 / det;

  const B = [
    (A[4] * A[8] - A[5] * A[7]) * oneOver,
    (A[2] * A[7] - A[1] * A[8]) * oneOver,
    (A[1] * A[5] - A[2] * A[4]) * oneOver,
    (A[5] * A[6] - A[3] * A[8]) * oneOver,
    (A[0] * A[8] - A[2] * A[6]) * oneOver,
    (A[2] * A[3] - A[0] * A[5]) * oneOver,
    (A[3] * A[7] - A[4] * A[6]) * oneOver,
    (A[1] * A[6] - A[0] * A[7]) * oneOver,
    (A[0] * A[4] - A[1] * A[3]) * oneOver,
  ];
  return B;
}

const matrixMul33 = (A, B) => {
  const C = [];
  C[0] = A[0]*B[0] + A[1]*B[3] + A[2]*B[6];
  C[1] = A[0]*B[1] + A[1]*B[4] + A[2]*B[7];
  C[2] = A[0]*B[2] + A[1]*B[5] + A[2]*B[8];
  C[3] = A[3]*B[0] + A[4]*B[3] + A[5]*B[6];
  C[4] = A[3]*B[1] + A[4]*B[4] + A[5]*B[7];
  C[5] = A[3]*B[2] + A[4]*B[5] + A[5]*B[8];
  C[6] = A[6]*B[0] + A[7]*B[3] + A[8]*B[6];
  C[7] = A[6]*B[1] + A[7]*B[4] + A[8]*B[7];
  C[8] = A[6]*B[2] + A[7]*B[5] + A[8]*B[8];
  return C;
}

const multiplyPointHomographyInhomogenous = (x, H) => {
  const w = H[6]*x[0] + H[7]*x[1] + H[8];
  const xp = [];
  xp[0] = (H[0]*x[0] + H[1]*x[1] + H[2])/w;
  xp[1] = (H[3]*x[0] + H[4]*x[1] + H[5])/w;
  return xp;
}

const smallestTriangleArea = (x1, x2, x3, x4) => {
  const v12 = _vector(x2, x1);
  const v13 = _vector(x3, x1);
  const v14 = _vector(x4, x1);
  const v32 = _vector(x2, x3);
  const v34 = _vector(x4, x3);
  const a1 = _areaOfTriangle(v12, v13);
  const a2 = _areaOfTriangle(v13, v14);
  const a3 = _areaOfTriangle(v12, v14);
  const a4 = _areaOfTriangle(v32, v34);
  return Math.min(Math.min(Math.min(a1, a2), a3), a4);
}

// check if four points form a convex quadrilaternal.
// all four combinations should have same sign
const quadrilateralConvex = (x1, x2, x3, x4) => {
  const first = linePointSide(x1, x2, x3) <= 0;
  if ( (linePointSide(x2, x3, x4) <= 0) !== first) return false;
  if ( (linePointSide(x3, x4, x1) <= 0) !== first) return false;
  if ( (linePointSide(x4, x1, x2) <= 0) !== first) return false;

  //if (linePointSide(x1, x2, x3) <= 0) return false;
  //if (linePointSide(x2, x3, x4) <= 0) return false;
  //if (linePointSide(x3, x4, x1) <= 0) return false;
  //if (linePointSide(x4, x1, x2) <= 0) return false;
  return true;
}

const _vector = (a, b) => {
  return [
    a[0] - b[0],
    a[1] - b[1]
  ]
}

const _areaOfTriangle = (u, v) => {
  const a = u[0]*v[1] - u[1]*v[0];
  return Math.abs(a) * 0.5;
}

module.exports = {
  matrixInverse33,
  matrixMul33,
  quadrilateralConvex,
  smallestTriangleArea,
  multiplyPointHomographyInhomogenous,
  checkThreePointsConsistent,
  checkFourPointsConsistent,
  determinant
}



/***/ }),

/***/ "./src/image-target/utils/images.js":
/*!******************************************!*\
  !*** ./src/image-target/utils/images.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// simpler version of upsampling. better performance
const _upsampleBilinear = ({image, padOneWidth, padOneHeight}) => {
  const {width, height, data} = image;
  const dstWidth = image.width * 2 + (padOneWidth?1:0);
  const dstHeight = image.height * 2 + (padOneHeight?1:0);
  const temp = new Float32Array(dstWidth * dstHeight);

  for (let i = 0; i < width; i++) {
    for (let j = 0; j < height; j++) {
      const v = 0.25 * data[j * width + i];
      const ii = Math.floor(i/2);
      const jj = Math.floor(j/2);
      const pos = Math.floor(j/2) * dstWidth + Math.floor(i/2);
      temp[pos] += v;
      temp[pos+1] += v;
      temp[pos+dstWidth] += v;
      temp[pos+dstWidth+1] += v;
    }
  }
  return {data: temp, width: dstWidth, height: dstHeight};
}

// artoolkit version. slower. is it necessary?
const upsampleBilinear = ({image, padOneWidth, padOneHeight}) => {
  const {width, height, data} = image;

  const dstWidth = image.width * 2 + (padOneWidth?1:0);
  const dstHeight = image.height * 2 + (padOneHeight?1:0);

  const temp = new Float32Array(dstWidth * dstHeight);
  for (let i = 0; i < dstWidth; i++) {
    const si = 0.5 * i - 0.25;
    let si0 = Math.floor(si);
    let si1 = Math.ceil(si);
    if (si0 < 0) si0 = 0; // border
    if (si1 >= width) si1 = width - 1; // border

    for (let j = 0; j < dstHeight; j++) {
      const sj = 0.5 * j - 0.25;
      let sj0 = Math.floor(sj);
      let sj1 = Math.ceil(sj);
      if (sj0 < 0) sj0 = 0; // border
      if (sj1 >= height) sj1 = height - 1; //border

      const value = (si1 - si) * (sj1 - sj) * data[ sj0 * width + si0 ] +
                    (si1 - si) * (sj - sj0) * data[ sj1 * width + si0 ] +
                    (si - si0) * (sj1 - sj) * data[ sj0 * width + si1 ] +
                    (si - si0) * (sj - sj0) * data[ sj1 * width + si1 ];

      temp[j * dstWidth + i] = value;
    }
  }

  return {data: temp, width: dstWidth, height: dstHeight};
}

const downsampleBilinear = ({image}) => {
  const {data, width, height} = image;

  const dstWidth = Math.floor(width / 2);
  const dstHeight = Math.floor(height / 2);

  const temp = new Float32Array(dstWidth * dstHeight);
  const offsets = [0, 1, width, width+1];

  for (let j = 0; j < dstHeight; j++) {
    for (let i = 0; i < dstWidth; i++) {
      let srcPos = j*2 * width + i*2;
      let value = 0.0;
      for (let d = 0; d < offsets.length; d++) {
        value += data[srcPos+ offsets[d]];
      }
      value *= 0.25;
      temp[j*dstWidth+i] = value;
    }
  }
  return {data: temp, width: dstWidth, height: dstHeight};
}

const resize = ({image, ratio}) => {
  const width = Math.round(image.width * ratio);
  const height = Math.round(image.height * ratio);

  //const imageData = new Float32Array(width * height);
  const imageData = new Uint8Array(width * height);
  for (let i = 0; i < width; i++) {
    let si1 = Math.round(1.0 * i / ratio);
    let si2 = Math.round(1.0 * (i+1) / ratio) - 1;
    if (si2 >= image.width) si2 = image.width - 1;

    for (let j = 0; j < height; j++) {
      let sj1 = Math.round(1.0 * j / ratio);
      let sj2 = Math.round(1.0 * (j+1) / ratio) - 1;
      if (sj2 >= image.height) sj2 = image.height - 1;

      let sum = 0;
      let count = 0;
      for (let ii = si1; ii <= si2; ii++) {
        for (let jj = sj1; jj <= sj2; jj++) {
          sum += (1.0 * image.data[jj * image.width + ii]);
          count += 1;
        }
      }
      imageData[j * width + i] = Math.floor(sum / count);
    }
  }
  return {data: imageData, width: width, height: height};
}

module.exports = {
  downsampleBilinear,
  upsampleBilinear,
  resize,
}



/***/ }),

/***/ "./src/image-target/utils/randomizer.js":
/*!**********************************************!*\
  !*** ./src/image-target/utils/randomizer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

const mRandSeed = 1234;

const createRandomizer = () => {
  const randomizer = {
    seed: mRandSeed,

    arrayShuffle(options) {
      const {arr, sampleSize} = options;
      for (let i = 0; i < sampleSize; i++) {

        this.seed = (214013 * this.seed + 2531011) % (1 << 31);
        let k = (this.seed >> 16) & 0x7fff;
        k = k % arr.length;

        let tmp = arr[i];
        arr[i] = arr[k];
        arr[k] = tmp;
      }
    },

    nextInt(maxValue) {
      this.seed = (214013 * this.seed + 2531011) % (1 << 31);
      let k = (this.seed >> 16) & 0x7fff;
      k = k % maxValue;
      return k;
    }
  }
  return randomizer;
}

module.exports = {
  createRandomizer
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {Controller} = __webpack_require__(/*! ./controller */ "./src/controller.js");
const {Compiler} = __webpack_require__(/*! ./compiler */ "./src/compiler.js");

module.exports = window.MINDAR = {
  Controller,
  Compiler
}


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svZGlzdC5lczUvbXNncGFjay5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2dwdS1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pcy1hbnktYXJyYXkvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tbC1hcnJheS1tYXgvbGliLWVzNi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwtYXJyYXktbWluL2xpYi1lczYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLWFycmF5LXJlc2NhbGUvbGliLWVzNi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwtbWF0cml4L3NyYy9jb3JyZWxhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwtbWF0cml4L3NyYy9jb3ZhcmlhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tbC1tYXRyaXgvc3JjL2RjL2Nob2xlc2t5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tbC1tYXRyaXgvc3JjL2RjL2V2ZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwtbWF0cml4L3NyYy9kYy9sdS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwtbWF0cml4L3NyYy9kYy9uaXBhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvZGMvcXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvZGMvc3ZkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tbC1tYXRyaXgvc3JjL2RjL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvZGVjb21wb3NpdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvZGV0ZXJtaW5hbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvaW5zcGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwtbWF0cml4L3NyYy9saW5lYXJEZXBlbmRlbmNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvbWF0aE9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvbWF0cml4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tbC1tYXRyaXgvc3JjL3BzZXVkb0ludmVyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvc3RhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwtbWF0cml4L3NyYy91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tbC1tYXRyaXgvc3JjL3ZpZXdzL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvdmlld3MvY29sdW1uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tbC1tYXRyaXgvc3JjL3ZpZXdzL2NvbHVtblNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwtbWF0cml4L3NyYy92aWV3cy9mbGlwQ29sdW1uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tbC1tYXRyaXgvc3JjL3ZpZXdzL2ZsaXBSb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvdmlld3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvdmlld3Mvcm93LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tbC1tYXRyaXgvc3JjL3ZpZXdzL3Jvd1NlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwtbWF0cml4L3NyYy92aWV3cy9zZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvdmlld3Mvc3ViLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tbC1tYXRyaXgvc3JjL3ZpZXdzL3RyYW5zcG9zZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwtbWF0cml4L3NyYy93cmFwL1dyYXBwZXJNYXRyaXgxRC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwtbWF0cml4L3NyYy93cmFwL1dyYXBwZXJNYXRyaXgyRC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwtbWF0cml4L3NyYy93cmFwL3dyYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGlueXF1ZXVlL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9jb21waWxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcGlsZXIud29ya2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9pbWFnZS10YXJnZXQvZGV0ZWN0b3JHUFUvZGV0ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ltYWdlLXRhcmdldC9pY3AvZXN0aW1hdGVfaG9tb2dyYXBoeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW1hZ2UtdGFyZ2V0L2ljcC9yZWZpbmVfaG9tb2dyYXBoeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW1hZ2UtdGFyZ2V0L2ljcC91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW1hZ2UtdGFyZ2V0L2ltYWdlLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ltYWdlLXRhcmdldC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW1hZ2UtdGFyZ2V0L21hdGNoaW5nL2hhbW1pbmctZGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ltYWdlLXRhcmdldC9tYXRjaGluZy9oaWVyYXJjaGljYWwtY2x1c3RlcmluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW1hZ2UtdGFyZ2V0L21hdGNoaW5nL2hvbW9ncmFwaHkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ltYWdlLXRhcmdldC9tYXRjaGluZy9ob3VnaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW1hZ2UtdGFyZ2V0L21hdGNoaW5nL21hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ltYWdlLXRhcmdldC9tYXRjaGluZy9tYXRjaGluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW1hZ2UtdGFyZ2V0L3RyYWNraW5nR1BVL3RyYWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ltYWdlLXRhcmdldC91dGlscy9nZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW1hZ2UtdGFyZ2V0L3V0aWxzL2ltYWdlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW1hZ2UtdGFyZ2V0L3V0aWxzL3JhbmRvbWl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNDQUFzQztBQUM3QztBQUNBLE9BQU8sdUNBQXVDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0NBQXNDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxXQUFXO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSw4REFBOEQsRUFBRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsNERBQTRELFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFdBQVc7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU0sV0FBVyxvQkFBb0IsYUFBYSxvQkFBb0IsTUFBTSxjQUFjO0FBQ2xIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFVBQVUsRUFBRSxVQUFVLEVBQUUsUUFBUTtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxnREFBZ0Q7QUFDbkQsT0FBTyxRQUFROztBQUVmO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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TztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQSx1Q0FBdUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLHVEQUF1RCx3QkFBd0IsR0FBRyx3QkFBd0I7QUFDcEw7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCxzQkFBc0I7QUFDOUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaURBQWlELGVBQWU7QUFDaEU7O0FBRUEsOENBQThDLGdCQUFnQjtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0I7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLGtDQUFrQztBQUNyQztBQUNBLE9BQU8sY0FBYztBQUNyQixPQUFPLGlCQUFpQjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRTtBQUMxRSxxREFBcUQsc0RBQXNELEVBQUU7QUFDN0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxJQUFJO0FB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSixPQUFPLFFBQVE7QUFDZixPQUFPLGVBQWU7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxhQUFhO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQUssUUFBUSxLQUFLLGNBQWMsS0FBSyxrQkFBa0IsS0FBSztBQUNyRixTQUFTO0FBQ1QseUJBQXlCLEtBQUssUUFBUSxLQUFLO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnQkFBZ0I7QUFDM0U7O0FBRUE7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZELDBCQUEwQjtBQUMxQixLQUFLO0FBQ0wscUNBQXFDLFlBQVksS0FBSyxtQkFBbUI7QUFDekUsNENBQTRDLGFBQWE7QUFDekQsS0FBSztBQUNMLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakMsT0FBTztBQUNQO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakMsT0FBTztBQUNQO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFLElBQUk7QUFDN0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUM7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsV0FBVyxXQUFXOztBQUV0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLFdBQVcsY0FBYztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxvRUFBb0U7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsdUNBQXVDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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N0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0wscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGlCQUFpQjtBQUN6RTtB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QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjtBQUNBLE9BQU8sUUFBUTtBQUNmLE9BQU8sVUFBVTs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsK0NBQStDLDhCQUE4QjtBQUM3RSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLG1DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMs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LE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGNBQWM7QUFDMUQsNENBQTRDLGNBQWM7QUFDMUQsNERBQTRELGNBQWM7QUFDMUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsOENBQThDLGNBQWM7QUFDNUQsOERBQThELGNBQWM7QUFDNUU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQkFBc0IsdUNBQXVDO0FBQzdEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQkFBc0IsbUNBQW1DO0FBQ3pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QixPQUFPO0FBQ1Asb0JBQW9CLHlDQUF5QztBQUM3RDtBQUNBO0FBQ0EsT0FBTztBQUNQLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcnlDQSxPQUFPLGdCQUFnQixHQUFHLG1CQUFPLENBQUMsd0RBQVc7QUFDN0MsT0FBTyw2RkFBNkYsR0FBRyxtQkFBTyxDQUFDLG1EQUFZOztBQUUzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrQ0FBK0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QyxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixzQ0FBc0M7QUFDekQscUJBQXFCLHlDQUF5QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25KQSxPQUFPLGdCQUFnQixHQUFHLG1CQUFPLENBQUMsd0RBQVc7QUFDN0MsT0FBTyxxSEFBcUgsR0FBRyxtQkFBTyxDQUFDLG1EQUFZOztBQUVuSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixvR0FBb0c7QUFDL0g7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBLHlCQUF5QixZQUFZOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLGtHQUFrRzs7QUFFakk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5Qix5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJDQUEyQztBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9ELHVCQUF1QjtBQUMzRTtBQUNBLFVBQVU7QUFDVjs7QUFFQSw4QkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsVUFBVTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxrRkFBa0Y7QUFDaEc7QUFDQSxTQUFTLFFBQVE7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0EsU0FBUyxvQkFBb0I7QUFDN0I7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pFQSxPQUFPLE9BQU8sR0FBRyxtQkFBTyxDQUFDLDZEQUFtQjs7QUFFNUM7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQyxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQSx5Q0FBeUMseUNBQXlDLElBQUksZ0JBQWdCO0FBQ3RHOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2Q0EsT0FBTyxPQUFPLEdBQUcsbUJBQU8sQ0FBQyw2REFBbUI7QUFDNUMsT0FBTyxlQUFlLEdBQUcsbUJBQU8sQ0FBQyx5REFBaUI7QUFDbEQsT0FBTyxRQUFRLEdBQUcsbUJBQU8sQ0FBQyxxRUFBdUI7QUFDakQsU0FBUyxpQkFBaUI7QUFDMUIsT0FBTyxpQkFBaUIsR0FBRyxtQkFBTyxDQUFDLDJFQUEwQjtBQUM3RCxPQUFPLG1CQUFtQixHQUFHLG1CQUFPLENBQUMsbUZBQThCO0FBQ25FLE9BQU8saUJBQWlCLEdBQUcsbUJBQU8sQ0FBQyw0RUFBeUI7O0FBRTVEO0FBQ0EsZUFBZSx3RUFBd0U7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDBCQUEwQjs7QUFFckMsMERBQTBELHlFQUF5RTtBQUNuSTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtREFBbUQscUJBQXFCLG9HQUFvRzs7QUFFdkw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM5REE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdkJBLE9BQU8sd0JBQXdCLEdBQUcsbUJBQU8sQ0FBQyw4RUFBdUI7QUFDakUsT0FBTyxpQkFBaUIsR0FBRyxtQkFBTyxDQUFDLHNFQUF3Qjs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsK0VBQStFO0FBQzFHLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxtREFBbUQ7O0FBRTVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUNBQWlDOztBQUUxRSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsK0ZBQStGO0FBQzlILEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsU0FBUyxpQ0FBaUM7O0FBRTFDO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hELDZCQUE2QixpREFBaUQ7O0FBRTlFO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBLGtDQUFrQyw2RUFBNkU7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNySEEsT0FBTyxpQkFBaUIsR0FBRyxtQkFBTyxDQUFDLHNFQUF3QjtBQUMzRCxPQUFPLG9LQUFvSyxHQUFHLG1CQUFPLENBQUMsa0VBQXNCOztBQUU1TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsK0JBQStCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTs7QUFFQSwyQkFBMkIsbUNBQW1DOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixrQ0FBa0M7O0FBRS9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGlCQUFpQiwrQ0FBK0M7QUFDaEU7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQXVCO0FBQzFDLHFCQUFxQixjQUFjO0FBQ25DLHdEQUF3RCxrRkFBa0Y7QUFDMUk7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyx5QkFBeUI7QUFDMUQsNERBQTREO0FBQzVEOztBQUVBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBOztBQUVBLHVDQUF1Qyw2QkFBNkI7O0FBRXBFLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTs7QUFFQSwyQkFBMkIsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQix1QkFBdUIsT0FBTztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwrQkFBK0IsSUFBSTtBQUNuQzs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLHFDQUFxQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0QsY0FBYztBQUN0RTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUM7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLHVFQUF1RTs7QUFFM0c7O0FBRUE7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyx1RUFBdUU7QUFDM0c7O0FBRUE7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsb0RBQW9EOztBQUV2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsbUNBQW1DO0FBQ2pGO0FBQ0E7O0FBRUEsZUFBZTtBQUNmLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7O0FBRUEsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGlDQUFpQzs7QUFFakM7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcmVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLDhFQUE4RTs7QUFFdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTs7QUFFQSxXQUFXLG1CQUFtQix1QkFBdUIsK0RBQStEOztBQUVwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCOztBQUVBLHNCQUFzQixRQUFRO0FBQzlCOztBQUVBLDRCQUE0QixZQUFZO0FBQ3hDOztBQUVBLDhCQUE4QixZQUFZO0FBQzFDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLDZDQUE2Qzs7QUFFL0U7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLCtEQUErRDtBQUM1RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0tBLE9BQU8sbUNBQW1DLEdBQUcsbUJBQU8sQ0FBQyw0RkFBOEI7QUFDbkYsT0FBTyxNQUFNLEdBQUcsbUJBQU8sQ0FBQywyREFBWTs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDBCQUEwQixzR0FBc0c7QUFDaEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcERBLGtCQUFrQixtQkFBTyxDQUFDLG9EQUFXO0FBQ3JDLE9BQU8sd0JBQXdCLEdBQUcsbUJBQU8sQ0FBQyw4RUFBdUI7QUFDakUsT0FBTyxvQkFBb0IsR0FBRyxtQkFBTyxDQUFDLHdEQUFZO0FBQ2xELE9BQU8sa0JBQWtCLEdBQUcsbUJBQU8sQ0FBQyxrRUFBaUI7QUFDckQsT0FBTyxxREFBcUQsR0FBRyxtQkFBTyxDQUFDLGtFQUFzQjs7QUFFN0Y7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxtREFBbUQsbUJBQW1COztBQUV0RSxjQUFjLHlFQUF5RTs7QUFFdkY7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTs7QUFFQSxrQ0FBa0MscURBQXFEO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUE2QztBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxxREFBcUQ7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLDZDQUE2QztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLDREQUE0RDtBQUM3RTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQSw4QkFBOEIsd0VBQXdFO0FBQ3RHO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7O0FBRUEsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBLGtCQUFrQix3Q0FBd0M7QUFDMUQ7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQSxjQUFjLDhFQUE4RTtBQUM1RjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWSw0REFBNEQ7QUFDeEU7QUFDQTs7QUFFQTtBQUNBLFNBQVMsOENBQThDOztBQUV2RDs7QUFFQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuWUEsT0FBTyxpQkFBaUIsR0FBRyxtQkFBTyxDQUFDLGdGQUE2QjtBQUNoRSxPQUFPLElBQUksR0FBRyxtQkFBTyxDQUFDLHlEQUFROztBQUU5QjtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLDZCQUE2Qjs7QUFFN0IsZ0NBQWdDO0FBQ2hDLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0EsMkNBQTJDOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7O0FBRUE7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0EsT0FBTztBQUNQLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQSxxQkFBcUIsa0NBQWtDO0FBQ3ZELGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0Esa0JBQWtCLGlEQUFpRDtBQUNuRSxrQkFBa0IsdURBQXVEO0FBQ3pFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDLHFDQUFxQyw2R0FBNkc7QUFDbEo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsZUFBZSx3RUFBd0U7O0FBRXZGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6Qyx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxlQUFlLG9DQUFvQzs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQyx5QkFBeUIsZ0JBQWdCO0FBQ3pDLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9GQUFvRjs7QUFFbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekMseUJBQXlCLE9BQU87QUFDaEMsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUMsMENBQTBDO0FBQzFDO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0Qyw2QkFBNkIsU0FBUztBQUN0QyxPQUFPO0FBQ1AsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG9CQUFvQixtREFBbUQ7QUFDdkU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLHNFQUFzRTtBQUNwRztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkJBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsNkJBQTZCO0FBQzlDLHVCQUF1QiwrREFBK0Q7QUFDdEYsc0JBQXNCLDhHQUE4RztBQUNwSTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGtJQUFrSTtBQUMvSixHQUFHO0FBQ0gsNkJBQTZCLHVIQUF1SDtBQUNwSjs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcjhCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BIQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0QsU0FBUyxvQkFBb0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixXQUFXO0FBQzVCLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0EsMkJBQTJCLGlDQUFpQztBQUM1RCxTQUFTLG9CQUFvQjs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixzQ0FBc0M7O0FBRXRDLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUEsNkJBQTZCLE1BQU07QUFDbkMsU0FBUyxvQkFBb0I7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsZUFBZTtBQUNoQyxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUEsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkMsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pIQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixxQkFBcUIsZ0JBQWdCOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hDQSxPQUFPLFdBQVcsR0FBRyxtQkFBTyxDQUFDLHlDQUFjO0FBQzNDLE9BQU8sU0FBUyxHQUFHLG1CQUFPLENBQUMscUNBQVk7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Im1pbmRhci5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL35oaXVraW0vcHJvamVjdHMvV2ViQ2FyZHMvbWluZC1hci1qcy9kaXN0L1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbiIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuTWVzc2FnZVBhY2s9dCgpOmUuTWVzc2FnZVBhY2s9dCgpfSh0aGlzLChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiByKG4pe2lmKHRbbl0pcmV0dXJuIHRbbl0uZXhwb3J0czt2YXIgaT10W25dPXtpOm4sbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtuXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxyKSxpLmw9ITAsaS5leHBvcnRzfXJldHVybiByLm09ZSxyLmM9dCxyLmQ9ZnVuY3Rpb24oZSx0LG4pe3IubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDpufSl9LHIucj1mdW5jdGlvbihlKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxyLnQ9ZnVuY3Rpb24oZSx0KXtpZigxJnQmJihlPXIoZSkpLDgmdClyZXR1cm4gZTtpZig0JnQmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49T2JqZWN0LmNyZWF0ZShudWxsKTtpZihyLnIobiksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pLDImdCYmXCJzdHJpbmdcIiE9dHlwZW9mIGUpZm9yKHZhciBpIGluIGUpci5kKG4saSxmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0uYmluZChudWxsLGkpKTtyZXR1cm4gbn0sci5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiByLmQodCxcImFcIix0KSx0fSxyLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHIucD1cIlwiLHIoci5zPTApfShbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3Iucih0KSxyLmQodCxcImVuY29kZVwiLChmdW5jdGlvbigpe3JldHVybiBJfSkpLHIuZCh0LFwiZGVjb2RlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIE59KSksci5kKHQsXCJkZWNvZGVBc3luY1wiLChmdW5jdGlvbigpe3JldHVybiBZfSkpLHIuZCh0LFwiZGVjb2RlQXJyYXlTdHJlYW1cIiwoZnVuY3Rpb24oKXtyZXR1cm4gWn0pKSxyLmQodCxcImRlY29kZVN0cmVhbVwiLChmdW5jdGlvbigpe3JldHVybiAkfSkpLHIuZCh0LFwiRGVjb2RlclwiLChmdW5jdGlvbigpe3JldHVybiBWfSkpLHIuZCh0LFwiRW5jb2RlclwiLChmdW5jdGlvbigpe3JldHVybiBMfSkpLHIuZCh0LFwiRXh0ZW5zaW9uQ29kZWNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gU30pKSxyLmQodCxcIkV4dERhdGFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gcH0pKSxyLmQodCxcIkVYVF9USU1FU1RBTVBcIiwoZnVuY3Rpb24oKXtyZXR1cm4gd30pKSxyLmQodCxcImVuY29kZURhdGVUb1RpbWVTcGVjXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSksci5kKHQsXCJlbmNvZGVUaW1lU3BlY1RvVGltZXN0YW1wXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSksci5kKHQsXCJkZWNvZGVUaW1lc3RhbXBUb1RpbWVTcGVjXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSksci5kKHQsXCJlbmNvZGVUaW1lc3RhbXBFeHRlbnNpb25cIiwoZnVuY3Rpb24oKXtyZXR1cm4gYn0pKSxyLmQodCxcImRlY29kZVRpbWVzdGFtcEV4dGVuc2lvblwiLChmdW5jdGlvbigpe3JldHVybiBVfSkpO3ZhciBuPWZ1bmN0aW9uKGUsdCl7dmFyIHI9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlW1N5bWJvbC5pdGVyYXRvcl07aWYoIXIpcmV0dXJuIGU7dmFyIG4saSxvPXIuY2FsbChlKSxzPVtdO3RyeXtmb3IoOyh2b2lkIDA9PT10fHx0LS0gPjApJiYhKG49by5uZXh0KCkpLmRvbmU7KXMucHVzaChuLnZhbHVlKX1jYXRjaChlKXtpPXtlcnJvcjplfX1maW5hbGx5e3RyeXtuJiYhbi5kb25lJiYocj1vLnJldHVybikmJnIuY2FsbChvKX1maW5hbGx5e2lmKGkpdGhyb3cgaS5lcnJvcn19cmV0dXJuIHN9LGk9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZT1lLmNvbmNhdChuKGFyZ3VtZW50c1t0XSkpO3JldHVybiBlfSxvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dEVuY29kZXImJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2RlcjtmdW5jdGlvbiBzKGUpe2Zvcih2YXIgdD1lLmxlbmd0aCxyPTAsbj0wO248dDspe3ZhciBpPWUuY2hhckNvZGVBdChuKyspO2lmKDAhPSg0Mjk0OTY3MTY4JmkpKWlmKDA9PSg0Mjk0OTY1MjQ4JmkpKXIrPTI7ZWxzZXtpZihpPj01NTI5NiYmaTw9NTYzMTkmJm48dCl7dmFyIG89ZS5jaGFyQ29kZUF0KG4pOzU2MzIwPT0oNjQ1MTImbykmJigrK24saT0oKDEwMjMmaSk8PDEwKSsoMTAyMyZvKSs2NTUzNil9cis9MD09KDQyOTQ5MDE3NjAmaSk/Mzo0fWVsc2UgcisrfXJldHVybiByfXZhciBhPW8/bmV3IFRleHRFbmNvZGVyOnZvaWQgMCxoPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzPzIwMDowO3ZhciB1PShudWxsPT1hP3ZvaWQgMDphLmVuY29kZUludG8pP2Z1bmN0aW9uKGUsdCxyKXthLmVuY29kZUludG8oZSx0LnN1YmFycmF5KHIpKX06ZnVuY3Rpb24oZSx0LHIpe3Quc2V0KGEuZW5jb2RlKGUpLHIpfTtmdW5jdGlvbiBjKGUsdCxyKXtmb3IodmFyIG49dCxvPW4rcixzPVtdLGE9XCJcIjtuPG87KXt2YXIgaD1lW24rK107aWYoMD09KDEyOCZoKSlzLnB1c2goaCk7ZWxzZSBpZigxOTI9PSgyMjQmaCkpe3ZhciB1PTYzJmVbbisrXTtzLnB1c2goKDMxJmgpPDw2fHUpfWVsc2UgaWYoMjI0PT0oMjQwJmgpKXt1PTYzJmVbbisrXTt2YXIgYz02MyZlW24rK107cy5wdXNoKCgzMSZoKTw8MTJ8dTw8NnxjKX1lbHNlIGlmKDI0MD09KDI0OCZoKSl7dmFyIGY9KDcmaCk8PDE4fCh1PTYzJmVbbisrXSk8PDEyfChjPTYzJmVbbisrXSk8PDZ8NjMmZVtuKytdO2Y+NjU1MzUmJihmLT02NTUzNixzLnB1c2goZj4+PjEwJjEwMjN8NTUyOTYpLGY9NTYzMjB8MTAyMyZmKSxzLnB1c2goZil9ZWxzZSBzLnB1c2goaCk7cy5sZW5ndGg+PTQwOTYmJihhKz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxpKHMpKSxzLmxlbmd0aD0wKX1yZXR1cm4gcy5sZW5ndGg+MCYmKGErPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGkocykpKSxhfXZhciBmPW8/bmV3IFRleHREZWNvZGVyOm51bGwsbD1cInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2Vzcz8yMDA6MDt2YXIgcD1mdW5jdGlvbihlLHQpe3RoaXMudHlwZT1lLHRoaXMuZGF0YT10fTtmdW5jdGlvbiBkKGUsdCxyKXt2YXIgbj1NYXRoLmZsb29yKHIvNDI5NDk2NzI5NiksaT1yO2Uuc2V0VWludDMyKHQsbiksZS5zZXRVaW50MzIodCs0LGkpfWZ1bmN0aW9uIHkoZSx0KXtyZXR1cm4gNDI5NDk2NzI5NiplLmdldEludDMyKHQpK2UuZ2V0VWludDMyKHQrNCl9dmFyIHc9LTE7ZnVuY3Rpb24gdihlKXt2YXIgdD1lLnNlYyxyPWUubnNlYztpZih0Pj0wJiZyPj0wJiZ0PD0xNzE3OTg2OTE4Myl7aWYoMD09PXImJnQ8PTQyOTQ5NjcyOTUpe3ZhciBuPW5ldyBVaW50OEFycmF5KDQpO3JldHVybihzPW5ldyBEYXRhVmlldyhuLmJ1ZmZlcikpLnNldFVpbnQzMigwLHQpLG59dmFyIGk9dC80Mjk0OTY3Mjk2LG89NDI5NDk2NzI5NSZ0O249bmV3IFVpbnQ4QXJyYXkoOCk7cmV0dXJuKHM9bmV3IERhdGFWaWV3KG4uYnVmZmVyKSkuc2V0VWludDMyKDAscjw8MnwzJmkpLHMuc2V0VWludDMyKDQsbyksbn12YXIgcztuPW5ldyBVaW50OEFycmF5KDEyKTtyZXR1cm4ocz1uZXcgRGF0YVZpZXcobi5idWZmZXIpKS5zZXRVaW50MzIoMCxyKSxkKHMsNCx0KSxufWZ1bmN0aW9uIGcoZSl7dmFyIHQ9ZS5nZXRUaW1lKCkscj1NYXRoLmZsb29yKHQvMWUzKSxuPTFlNioodC0xZTMqciksaT1NYXRoLmZsb29yKG4vMWU5KTtyZXR1cm57c2VjOnIraSxuc2VjOm4tMWU5Kml9fWZ1bmN0aW9uIGIoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBEYXRlP3YoZyhlKSk6bnVsbH1mdW5jdGlvbiB4KGUpe3ZhciB0PW5ldyBEYXRhVmlldyhlLmJ1ZmZlcixlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoKTtzd2l0Y2goZS5ieXRlTGVuZ3RoKXtjYXNlIDQ6cmV0dXJue3NlYzp0LmdldFVpbnQzMigwKSxuc2VjOjB9O2Nhc2UgODp2YXIgcj10LmdldFVpbnQzMigwKTtyZXR1cm57c2VjOjQyOTQ5NjcyOTYqKDMmcikrdC5nZXRVaW50MzIoNCksbnNlYzpyPj4+Mn07Y2FzZSAxMjpyZXR1cm57c2VjOnkodCw0KSxuc2VjOnQuZ2V0VWludDMyKDApfTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBkYXRhIHNpemUgZm9yIHRpbWVzdGFtcDogXCIrZS5sZW5ndGgpfX1mdW5jdGlvbiBVKGUpe3ZhciB0PXgoZSk7cmV0dXJuIG5ldyBEYXRlKDFlMyp0LnNlYyt0Lm5zZWMvMWU2KX12YXIgbT17dHlwZTp3LGVuY29kZTpiLGRlY29kZTpVfSxTPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3RoaXMuYnVpbHRJbkVuY29kZXJzPVtdLHRoaXMuYnVpbHRJbkRlY29kZXJzPVtdLHRoaXMuZW5jb2RlcnM9W10sdGhpcy5kZWNvZGVycz1bXSx0aGlzLnJlZ2lzdGVyKG0pfXJldHVybiBlLnByb3RvdHlwZS5yZWdpc3Rlcj1mdW5jdGlvbihlKXt2YXIgdD1lLnR5cGUscj1lLmVuY29kZSxuPWUuZGVjb2RlO2lmKHQ+PTApdGhpcy5lbmNvZGVyc1t0XT1yLHRoaXMuZGVjb2RlcnNbdF09bjtlbHNle3ZhciBpPTErdDt0aGlzLmJ1aWx0SW5FbmNvZGVyc1tpXT1yLHRoaXMuYnVpbHRJbkRlY29kZXJzW2ldPW59fSxlLnByb3RvdHlwZS50cnlUb0VuY29kZT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgcj0wO3I8dGhpcy5idWlsdEluRW5jb2RlcnMubGVuZ3RoO3IrKyl7aWYobnVsbCE9KG49dGhpcy5idWlsdEluRW5jb2RlcnNbcl0pKWlmKG51bGwhPShpPW4oZSx0KSkpcmV0dXJuIG5ldyBwKC0xLXIsaSl9Zm9yKHI9MDtyPHRoaXMuZW5jb2RlcnMubGVuZ3RoO3IrKyl7dmFyIG4saTtpZihudWxsIT0obj10aGlzLmVuY29kZXJzW3JdKSlpZihudWxsIT0oaT1uKGUsdCkpKXJldHVybiBuZXcgcChyLGkpfXJldHVybiBlIGluc3RhbmNlb2YgcD9lOm51bGx9LGUucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbihlLHQscil7dmFyIG49dDwwP3RoaXMuYnVpbHRJbkRlY29kZXJzWy0xLXRdOnRoaXMuZGVjb2RlcnNbdF07cmV0dXJuIG4/bihlLHQscik6bmV3IHAodCxlKX0sZS5kZWZhdWx0Q29kZWM9bmV3IGUsZX0oKTtmdW5jdGlvbiBFKGUpe3JldHVybiBlIGluc3RhbmNlb2YgVWludDhBcnJheT9lOkFycmF5QnVmZmVyLmlzVmlldyhlKT9uZXcgVWludDhBcnJheShlLmJ1ZmZlcixlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoKTplIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/bmV3IFVpbnQ4QXJyYXkoZSk6VWludDhBcnJheS5mcm9tKGUpfXZhciBCPWZ1bmN0aW9uKGUpe3ZhciB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yLHI9dCYmZVt0XSxuPTA7aWYocilyZXR1cm4gci5jYWxsKGUpO2lmKGUmJlwibnVtYmVyXCI9PXR5cGVvZiBlLmxlbmd0aClyZXR1cm57bmV4dDpmdW5jdGlvbigpe3JldHVybiBlJiZuPj1lLmxlbmd0aCYmKGU9dm9pZCAwKSx7dmFsdWU6ZSYmZVtuKytdLGRvbmU6IWV9fX07dGhyb3cgbmV3IFR5cGVFcnJvcih0P1wiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIjpcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIil9LEw9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxyLG4saSxvLHMpe3ZvaWQgMD09PWUmJihlPVMuZGVmYXVsdENvZGVjKSx2b2lkIDA9PT1yJiYocj0xMDApLHZvaWQgMD09PW4mJihuPTIwNDgpLHZvaWQgMD09PWkmJihpPSExKSx2b2lkIDA9PT1vJiYobz0hMSksdm9pZCAwPT09cyYmKHM9ITEpLHRoaXMuZXh0ZW5zaW9uQ29kZWM9ZSx0aGlzLmNvbnRleHQ9dCx0aGlzLm1heERlcHRoPXIsdGhpcy5pbml0aWFsQnVmZmVyU2l6ZT1uLHRoaXMuc29ydEtleXM9aSx0aGlzLmZvcmNlRmxvYXQzMj1vLHRoaXMuaWdub3JlVW5kZWZpbmVkPXMsdGhpcy5wb3M9MCx0aGlzLnZpZXc9bmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcih0aGlzLmluaXRpYWxCdWZmZXJTaXplKSksdGhpcy5ieXRlcz1uZXcgVWludDhBcnJheSh0aGlzLnZpZXcuYnVmZmVyKX1yZXR1cm4gZS5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7aWYodD50aGlzLm1heERlcHRoKXRocm93IG5ldyBFcnJvcihcIlRvbyBkZWVwIG9iamVjdHMgaW4gZGVwdGggXCIrdCk7bnVsbD09ZT90aGlzLmVuY29kZU5pbCgpOlwiYm9vbGVhblwiPT10eXBlb2YgZT90aGlzLmVuY29kZUJvb2xlYW4oZSk6XCJudW1iZXJcIj09dHlwZW9mIGU/dGhpcy5lbmNvZGVOdW1iZXIoZSk6XCJzdHJpbmdcIj09dHlwZW9mIGU/dGhpcy5lbmNvZGVTdHJpbmcoZSk6dGhpcy5lbmNvZGVPYmplY3QoZSx0KX0sZS5wcm90b3R5cGUuZ2V0VWludDhBcnJheT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ5dGVzLnN1YmFycmF5KDAsdGhpcy5wb3MpfSxlLnByb3RvdHlwZS5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnBvcytlO3RoaXMudmlldy5ieXRlTGVuZ3RoPHQmJnRoaXMucmVzaXplQnVmZmVyKDIqdCl9LGUucHJvdG90eXBlLnJlc2l6ZUJ1ZmZlcj1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXlCdWZmZXIoZSkscj1uZXcgVWludDhBcnJheSh0KSxuPW5ldyBEYXRhVmlldyh0KTtyLnNldCh0aGlzLmJ5dGVzKSx0aGlzLnZpZXc9bix0aGlzLmJ5dGVzPXJ9LGUucHJvdG90eXBlLmVuY29kZU5pbD1mdW5jdGlvbigpe3RoaXMud3JpdGVVOCgxOTIpfSxlLnByb3RvdHlwZS5lbmNvZGVCb29sZWFuPWZ1bmN0aW9uKGUpeyExPT09ZT90aGlzLndyaXRlVTgoMTk0KTp0aGlzLndyaXRlVTgoMTk1KX0sZS5wcm90b3R5cGUuZW5jb2RlTnVtYmVyPWZ1bmN0aW9uKGUpe051bWJlci5pc1NhZmVJbnRlZ2VyKGUpP2U+PTA/ZTwxMjg/dGhpcy53cml0ZVU4KGUpOmU8MjU2Pyh0aGlzLndyaXRlVTgoMjA0KSx0aGlzLndyaXRlVTgoZSkpOmU8NjU1MzY/KHRoaXMud3JpdGVVOCgyMDUpLHRoaXMud3JpdGVVMTYoZSkpOmU8NDI5NDk2NzI5Nj8odGhpcy53cml0ZVU4KDIwNiksdGhpcy53cml0ZVUzMihlKSk6KHRoaXMud3JpdGVVOCgyMDcpLHRoaXMud3JpdGVVNjQoZSkpOmU+PS0zMj90aGlzLndyaXRlVTgoMjI0fGUrMzIpOmU+PS0xMjg/KHRoaXMud3JpdGVVOCgyMDgpLHRoaXMud3JpdGVJOChlKSk6ZT49LTMyNzY4Pyh0aGlzLndyaXRlVTgoMjA5KSx0aGlzLndyaXRlSTE2KGUpKTplPj0tMjE0NzQ4MzY0OD8odGhpcy53cml0ZVU4KDIxMCksdGhpcy53cml0ZUkzMihlKSk6KHRoaXMud3JpdGVVOCgyMTEpLHRoaXMud3JpdGVJNjQoZSkpOnRoaXMuZm9yY2VGbG9hdDMyPyh0aGlzLndyaXRlVTgoMjAyKSx0aGlzLndyaXRlRjMyKGUpKToodGhpcy53cml0ZVU4KDIwMyksdGhpcy53cml0ZUY2NChlKSl9LGUucHJvdG90eXBlLndyaXRlU3RyaW5nSGVhZGVyPWZ1bmN0aW9uKGUpe2lmKGU8MzIpdGhpcy53cml0ZVU4KDE2MCtlKTtlbHNlIGlmKGU8MjU2KXRoaXMud3JpdGVVOCgyMTcpLHRoaXMud3JpdGVVOChlKTtlbHNlIGlmKGU8NjU1MzYpdGhpcy53cml0ZVU4KDIxOCksdGhpcy53cml0ZVUxNihlKTtlbHNle2lmKCEoZTw0Mjk0OTY3Mjk2KSl0aHJvdyBuZXcgRXJyb3IoXCJUb28gbG9uZyBzdHJpbmc6IFwiK2UrXCIgYnl0ZXMgaW4gVVRGLThcIik7dGhpcy53cml0ZVU4KDIxOSksdGhpcy53cml0ZVUzMihlKX19LGUucHJvdG90eXBlLmVuY29kZVN0cmluZz1mdW5jdGlvbihlKXt2YXIgdD1lLmxlbmd0aDtpZihvJiZ0Pmgpe3ZhciByPXMoZSk7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg1K3IpLHRoaXMud3JpdGVTdHJpbmdIZWFkZXIociksdShlLHRoaXMuYnl0ZXMsdGhpcy5wb3MpLHRoaXMucG9zKz1yfWVsc2V7cj1zKGUpO3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoNStyKSx0aGlzLndyaXRlU3RyaW5nSGVhZGVyKHIpLGZ1bmN0aW9uKGUsdCxyKXtmb3IodmFyIG49ZS5sZW5ndGgsaT1yLG89MDtvPG47KXt2YXIgcz1lLmNoYXJDb2RlQXQobysrKTtpZigwIT0oNDI5NDk2NzE2OCZzKSl7aWYoMD09KDQyOTQ5NjUyNDgmcykpdFtpKytdPXM+PjYmMzF8MTkyO2Vsc2V7aWYocz49NTUyOTYmJnM8PTU2MzE5JiZvPG4pe3ZhciBhPWUuY2hhckNvZGVBdChvKTs1NjMyMD09KDY0NTEyJmEpJiYoKytvLHM9KCgxMDIzJnMpPDwxMCkrKDEwMjMmYSkrNjU1MzYpfTA9PSg0Mjk0OTAxNzYwJnMpPyh0W2krK109cz4+MTImMTV8MjI0LHRbaSsrXT1zPj42JjYzfDEyOCk6KHRbaSsrXT1zPj4xOCY3fDI0MCx0W2krK109cz4+MTImNjN8MTI4LHRbaSsrXT1zPj42JjYzfDEyOCl9dFtpKytdPTYzJnN8MTI4fWVsc2UgdFtpKytdPXN9fShlLHRoaXMuYnl0ZXMsdGhpcy5wb3MpLHRoaXMucG9zKz1yfX0sZS5wcm90b3R5cGUuZW5jb2RlT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcy5leHRlbnNpb25Db2RlYy50cnlUb0VuY29kZShlLHRoaXMuY29udGV4dCk7aWYobnVsbCE9cil0aGlzLmVuY29kZUV4dGVuc2lvbihyKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZSkpdGhpcy5lbmNvZGVBcnJheShlLHQpO2Vsc2UgaWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpKXRoaXMuZW5jb2RlQmluYXJ5KGUpO2Vsc2V7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG9iamVjdDogXCIrT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShlKSk7dGhpcy5lbmNvZGVNYXAoZSx0KX19LGUucHJvdG90eXBlLmVuY29kZUJpbmFyeT1mdW5jdGlvbihlKXt2YXIgdD1lLmJ5dGVMZW5ndGg7aWYodDwyNTYpdGhpcy53cml0ZVU4KDE5NiksdGhpcy53cml0ZVU4KHQpO2Vsc2UgaWYodDw2NTUzNil0aGlzLndyaXRlVTgoMTk3KSx0aGlzLndyaXRlVTE2KHQpO2Vsc2V7aWYoISh0PDQyOTQ5NjcyOTYpKXRocm93IG5ldyBFcnJvcihcIlRvbyBsYXJnZSBiaW5hcnk6IFwiK3QpO3RoaXMud3JpdGVVOCgxOTgpLHRoaXMud3JpdGVVMzIodCl9dmFyIHI9RShlKTt0aGlzLndyaXRlVThhKHIpfSxlLnByb3RvdHlwZS5lbmNvZGVBcnJheT1mdW5jdGlvbihlLHQpe3ZhciByLG4saT1lLmxlbmd0aDtpZihpPDE2KXRoaXMud3JpdGVVOCgxNDQraSk7ZWxzZSBpZihpPDY1NTM2KXRoaXMud3JpdGVVOCgyMjApLHRoaXMud3JpdGVVMTYoaSk7ZWxzZXtpZighKGk8NDI5NDk2NzI5NikpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGxhcmdlIGFycmF5OiBcIitpKTt0aGlzLndyaXRlVTgoMjIxKSx0aGlzLndyaXRlVTMyKGkpfXRyeXtmb3IodmFyIG89QihlKSxzPW8ubmV4dCgpOyFzLmRvbmU7cz1vLm5leHQoKSl7dmFyIGE9cy52YWx1ZTt0aGlzLmVuY29kZShhLHQrMSl9fWNhdGNoKGUpe3I9e2Vycm9yOmV9fWZpbmFsbHl7dHJ5e3MmJiFzLmRvbmUmJihuPW8ucmV0dXJuKSYmbi5jYWxsKG8pfWZpbmFsbHl7aWYocil0aHJvdyByLmVycm9yfX19LGUucHJvdG90eXBlLmNvdW50V2l0aG91dFVuZGVmaW5lZD1mdW5jdGlvbihlLHQpe3ZhciByLG4saT0wO3RyeXtmb3IodmFyIG89Qih0KSxzPW8ubmV4dCgpOyFzLmRvbmU7cz1vLm5leHQoKSl7dm9pZCAwIT09ZVtzLnZhbHVlXSYmaSsrfX1jYXRjaChlKXtyPXtlcnJvcjplfX1maW5hbGx5e3RyeXtzJiYhcy5kb25lJiYobj1vLnJldHVybikmJm4uY2FsbChvKX1maW5hbGx5e2lmKHIpdGhyb3cgci5lcnJvcn19cmV0dXJuIGl9LGUucHJvdG90eXBlLmVuY29kZU1hcD1mdW5jdGlvbihlLHQpe3ZhciByLG4saT1PYmplY3Qua2V5cyhlKTt0aGlzLnNvcnRLZXlzJiZpLnNvcnQoKTt2YXIgbz10aGlzLmlnbm9yZVVuZGVmaW5lZD90aGlzLmNvdW50V2l0aG91dFVuZGVmaW5lZChlLGkpOmkubGVuZ3RoO2lmKG88MTYpdGhpcy53cml0ZVU4KDEyOCtvKTtlbHNlIGlmKG88NjU1MzYpdGhpcy53cml0ZVU4KDIyMiksdGhpcy53cml0ZVUxNihvKTtlbHNle2lmKCEobzw0Mjk0OTY3Mjk2KSl0aHJvdyBuZXcgRXJyb3IoXCJUb28gbGFyZ2UgbWFwIG9iamVjdDogXCIrbyk7dGhpcy53cml0ZVU4KDIyMyksdGhpcy53cml0ZVUzMihvKX10cnl7Zm9yKHZhciBzPUIoaSksYT1zLm5leHQoKTshYS5kb25lO2E9cy5uZXh0KCkpe3ZhciBoPWEudmFsdWUsdT1lW2hdO3RoaXMuaWdub3JlVW5kZWZpbmVkJiZ2b2lkIDA9PT11fHwodGhpcy5lbmNvZGVTdHJpbmcoaCksdGhpcy5lbmNvZGUodSx0KzEpKX19Y2F0Y2goZSl7cj17ZXJyb3I6ZX19ZmluYWxseXt0cnl7YSYmIWEuZG9uZSYmKG49cy5yZXR1cm4pJiZuLmNhbGwocyl9ZmluYWxseXtpZihyKXRocm93IHIuZXJyb3J9fX0sZS5wcm90b3R5cGUuZW5jb2RlRXh0ZW5zaW9uPWZ1bmN0aW9uKGUpe3ZhciB0PWUuZGF0YS5sZW5ndGg7aWYoMT09PXQpdGhpcy53cml0ZVU4KDIxMik7ZWxzZSBpZigyPT09dCl0aGlzLndyaXRlVTgoMjEzKTtlbHNlIGlmKDQ9PT10KXRoaXMud3JpdGVVOCgyMTQpO2Vsc2UgaWYoOD09PXQpdGhpcy53cml0ZVU4KDIxNSk7ZWxzZSBpZigxNj09PXQpdGhpcy53cml0ZVU4KDIxNik7ZWxzZSBpZih0PDI1Nil0aGlzLndyaXRlVTgoMTk5KSx0aGlzLndyaXRlVTgodCk7ZWxzZSBpZih0PDY1NTM2KXRoaXMud3JpdGVVOCgyMDApLHRoaXMud3JpdGVVMTYodCk7ZWxzZXtpZighKHQ8NDI5NDk2NzI5NikpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGxhcmdlIGV4dGVuc2lvbiBvYmplY3Q6IFwiK3QpO3RoaXMud3JpdGVVOCgyMDEpLHRoaXMud3JpdGVVMzIodCl9dGhpcy53cml0ZUk4KGUudHlwZSksdGhpcy53cml0ZVU4YShlLmRhdGEpfSxlLnByb3RvdHlwZS53cml0ZVU4PWZ1bmN0aW9uKGUpe3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoMSksdGhpcy52aWV3LnNldFVpbnQ4KHRoaXMucG9zLGUpLHRoaXMucG9zKyt9LGUucHJvdG90eXBlLndyaXRlVThhPWZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoO3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUodCksdGhpcy5ieXRlcy5zZXQoZSx0aGlzLnBvcyksdGhpcy5wb3MrPXR9LGUucHJvdG90eXBlLndyaXRlSTg9ZnVuY3Rpb24oZSl7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSgxKSx0aGlzLnZpZXcuc2V0SW50OCh0aGlzLnBvcyxlKSx0aGlzLnBvcysrfSxlLnByb3RvdHlwZS53cml0ZVUxNj1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDIpLHRoaXMudmlldy5zZXRVaW50MTYodGhpcy5wb3MsZSksdGhpcy5wb3MrPTJ9LGUucHJvdG90eXBlLndyaXRlSTE2PWZ1bmN0aW9uKGUpe3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoMiksdGhpcy52aWV3LnNldEludDE2KHRoaXMucG9zLGUpLHRoaXMucG9zKz0yfSxlLnByb3RvdHlwZS53cml0ZVUzMj1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDQpLHRoaXMudmlldy5zZXRVaW50MzIodGhpcy5wb3MsZSksdGhpcy5wb3MrPTR9LGUucHJvdG90eXBlLndyaXRlSTMyPWZ1bmN0aW9uKGUpe3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoNCksdGhpcy52aWV3LnNldEludDMyKHRoaXMucG9zLGUpLHRoaXMucG9zKz00fSxlLnByb3RvdHlwZS53cml0ZUYzMj1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDQpLHRoaXMudmlldy5zZXRGbG9hdDMyKHRoaXMucG9zLGUpLHRoaXMucG9zKz00fSxlLnByb3RvdHlwZS53cml0ZUY2ND1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDgpLHRoaXMudmlldy5zZXRGbG9hdDY0KHRoaXMucG9zLGUpLHRoaXMucG9zKz04fSxlLnByb3RvdHlwZS53cml0ZVU2ND1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDgpLGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yLzQyOTQ5NjcyOTYsaT1yO2Uuc2V0VWludDMyKHQsbiksZS5zZXRVaW50MzIodCs0LGkpfSh0aGlzLnZpZXcsdGhpcy5wb3MsZSksdGhpcy5wb3MrPTh9LGUucHJvdG90eXBlLndyaXRlSTY0PWZ1bmN0aW9uKGUpe3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoOCksZCh0aGlzLnZpZXcsdGhpcy5wb3MsZSksdGhpcy5wb3MrPTh9LGV9KCksQT17fTtmdW5jdGlvbiBJKGUsdCl7dm9pZCAwPT09dCYmKHQ9QSk7dmFyIHI9bmV3IEwodC5leHRlbnNpb25Db2RlYyx0LmNvbnRleHQsdC5tYXhEZXB0aCx0LmluaXRpYWxCdWZmZXJTaXplLHQuc29ydEtleXMsdC5mb3JjZUZsb2F0MzIsdC5pZ25vcmVVbmRlZmluZWQpO3JldHVybiByLmVuY29kZShlLDEpLHIuZ2V0VWludDhBcnJheSgpfWZ1bmN0aW9uIFQoZSl7cmV0dXJuKGU8MD9cIi1cIjpcIlwiKStcIjB4XCIrTWF0aC5hYnMoZSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsXCIwXCIpfXZhciBrPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3ZvaWQgMD09PWUmJihlPTE2KSx2b2lkIDA9PT10JiYodD0xNiksdGhpcy5tYXhLZXlMZW5ndGg9ZSx0aGlzLm1heExlbmd0aFBlcktleT10LHRoaXMuY2FjaGVzPVtdO2Zvcih2YXIgcj0wO3I8dGhpcy5tYXhLZXlMZW5ndGg7cisrKXRoaXMuY2FjaGVzLnB1c2goW10pfXJldHVybiBlLnByb3RvdHlwZS5jYW5CZUNhY2hlZD1mdW5jdGlvbihlKXtyZXR1cm4gZT4wJiZlPD10aGlzLm1heEtleUxlbmd0aH0sZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzLmNhY2hlc1tyLTFdLGk9bi5sZW5ndGg7ZTpmb3IodmFyIG89MDtvPGk7bysrKXtmb3IodmFyIHM9bltvXSxhPXMuYnl0ZXMsaD0wO2g8cjtoKyspaWYoYVtoXSE9PWVbdCtoXSljb250aW51ZSBlO3JldHVybiBzLnZhbHVlfXJldHVybiBudWxsfSxlLnByb3RvdHlwZS5zdG9yZT1mdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuY2FjaGVzW2UubGVuZ3RoLTFdLG49e2J5dGVzOmUsdmFsdWU6dH07ci5sZW5ndGg+PXRoaXMubWF4TGVuZ3RoUGVyS2V5P3JbTWF0aC5yYW5kb20oKSpyLmxlbmd0aHwwXT1uOnIucHVzaChuKX0sZS5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzLmdldChlLHQscik7aWYobnVsbCE9bilyZXR1cm4gbjt2YXIgaT1jKGUsdCxyKSxvPVVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSx0LHQrcik7cmV0dXJuIHRoaXMuc3RvcmUobyxpKSxpfSxlfSgpLE09ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIG5ldyhyfHwocj1Qcm9taXNlKSkoKGZ1bmN0aW9uKGksbyl7ZnVuY3Rpb24gcyhlKXt0cnl7aChuLm5leHQoZSkpfWNhdGNoKGUpe28oZSl9fWZ1bmN0aW9uIGEoZSl7dHJ5e2gobi50aHJvdyhlKSl9Y2F0Y2goZSl7byhlKX19ZnVuY3Rpb24gaChlKXt2YXIgdDtlLmRvbmU/aShlLnZhbHVlKToodD1lLnZhbHVlLHQgaW5zdGFuY2VvZiByP3Q6bmV3IHIoKGZ1bmN0aW9uKGUpe2UodCl9KSkpLnRoZW4ocyxhKX1oKChuPW4uYXBwbHkoZSx0fHxbXSkpLm5leHQoKSl9KSl9LHo9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksbyxzPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJmlbMF0pdGhyb3cgaVsxXTtyZXR1cm4gaVsxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBvPXtuZXh0OmEoMCksdGhyb3c6YSgxKSxyZXR1cm46YSgyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYob1tTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxvO2Z1bmN0aW9uIGEobyl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihvKXtpZihyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7czspdHJ5e2lmKHI9MSxuJiYoaT0yJm9bMF0/bi5yZXR1cm46b1swXT9uLnRocm93fHwoKGk9bi5yZXR1cm4pJiZpLmNhbGwobiksMCk6bi5uZXh0KSYmIShpPWkuY2FsbChuLG9bMV0pKS5kb25lKXJldHVybiBpO3N3aXRjaChuPTAsaSYmKG89WzImb1swXSxpLnZhbHVlXSksb1swXSl7Y2FzZSAwOmNhc2UgMTppPW87YnJlYWs7Y2FzZSA0OnJldHVybiBzLmxhYmVsKysse3ZhbHVlOm9bMV0sZG9uZTohMX07Y2FzZSA1OnMubGFiZWwrKyxuPW9bMV0sbz1bMF07Y29udGludWU7Y2FzZSA3Om89cy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShpPXMudHJ5cywoaT1pLmxlbmd0aD4wJiZpW2kubGVuZ3RoLTFdKXx8NiE9PW9bMF0mJjIhPT1vWzBdKSl7cz0wO2NvbnRpbnVlfWlmKDM9PT1vWzBdJiYoIWl8fG9bMV0+aVswXSYmb1sxXTxpWzNdKSl7cy5sYWJlbD1vWzFdO2JyZWFrfWlmKDY9PT1vWzBdJiZzLmxhYmVsPGlbMV0pe3MubGFiZWw9aVsxXSxpPW87YnJlYWt9aWYoaSYmcy5sYWJlbDxpWzJdKXtzLmxhYmVsPWlbMl0scy5vcHMucHVzaChvKTticmVha31pWzJdJiZzLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWV9bz10LmNhbGwoZSxzKX1jYXRjaChlKXtvPVs2LGVdLG49MH1maW5hbGx5e3I9aT0wfWlmKDUmb1swXSl0aHJvdyBvWzFdO3JldHVybnt2YWx1ZTpvWzBdP29bMV06dm9pZCAwLGRvbmU6ITB9fShbbyxhXSl9fX0sQz1mdW5jdGlvbihlKXtpZighU3ltYm9sLmFzeW5jSXRlcmF0b3IpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTt2YXIgdCxyPWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdO3JldHVybiByP3IuY2FsbChlKTooZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBfX3ZhbHVlcz9fX3ZhbHVlcyhlKTplW1N5bWJvbC5pdGVyYXRvcl0oKSx0PXt9LG4oXCJuZXh0XCIpLG4oXCJ0aHJvd1wiKSxuKFwicmV0dXJuXCIpLHRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LHQpO2Z1bmN0aW9uIG4ocil7dFtyXT1lW3JdJiZmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG4saSl7KGZ1bmN0aW9uKGUsdCxyLG4pe1Byb21pc2UucmVzb2x2ZShuKS50aGVuKChmdW5jdGlvbih0KXtlKHt2YWx1ZTp0LGRvbmU6cn0pfSksdCl9KShuLGksKHQ9ZVtyXSh0KSkuZG9uZSx0LnZhbHVlKX0pKX19fSxEPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzIGluc3RhbmNlb2YgRD8odGhpcy52PWUsdGhpcyk6bmV3IEQoZSl9LFA9ZnVuY3Rpb24oZSx0LHIpe2lmKCFTeW1ib2wuYXN5bmNJdGVyYXRvcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO3ZhciBuLGk9ci5hcHBseShlLHR8fFtdKSxvPVtdO3JldHVybiBuPXt9LHMoXCJuZXh0XCIpLHMoXCJ0aHJvd1wiKSxzKFwicmV0dXJuXCIpLG5bU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LG47ZnVuY3Rpb24gcyhlKXtpW2VdJiYobltlXT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHIsbil7by5wdXNoKFtlLHQscixuXSk+MXx8YShlLHQpfSkpfSl9ZnVuY3Rpb24gYShlLHQpe3RyeXsocj1pW2VdKHQpKS52YWx1ZSBpbnN0YW5jZW9mIEQ/UHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihoLHUpOmMob1swXVsyXSxyKX1jYXRjaChlKXtjKG9bMF1bM10sZSl9dmFyIHJ9ZnVuY3Rpb24gaChlKXthKFwibmV4dFwiLGUpfWZ1bmN0aW9uIHUoZSl7YShcInRocm93XCIsZSl9ZnVuY3Rpb24gYyhlLHQpe2UodCksby5zaGlmdCgpLG8ubGVuZ3RoJiZhKG9bMF1bMF0sb1swXVsxXSl9fSxqPW5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpLEY9bmV3IFVpbnQ4QXJyYXkoai5idWZmZXIpLFc9ZnVuY3Rpb24oKXt0cnl7ai5nZXRJbnQ4KDApfWNhdGNoKGUpe3JldHVybiBlLmNvbnN0cnVjdG9yfXRocm93IG5ldyBFcnJvcihcIm5ldmVyIHJlYWNoZWRcIil9KCksTz1uZXcgVyhcIkluc3VmZmljaWVudCBkYXRhXCIpLEs9bmV3IGssVj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LHIsbixpLG8scyxhKXt2b2lkIDA9PT1lJiYoZT1TLmRlZmF1bHRDb2RlYyksdm9pZCAwPT09ciYmKHI9NDI5NDk2NzI5NSksdm9pZCAwPT09biYmKG49NDI5NDk2NzI5NSksdm9pZCAwPT09aSYmKGk9NDI5NDk2NzI5NSksdm9pZCAwPT09byYmKG89NDI5NDk2NzI5NSksdm9pZCAwPT09cyYmKHM9NDI5NDk2NzI5NSksdm9pZCAwPT09YSYmKGE9SyksdGhpcy5leHRlbnNpb25Db2RlYz1lLHRoaXMuY29udGV4dD10LHRoaXMubWF4U3RyTGVuZ3RoPXIsdGhpcy5tYXhCaW5MZW5ndGg9bix0aGlzLm1heEFycmF5TGVuZ3RoPWksdGhpcy5tYXhNYXBMZW5ndGg9byx0aGlzLm1heEV4dExlbmd0aD1zLHRoaXMuY2FjaGVkS2V5RGVjb2Rlcj1hLHRoaXMudG90YWxQb3M9MCx0aGlzLnBvcz0wLHRoaXMudmlldz1qLHRoaXMuYnl0ZXM9Rix0aGlzLmhlYWRCeXRlPS0xLHRoaXMuc3RhY2s9W119cmV0dXJuIGUucHJvdG90eXBlLnNldEJ1ZmZlcj1mdW5jdGlvbihlKXt0aGlzLmJ5dGVzPUUoZSksdGhpcy52aWV3PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilyZXR1cm4gbmV3IERhdGFWaWV3KGUpO3ZhciB0PUUoZSk7cmV0dXJuIG5ldyBEYXRhVmlldyh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKX0odGhpcy5ieXRlcyksdGhpcy5wb3M9MH0sZS5wcm90b3R5cGUuYXBwZW5kQnVmZmVyPWZ1bmN0aW9uKGUpe2lmKC0xIT09dGhpcy5oZWFkQnl0ZXx8dGhpcy5oYXNSZW1haW5pbmcoKSl7dmFyIHQ9dGhpcy5ieXRlcy5zdWJhcnJheSh0aGlzLnBvcykscj1FKGUpLG49bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgrci5sZW5ndGgpO24uc2V0KHQpLG4uc2V0KHIsdC5sZW5ndGgpLHRoaXMuc2V0QnVmZmVyKG4pfWVsc2UgdGhpcy5zZXRCdWZmZXIoZSl9LGUucHJvdG90eXBlLmhhc1JlbWFpbmluZz1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MSksdGhpcy52aWV3LmJ5dGVMZW5ndGgtdGhpcy5wb3M+PWV9LGUucHJvdG90eXBlLmNyZWF0ZU5vRXh0cmFCeXRlc0Vycm9yPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMudmlldyxyPXRoaXMucG9zO3JldHVybiBuZXcgUmFuZ2VFcnJvcihcIkV4dHJhIFwiKyh0LmJ5dGVMZW5ndGgtcikrXCIgYnl0ZShzKSBmb3VuZCBhdCBidWZmZXJbXCIrZStcIl1cIil9LGUucHJvdG90eXBlLmRlY29kZVNpbmdsZVN5bmM9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmRlY29kZVN5bmMoKTtpZih0aGlzLmhhc1JlbWFpbmluZygpKXRocm93IHRoaXMuY3JlYXRlTm9FeHRyYUJ5dGVzRXJyb3IodGhpcy5wb3MpO3JldHVybiBlfSxlLnByb3RvdHlwZS5kZWNvZGVTaW5nbGVBc3luYz1mdW5jdGlvbihlKXt2YXIgdCxyLG4saTtyZXR1cm4gTSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG8scyxhLGgsdSxjLGYsbDtyZXR1cm4geih0aGlzLChmdW5jdGlvbihwKXtzd2l0Y2gocC5sYWJlbCl7Y2FzZSAwOm89ITEscC5sYWJlbD0xO2Nhc2UgMTpwLnRyeXMucHVzaChbMSw2LDcsMTJdKSx0PUMoZSkscC5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bNCx0Lm5leHQoKV07Y2FzZSAzOmlmKChyPXAuc2VudCgpKS5kb25lKXJldHVyblszLDVdO2lmKGE9ci52YWx1ZSxvKXRocm93IHRoaXMuY3JlYXRlTm9FeHRyYUJ5dGVzRXJyb3IodGhpcy50b3RhbFBvcyk7dGhpcy5hcHBlbmRCdWZmZXIoYSk7dHJ5e3M9dGhpcy5kZWNvZGVTeW5jKCksbz0hMH1jYXRjaChlKXtpZighKGUgaW5zdGFuY2VvZiBXKSl0aHJvdyBlfXRoaXMudG90YWxQb3MrPXRoaXMucG9zLHAubGFiZWw9NDtjYXNlIDQ6cmV0dXJuWzMsMl07Y2FzZSA1OnJldHVyblszLDEyXTtjYXNlIDY6cmV0dXJuIGg9cC5zZW50KCksbj17ZXJyb3I6aH0sWzMsMTJdO2Nhc2UgNzpyZXR1cm4gcC50cnlzLnB1c2goWzcsLDEwLDExXSksciYmIXIuZG9uZSYmKGk9dC5yZXR1cm4pP1s0LGkuY2FsbCh0KV06WzMsOV07Y2FzZSA4OnAuc2VudCgpLHAubGFiZWw9OTtjYXNlIDk6cmV0dXJuWzMsMTFdO2Nhc2UgMTA6aWYobil0aHJvdyBuLmVycm9yO3JldHVybls3XTtjYXNlIDExOnJldHVybls3XTtjYXNlIDEyOmlmKG8pe2lmKHRoaXMuaGFzUmVtYWluaW5nKCkpdGhyb3cgdGhpcy5jcmVhdGVOb0V4dHJhQnl0ZXNFcnJvcih0aGlzLnRvdGFsUG9zKTtyZXR1cm5bMixzXX10aHJvdyBjPSh1PXRoaXMpLmhlYWRCeXRlLGY9dS5wb3MsbD11LnRvdGFsUG9zLG5ldyBSYW5nZUVycm9yKFwiSW5zdWZmaWNpZW50IGRhdGEgaW4gcGFyY2luZyBcIitUKGMpK1wiIGF0IFwiK2wrXCIgKFwiK2YrXCIgaW4gdGhlIGN1cnJlbnQgYnVmZmVyKVwiKX19KSl9KSl9LGUucHJvdG90eXBlLmRlY29kZUFycmF5U3RyZWFtPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmRlY29kZU11bHRpQXN5bmMoZSwhMCl9LGUucHJvdG90eXBlLmRlY29kZVN0cmVhbT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5kZWNvZGVNdWx0aUFzeW5jKGUsITEpfSxlLnByb3RvdHlwZS5kZWNvZGVNdWx0aUFzeW5jPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIFAodGhpcyxhcmd1bWVudHMsKGZ1bmN0aW9uKCl7dmFyIHIsbixpLG8scyxhLGgsdSxjO3JldHVybiB6KHRoaXMsKGZ1bmN0aW9uKGYpe3N3aXRjaChmLmxhYmVsKXtjYXNlIDA6cj10LG49LTEsZi5sYWJlbD0xO2Nhc2UgMTpmLnRyeXMucHVzaChbMSwxMywxNCwxOV0pLGk9QyhlKSxmLmxhYmVsPTI7Y2FzZSAyOnJldHVybls0LEQoaS5uZXh0KCkpXTtjYXNlIDM6aWYoKG89Zi5zZW50KCkpLmRvbmUpcmV0dXJuWzMsMTJdO2lmKHM9by52YWx1ZSx0JiYwPT09bil0aHJvdyB0aGlzLmNyZWF0ZU5vRXh0cmFCeXRlc0Vycm9yKHRoaXMudG90YWxQb3MpO3RoaXMuYXBwZW5kQnVmZmVyKHMpLHImJihuPXRoaXMucmVhZEFycmF5U2l6ZSgpLHI9ITEsdGhpcy5jb21wbGV0ZSgpKSxmLmxhYmVsPTQ7Y2FzZSA0OmYudHJ5cy5wdXNoKFs0LDksLDEwXSksZi5sYWJlbD01O2Nhc2UgNTpyZXR1cm5bNCxEKHRoaXMuZGVjb2RlU3luYygpKV07Y2FzZSA2OnJldHVybls0LGYuc2VudCgpXTtjYXNlIDc6cmV0dXJuIGYuc2VudCgpLDA9PS0tbj9bMyw4XTpbMyw1XTtjYXNlIDg6cmV0dXJuWzMsMTBdO2Nhc2UgOTppZighKChhPWYuc2VudCgpKWluc3RhbmNlb2YgVykpdGhyb3cgYTtyZXR1cm5bMywxMF07Y2FzZSAxMDp0aGlzLnRvdGFsUG9zKz10aGlzLnBvcyxmLmxhYmVsPTExO2Nhc2UgMTE6cmV0dXJuWzMsMl07Y2FzZSAxMjpyZXR1cm5bMywxOV07Y2FzZSAxMzpyZXR1cm4gaD1mLnNlbnQoKSx1PXtlcnJvcjpofSxbMywxOV07Y2FzZSAxNDpyZXR1cm4gZi50cnlzLnB1c2goWzE0LCwxNywxOF0pLG8mJiFvLmRvbmUmJihjPWkucmV0dXJuKT9bNCxEKGMuY2FsbChpKSldOlszLDE2XTtjYXNlIDE1OmYuc2VudCgpLGYubGFiZWw9MTY7Y2FzZSAxNjpyZXR1cm5bMywxOF07Y2FzZSAxNzppZih1KXRocm93IHUuZXJyb3I7cmV0dXJuWzddO2Nhc2UgMTg6cmV0dXJuWzddO2Nhc2UgMTk6cmV0dXJuWzJdfX0pKX0pKX0sZS5wcm90b3R5cGUuZGVjb2RlU3luYz1mdW5jdGlvbigpe2U6Zm9yKDs7KXt2YXIgZT10aGlzLnJlYWRIZWFkQnl0ZSgpLHQ9dm9pZCAwO2lmKGU+PTIyNCl0PWUtMjU2O2Vsc2UgaWYoZTwxOTIpaWYoZTwxMjgpdD1lO2Vsc2UgaWYoZTwxNDQpe2lmKDAhPT0obj1lLTEyOCkpe3RoaXMucHVzaE1hcFN0YXRlKG4pLHRoaXMuY29tcGxldGUoKTtjb250aW51ZSBlfXQ9e319ZWxzZSBpZihlPDE2MCl7aWYoMCE9PShuPWUtMTQ0KSl7dGhpcy5wdXNoQXJyYXlTdGF0ZShuKSx0aGlzLmNvbXBsZXRlKCk7Y29udGludWUgZX10PVtdfWVsc2V7dmFyIHI9ZS0xNjA7dD10aGlzLmRlY29kZVV0ZjhTdHJpbmcociwwKX1lbHNlIGlmKDE5Mj09PWUpdD1udWxsO2Vsc2UgaWYoMTk0PT09ZSl0PSExO2Vsc2UgaWYoMTk1PT09ZSl0PSEwO2Vsc2UgaWYoMjAyPT09ZSl0PXRoaXMucmVhZEYzMigpO2Vsc2UgaWYoMjAzPT09ZSl0PXRoaXMucmVhZEY2NCgpO2Vsc2UgaWYoMjA0PT09ZSl0PXRoaXMucmVhZFU4KCk7ZWxzZSBpZigyMDU9PT1lKXQ9dGhpcy5yZWFkVTE2KCk7ZWxzZSBpZigyMDY9PT1lKXQ9dGhpcy5yZWFkVTMyKCk7ZWxzZSBpZigyMDc9PT1lKXQ9dGhpcy5yZWFkVTY0KCk7ZWxzZSBpZigyMDg9PT1lKXQ9dGhpcy5yZWFkSTgoKTtlbHNlIGlmKDIwOT09PWUpdD10aGlzLnJlYWRJMTYoKTtlbHNlIGlmKDIxMD09PWUpdD10aGlzLnJlYWRJMzIoKTtlbHNlIGlmKDIxMT09PWUpdD10aGlzLnJlYWRJNjQoKTtlbHNlIGlmKDIxNz09PWUpe3I9dGhpcy5sb29rVTgoKTt0PXRoaXMuZGVjb2RlVXRmOFN0cmluZyhyLDEpfWVsc2UgaWYoMjE4PT09ZSl7cj10aGlzLmxvb2tVMTYoKTt0PXRoaXMuZGVjb2RlVXRmOFN0cmluZyhyLDIpfWVsc2UgaWYoMjE5PT09ZSl7cj10aGlzLmxvb2tVMzIoKTt0PXRoaXMuZGVjb2RlVXRmOFN0cmluZyhyLDQpfWVsc2UgaWYoMjIwPT09ZSl7aWYoMCE9PShuPXRoaXMucmVhZFUxNigpKSl7dGhpcy5wdXNoQXJyYXlTdGF0ZShuKSx0aGlzLmNvbXBsZXRlKCk7Y29udGludWUgZX10PVtdfWVsc2UgaWYoMjIxPT09ZSl7aWYoMCE9PShuPXRoaXMucmVhZFUzMigpKSl7dGhpcy5wdXNoQXJyYXlTdGF0ZShuKSx0aGlzLmNvbXBsZXRlKCk7Y29udGludWUgZX10PVtdfWVsc2UgaWYoMjIyPT09ZSl7aWYoMCE9PShuPXRoaXMucmVhZFUxNigpKSl7dGhpcy5wdXNoTWFwU3RhdGUobiksdGhpcy5jb21wbGV0ZSgpO2NvbnRpbnVlIGV9dD17fX1lbHNlIGlmKDIyMz09PWUpe2lmKDAhPT0obj10aGlzLnJlYWRVMzIoKSkpe3RoaXMucHVzaE1hcFN0YXRlKG4pLHRoaXMuY29tcGxldGUoKTtjb250aW51ZSBlfXQ9e319ZWxzZSBpZigxOTY9PT1lKXt2YXIgbj10aGlzLmxvb2tVOCgpO3Q9dGhpcy5kZWNvZGVCaW5hcnkobiwxKX1lbHNlIGlmKDE5Nz09PWUpe249dGhpcy5sb29rVTE2KCk7dD10aGlzLmRlY29kZUJpbmFyeShuLDIpfWVsc2UgaWYoMTk4PT09ZSl7bj10aGlzLmxvb2tVMzIoKTt0PXRoaXMuZGVjb2RlQmluYXJ5KG4sNCl9ZWxzZSBpZigyMTI9PT1lKXQ9dGhpcy5kZWNvZGVFeHRlbnNpb24oMSwwKTtlbHNlIGlmKDIxMz09PWUpdD10aGlzLmRlY29kZUV4dGVuc2lvbigyLDApO2Vsc2UgaWYoMjE0PT09ZSl0PXRoaXMuZGVjb2RlRXh0ZW5zaW9uKDQsMCk7ZWxzZSBpZigyMTU9PT1lKXQ9dGhpcy5kZWNvZGVFeHRlbnNpb24oOCwwKTtlbHNlIGlmKDIxNj09PWUpdD10aGlzLmRlY29kZUV4dGVuc2lvbigxNiwwKTtlbHNlIGlmKDE5OT09PWUpe249dGhpcy5sb29rVTgoKTt0PXRoaXMuZGVjb2RlRXh0ZW5zaW9uKG4sMSl9ZWxzZSBpZigyMDA9PT1lKXtuPXRoaXMubG9va1UxNigpO3Q9dGhpcy5kZWNvZGVFeHRlbnNpb24obiwyKX1lbHNle2lmKDIwMSE9PWUpdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIHR5cGUgYnl0ZTogXCIrVChlKSk7bj10aGlzLmxvb2tVMzIoKTt0PXRoaXMuZGVjb2RlRXh0ZW5zaW9uKG4sNCl9dGhpcy5jb21wbGV0ZSgpO2Zvcih2YXIgaT10aGlzLnN0YWNrO2kubGVuZ3RoPjA7KXt2YXIgbz1pW2kubGVuZ3RoLTFdO2lmKDA9PT1vLnR5cGUpe2lmKG8uYXJyYXlbby5wb3NpdGlvbl09dCxvLnBvc2l0aW9uKyssby5wb3NpdGlvbiE9PW8uc2l6ZSljb250aW51ZSBlO2kucG9wKCksdD1vLmFycmF5fWVsc2V7aWYoMT09PW8udHlwZSl7aWYocz12b2lkIDAsXCJzdHJpbmdcIiE9PShzPXR5cGVvZiB0KSYmXCJudW1iZXJcIiE9PXMpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHR5cGUgb2Yga2V5IG11c3QgYmUgc3RyaW5nIG9yIG51bWJlciBidXQgXCIrdHlwZW9mIHQpO28ua2V5PXQsby50eXBlPTI7Y29udGludWUgZX1pZihvLm1hcFtvLmtleV09dCxvLnJlYWRDb3VudCsrLG8ucmVhZENvdW50IT09by5zaXplKXtvLmtleT1udWxsLG8udHlwZT0xO2NvbnRpbnVlIGV9aS5wb3AoKSx0PW8ubWFwfX1yZXR1cm4gdH12YXIgc30sZS5wcm90b3R5cGUucmVhZEhlYWRCeXRlPWZ1bmN0aW9uKCl7cmV0dXJuLTE9PT10aGlzLmhlYWRCeXRlJiYodGhpcy5oZWFkQnl0ZT10aGlzLnJlYWRVOCgpKSx0aGlzLmhlYWRCeXRlfSxlLnByb3RvdHlwZS5jb21wbGV0ZT1mdW5jdGlvbigpe3RoaXMuaGVhZEJ5dGU9LTF9LGUucHJvdG90eXBlLnJlYWRBcnJheVNpemU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnJlYWRIZWFkQnl0ZSgpO3N3aXRjaChlKXtjYXNlIDIyMDpyZXR1cm4gdGhpcy5yZWFkVTE2KCk7Y2FzZSAyMjE6cmV0dXJuIHRoaXMucmVhZFUzMigpO2RlZmF1bHQ6aWYoZTwxNjApcmV0dXJuIGUtMTQ0O3Rocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBhcnJheSB0eXBlIGJ5dGU6IFwiK1QoZSkpfX0sZS5wcm90b3R5cGUucHVzaE1hcFN0YXRlPWZ1bmN0aW9uKGUpe2lmKGU+dGhpcy5tYXhNYXBMZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTWF4IGxlbmd0aCBleGNlZWRlZDogbWFwIGxlbmd0aCAoXCIrZStcIikgPiBtYXhNYXBMZW5ndGhMZW5ndGggKFwiK3RoaXMubWF4TWFwTGVuZ3RoK1wiKVwiKTt0aGlzLnN0YWNrLnB1c2goe3R5cGU6MSxzaXplOmUsa2V5Om51bGwscmVhZENvdW50OjAsbWFwOnt9fSl9LGUucHJvdG90eXBlLnB1c2hBcnJheVN0YXRlPWZ1bmN0aW9uKGUpe2lmKGU+dGhpcy5tYXhBcnJheUxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJNYXggbGVuZ3RoIGV4Y2VlZGVkOiBhcnJheSBsZW5ndGggKFwiK2UrXCIpID4gbWF4QXJyYXlMZW5ndGggKFwiK3RoaXMubWF4QXJyYXlMZW5ndGgrXCIpXCIpO3RoaXMuc3RhY2sucHVzaCh7dHlwZTowLHNpemU6ZSxhcnJheTpuZXcgQXJyYXkoZSkscG9zaXRpb246MH0pfSxlLnByb3RvdHlwZS5kZWNvZGVVdGY4U3RyaW5nPWZ1bmN0aW9uKGUsdCl7dmFyIHI7aWYoZT50aGlzLm1heFN0ckxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJNYXggbGVuZ3RoIGV4Y2VlZGVkOiBVVEYtOCBieXRlIGxlbmd0aCAoXCIrZStcIikgPiBtYXhTdHJMZW5ndGggKFwiK3RoaXMubWF4U3RyTGVuZ3RoK1wiKVwiKTtpZih0aGlzLmJ5dGVzLmJ5dGVMZW5ndGg8dGhpcy5wb3MrdCtlKXRocm93IE87dmFyIG4saT10aGlzLnBvcyt0O3JldHVybiBuPXRoaXMuc3RhdGVJc01hcEtleSgpJiYobnVsbD09PShyPXRoaXMuY2FjaGVkS2V5RGVjb2Rlcil8fHZvaWQgMD09PXI/dm9pZCAwOnIuY2FuQmVDYWNoZWQoZSkpP3RoaXMuY2FjaGVkS2V5RGVjb2Rlci5kZWNvZGUodGhpcy5ieXRlcyxpLGUpOm8mJmU+bD9mdW5jdGlvbihlLHQscil7dmFyIG49ZS5zdWJhcnJheSh0LHQrcik7cmV0dXJuIGYuZGVjb2RlKG4pfSh0aGlzLmJ5dGVzLGksZSk6Yyh0aGlzLmJ5dGVzLGksZSksdGhpcy5wb3MrPXQrZSxufSxlLnByb3RvdHlwZS5zdGF0ZUlzTWFwS2V5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhY2subGVuZ3RoPjAmJjE9PT10aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdLnR5cGV9LGUucHJvdG90eXBlLmRlY29kZUJpbmFyeT1mdW5jdGlvbihlLHQpe2lmKGU+dGhpcy5tYXhCaW5MZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTWF4IGxlbmd0aCBleGNlZWRlZDogYmluIGxlbmd0aCAoXCIrZStcIikgPiBtYXhCaW5MZW5ndGggKFwiK3RoaXMubWF4QmluTGVuZ3RoK1wiKVwiKTtpZighdGhpcy5oYXNSZW1haW5pbmcoZSt0KSl0aHJvdyBPO3ZhciByPXRoaXMucG9zK3Qsbj10aGlzLmJ5dGVzLnN1YmFycmF5KHIscitlKTtyZXR1cm4gdGhpcy5wb3MrPXQrZSxufSxlLnByb3RvdHlwZS5kZWNvZGVFeHRlbnNpb249ZnVuY3Rpb24oZSx0KXtpZihlPnRoaXMubWF4RXh0TGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1heCBsZW5ndGggZXhjZWVkZWQ6IGV4dCBsZW5ndGggKFwiK2UrXCIpID4gbWF4RXh0TGVuZ3RoIChcIit0aGlzLm1heEV4dExlbmd0aCtcIilcIik7dmFyIHI9dGhpcy52aWV3LmdldEludDgodGhpcy5wb3MrdCksbj10aGlzLmRlY29kZUJpbmFyeShlLHQrMSk7cmV0dXJuIHRoaXMuZXh0ZW5zaW9uQ29kZWMuZGVjb2RlKG4scix0aGlzLmNvbnRleHQpfSxlLnByb3RvdHlwZS5sb29rVTg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zKX0sZS5wcm90b3R5cGUubG9va1UxNj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMucG9zKX0sZS5wcm90b3R5cGUubG9va1UzMj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMucG9zKX0sZS5wcm90b3R5cGUucmVhZFU4PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrKyxlfSxlLnByb3RvdHlwZS5yZWFkSTg9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnZpZXcuZ2V0SW50OCh0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKyssZX0sZS5wcm90b3R5cGUucmVhZFUxNj1mdW5jdGlvbigpe3ZhciBlPXRoaXMudmlldy5nZXRVaW50MTYodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9MixlfSxlLnByb3RvdHlwZS5yZWFkSTE2PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldEludDE2KHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrPTIsZX0sZS5wcm90b3R5cGUucmVhZFUzMj1mdW5jdGlvbigpe3ZhciBlPXRoaXMudmlldy5nZXRVaW50MzIodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCxlfSxlLnByb3RvdHlwZS5yZWFkSTMyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldEludDMyKHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrPTQsZX0sZS5wcm90b3R5cGUucmVhZFU2ND1mdW5jdGlvbigpe3ZhciBlLHQscj0oZT10aGlzLnZpZXcsdD10aGlzLnBvcyw0Mjk0OTY3Mjk2KmUuZ2V0VWludDMyKHQpK2UuZ2V0VWludDMyKHQrNCkpO3JldHVybiB0aGlzLnBvcys9OCxyfSxlLnByb3RvdHlwZS5yZWFkSTY0PWZ1bmN0aW9uKCl7dmFyIGU9eSh0aGlzLnZpZXcsdGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9OCxlfSxlLnByb3RvdHlwZS5yZWFkRjMyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldEZsb2F0MzIodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCxlfSxlLnByb3RvdHlwZS5yZWFkRjY0PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldEZsb2F0NjQodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9OCxlfSxlfSgpLF89e307ZnVuY3Rpb24gTihlLHQpe3ZvaWQgMD09PXQmJih0PV8pO3ZhciByPW5ldyBWKHQuZXh0ZW5zaW9uQ29kZWMsdC5jb250ZXh0LHQubWF4U3RyTGVuZ3RoLHQubWF4QmluTGVuZ3RoLHQubWF4QXJyYXlMZW5ndGgsdC5tYXhNYXBMZW5ndGgsdC5tYXhFeHRMZW5ndGgpO3JldHVybiByLnNldEJ1ZmZlcihlKSxyLmRlY29kZVNpbmdsZVN5bmMoKX12YXIgUj1mdW5jdGlvbihlLHQpe3ZhciByLG4saSxvLHM9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmaVswXSl0aHJvdyBpWzFdO3JldHVybiBpWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIG89e25leHQ6YSgwKSx0aHJvdzphKDEpLHJldHVybjphKDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihvW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLG87ZnVuY3Rpb24gYShvKXtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKG8pe2lmKHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDtzOyl0cnl7aWYocj0xLG4mJihpPTImb1swXT9uLnJldHVybjpvWzBdP24udGhyb3d8fCgoaT1uLnJldHVybikmJmkuY2FsbChuKSwwKTpuLm5leHQpJiYhKGk9aS5jYWxsKG4sb1sxXSkpLmRvbmUpcmV0dXJuIGk7c3dpdGNoKG49MCxpJiYobz1bMiZvWzBdLGkudmFsdWVdKSxvWzBdKXtjYXNlIDA6Y2FzZSAxOmk9bzticmVhaztjYXNlIDQ6cmV0dXJuIHMubGFiZWwrKyx7dmFsdWU6b1sxXSxkb25lOiExfTtjYXNlIDU6cy5sYWJlbCsrLG49b1sxXSxvPVswXTtjb250aW51ZTtjYXNlIDc6bz1zLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKGk9cy50cnlzLChpPWkubGVuZ3RoPjAmJmlbaS5sZW5ndGgtMV0pfHw2IT09b1swXSYmMiE9PW9bMF0pKXtzPTA7Y29udGludWV9aWYoMz09PW9bMF0mJighaXx8b1sxXT5pWzBdJiZvWzFdPGlbM10pKXtzLmxhYmVsPW9bMV07YnJlYWt9aWYoNj09PW9bMF0mJnMubGFiZWw8aVsxXSl7cy5sYWJlbD1pWzFdLGk9bzticmVha31pZihpJiZzLmxhYmVsPGlbMl0pe3MubGFiZWw9aVsyXSxzLm9wcy5wdXNoKG8pO2JyZWFrfWlbMl0mJnMub3BzLnBvcCgpLHMudHJ5cy5wb3AoKTtjb250aW51ZX1vPXQuY2FsbChlLHMpfWNhdGNoKGUpe289WzYsZV0sbj0wfWZpbmFsbHl7cj1pPTB9aWYoNSZvWzBdKXRocm93IG9bMV07cmV0dXJue3ZhbHVlOm9bMF0/b1sxXTp2b2lkIDAsZG9uZTohMH19KFtvLGFdKX19fSxIPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzIGluc3RhbmNlb2YgSD8odGhpcy52PWUsdGhpcyk6bmV3IEgoZSl9LEc9ZnVuY3Rpb24oZSx0LHIpe2lmKCFTeW1ib2wuYXN5bmNJdGVyYXRvcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO3ZhciBuLGk9ci5hcHBseShlLHR8fFtdKSxvPVtdO3JldHVybiBuPXt9LHMoXCJuZXh0XCIpLHMoXCJ0aHJvd1wiKSxzKFwicmV0dXJuXCIpLG5bU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LG47ZnVuY3Rpb24gcyhlKXtpW2VdJiYobltlXT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHIsbil7by5wdXNoKFtlLHQscixuXSk+MXx8YShlLHQpfSkpfSl9ZnVuY3Rpb24gYShlLHQpe3RyeXsocj1pW2VdKHQpKS52YWx1ZSBpbnN0YW5jZW9mIEg/UHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihoLHUpOmMob1swXVsyXSxyKX1jYXRjaChlKXtjKG9bMF1bM10sZSl9dmFyIHJ9ZnVuY3Rpb24gaChlKXthKFwibmV4dFwiLGUpfWZ1bmN0aW9uIHUoZSl7YShcInRocm93XCIsZSl9ZnVuY3Rpb24gYyhlLHQpe2UodCksby5zaGlmdCgpLG8ubGVuZ3RoJiZhKG9bMF1bMF0sb1swXVsxXSl9fTtmdW5jdGlvbiBYKGUpe2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIEZhaWx1cmU6IHZhbHVlIG11c3Qgbm90IGJlIG51bGwgbm9yIHVuZGVmaW5lZFwiKX1mdW5jdGlvbiBxKGUpe3JldHVybiBudWxsIT1lW1N5bWJvbC5hc3luY0l0ZXJhdG9yXT9lOmZ1bmN0aW9uKGUpe3JldHVybiBHKHRoaXMsYXJndW1lbnRzLChmdW5jdGlvbigpe3ZhciB0LHIsbixpO3JldHVybiBSKHRoaXMsKGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6dD1lLmdldFJlYWRlcigpLG8ubGFiZWw9MTtjYXNlIDE6by50cnlzLnB1c2goWzEsLDksMTBdKSxvLmxhYmVsPTI7Y2FzZSAyOnJldHVybls0LEgodC5yZWFkKCkpXTtjYXNlIDM6cmV0dXJuIHI9by5zZW50KCksbj1yLmRvbmUsaT1yLnZhbHVlLG4/WzQsSCh2b2lkIDApXTpbMyw1XTtjYXNlIDQ6cmV0dXJuWzIsby5zZW50KCldO2Nhc2UgNTpyZXR1cm4gWChpKSxbNCxIKGkpXTtjYXNlIDY6cmV0dXJuWzQsby5zZW50KCldO2Nhc2UgNzpyZXR1cm4gby5zZW50KCksWzMsMl07Y2FzZSA4OnJldHVyblszLDEwXTtjYXNlIDk6cmV0dXJuIHQucmVsZWFzZUxvY2soKSxbN107Y2FzZSAxMDpyZXR1cm5bMl19fSkpfSkpfShlKX12YXIgSj1mdW5jdGlvbihlLHQscixuKXtyZXR1cm4gbmV3KHJ8fChyPVByb21pc2UpKSgoZnVuY3Rpb24oaSxvKXtmdW5jdGlvbiBzKGUpe3RyeXtoKG4ubmV4dChlKSl9Y2F0Y2goZSl7byhlKX19ZnVuY3Rpb24gYShlKXt0cnl7aChuLnRocm93KGUpKX1jYXRjaChlKXtvKGUpfX1mdW5jdGlvbiBoKGUpe3ZhciB0O2UuZG9uZT9pKGUudmFsdWUpOih0PWUudmFsdWUsdCBpbnN0YW5jZW9mIHI/dDpuZXcgcigoZnVuY3Rpb24oZSl7ZSh0KX0pKSkudGhlbihzLGEpfWgoKG49bi5hcHBseShlLHR8fFtdKSkubmV4dCgpKX0pKX0sUT1mdW5jdGlvbihlLHQpe3ZhciByLG4saSxvLHM9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmaVswXSl0aHJvdyBpWzFdO3JldHVybiBpWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIG89e25leHQ6YSgwKSx0aHJvdzphKDEpLHJldHVybjphKDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihvW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLG87ZnVuY3Rpb24gYShvKXtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKG8pe2lmKHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDtzOyl0cnl7aWYocj0xLG4mJihpPTImb1swXT9uLnJldHVybjpvWzBdP24udGhyb3d8fCgoaT1uLnJldHVybikmJmkuY2FsbChuKSwwKTpuLm5leHQpJiYhKGk9aS5jYWxsKG4sb1sxXSkpLmRvbmUpcmV0dXJuIGk7c3dpdGNoKG49MCxpJiYobz1bMiZvWzBdLGkudmFsdWVdKSxvWzBdKXtjYXNlIDA6Y2FzZSAxOmk9bzticmVhaztjYXNlIDQ6cmV0dXJuIHMubGFiZWwrKyx7dmFsdWU6b1sxXSxkb25lOiExfTtjYXNlIDU6cy5sYWJlbCsrLG49b1sxXSxvPVswXTtjb250aW51ZTtjYXNlIDc6bz1zLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKGk9cy50cnlzLChpPWkubGVuZ3RoPjAmJmlbaS5sZW5ndGgtMV0pfHw2IT09b1swXSYmMiE9PW9bMF0pKXtzPTA7Y29udGludWV9aWYoMz09PW9bMF0mJighaXx8b1sxXT5pWzBdJiZvWzFdPGlbM10pKXtzLmxhYmVsPW9bMV07YnJlYWt9aWYoNj09PW9bMF0mJnMubGFiZWw8aVsxXSl7cy5sYWJlbD1pWzFdLGk9bzticmVha31pZihpJiZzLmxhYmVsPGlbMl0pe3MubGFiZWw9aVsyXSxzLm9wcy5wdXNoKG8pO2JyZWFrfWlbMl0mJnMub3BzLnBvcCgpLHMudHJ5cy5wb3AoKTtjb250aW51ZX1vPXQuY2FsbChlLHMpfWNhdGNoKGUpe289WzYsZV0sbj0wfWZpbmFsbHl7cj1pPTB9aWYoNSZvWzBdKXRocm93IG9bMV07cmV0dXJue3ZhbHVlOm9bMF0/b1sxXTp2b2lkIDAsZG9uZTohMH19KFtvLGFdKX19fTtmdW5jdGlvbiBZKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PV8pLEoodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciByO3JldHVybiBRKHRoaXMsKGZ1bmN0aW9uKG4pe3JldHVybiByPXEoZSksWzIsbmV3IFYodC5leHRlbnNpb25Db2RlYyx0LmNvbnRleHQsdC5tYXhTdHJMZW5ndGgsdC5tYXhCaW5MZW5ndGgsdC5tYXhBcnJheUxlbmd0aCx0Lm1heE1hcExlbmd0aCx0Lm1heEV4dExlbmd0aCkuZGVjb2RlU2luZ2xlQXN5bmMocildfSkpfSkpfWZ1bmN0aW9uIFooZSx0KXt2b2lkIDA9PT10JiYodD1fKTt2YXIgcj1xKGUpO3JldHVybiBuZXcgVih0LmV4dGVuc2lvbkNvZGVjLHQuY29udGV4dCx0Lm1heFN0ckxlbmd0aCx0Lm1heEJpbkxlbmd0aCx0Lm1heEFycmF5TGVuZ3RoLHQubWF4TWFwTGVuZ3RoLHQubWF4RXh0TGVuZ3RoKS5kZWNvZGVBcnJheVN0cmVhbShyKX1mdW5jdGlvbiAkKGUsdCl7dm9pZCAwPT09dCYmKHQ9Xyk7dmFyIHI9cShlKTtyZXR1cm4gbmV3IFYodC5leHRlbnNpb25Db2RlYyx0LmNvbnRleHQsdC5tYXhTdHJMZW5ndGgsdC5tYXhCaW5MZW5ndGgsdC5tYXhBcnJheUxlbmd0aCx0Lm1heE1hcExlbmd0aCx0Lm1heEV4dExlbmd0aCkuZGVjb2RlU3RyZWFtKHIpfX1dKX0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1zZ3BhY2subWluLmpzLm1hcCIsIi8qKlxuICogZ3B1LmpzXG4gKiBodHRwOi8vZ3B1LnJvY2tzL1xuICpcbiAqIEdQVSBBY2NlbGVyYXRlZCBKYXZhU2NyaXB0XG4gKlxuICogQHZlcnNpb24gMi45LjRcbiAqIEBkYXRlIFNhdCBNYXkgMDIgMjAyMCAxMTo0Njo0OSBHTVQtMDQwMCAoRWFzdGVybiBEYXlsaWdodCBUaW1lKVxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICogVGhlIE1JVCBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIwIGdwdS5qcyBUZWFtXG4gKi8oZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5HUFUgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5hY29ybiA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gIHZhciByZXNlcnZlZFdvcmRzID0ge1xuICAgIDM6IFwiYWJzdHJhY3QgYm9vbGVhbiBieXRlIGNoYXIgY2xhc3MgZG91YmxlIGVudW0gZXhwb3J0IGV4dGVuZHMgZmluYWwgZmxvYXQgZ290byBpbXBsZW1lbnRzIGltcG9ydCBpbnQgaW50ZXJmYWNlIGxvbmcgbmF0aXZlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHNob3J0IHN0YXRpYyBzdXBlciBzeW5jaHJvbml6ZWQgdGhyb3dzIHRyYW5zaWVudCB2b2xhdGlsZVwiLFxuICAgIDU6IFwiY2xhc3MgZW51bSBleHRlbmRzIHN1cGVyIGNvbnN0IGV4cG9ydCBpbXBvcnRcIixcbiAgICA2OiBcImVudW1cIixcbiAgICBzdHJpY3Q6IFwiaW1wbGVtZW50cyBpbnRlcmZhY2UgbGV0IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZFwiLFxuICAgIHN0cmljdEJpbmQ6IFwiZXZhbCBhcmd1bWVudHNcIlxuICB9O1xuXG5cbiAgdmFyIGVjbWE1QW5kTGVzc0tleXdvcmRzID0gXCJicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB2YXIgd2hpbGUgd2l0aCBudWxsIHRydWUgZmFsc2UgaW5zdGFuY2VvZiB0eXBlb2Ygdm9pZCBkZWxldGUgbmV3IGluIHRoaXNcIjtcblxuICB2YXIga2V5d29yZHMgPSB7XG4gICAgNTogZWNtYTVBbmRMZXNzS2V5d29yZHMsXG4gICAgXCI1bW9kdWxlXCI6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgZXhwb3J0IGltcG9ydFwiLFxuICAgIDY6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgY29uc3QgY2xhc3MgZXh0ZW5kcyBleHBvcnQgaW1wb3J0IHN1cGVyXCJcbiAgfTtcblxuICB2YXIga2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciA9IC9eaW4oc3RhbmNlb2YpPyQvO1xuXG5cbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzN2ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyZlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNWQwLVxcdTA1ZWFcXHUwNWVmLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZhXFx1MDhhMC1cXHUwOGI0XFx1MDhiNi1cXHUwOGJkXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwOWZjXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGFmOVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzM5XFx1MGMzZFxcdTBjNTgtXFx1MGM1YVxcdTBjNjBcXHUwYzYxXFx1MGM4MFxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzg4XFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmVmXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3YmZcXHVhN2MyLVxcdWE3YzZcXHVhN2Y3LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY3XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MjAwY1xcdTIwMGRcXHhiN1xcdTAzMDAtXFx1MDM2ZlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NjlcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZi1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNmYwLVxcdTA2ZjlcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdjMC1cXHUwN2M5XFx1MDdlYi1cXHUwN2YzXFx1MDdmZFxcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NTktXFx1MDg1YlxcdTA4ZDMtXFx1MDhlMVxcdTA4ZTMtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDljYi1cXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MDllNi1cXHUwOWVmXFx1MDlmZVxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGFmYS1cXHUwYWZmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzZS1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODEtXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMC1cXHUwZDAzXFx1MGQzYlxcdTBkM2NcXHUwZDNlLVxcdTBkNDRcXHUwZDQ2LVxcdTBkNDhcXHUwZDRhLVxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmOVxcdTFkZmItXFx1MWRmZlxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZDdmXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4ODBcXHVhODgxXFx1YThiNC1cXHVhOGM1XFx1YThkMC1cXHVhOGQ5XFx1YThlMC1cXHVhOGYxXFx1YThmZi1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUzXFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YTlkMC1cXHVhOWQ5XFx1YTllNVxcdWE5ZjAtXFx1YTlmOVxcdWFhMjktXFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2ItXFx1YWE3ZFxcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFhZWItXFx1YWFlZlxcdWFhZjVcXHVhYWY2XFx1YWJlMy1cXHVhYmVhXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTJmXFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCI7XG5cbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG4gIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IG51bGw7XG5cblxuICB2YXIgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMgPSBbMCwxMSwyLDI1LDIsMTgsMiwxLDIsMTQsMywxMywzNSwxMjIsNzAsNTIsMjY4LDI4LDQsNDgsNDgsMzEsMTQsMjksNiwzNywxMSwyOSwzLDM1LDUsNywyLDQsNDMsMTU3LDE5LDM1LDUsMzUsNSwzOSw5LDUxLDE1NywzMTAsMTAsMjEsMTEsNywxNTMsNSwzLDAsMiw0MywyLDEsNCwwLDMsMjIsMTEsMjIsMTAsMzAsNjYsMTgsMiwxLDExLDIxLDExLDI1LDcxLDU1LDcsMSw2NSwwLDE2LDMsMiwyLDIsMjgsNDMsMjgsNCwyOCwzNiw3LDIsMjcsMjgsNTMsMTEsMjEsMTEsMTgsMTQsMTcsMTExLDcyLDU2LDUwLDE0LDUwLDE0LDM1LDQ3NywyOCwxMSwwLDksMjEsMTU1LDIyLDEzLDUyLDc2LDQ0LDMzLDI0LDI3LDM1LDMwLDAsMTIsMzQsNCwwLDEzLDQ3LDE1LDMsMjIsMCwyLDAsMzYsMTcsMiwyNCw4NSw2LDIsMCwyLDMsMiwxNCwyLDksOCw0NiwzOSw3LDMsMSwzLDIxLDIsNiwyLDEsMiw0LDQsMCwxOSwwLDEzLDQsMTU5LDUyLDE5LDMsMjEsMCwzMyw0NywyMSwxLDIsMCwxODUsNDYsNDIsMywzNyw0NywyMSwwLDYwLDQyLDE0LDAsNzIsMjYsMjMwLDQzLDExNyw2MywzMiwwLDE2MSw3LDMsMzgsMTcsMCwyLDAsMjksMCwxMSwzOSw4LDAsMjIsMCwxMiw0NSwyMCwwLDM1LDU2LDI2NCw4LDIsMzYsMTgsMCw1MCwyOSwxMTMsNiwyLDEsMiwzNywyMiwwLDI2LDUsMiwxLDIsMzEsMTUsMCwzMjgsMTgsMjcwLDkyMSwxMDMsMTEwLDE4LDE5NSwyNzQ5LDEwNzAsNDA1MCw1ODIsODYzNCw1NjgsOCwzMCwxMTQsMjksMTksNDcsMTcsMywzMiwyMCw2LDE4LDY4OSw2MywxMjksNzQsNiwwLDY3LDEyLDY1LDEsMiwwLDI5LDYxMzUsOSw3NTQsOTQ4NiwyODYsNTAsMiwxOCwzLDksMzk1LDIzMDksMTA2LDYsMTIsNCw4LDgsOSw1OTkxLDg0LDIsNzAsMiwxLDMsMCwzLDEsMywzLDIsMTEsMiwwLDIsNiwyLDY0LDIsMywzLDcsMiw2LDIsMjcsMiwzLDIsNCwyLDAsNCw2LDIsMzM5LDMsMjQsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiw3LDIzNTcsNDQsMTEsNiwxNywwLDM3MCw0MywxMzAxLDE5Niw2MCw2Nyw4LDAsMTIwNSwzLDIsMjYsMiwxLDIsMCwzLDAsMiw5LDIsMywyLDAsMiwwLDcsMCw1LDAsMiwwLDIsMCwyLDIsMiwxLDIsMCwzLDAsMiwwLDIsMCwyLDAsMiwwLDIsMSwyLDAsMywzLDIsNiwyLDMsMiwzLDIsMCwyLDksMiwxNiw2LDIsMiw0LDIsMTYsNDQyMSw0MjcxMCw0Miw0MTQ4LDEyLDIyMSwzLDU3NjEsMTUsNzQ3MiwzMTA0LDU0MV07XG5cbiAgdmFyIGFzdHJhbElkZW50aWZpZXJDb2RlcyA9IFs1MDksMCwyMjcsMCwxNTAsNCwyOTQsOSwxMzY4LDIsMiwxLDYsMyw0MSwyLDUsMCwxNjYsMSw1NzQsMyw5LDksNTI1LDEwLDE3NiwyLDU0LDE0LDMyLDksMTYsMyw0NiwxMCw1NCw5LDcsMiwzNywxMywyLDksNiwxLDQ1LDAsMTMsMiw0OSwxMyw5LDMsNCw5LDgzLDExLDcsMCwxNjEsMTEsNiw5LDcsMyw1NiwxLDIsNiwzLDEsMywyLDEwLDAsMTEsMSwzLDYsNCw0LDE5MywxNywxMCw5LDUsMCw4MiwxOSwxMyw5LDIxNCw2LDMsOCwyOCwxLDgzLDE2LDE2LDksODIsMTIsOSw5LDg0LDE0LDUsOSwyNDMsMTQsMTY2LDksMjMyLDYsMyw2LDQsMCwyOSw5LDQxLDYsMiwzLDksMCwxMCwxMCw0NywxNSw0MDYsNywyLDcsMTcsOSw1NywyMSwyLDEzLDEyMyw1LDQsMCwyLDEsMiw2LDIsMCw5LDksNDksNCwyLDEsMiw0LDksOSwzMzAsMywxOTMwNiw5LDEzNSw0LDYwLDYsMjYsOSwxMDE0LDAsMiw1NCw4LDMsMTk3MjMsMSw1MzE5LDQsNCw1LDksNywzLDYsMzEsMywxNDksMiwxNDE4LDQ5LDUxMyw1NCw1LDQ5LDksMCwxNSwwLDIzLDQsMiwxNCwxMzYxLDYsMiwxNiwzLDYsMiwxLDIsNCwyNjIsNiwxMCw5LDQxOSwxMywxNDk1LDYsMTEwLDYsNiw5LDc5MjQ4NywyMzldO1xuXG4gIGZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gICAgdmFyIHBvcyA9IDB4MTAwMDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHBvcyArPSBzZXRbaV07XG4gICAgICBpZiAocG9zID4gY29kZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgICBpZiAocG9zID49IGNvZGUpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgfVxuXG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgYXN0cmFsKSB7XG4gICAgaWYgKGNvZGUgPCA2NSkgeyByZXR1cm4gY29kZSA9PT0gMzYgfVxuICAgIGlmIChjb2RlIDwgOTEpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgICBpZiAoY29kZSA8IDEyMykgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7IHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gICAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcylcbiAgfVxuXG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjb2RlLCBhc3RyYWwpIHtcbiAgICBpZiAoY29kZSA8IDQ4KSB7IHJldHVybiBjb2RlID09PSAzNiB9XG4gICAgaWYgKGNvZGUgPCA1OCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA2NSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChjb2RlIDwgOTEpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgICBpZiAoY29kZSA8IDEyMykgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7IHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSkgfVxuICAgIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpIHx8IGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllckNvZGVzKVxuICB9XG5cblxuXG5cblxuICB2YXIgVG9rZW5UeXBlID0gZnVuY3Rpb24gVG9rZW5UeXBlKGxhYmVsLCBjb25mKSB7XG4gICAgaWYgKCBjb25mID09PSB2b2lkIDAgKSBjb25mID0ge307XG5cbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5rZXl3b3JkID0gY29uZi5rZXl3b3JkO1xuICAgIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICAgIHRoaXMuc3RhcnRzRXhwciA9ICEhY29uZi5zdGFydHNFeHByO1xuICAgIHRoaXMuaXNMb29wID0gISFjb25mLmlzTG9vcDtcbiAgICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICAgIHRoaXMucHJlZml4ID0gISFjb25mLnByZWZpeDtcbiAgICB0aGlzLnBvc3RmaXggPSAhIWNvbmYucG9zdGZpeDtcbiAgICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICAgIHRoaXMudXBkYXRlQ29udGV4dCA9IG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICAgIHJldHVybiBuZXcgVG9rZW5UeXBlKG5hbWUsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogcHJlY30pXG4gIH1cbiAgdmFyIGJlZm9yZUV4cHIgPSB7YmVmb3JlRXhwcjogdHJ1ZX0sIHN0YXJ0c0V4cHIgPSB7c3RhcnRzRXhwcjogdHJ1ZX07XG5cblxuICB2YXIga2V5d29yZHMkMSA9IHt9O1xuXG4gIGZ1bmN0aW9uIGt3KG5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAgIG9wdGlvbnMua2V5d29yZCA9IG5hbWU7XG4gICAgcmV0dXJuIGtleXdvcmRzJDFbbmFtZV0gPSBuZXcgVG9rZW5UeXBlKG5hbWUsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgdHlwZXMgPSB7XG4gICAgbnVtOiBuZXcgVG9rZW5UeXBlKFwibnVtXCIsIHN0YXJ0c0V4cHIpLFxuICAgIHJlZ2V4cDogbmV3IFRva2VuVHlwZShcInJlZ2V4cFwiLCBzdGFydHNFeHByKSxcbiAgICBzdHJpbmc6IG5ldyBUb2tlblR5cGUoXCJzdHJpbmdcIiwgc3RhcnRzRXhwciksXG4gICAgbmFtZTogbmV3IFRva2VuVHlwZShcIm5hbWVcIiwgc3RhcnRzRXhwciksXG4gICAgZW9mOiBuZXcgVG9rZW5UeXBlKFwiZW9mXCIpLFxuXG4gICAgYnJhY2tldEw6IG5ldyBUb2tlblR5cGUoXCJbXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgYnJhY2tldFI6IG5ldyBUb2tlblR5cGUoXCJdXCIpLFxuICAgIGJyYWNlTDogbmV3IFRva2VuVHlwZShcIntcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBicmFjZVI6IG5ldyBUb2tlblR5cGUoXCJ9XCIpLFxuICAgIHBhcmVuTDogbmV3IFRva2VuVHlwZShcIihcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBwYXJlblI6IG5ldyBUb2tlblR5cGUoXCIpXCIpLFxuICAgIGNvbW1hOiBuZXcgVG9rZW5UeXBlKFwiLFwiLCBiZWZvcmVFeHByKSxcbiAgICBzZW1pOiBuZXcgVG9rZW5UeXBlKFwiO1wiLCBiZWZvcmVFeHByKSxcbiAgICBjb2xvbjogbmV3IFRva2VuVHlwZShcIjpcIiwgYmVmb3JlRXhwciksXG4gICAgZG90OiBuZXcgVG9rZW5UeXBlKFwiLlwiKSxcbiAgICBxdWVzdGlvbjogbmV3IFRva2VuVHlwZShcIj9cIiwgYmVmb3JlRXhwciksXG4gICAgYXJyb3c6IG5ldyBUb2tlblR5cGUoXCI9PlwiLCBiZWZvcmVFeHByKSxcbiAgICB0ZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcInRlbXBsYXRlXCIpLFxuICAgIGludmFsaWRUZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcImludmFsaWRUZW1wbGF0ZVwiKSxcbiAgICBlbGxpcHNpczogbmV3IFRva2VuVHlwZShcIi4uLlwiLCBiZWZvcmVFeHByKSxcbiAgICBiYWNrUXVvdGU6IG5ldyBUb2tlblR5cGUoXCJgXCIsIHN0YXJ0c0V4cHIpLFxuICAgIGRvbGxhckJyYWNlTDogbmV3IFRva2VuVHlwZShcIiR7XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG5cblxuICAgIGVxOiBuZXcgVG9rZW5UeXBlKFwiPVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWV9KSxcbiAgICBhc3NpZ246IG5ldyBUb2tlblR5cGUoXCJfPVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWV9KSxcbiAgICBpbmNEZWM6IG5ldyBUb2tlblR5cGUoXCIrKy8tLVwiLCB7cHJlZml4OiB0cnVlLCBwb3N0Zml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgcHJlZml4OiBuZXcgVG9rZW5UeXBlKFwiIS9+XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBsb2dpY2FsT1I6IGJpbm9wKFwifHxcIiwgMSksXG4gICAgbG9naWNhbEFORDogYmlub3AoXCImJlwiLCAyKSxcbiAgICBiaXR3aXNlT1I6IGJpbm9wKFwifFwiLCAzKSxcbiAgICBiaXR3aXNlWE9SOiBiaW5vcChcIl5cIiwgNCksXG4gICAgYml0d2lzZUFORDogYmlub3AoXCImXCIsIDUpLFxuICAgIGVxdWFsaXR5OiBiaW5vcChcIj09LyE9Lz09PS8hPT1cIiwgNiksXG4gICAgcmVsYXRpb25hbDogYmlub3AoXCI8Lz4vPD0vPj1cIiwgNyksXG4gICAgYml0U2hpZnQ6IGJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICAgIHBsdXNNaW46IG5ldyBUb2tlblR5cGUoXCIrLy1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA5LCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBtb2R1bG86IGJpbm9wKFwiJVwiLCAxMCksXG4gICAgc3RhcjogYmlub3AoXCIqXCIsIDEwKSxcbiAgICBzbGFzaDogYmlub3AoXCIvXCIsIDEwKSxcbiAgICBzdGFyc3RhcjogbmV3IFRva2VuVHlwZShcIioqXCIsIHtiZWZvcmVFeHByOiB0cnVlfSksXG5cbiAgICBfYnJlYWs6IGt3KFwiYnJlYWtcIiksXG4gICAgX2Nhc2U6IGt3KFwiY2FzZVwiLCBiZWZvcmVFeHByKSxcbiAgICBfY2F0Y2g6IGt3KFwiY2F0Y2hcIiksXG4gICAgX2NvbnRpbnVlOiBrdyhcImNvbnRpbnVlXCIpLFxuICAgIF9kZWJ1Z2dlcjoga3coXCJkZWJ1Z2dlclwiKSxcbiAgICBfZGVmYXVsdDoga3coXCJkZWZhdWx0XCIsIGJlZm9yZUV4cHIpLFxuICAgIF9kbzoga3coXCJkb1wiLCB7aXNMb29wOiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfSksXG4gICAgX2Vsc2U6IGt3KFwiZWxzZVwiLCBiZWZvcmVFeHByKSxcbiAgICBfZmluYWxseToga3coXCJmaW5hbGx5XCIpLFxuICAgIF9mb3I6IGt3KFwiZm9yXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgICBfZnVuY3Rpb246IGt3KFwiZnVuY3Rpb25cIiwgc3RhcnRzRXhwciksXG4gICAgX2lmOiBrdyhcImlmXCIpLFxuICAgIF9yZXR1cm46IGt3KFwicmV0dXJuXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9zd2l0Y2g6IGt3KFwic3dpdGNoXCIpLFxuICAgIF90aHJvdzoga3coXCJ0aHJvd1wiLCBiZWZvcmVFeHByKSxcbiAgICBfdHJ5OiBrdyhcInRyeVwiKSxcbiAgICBfdmFyOiBrdyhcInZhclwiKSxcbiAgICBfY29uc3Q6IGt3KFwiY29uc3RcIiksXG4gICAgX3doaWxlOiBrdyhcIndoaWxlXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgICBfd2l0aDoga3coXCJ3aXRoXCIpLFxuICAgIF9uZXc6IGt3KFwibmV3XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX3RoaXM6IGt3KFwidGhpc1wiLCBzdGFydHNFeHByKSxcbiAgICBfc3VwZXI6IGt3KFwic3VwZXJcIiwgc3RhcnRzRXhwciksXG4gICAgX2NsYXNzOiBrdyhcImNsYXNzXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9leHRlbmRzOiBrdyhcImV4dGVuZHNcIiwgYmVmb3JlRXhwciksXG4gICAgX2V4cG9ydDoga3coXCJleHBvcnRcIiksXG4gICAgX2ltcG9ydDoga3coXCJpbXBvcnRcIiwgc3RhcnRzRXhwciksXG4gICAgX251bGw6IGt3KFwibnVsbFwiLCBzdGFydHNFeHByKSxcbiAgICBfdHJ1ZToga3coXCJ0cnVlXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9mYWxzZToga3coXCJmYWxzZVwiLCBzdGFydHNFeHByKSxcbiAgICBfaW46IGt3KFwiaW5cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gICAgX2luc3RhbmNlb2Y6IGt3KFwiaW5zdGFuY2VvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgICBfdHlwZW9mOiBrdyhcInR5cGVvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX3ZvaWQ6IGt3KFwidm9pZFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX2RlbGV0ZToga3coXCJkZWxldGVcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pXG4gIH07XG5cblxuICB2YXIgbGluZUJyZWFrID0gL1xcclxcbj98XFxufFxcdTIwMjh8XFx1MjAyOS87XG4gIHZhciBsaW5lQnJlYWtHID0gbmV3IFJlZ0V4cChsaW5lQnJlYWsuc291cmNlLCBcImdcIik7XG5cbiAgZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUsIGVjbWEyMDE5U3RyaW5nKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09IDEwIHx8IGNvZGUgPT09IDEzIHx8ICghZWNtYTIwMTlTdHJpbmcgJiYgKGNvZGUgPT09IDB4MjAyOCB8fCBjb2RlID09PSAweDIwMjkpKVxuICB9XG5cbiAgdmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLztcblxuICB2YXIgc2tpcFdoaXRlU3BhY2UgPSAvKD86XFxzfFxcL1xcLy4qfFxcL1xcKlteXSo/XFwqXFwvKSovZztcblxuICB2YXIgcmVmID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gcmVmLmhhc093blByb3BlcnR5O1xuICB2YXIgdG9TdHJpbmcgPSByZWYudG9TdHJpbmc7XG5cblxuICBmdW5jdGlvbiBoYXMob2JqLCBwcm9wTmFtZSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcE5hbWUpXG4gIH1cblxuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIChcbiAgICB0b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIlxuICApOyB9KTtcblxuICBmdW5jdGlvbiB3b3Jkc1JlZ2V4cCh3b3Jkcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgd29yZHMucmVwbGFjZSgvIC9nLCBcInxcIikgKyBcIikkXCIpXG4gIH1cblxuXG4gIHZhciBQb3NpdGlvbiA9IGZ1bmN0aW9uIFBvc2l0aW9uKGxpbmUsIGNvbCkge1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2w7XG4gIH07XG5cbiAgUG9zaXRpb24ucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldCAobikge1xuICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5saW5lLCB0aGlzLmNvbHVtbiArIG4pXG4gIH07XG5cbiAgdmFyIFNvdXJjZUxvY2F0aW9uID0gZnVuY3Rpb24gU291cmNlTG9jYXRpb24ocCwgc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICBpZiAocC5zb3VyY2VGaWxlICE9PSBudWxsKSB7IHRoaXMuc291cmNlID0gcC5zb3VyY2VGaWxlOyB9XG4gIH07XG5cblxuICBmdW5jdGlvbiBnZXRMaW5lSW5mbyhpbnB1dCwgb2Zmc2V0KSB7XG4gICAgZm9yICh2YXIgbGluZSA9IDEsIGN1ciA9IDA7Oykge1xuICAgICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBjdXI7XG4gICAgICB2YXIgbWF0Y2ggPSBsaW5lQnJlYWtHLmV4ZWMoaW5wdXQpO1xuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4IDwgb2Zmc2V0KSB7XG4gICAgICAgICsrbGluZTtcbiAgICAgICAgY3VyID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIG9mZnNldCAtIGN1cilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBlY21hVmVyc2lvbjogMTAsXG4gICAgc291cmNlVHlwZTogXCJzY3JpcHRcIixcbiAgICBvbkluc2VydGVkU2VtaWNvbG9uOiBudWxsLFxuICAgIG9uVHJhaWxpbmdDb21tYTogbnVsbCxcbiAgICBhbGxvd1Jlc2VydmVkOiBudWxsLFxuICAgIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICBhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmU6IGZhbHNlLFxuICAgIGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIGFsbG93SGFzaEJhbmc6IGZhbHNlLFxuICAgIGxvY2F0aW9uczogZmFsc2UsXG4gICAgb25Ub2tlbjogbnVsbCxcbiAgICBvbkNvbW1lbnQ6IG51bGwsXG4gICAgcmFuZ2VzOiBmYWxzZSxcbiAgICBwcm9ncmFtOiBudWxsLFxuICAgIHNvdXJjZUZpbGU6IG51bGwsXG4gICAgZGlyZWN0U291cmNlRmlsZTogbnVsbCxcbiAgICBwcmVzZXJ2ZVBhcmVuczogZmFsc2VcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGdldE9wdGlvbnMob3B0cykge1xuICAgIHZhciBvcHRpb25zID0ge307XG5cbiAgICBmb3IgKHZhciBvcHQgaW4gZGVmYXVsdE9wdGlvbnMpXG4gICAgICB7IG9wdGlvbnNbb3B0XSA9IG9wdHMgJiYgaGFzKG9wdHMsIG9wdCkgPyBvcHRzW29wdF0gOiBkZWZhdWx0T3B0aW9uc1tvcHRdOyB9XG5cbiAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSAyMDE1KVxuICAgICAgeyBvcHRpb25zLmVjbWFWZXJzaW9uIC09IDIwMDk7IH1cblxuICAgIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT0gbnVsbClcbiAgICAgIHsgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID0gb3B0aW9ucy5lY21hVmVyc2lvbiA8IDU7IH1cblxuICAgIGlmIChpc0FycmF5KG9wdGlvbnMub25Ub2tlbikpIHtcbiAgICAgIHZhciB0b2tlbnMgPSBvcHRpb25zLm9uVG9rZW47XG4gICAgICBvcHRpb25zLm9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2Vucy5wdXNoKHRva2VuKTsgfTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpKVxuICAgICAgeyBvcHRpb25zLm9uQ29tbWVudCA9IHB1c2hDb21tZW50KG9wdGlvbnMsIG9wdGlvbnMub25Db21tZW50KTsgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hDb21tZW50KG9wdGlvbnMsIGFycmF5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGJsb2NrLCB0ZXh0LCBzdGFydCwgZW5kLCBzdGFydExvYywgZW5kTG9jKSB7XG4gICAgICB2YXIgY29tbWVudCA9IHtcbiAgICAgICAgdHlwZTogYmxvY2sgPyBcIkJsb2NrXCIgOiBcIkxpbmVcIixcbiAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmRcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICAgIHsgY29tbWVudC5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24odGhpcywgc3RhcnRMb2MsIGVuZExvYyk7IH1cbiAgICAgIGlmIChvcHRpb25zLnJhbmdlcylcbiAgICAgICAgeyBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdOyB9XG4gICAgICBhcnJheS5wdXNoKGNvbW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHZhclxuICAgICAgU0NPUEVfVE9QID0gMSxcbiAgICAgIFNDT1BFX0ZVTkNUSU9OID0gMixcbiAgICAgIFNDT1BFX1ZBUiA9IFNDT1BFX1RPUCB8IFNDT1BFX0ZVTkNUSU9OLFxuICAgICAgU0NPUEVfQVNZTkMgPSA0LFxuICAgICAgU0NPUEVfR0VORVJBVE9SID0gOCxcbiAgICAgIFNDT1BFX0FSUk9XID0gMTYsXG4gICAgICBTQ09QRV9TSU1QTEVfQ0FUQ0ggPSAzMixcbiAgICAgIFNDT1BFX1NVUEVSID0gNjQsXG4gICAgICBTQ09QRV9ESVJFQ1RfU1VQRVIgPSAxMjg7XG5cbiAgZnVuY3Rpb24gZnVuY3Rpb25GbGFncyhhc3luYywgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIFNDT1BFX0ZVTkNUSU9OIHwgKGFzeW5jID8gU0NPUEVfQVNZTkMgOiAwKSB8IChnZW5lcmF0b3IgPyBTQ09QRV9HRU5FUkFUT1IgOiAwKVxuICB9XG5cbiAgdmFyXG4gICAgICBCSU5EX05PTkUgPSAwLCBcbiAgICAgIEJJTkRfVkFSID0gMSwgXG4gICAgICBCSU5EX0xFWElDQUwgPSAyLCBcbiAgICAgIEJJTkRfRlVOQ1RJT04gPSAzLCBcbiAgICAgIEJJTkRfU0lNUExFX0NBVENIID0gNCwgXG4gICAgICBCSU5EX09VVFNJREUgPSA1OyBcblxuICB2YXIgUGFyc2VyID0gZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMsIGlucHV0LCBzdGFydFBvcykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuc291cmNlRmlsZSA9IG9wdGlvbnMuc291cmNlRmlsZTtcbiAgICB0aGlzLmtleXdvcmRzID0gd29yZHNSZWdleHAoa2V5d29yZHNbb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gNiA6IG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIiA/IFwiNW1vZHVsZVwiIDogNV0pO1xuICAgIHZhciByZXNlcnZlZCA9IFwiXCI7XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gdHJ1ZSkge1xuICAgICAgZm9yICh2YXIgdiA9IG9wdGlvbnMuZWNtYVZlcnNpb247OyB2LS0pXG4gICAgICAgIHsgaWYgKHJlc2VydmVkID0gcmVzZXJ2ZWRXb3Jkc1t2XSkgeyBicmVhayB9IH1cbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIpIHsgcmVzZXJ2ZWQgKz0gXCIgYXdhaXRcIjsgfVxuICAgIH1cbiAgICB0aGlzLnJlc2VydmVkV29yZHMgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZCk7XG4gICAgdmFyIHJlc2VydmVkU3RyaWN0ID0gKHJlc2VydmVkID8gcmVzZXJ2ZWQgKyBcIiBcIiA6IFwiXCIpICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3Q7XG4gICAgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0ID0gd29yZHNSZWdleHAocmVzZXJ2ZWRTdHJpY3QpO1xuICAgIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZFN0cmljdCArIFwiIFwiICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKTtcbiAgICB0aGlzLmlucHV0ID0gU3RyaW5nKGlucHV0KTtcblxuICAgIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcblxuXG4gICAgaWYgKHN0YXJ0UG9zKSB7XG4gICAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zO1xuICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmlucHV0Lmxhc3RJbmRleE9mKFwiXFxuXCIsIHN0YXJ0UG9zIC0gMSkgKyAxO1xuICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pbnB1dC5zbGljZSgwLCB0aGlzLmxpbmVTdGFydCkuc3BsaXQobGluZUJyZWFrKS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucG9zID0gdGhpcy5saW5lU3RhcnQgPSAwO1xuICAgICAgdGhpcy5jdXJMaW5lID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlcy5lb2Y7XG4gICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgdGhpcy5zdGFydCA9IHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gICAgdGhpcy5zdGFydExvYyA9IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpO1xuXG4gICAgdGhpcy5sYXN0VG9rRW5kTG9jID0gdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSBudWxsO1xuICAgIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5wb3M7XG5cbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmluaXRpYWxDb250ZXh0KCk7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG5cbiAgICB0aGlzLmluTW9kdWxlID0gb3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiO1xuICAgIHRoaXMuc3RyaWN0ID0gdGhpcy5pbk1vZHVsZSB8fCB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLnBvcyk7XG5cbiAgICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcblxuICAgIHRoaXMueWllbGRQb3MgPSB0aGlzLmF3YWl0UG9zID0gdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0cyA9IHt9O1xuXG4gICAgaWYgKHRoaXMucG9zID09PSAwICYmIG9wdGlvbnMuYWxsb3dIYXNoQmFuZyAmJiB0aGlzLmlucHV0LnNsaWNlKDAsIDIpID09PSBcIiMhXCIpXG4gICAgICB7IHRoaXMuc2tpcExpbmVDb21tZW50KDIpOyB9XG5cbiAgICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcbiAgICB0aGlzLmVudGVyU2NvcGUoU0NPUEVfVE9QKTtcblxuICAgIHRoaXMucmVnZXhwU3RhdGUgPSBudWxsO1xuICB9O1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGluRnVuY3Rpb246IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5HZW5lcmF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5Bc3luYzogeyBjb25maWd1cmFibGU6IHRydWUgfSxhbGxvd1N1cGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93RGlyZWN0U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sdHJlYXRGdW5jdGlvbnNBc1ZhcjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm9wdGlvbnMucHJvZ3JhbSB8fCB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VUb3BMZXZlbChub2RlKVxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkZ1bmN0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pID4gMCB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMuaW5HZW5lcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9HRU5FUkFUT1IpID4gMCB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMuaW5Bc3luYy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0FTWU5DKSA+IDAgfTtcbiAgcHJvdG90eXBlQWNjZXNzb3JzLmFsbG93U3VwZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfU1VQRVIpID4gMCB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dEaXJlY3RTdXBlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9ESVJFQ1RfU1VQRVIpID4gMCB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMudHJlYXRGdW5jdGlvbnNBc1Zhci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHRoaXMuY3VycmVudFNjb3BlKCkpIH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5pbk5vbkFycm93RnVuY3Rpb24gPSBmdW5jdGlvbiBpbk5vbkFycm93RnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pID4gMCB9O1xuXG4gIFBhcnNlci5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKCkge1xuICAgICAgdmFyIHBsdWdpbnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBwbHVnaW5zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgY2xzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHsgY2xzID0gcGx1Z2luc1tpXShjbHMpOyB9XG4gICAgcmV0dXJuIGNsc1xuICB9O1xuXG4gIFBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCkucGFyc2UoKVxuICB9O1xuXG4gIFBhcnNlci5wYXJzZUV4cHJlc3Npb25BdCA9IGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0IChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlciA9IG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0LCBwb3MpO1xuICAgIHBhcnNlci5uZXh0VG9rZW4oKTtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbigpXG4gIH07XG5cbiAgUGFyc2VyLnRva2VuaXplciA9IGZ1bmN0aW9uIHRva2VuaXplciAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQpXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFBhcnNlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gIHZhciBwcCA9IFBhcnNlci5wcm90b3R5cGU7XG5cblxuICB2YXIgbGl0ZXJhbCA9IC9eKD86JygoPzpcXFxcLnxbXiddKSo/KSd8XCIoKD86XFxcXC58W15cIl0pKj8pXCIpLztcbiAgcHAuc3RyaWN0RGlyZWN0aXZlID0gZnVuY3Rpb24oc3RhcnQpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgICAgdmFyIG1hdGNoID0gbGl0ZXJhbC5leGVjKHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQpKTtcbiAgICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIGlmICgobWF0Y2hbMV0gfHwgbWF0Y2hbMl0pID09PSBcInVzZSBzdHJpY3RcIikgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICBzdGFydCArPSBtYXRjaFswXS5sZW5ndGg7XG5cbiAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5pbnB1dFtzdGFydF0gPT09IFwiO1wiKVxuICAgICAgICB7IHN0YXJ0Kys7IH1cbiAgICB9XG4gIH07XG5cblxuICBwcC5lYXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH07XG5cblxuICBwcC5pc0NvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSAmJiB0aGlzLnZhbHVlID09PSBuYW1lICYmICF0aGlzLmNvbnRhaW5zRXNjXG4gIH07XG5cblxuICBwcC5lYXRDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwobmFtZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG5cbiAgcHAuZXhwZWN0Q29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuZWF0Q29udGV4dHVhbChuYW1lKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICB9O1xuXG5cbiAgcHAuY2FuSW5zZXJ0U2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZXMuZW9mIHx8XG4gICAgICB0aGlzLnR5cGUgPT09IHR5cGVzLmJyYWNlUiB8fFxuICAgICAgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKVxuICB9O1xuXG4gIHBwLmluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24pXG4gICAgICAgIHsgdGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24odGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpOyB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfTtcblxuXG4gIHBwLnNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5lYXQodHlwZXMuc2VtaSkgJiYgIXRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgfTtcblxuICBwcC5hZnRlclRyYWlsaW5nQ29tbWEgPSBmdW5jdGlvbih0b2tUeXBlLCBub3ROZXh0KSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdG9rVHlwZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEpXG4gICAgICAgIHsgdGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rU3RhcnRMb2MpOyB9XG4gICAgICBpZiAoIW5vdE5leHQpXG4gICAgICAgIHsgdGhpcy5uZXh0KCk7IH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9O1xuXG5cbiAgcHAuZXhwZWN0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHRoaXMuZWF0KHR5cGUpIHx8IHRoaXMudW5leHBlY3RlZCgpO1xuICB9O1xuXG5cbiAgcHAudW5leHBlY3RlZCA9IGZ1bmN0aW9uKHBvcykge1xuICAgIHRoaXMucmFpc2UocG9zICE9IG51bGwgPyBwb3MgOiB0aGlzLnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gIH07XG5cbiAgZnVuY3Rpb24gRGVzdHJ1Y3R1cmluZ0Vycm9ycygpIHtcbiAgICB0aGlzLnNob3J0aGFuZEFzc2lnbiA9XG4gICAgdGhpcy50cmFpbGluZ0NvbW1hID1cbiAgICB0aGlzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPVxuICAgIHRoaXMucGFyZW50aGVzaXplZEJpbmQgPVxuICAgIHRoaXMuZG91YmxlUHJvdG8gPVxuICAgICAgLTE7XG4gIH1cblxuICBwcC5jaGVja1BhdHRlcm5FcnJvcnMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBpc0Fzc2lnbikge1xuICAgIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyByZXR1cm4gfVxuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPiAtMSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgICB2YXIgcGFyZW5zID0gaXNBc3NpZ24gPyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gOiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kO1xuICAgIGlmIChwYXJlbnMgPiAtMSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocGFyZW5zLCBcIlBhcmVudGhlc2l6ZWQgcGF0dGVyblwiKTsgfVxuICB9O1xuXG4gIHBwLmNoZWNrRXhwcmVzc2lvbkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFuZFRocm93KSB7XG4gICAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIHNob3J0aGFuZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduO1xuICAgIHZhciBkb3VibGVQcm90byA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG87XG4gICAgaWYgKCFhbmRUaHJvdykgeyByZXR1cm4gc2hvcnRoYW5kQXNzaWduID49IDAgfHwgZG91YmxlUHJvdG8gPj0gMCB9XG4gICAgaWYgKHNob3J0aGFuZEFzc2lnbiA+PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlKHNob3J0aGFuZEFzc2lnbiwgXCJTaG9ydGhhbmQgcHJvcGVydHkgYXNzaWdubWVudHMgYXJlIHZhbGlkIG9ubHkgaW4gZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuc1wiKTsgfVxuICAgIGlmIChkb3VibGVQcm90byA+PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZG91YmxlUHJvdG8sIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTsgfVxuICB9O1xuXG4gIHBwLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnlpZWxkUG9zICYmICghdGhpcy5hd2FpdFBvcyB8fCB0aGlzLnlpZWxkUG9zIDwgdGhpcy5hd2FpdFBvcykpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy55aWVsZFBvcywgXCJZaWVsZCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgICBpZiAodGhpcy5hd2FpdFBvcylcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0UG9zLCBcIkF3YWl0IGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICB9O1xuXG4gIHBwLmlzU2ltcGxlQXNzaWduVGFyZ2V0ID0gZnVuY3Rpb24oZXhwcikge1xuICAgIGlmIChleHByLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICAgIHsgcmV0dXJuIHRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwci5leHByZXNzaW9uKSB9XG4gICAgcmV0dXJuIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgZXhwci50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIlxuICB9O1xuXG4gIHZhciBwcCQxID0gUGFyc2VyLnByb3RvdHlwZTtcblxuXG5cbiAgcHAkMS5wYXJzZVRvcExldmVsID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBleHBvcnRzID0ge307XG4gICAgaWYgKCFub2RlLmJvZHkpIHsgbm9kZS5ib2R5ID0gW107IH1cbiAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcy5lb2YpIHtcbiAgICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsLCB0cnVlLCBleHBvcnRzKTtcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbk1vZHVsZSlcbiAgICAgIHsgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBPYmplY3Qua2V5cyh0aGlzLnVuZGVmaW5lZEV4cG9ydHMpOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgICAge1xuICAgICAgICAgIHZhciBuYW1lID0gbGlzdFtpXTtcblxuICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV0uc3RhcnQsIChcIkV4cG9ydCAnXCIgKyBuYW1lICsgXCInIGlzIG5vdCBkZWZpbmVkXCIpKTtcbiAgICAgICAgfSB9XG4gICAgdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keSk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5zb3VyY2VUeXBlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByb2dyYW1cIilcbiAgfTtcblxuICB2YXIgbG9vcExhYmVsID0ge2tpbmQ6IFwibG9vcFwifSwgc3dpdGNoTGFiZWwgPSB7a2luZDogXCJzd2l0Y2hcIn07XG5cbiAgcHAkMS5pc0xldCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJsZXRcIikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gICAgaWYgKG5leHRDaCA9PT0gOTEpIHsgcmV0dXJuIHRydWUgfSBcbiAgICBpZiAoY29udGV4dCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYgKG5leHRDaCA9PT0gMTIzKSB7IHJldHVybiB0cnVlIH0gXG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KG5leHRDaCwgdHJ1ZSkpIHtcbiAgICAgIHZhciBwb3MgPSBuZXh0ICsgMTtcbiAgICAgIHdoaWxlIChpc0lkZW50aWZpZXJDaGFyKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpLCB0cnVlKSkgeyArK3BvczsgfVxuICAgICAgdmFyIGlkZW50ID0gdGhpcy5pbnB1dC5zbGljZShuZXh0LCBwb3MpO1xuICAgICAgaWYgKCFrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLnRlc3QoaWRlbnQpKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkMS5pc0FzeW5jRnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJhc3luY1wiKSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICAgIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGg7XG4gICAgcmV0dXJuICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCBuZXh0KSkgJiZcbiAgICAgIHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgbmV4dCArIDgpID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgIChuZXh0ICsgOCA9PT0gdGhpcy5pbnB1dC5sZW5ndGggfHwgIWlzSWRlbnRpZmllckNoYXIodGhpcy5pbnB1dC5jaGFyQXQobmV4dCArIDgpKSlcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VTdGF0ZW1lbnQgPSBmdW5jdGlvbihjb250ZXh0LCB0b3BMZXZlbCwgZXhwb3J0cykge1xuICAgIHZhciBzdGFydHR5cGUgPSB0aGlzLnR5cGUsIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBraW5kO1xuXG4gICAgaWYgKHRoaXMuaXNMZXQoY29udGV4dCkpIHtcbiAgICAgIHN0YXJ0dHlwZSA9IHR5cGVzLl92YXI7XG4gICAgICBraW5kID0gXCJsZXRcIjtcbiAgICB9XG5cblxuICAgIHN3aXRjaCAoc3RhcnR0eXBlKSB7XG4gICAgY2FzZSB0eXBlcy5fYnJlYWs6IGNhc2UgdHlwZXMuX2NvbnRpbnVlOiByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgc3RhcnR0eXBlLmtleXdvcmQpXG4gICAgY2FzZSB0eXBlcy5fZGVidWdnZXI6IHJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9kbzogcmV0dXJuIHRoaXMucGFyc2VEb1N0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX2ZvcjogcmV0dXJuIHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9mdW5jdGlvbjpcbiAgICAgIGlmICgoY29udGV4dCAmJiAodGhpcy5zdHJpY3QgfHwgY29udGV4dCAhPT0gXCJpZlwiICYmIGNvbnRleHQgIT09IFwibGFiZWxcIikpICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIGZhbHNlLCAhY29udGV4dClcbiAgICBjYXNlIHR5cGVzLl9jbGFzczpcbiAgICAgIGlmIChjb250ZXh0KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpXG4gICAgY2FzZSB0eXBlcy5faWY6IHJldHVybiB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9yZXR1cm46IHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fc3dpdGNoOiByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX3Rocm93OiByZXR1cm4gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fdHJ5OiByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX2NvbnN0OiBjYXNlIHR5cGVzLl92YXI6XG4gICAgICBraW5kID0ga2luZCB8fCB0aGlzLnZhbHVlO1xuICAgICAgaWYgKGNvbnRleHQgJiYga2luZCAhPT0gXCJ2YXJcIikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZClcbiAgICBjYXNlIHR5cGVzLl93aGlsZTogcmV0dXJuIHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX3dpdGg6IHJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuYnJhY2VMOiByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKHRydWUsIG5vZGUpXG4gICAgY2FzZSB0eXBlcy5zZW1pOiByZXR1cm4gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fZXhwb3J0OlxuICAgIGNhc2UgdHlwZXMuX2ltcG9ydDpcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPiAxMCAmJiBzdGFydHR5cGUgPT09IHR5cGVzLl9pbXBvcnQpIHtcbiAgICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgICAgIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gICAgICAgIGlmIChuZXh0Q2ggPT09IDQwKSBcbiAgICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCB0aGlzLnBhcnNlRXhwcmVzc2lvbigpKSB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSkge1xuICAgICAgICBpZiAoIXRvcExldmVsKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbFwiKTsgfVxuICAgICAgICBpZiAoIXRoaXMuaW5Nb2R1bGUpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBtb2R1bGUnXCIpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnR0eXBlID09PSB0eXBlcy5faW1wb3J0ID8gdGhpcy5wYXJzZUltcG9ydChub2RlKSA6IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgZXhwb3J0cylcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgICBpZiAoY29udGV4dCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhY29udGV4dClcbiAgICAgIH1cblxuICAgICAgdmFyIG1heWJlTmFtZSA9IHRoaXMudmFsdWUsIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHlwZXMubmFtZSAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHRoaXMuZWF0KHR5cGVzLmNvbG9uKSlcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQobm9kZSwgbWF5YmVOYW1lLCBleHByLCBjb250ZXh0KSB9XG4gICAgICBlbHNlIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIH1cbiAgICB9XG4gIH07XG5cbiAgcHAkMS5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBrZXl3b3JkKSB7XG4gICAgdmFyIGlzQnJlYWsgPSBrZXl3b3JkID09PSBcImJyZWFrXCI7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5sYWJlbCA9IG51bGw7IH1cbiAgICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBlbHNlIHtcbiAgICAgIG5vZGUubGFiZWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsYWIgPSB0aGlzLmxhYmVsc1tpXTtcbiAgICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgICBpZiAobGFiLmtpbmQgIT0gbnVsbCAmJiAoaXNCcmVhayB8fCBsYWIua2luZCA9PT0gXCJsb29wXCIpKSB7IGJyZWFrIH1cbiAgICAgICAgaWYgKG5vZGUubGFiZWwgJiYgaXNCcmVhaykgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSB0aGlzLmxhYmVscy5sZW5ndGgpIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIlVuc3ludGFjdGljIFwiICsga2V5d29yZCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZURlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZURvU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZG9cIik7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuX3doaWxlKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgICAgeyB0aGlzLmVhdCh0eXBlcy5zZW1pKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5zZW1pY29sb24oKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpXG4gIH07XG5cblxuICBwcCQxLnBhcnNlRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHZhciBhd2FpdEF0ID0gKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmICh0aGlzLmluQXN5bmMgfHwgKCF0aGlzLmluRnVuY3Rpb24gJiYgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24pKSAmJiB0aGlzLmVhdENvbnRleHR1YWwoXCJhd2FpdFwiKSkgPyB0aGlzLmxhc3RUb2tTdGFydCA6IC0xO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zZW1pKSB7XG4gICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgbnVsbClcbiAgICB9XG4gICAgdmFyIGlzTGV0ID0gdGhpcy5pc0xldCgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl92YXIgfHwgdGhpcy50eXBlID09PSB0eXBlcy5fY29uc3QgfHwgaXNMZXQpIHtcbiAgICAgIHZhciBpbml0JDEgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBraW5kID0gaXNMZXQgPyBcImxldFwiIDogdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5wYXJzZVZhcihpbml0JDEsIHRydWUsIGtpbmQpO1xuICAgICAgdGhpcy5maW5pc2hOb2RlKGluaXQkMSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuICAgICAgaWYgKCh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpICYmIGluaXQkMS5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbikge1xuICAgICAgICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0JDEpXG4gICAgICB9XG4gICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCQxKVxuICAgIH1cbiAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICAgIHZhciBpbml0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbikge1xuICAgICAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICAgIH0gZWxzZSB7IG5vZGUuYXdhaXQgPSBhd2FpdEF0ID4gLTE7IH1cbiAgICAgIH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGluaXQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGluaXQpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0KVxuICB9O1xuXG4gIHBwJDEucGFyc2VGdW5jdGlvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMsIGRlY2xhcmF0aW9uUG9zaXRpb24pIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIEZVTkNfU1RBVEVNRU5UIHwgKGRlY2xhcmF0aW9uUG9zaXRpb24gPyAwIDogRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCksIGZhbHNlLCBpc0FzeW5jKVxuICB9O1xuXG4gIHBwJDEucGFyc2VJZlN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpO1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5lYXQodHlwZXMuX2Vsc2UpID8gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpIDogbnVsbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWZTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghdGhpcy5pbkZ1bmN0aW9uICYmICF0aGlzLm9wdGlvbnMuYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb24pXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpOyB9XG4gICAgdGhpcy5uZXh0KCk7XG5cblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5zZW1pKSB8fCB0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IG5vZGUuYXJndW1lbnQgPSBudWxsOyB9XG4gICAgZWxzZSB7IG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpOyB0aGlzLnNlbWljb2xvbigpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VTd2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5kaXNjcmltaW5hbnQgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgbm9kZS5jYXNlcyA9IFtdO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgdGhpcy5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG4gICAgdGhpcy5lbnRlclNjb3BlKDApO1xuXG5cbiAgICB2YXIgY3VyO1xuICAgIGZvciAodmFyIHNhd0RlZmF1bHQgPSBmYWxzZTsgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZVI7KSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2FzZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLl9kZWZhdWx0KSB7XG4gICAgICAgIHZhciBpc0Nhc2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9jYXNlO1xuICAgICAgICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICAgICAgICBub2RlLmNhc2VzLnB1c2goY3VyID0gdGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICAgIGN1ci5jb25zZXF1ZW50ID0gW107XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgICAgY3VyLnRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzYXdEZWZhdWx0KSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLmxhc3RUb2tTdGFydCwgXCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXNcIik7IH1cbiAgICAgICAgICBzYXdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICBjdXIudGVzdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjdXIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgY3VyLmNvbnNlcXVlbnQucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICAgIHRoaXMubmV4dCgpOyBcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3dpdGNoU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVRocm93U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmIChsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3dcIik7IH1cbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKVxuICB9O1xuXG5cbiAgdmFyIGVtcHR5ID0gW107XG5cbiAgcHAkMS5wYXJzZVRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2F0Y2gpIHtcbiAgICAgIHZhciBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMucGFyZW5MKSkge1xuICAgICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICAgICAgdmFyIHNpbXBsZSA9IGNsYXVzZS5wYXJhbS50eXBlID09PSBcIklkZW50aWZpZXJcIjtcbiAgICAgICAgdGhpcy5lbnRlclNjb3BlKHNpbXBsZSA/IFNDT1BFX1NJTVBMRV9DQVRDSCA6IDApO1xuICAgICAgICB0aGlzLmNoZWNrTFZhbChjbGF1c2UucGFyYW0sIHNpbXBsZSA/IEJJTkRfU0lNUExFX0NBVENIIDogQklORF9MRVhJQ0FMKTtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCAxMCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICBjbGF1c2UucGFyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gICAgICB9XG4gICAgICBjbGF1c2UuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSk7XG4gICAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgICB9XG4gICAgbm9kZS5maW5hbGl6ZXIgPSB0aGlzLmVhdCh0eXBlcy5fZmluYWxseSkgPyB0aGlzLnBhcnNlQmxvY2soKSA6IG51bGw7XG4gICAgaWYgKCFub2RlLmhhbmRsZXIgJiYgIW5vZGUuZmluYWxpemVyKVxuICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlVmFyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2luZCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgfTtcblxuICBwcCQxLnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2hpbGVcIik7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldoaWxlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLm9iamVjdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2l0aFwiKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QgPSB0aGlzLmxhYmVsczsgaSQxIDwgbGlzdC5sZW5ndGg7IGkkMSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIGxhYmVsID0gbGlzdFtpJDFdO1xuXG4gICAgICBpZiAobGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKVxuICAgICAgICB7IHRoaXMucmFpc2UoZXhwci5zdGFydCwgXCJMYWJlbCAnXCIgKyBtYXliZU5hbWUgKyBcIicgaXMgYWxyZWFkeSBkZWNsYXJlZFwiKTtcbiAgICB9IH1cbiAgICB2YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gdHlwZXMuX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGxhYmVsJDEgPSB0aGlzLmxhYmVsc1tpXTtcbiAgICAgIGlmIChsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID09PSBub2RlLnN0YXJ0KSB7XG4gICAgICAgIGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBsYWJlbCQxLmtpbmQgPSBraW5kO1xuICAgICAgfSBlbHNlIHsgYnJlYWsgfVxuICAgIH1cbiAgICB0aGlzLmxhYmVscy5wdXNoKHtuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXJ0fSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChjb250ZXh0ID8gY29udGV4dC5pbmRleE9mKFwibGFiZWxcIikgPT09IC0xID8gY29udGV4dCArIFwibGFiZWxcIiA6IGNvbnRleHQgOiBcImxhYmVsXCIpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIG5vZGUubGFiZWwgPSBleHByO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBleHByKSB7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZXhwcjtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpXG4gIH07XG5cblxuICBwcCQxLnBhcnNlQmxvY2sgPSBmdW5jdGlvbihjcmVhdGVOZXdMZXhpY2FsU2NvcGUsIG5vZGUpIHtcbiAgICBpZiAoIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9PT0gdm9pZCAwICkgY3JlYXRlTmV3TGV4aWNhbFNjb3BlID0gdHJ1ZTtcbiAgICBpZiAoIG5vZGUgPT09IHZvaWQgMCApIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgbm9kZS5ib2R5ID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZW50ZXJTY29wZSgwKTsgfVxuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpO1xuICAgICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gICAgfVxuICAgIGlmIChjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHsgdGhpcy5leGl0U2NvcGUoKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKVxuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUZvciA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgICBub2RlLmluaXQgPSBpbml0O1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnNlbWkpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnNlbWkpO1xuICAgIG5vZGUudXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcy5wYXJlblIgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpXG4gIH07XG5cblxuICBwcCQxLnBhcnNlRm9ySW4gPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gICAgdmFyIGlzRm9ySW4gPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9pbjtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmIChcbiAgICAgIGluaXQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgJiZcbiAgICAgIGluaXQuZGVjbGFyYXRpb25zWzBdLmluaXQgIT0gbnVsbCAmJlxuICAgICAgKFxuICAgICAgICAhaXNGb3JJbiB8fFxuICAgICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8XG4gICAgICAgIHRoaXMuc3RyaWN0IHx8XG4gICAgICAgIGluaXQua2luZCAhPT0gXCJ2YXJcIiB8fFxuICAgICAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIlxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhpcy5yYWlzZShcbiAgICAgICAgaW5pdC5zdGFydCxcbiAgICAgICAgKChpc0ZvckluID8gXCJmb3ItaW5cIiA6IFwiZm9yLW9mXCIpICsgXCIgbG9vcCB2YXJpYWJsZSBkZWNsYXJhdGlvbiBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXJcIilcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpbml0LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIikge1xuICAgICAgdGhpcy5yYWlzZShpbml0LnN0YXJ0LCBcIkludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWxvb3BcIik7XG4gICAgfVxuICAgIG5vZGUubGVmdCA9IGluaXQ7XG4gICAgbm9kZS5yaWdodCA9IGlzRm9ySW4gPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZm9yXCIpO1xuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0ZvckluID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiKVxuICB9O1xuXG5cbiAgcHAkMS5wYXJzZVZhciA9IGZ1bmN0aW9uKG5vZGUsIGlzRm9yLCBraW5kKSB7XG4gICAgbm9kZS5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgICBub2RlLmtpbmQgPSBraW5kO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBkZWNsID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5lcSkpIHtcbiAgICAgICAgZGVjbC5pbml0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGlzRm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gXCJjb25zdFwiICYmICEodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVjbC5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiQ29tcGxleCBiaW5kaW5nIHBhdHRlcm5zIHJlcXVpcmUgYW4gaW5pdGlhbGl6YXRpb24gdmFsdWVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWNsLmluaXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuICAgICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHsgYnJlYWsgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIHBwJDEucGFyc2VWYXJJZCA9IGZ1bmN0aW9uKGRlY2wsIGtpbmQpIHtcbiAgICBkZWNsLmlkID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgdGhpcy5jaGVja0xWYWwoZGVjbC5pZCwga2luZCA9PT0gXCJ2YXJcIiA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMLCBmYWxzZSk7XG4gIH07XG5cbiAgdmFyIEZVTkNfU1RBVEVNRU5UID0gMSwgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCA9IDIsIEZVTkNfTlVMTEFCTEVfSUQgPSA0O1xuXG5cbiAgcHAkMS5wYXJzZUZ1bmN0aW9uID0gZnVuY3Rpb24obm9kZSwgc3RhdGVtZW50LCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBpc0FzeW5jKSB7XG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5IHx8IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFpc0FzeW5jKSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdGFyICYmIChzdGF0ZW1lbnQgJiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSlcbiAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbm9kZS5nZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgICBpZiAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpIHtcbiAgICAgIG5vZGUuaWQgPSAoc3RhdGVtZW50ICYgRlVOQ19OVUxMQUJMRV9JRCkgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5uYW1lID8gbnVsbCA6IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgaWYgKG5vZGUuaWQgJiYgIShzdGF0ZW1lbnQgJiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSlcbiAgICAgICAgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCAodGhpcy5zdHJpY3QgfHwgbm9kZS5nZW5lcmF0b3IgfHwgbm9kZS5hc3luYykgPyB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIgPyBCSU5EX1ZBUiA6IEJJTkRfTEVYSUNBTCA6IEJJTkRfRlVOQ1RJT04pOyB9XG4gICAgfVxuXG4gICAgdmFyIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3Mobm9kZS5hc3luYywgbm9kZS5nZW5lcmF0b3IpKTtcblxuICAgIGlmICghKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSlcbiAgICAgIHsgbm9kZS5pZCA9IHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSA/IHRoaXMucGFyc2VJZGVudCgpIDogbnVsbDsgfVxuXG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uQm9keSwgZmFsc2UpO1xuXG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQxLnBhcnNlRnVuY3Rpb25QYXJhbXMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VDbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3Q7XG4gICAgdGhpcy5zdHJpY3QgPSB0cnVlO1xuXG4gICAgdGhpcy5wYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQpO1xuICAgIHRoaXMucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICAgIHZhciBjbGFzc0JvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciBoYWRDb25zdHJ1Y3RvciA9IGZhbHNlO1xuICAgIGNsYXNzQm9keS5ib2R5ID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZUNsYXNzRWxlbWVudChub2RlLnN1cGVyQ2xhc3MgIT09IG51bGwpO1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgY2xhc3NCb2R5LmJvZHkucHVzaChlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgZWxlbWVudC5raW5kID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICBpZiAoaGFkQ29uc3RydWN0b3IpIHsgdGhpcy5yYWlzZShlbGVtZW50LnN0YXJ0LCBcIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBpbiB0aGUgc2FtZSBjbGFzc1wiKTsgfVxuICAgICAgICAgIGhhZENvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaE5vZGUoY2xhc3NCb2R5LCBcIkNsYXNzQm9keVwiKTtcbiAgICB0aGlzLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJDbGFzc0RlY2xhcmF0aW9uXCIgOiBcIkNsYXNzRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VDbGFzc0VsZW1lbnQgPSBmdW5jdGlvbihjb25zdHJ1Y3RvckFsbG93c1N1cGVyKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkpIHsgcmV0dXJuIG51bGwgfVxuXG4gICAgdmFyIG1ldGhvZCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdmFyIHRyeUNvbnRleHR1YWwgPSBmdW5jdGlvbiAoaywgbm9MaW5lQnJlYWspIHtcbiAgICAgIGlmICggbm9MaW5lQnJlYWsgPT09IHZvaWQgMCApIG5vTGluZUJyZWFrID0gZmFsc2U7XG5cbiAgICAgIHZhciBzdGFydCA9IHRoaXMkMS5zdGFydCwgc3RhcnRMb2MgPSB0aGlzJDEuc3RhcnRMb2M7XG4gICAgICBpZiAoIXRoaXMkMS5lYXRDb250ZXh0dWFsKGspKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBpZiAodGhpcyQxLnR5cGUgIT09IHR5cGVzLnBhcmVuTCAmJiAoIW5vTGluZUJyZWFrIHx8ICF0aGlzJDEuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmIChtZXRob2Qua2V5KSB7IHRoaXMkMS51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG1ldGhvZC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgbWV0aG9kLmtleSA9IHRoaXMkMS5zdGFydE5vZGVBdChzdGFydCwgc3RhcnRMb2MpO1xuICAgICAgbWV0aG9kLmtleS5uYW1lID0gaztcbiAgICAgIHRoaXMkMS5maW5pc2hOb2RlKG1ldGhvZC5rZXksIFwiSWRlbnRpZmllclwiKTtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH07XG5cbiAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgbWV0aG9kLnN0YXRpYyA9IHRyeUNvbnRleHR1YWwoXCJzdGF0aWNcIik7XG4gICAgdmFyIGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcbiAgICBpZiAoIWlzR2VuZXJhdG9yKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgdHJ5Q29udGV4dHVhbChcImFzeW5jXCIsIHRydWUpKSB7XG4gICAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgICAgICBpc0dlbmVyYXRvciA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgICAgfSBlbHNlIGlmICh0cnlDb250ZXh0dWFsKFwiZ2V0XCIpKSB7XG4gICAgICAgIG1ldGhvZC5raW5kID0gXCJnZXRcIjtcbiAgICAgIH0gZWxzZSBpZiAodHJ5Q29udGV4dHVhbChcInNldFwiKSkge1xuICAgICAgICBtZXRob2Qua2luZCA9IFwic2V0XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbWV0aG9kLmtleSkgeyB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKG1ldGhvZCk7IH1cbiAgICB2YXIga2V5ID0gbWV0aG9kLmtleTtcbiAgICB2YXIgYWxsb3dzRGlyZWN0U3VwZXIgPSBmYWxzZTtcbiAgICBpZiAoIW1ldGhvZC5jb21wdXRlZCAmJiAhbWV0aG9kLnN0YXRpYyAmJiAoa2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBcImNvbnN0cnVjdG9yXCIgfHxcbiAgICAgICAga2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGtleS52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgaWYgKG1ldGhvZC5raW5kICE9PSBcIm1ldGhvZFwiKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGhhdmUgZ2V0L3NldCBtb2RpZmllclwiKTsgfVxuICAgICAgaWYgKGlzR2VuZXJhdG9yKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gICAgICBpZiAoaXNBc3luYykgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhbiBhc3luYyBtZXRob2RcIik7IH1cbiAgICAgIG1ldGhvZC5raW5kID0gXCJjb25zdHJ1Y3RvclwiO1xuICAgICAgYWxsb3dzRGlyZWN0U3VwZXIgPSBjb25zdHJ1Y3RvckFsbG93c1N1cGVyO1xuICAgIH0gZWxzZSBpZiAobWV0aG9kLnN0YXRpYyAmJiBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYga2V5Lm5hbWUgPT09IFwicHJvdG90eXBlXCIpIHtcbiAgICAgIHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZVwiKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZUNsYXNzTWV0aG9kKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgICBpZiAobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IDApXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShtZXRob2QudmFsdWUuc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiBtZXRob2QudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5zdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShtZXRob2QudmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG4gICAgcmV0dXJuIG1ldGhvZFxuICB9O1xuXG4gIHBwJDEucGFyc2VDbGFzc01ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gICAgbWV0aG9kLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIk1ldGhvZERlZmluaXRpb25cIilcbiAgfTtcblxuICBwcCQxLnBhcnNlQ2xhc3NJZCA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSkge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgaWYgKGlzU3RhdGVtZW50KVxuICAgICAgICB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIEJJTkRfTEVYSUNBTCwgZmFsc2UpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1N0YXRlbWVudCA9PT0gdHJ1ZSlcbiAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbm9kZS5pZCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHBwJDEucGFyc2VDbGFzc1N1cGVyID0gZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUuc3VwZXJDbGFzcyA9IHRoaXMuZWF0KHR5cGVzLl9leHRlbmRzKSA/IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cygpIDogbnVsbDtcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VFeHBvcnQgPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnN0YXIpKSB7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RyaW5nKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKVxuICAgIH1cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuX2RlZmF1bHQpKSB7IFxuICAgICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBcImRlZmF1bHRcIiwgdGhpcy5sYXN0VG9rU3RhcnQpO1xuICAgICAgdmFyIGlzQXN5bmM7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fZnVuY3Rpb24gfHwgKGlzQXN5bmMgPSB0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSkge1xuICAgICAgICB2YXIgZk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5uZXh0KCk7IH1cbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbihmTm9kZSwgRlVOQ19TVEFURU1FTlQgfCBGVU5DX05VTExBQkxFX0lELCBmYWxzZSwgaXNBc3luYyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2NsYXNzKSB7XG4gICAgICAgIHZhciBjTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlQ2xhc3MoY05vZGUsIFwibnVsbGFibGVJRFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIilcbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQoKSkge1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gICAgICBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgICAgICAgeyB0aGlzLmNoZWNrVmFyaWFibGVFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmlkLm5hbWUsIG5vZGUuZGVjbGFyYXRpb24uaWQuc3RhcnQpOyB9XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICB9IGVsc2UgeyBcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSBudWxsO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcnMoZXhwb3J0cyk7XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiZnJvbVwiKSkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5zcGVjaWZpZXJzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBzcGVjID0gbGlzdFtpXTtcblxuICAgICAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHNwZWMubG9jYWwpO1xuICAgICAgICAgIHRoaXMuY2hlY2tMb2NhbEV4cG9ydChzcGVjLmxvY2FsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpXG4gIH07XG5cbiAgcHAkMS5jaGVja0V4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIHBvcykge1xuICAgIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICAgIGlmIChoYXMoZXhwb3J0cywgbmFtZSkpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIFwiRHVwbGljYXRlIGV4cG9ydCAnXCIgKyBuYW1lICsgXCInXCIpOyB9XG4gICAgZXhwb3J0c1tuYW1lXSA9IHRydWU7XG4gIH07XG5cbiAgcHAkMS5jaGVja1BhdHRlcm5FeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBwYXQpIHtcbiAgICB2YXIgdHlwZSA9IHBhdC50eXBlO1xuICAgIGlmICh0eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBwYXQubmFtZSwgcGF0LnN0YXJ0KTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhdC5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHByb3ApO1xuICAgICAgICB9IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIkFycmF5UGF0dGVyblwiKVxuICAgICAgeyBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBwYXQuZWxlbWVudHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciBlbHQgPSBsaXN0JDFbaSQxXTtcblxuICAgICAgICAgIGlmIChlbHQpIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZWx0KTsgfVxuICAgICAgfSB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJQcm9wZXJ0eVwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQudmFsdWUpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQubGVmdCk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5hcmd1bWVudCk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5leHByZXNzaW9uKTsgfVxuICB9O1xuXG4gIHBwJDEuY2hlY2tWYXJpYWJsZUV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlY2xzKSB7XG4gICAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBkZWNsczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgZGVjbCA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGRlY2wuaWQpO1xuICAgIH1cbiAgfTtcblxuICBwcCQxLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZS5rZXl3b3JkID09PSBcInZhclwiIHx8XG4gICAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJjb25zdFwiIHx8XG4gICAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJjbGFzc1wiIHx8XG4gICAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICB0aGlzLmlzTGV0KCkgfHxcbiAgICAgIHRoaXMuaXNBc3luY0Z1bmN0aW9uKClcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VFeHBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oZXhwb3J0cykge1xuICAgIHZhciBub2RlcyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikgPyB0aGlzLnBhcnNlSWRlbnQodHJ1ZSkgOiBub2RlLmxvY2FsO1xuICAgICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmV4cG9ydGVkLm5hbWUsIG5vZGUuZXhwb3J0ZWQuc3RhcnQpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VJbXBvcnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nKSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBlbXB0eTtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlY2xhcmF0aW9uXCIpXG4gIH07XG5cblxuICBwcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlcyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgdGhpcy5jaGVja0xWYWwobm9kZS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSk7XG4gICAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyByZXR1cm4gbm9kZXMgfVxuICAgIH1cbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdGFyKSB7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiYXNcIik7XG4gICAgICBub2RlJDEubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUkMS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikpO1xuICAgICAgcmV0dXJuIG5vZGVzXG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUkMi5pbXBvcnRlZCA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgICBub2RlJDIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUkMi5pbXBvcnRlZCk7XG4gICAgICAgIG5vZGUkMi5sb2NhbCA9IG5vZGUkMi5pbXBvcnRlZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUkMi5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJJbXBvcnRTcGVjaWZpZXJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfTtcblxuICBwcCQxLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUgPSBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aCAmJiB0aGlzLmlzRGlyZWN0aXZlQ2FuZGlkYXRlKHN0YXRlbWVudHNbaV0pOyArK2kpIHtcbiAgICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gICAgfVxuICB9O1xuICBwcCQxLmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHN0YXRlbWVudC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJlxuICAgICAgc3RhdGVtZW50LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiZcbiAgICAgIHR5cGVvZiBzdGF0ZW1lbnQuZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgKHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCJcXFwiXCIgfHwgdGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIidcIilcbiAgICApXG4gIH07XG5cbiAgdmFyIHBwJDIgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5cbiAgcHAkMi50b0Fzc2lnbmFibGUgPSBmdW5jdGlvbihub2RlLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbm9kZSkge1xuICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgIGlmICh0aGlzLmluQXN5bmMgJiYgbm9kZS5uYW1lID09PSBcImF3YWl0XCIpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBpc0JpbmRpbmcpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHByb3AudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmXG4gICAgICAgICAgICAocHJvcC5hcmd1bWVudC50eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKHByb3AuYXJndW1lbnQuc3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAgIGlmIChub2RlLmtpbmQgIT09IFwiaW5pdFwiKSB7IHRoaXMucmFpc2Uobm9kZS5rZXkuc3RhcnQsIFwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBnZXR0ZXIgb3Igc2V0dGVyXCIpOyB9XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUudmFsdWUsIGlzQmluZGluZyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJBcnJheVBhdHRlcm5cIjtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KG5vZGUuZWxlbWVudHMsIGlzQmluZGluZyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiUmVzdEVsZW1lbnRcIjtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5hcmd1bWVudCwgaXNCaW5kaW5nKTtcbiAgICAgICAgaWYgKG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZShub2RlLmFyZ3VtZW50LnN0YXJ0LCBcIlJlc3QgZWxlbWVudHMgY2Fubm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAobm9kZS5vcGVyYXRvciAhPT0gXCI9XCIpIHsgdGhpcy5yYWlzZShub2RlLmxlZnQuZW5kLCBcIk9ubHkgJz0nIG9wZXJhdG9yIGNhbiBiZSB1c2VkIGZvciBzcGVjaWZ5aW5nIGRlZmF1bHQgdmFsdWUuXCIpOyB9XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICAgICAgZGVsZXRlIG5vZGUub3BlcmF0b3I7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUubGVmdCwgaXNCaW5kaW5nKTtcblxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmICghaXNCaW5kaW5nKSB7IGJyZWFrIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkFzc2lnbmluZyB0byBydmFsdWVcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuXG4gIHBwJDIudG9Bc3NpZ25hYmxlTGlzdCA9IGZ1bmN0aW9uKGV4cHJMaXN0LCBpc0JpbmRpbmcpIHtcbiAgICB2YXIgZW5kID0gZXhwckxpc3QubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBlbHQgPSBleHByTGlzdFtpXTtcbiAgICAgIGlmIChlbHQpIHsgdGhpcy50b0Fzc2lnbmFibGUoZWx0LCBpc0JpbmRpbmcpOyB9XG4gICAgfVxuICAgIGlmIChlbmQpIHtcbiAgICAgIHZhciBsYXN0ID0gZXhwckxpc3RbZW5kIC0gMV07XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID09PSA2ICYmIGlzQmluZGluZyAmJiBsYXN0ICYmIGxhc3QudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmIGxhc3QuYXJndW1lbnQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKGxhc3QuYXJndW1lbnQuc3RhcnQpOyB9XG4gICAgfVxuICAgIHJldHVybiBleHByTGlzdFxuICB9O1xuXG5cbiAgcHAkMi5wYXJzZVNwcmVhZCA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgfTtcblxuICBwcCQyLnBhcnNlUmVzdEJpbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID09PSA2ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKVxuICB9O1xuXG5cbiAgcHAkMi5wYXJzZUJpbmRpbmdBdG9tID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSB0eXBlcy5icmFja2V0TDpcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVBhdHRlcm5cIilcblxuICAgICAgY2FzZSB0eXBlcy5icmFjZUw6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKHRydWUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnQoKVxuICB9O1xuXG4gIHBwJDIucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd0VtcHR5LCBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcbiAgICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmIChmaXJzdCkgeyBmaXJzdCA9IGZhbHNlOyB9XG4gICAgICBlbHNlIHsgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpOyB9XG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICAgIGVsdHMucHVzaChudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVsbGlwc2lzKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5wYXJzZVJlc3RCaW5kaW5nKCk7XG4gICAgICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0ocmVzdCk7XG4gICAgICAgIGVsdHMucHVzaChyZXN0KTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgICB0aGlzLmV4cGVjdChjbG9zZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWxlbSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYyk7XG4gICAgICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0oZWxlbSk7XG4gICAgICAgIGVsdHMucHVzaChlbGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsdHNcbiAgfTtcblxuICBwcCQyLnBhcnNlQmluZGluZ0xpc3RJdGVtID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICByZXR1cm4gcGFyYW1cbiAgfTtcblxuXG4gIHBwJDIucGFyc2VNYXliZURlZmF1bHQgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBsZWZ0ID0gbGVmdCB8fCB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5lYXQodHlwZXMuZXEpKSB7IHJldHVybiBsZWZ0IH1cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgfTtcblxuXG4gIHBwJDIuY2hlY2tMVmFsID0gZnVuY3Rpb24oZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcykge1xuICAgIGlmICggYmluZGluZ1R5cGUgPT09IHZvaWQgMCApIGJpbmRpbmdUeXBlID0gQklORF9OT05FO1xuXG4gICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwgJiYgZXhwci5uYW1lID09PSBcImxldFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcImxldCBpcyBkaXNhbGxvd2VkIGFzIGEgbGV4aWNhbGx5IGJvdW5kIG5hbWVcIik7IH1cbiAgICAgIGlmICh0aGlzLnN0cmljdCAmJiB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kLnRlc3QoZXhwci5uYW1lKSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgKGJpbmRpbmdUeXBlID8gXCJCaW5kaW5nIFwiIDogXCJBc3NpZ25pbmcgdG8gXCIpICsgZXhwci5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICAgIGlmIChjaGVja0NsYXNoZXMpIHtcbiAgICAgICAgaWYgKGhhcyhjaGVja0NsYXNoZXMsIGV4cHIubmFtZSkpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJBcmd1bWVudCBuYW1lIGNsYXNoXCIpOyB9XG4gICAgICAgIGNoZWNrQ2xhc2hlc1tleHByLm5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kaW5nVHlwZSAhPT0gQklORF9OT05FICYmIGJpbmRpbmdUeXBlICE9PSBCSU5EX09VVFNJREUpIHsgdGhpcy5kZWNsYXJlTmFtZShleHByLm5hbWUsIGJpbmRpbmdUeXBlLCBleHByLnN0YXJ0KTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBpZiAoYmluZGluZ1R5cGUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQmluZGluZyBtZW1iZXIgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGV4cHIucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICAgIHtcbiAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5jaGVja0xWYWwocHJvcCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci52YWx1ZSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gZXhwci5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIGVsZW0gPSBsaXN0JDFbaSQxXTtcblxuICAgICAgaWYgKGVsZW0pIHsgdGhpcy5jaGVja0xWYWwoZWxlbSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7IH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIubGVmdCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLmFyZ3VtZW50LCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMucmFpc2UoZXhwci5zdGFydCwgKGJpbmRpbmdUeXBlID8gXCJCaW5kaW5nXCIgOiBcIkFzc2lnbmluZyB0b1wiKSArIFwiIHJ2YWx1ZVwiKTtcbiAgICB9XG4gIH07XG5cblxuICB2YXIgcHAkMyA9IFBhcnNlci5wcm90b3R5cGU7XG5cblxuICBwcCQzLmNoZWNrUHJvcENsYXNoID0gZnVuY3Rpb24ocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgcHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICAgIHsgcmV0dXJuIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgKHByb3AuY29tcHV0ZWQgfHwgcHJvcC5tZXRob2QgfHwgcHJvcC5zaG9ydGhhbmQpKVxuICAgICAgeyByZXR1cm4gfVxuICAgIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgICB2YXIgbmFtZTtcbiAgICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjogbmFtZSA9IGtleS5uYW1lOyBicmVha1xuICAgIGNhc2UgXCJMaXRlcmFsXCI6IG5hbWUgPSBTdHJpbmcoa2V5LnZhbHVlKTsgYnJlYWtcbiAgICBkZWZhdWx0OiByZXR1cm5cbiAgICB9XG4gICAgdmFyIGtpbmQgPSBwcm9wLmtpbmQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIiAmJiBraW5kID09PSBcImluaXRcIikge1xuICAgICAgICBpZiAocHJvcEhhc2gucHJvdG8pIHtcbiAgICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPCAwKVxuICAgICAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSBrZXkuc3RhcnQ7IH1cbiAgICAgICAgICB9IGVsc2UgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbiAgICAgICAgfVxuICAgICAgICBwcm9wSGFzaC5wcm90byA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbmFtZSA9IFwiJFwiICsgbmFtZTtcbiAgICB2YXIgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXTtcbiAgICBpZiAob3RoZXIpIHtcbiAgICAgIHZhciByZWRlZmluaXRpb247XG4gICAgICBpZiAoa2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgICAgcmVkZWZpbml0aW9uID0gdGhpcy5zdHJpY3QgJiYgb3RoZXIuaW5pdCB8fCBvdGhlci5nZXQgfHwgb3RoZXIuc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVkZWZpbml0aW9uID0gb3RoZXIuaW5pdCB8fCBvdGhlcltraW5kXTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWRlZmluaXRpb24pXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHlcIik7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXSA9IHtcbiAgICAgICAgaW5pdDogZmFsc2UsXG4gICAgICAgIGdldDogZmFsc2UsXG4gICAgICAgIHNldDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIG90aGVyW2tpbmRdID0gdHJ1ZTtcbiAgfTtcblxuXG5cblxuICBwcCQzLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcbiAgICAgIHdoaWxlICh0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHsgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSk7IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIilcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VNYXliZUFzc2lnbiA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwieWllbGRcIikpIHtcbiAgICAgIGlmICh0aGlzLmluR2VuZXJhdG9yKSB7IHJldHVybiB0aGlzLnBhcnNlWWllbGQobm9JbikgfVxuICAgICAgZWxzZSB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICAgIH1cblxuICAgIHZhciBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gZmFsc2UsIG9sZFBhcmVuQXNzaWduID0gLTEsIG9sZFRyYWlsaW5nQ29tbWEgPSAtMTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgb2xkUGFyZW5Bc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ247XG4gICAgICBvbGRUcmFpbGluZ0NvbW1hID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hO1xuICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgfHwgdGhpcy50eXBlID09PSB0eXBlcy5uYW1lKVxuICAgICAgeyB0aGlzLnBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXJ0OyB9XG4gICAgdmFyIGxlZnQgPSB0aGlzLnBhcnNlTWF5YmVDb25kaXRpb25hbChub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIHsgbGVmdCA9IGFmdGVyTGVmdFBhcnNlLmNhbGwodGhpcywgbGVmdCwgc3RhcnRQb3MsIHN0YXJ0TG9jKTsgfVxuICAgIGlmICh0aGlzLnR5cGUuaXNBc3NpZ24pIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgICBub2RlLmxlZnQgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmVxID8gdGhpcy50b0Fzc2lnbmFibGUobGVmdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIDogbGVmdDtcbiAgICAgIGlmICghb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0gLTE7XG4gICAgICB9XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPj0gbm9kZS5sZWZ0LnN0YXJ0KVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7IH0gXG4gICAgICB0aGlzLmNoZWNrTFZhbChsZWZ0KTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgIH1cbiAgICBpZiAob2xkUGFyZW5Bc3NpZ24gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBvbGRQYXJlbkFzc2lnbjsgfVxuICAgIGlmIChvbGRUcmFpbGluZ0NvbW1hID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gb2xkVHJhaWxpbmdDb21tYTsgfVxuICAgIHJldHVybiBsZWZ0XG4gIH07XG5cblxuICBwcCQzLnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICAgICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH07XG5cblxuICBwcCQzLnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgICByZXR1cm4gZXhwci5zdGFydCA9PT0gc3RhcnRQb3MgJiYgZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgPyBleHByIDogdGhpcy5wYXJzZUV4cHJPcChleHByLCBzdGFydFBvcywgc3RhcnRMb2MsIC0xLCBub0luKVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZUV4cHJPcCA9IGZ1bmN0aW9uKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKSB7XG4gICAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gICAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIW5vSW4gfHwgdGhpcy50eXBlICE9PSB0eXBlcy5faW4pKSB7XG4gICAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgICAgdmFyIGxvZ2ljYWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxPUiB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxBTkQ7XG4gICAgICAgIHZhciBvcCA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpLCBzdGFydFBvcywgc3RhcnRMb2MsIHByZWMsIG5vSW4pO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYnVpbGRCaW5hcnkobGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIGxlZnQsIHJpZ2h0LCBvcCwgbG9naWNhbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKG5vZGUsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVmdFxuICB9O1xuXG4gIHBwJDMuYnVpbGRCaW5hcnkgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQsIHJpZ2h0LCBvcCwgbG9naWNhbCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgbm9kZS5vcGVyYXRvciA9IG9wO1xuICAgIG5vZGUucmlnaHQgPSByaWdodDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGxvZ2ljYWwgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgOiBcIkJpbmFyeUV4cHJlc3Npb25cIilcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VNYXliZVVuYXJ5ID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgc2F3VW5hcnkpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGV4cHI7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiYXdhaXRcIikgJiYgKHRoaXMuaW5Bc3luYyB8fCAoIXRoaXMuaW5GdW5jdGlvbiAmJiB0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbikpKSB7XG4gICAgICBleHByID0gdGhpcy5wYXJzZUF3YWl0KCk7XG4gICAgICBzYXdVbmFyeSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUucHJlZml4KSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIHVwZGF0ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuaW5jRGVjO1xuICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgICBub2RlLnByZWZpeCA9IHRydWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlKTtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgaWYgKHVwZGF0ZSkgeyB0aGlzLmNoZWNrTFZhbChub2RlLmFyZ3VtZW50KTsgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJlxuICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudC50eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgICAgZWxzZSB7IHNhd1VuYXJ5ID0gdHJ1ZTsgfVxuICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlLCB1cGRhdGUgPyBcIlVwZGF0ZUV4cHJlc3Npb25cIiA6IFwiVW5hcnlFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgICAgIHdoaWxlICh0aGlzLnR5cGUucG9zdGZpeCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICBub2RlJDEub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgICBub2RlJDEucHJlZml4ID0gZmFsc2U7XG4gICAgICAgIG5vZGUkMS5hcmd1bWVudCA9IGV4cHI7XG4gICAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNhd1VuYXJ5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXJzdGFyKSlcbiAgICAgIHsgcmV0dXJuIHRoaXMuYnVpbGRCaW5hcnkoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByLCB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSksIFwiKipcIiwgZmFsc2UpIH1cbiAgICBlbHNlXG4gICAgICB7IHJldHVybiBleHByIH1cbiAgfTtcblxuXG4gIHBwJDMucGFyc2VFeHByU3Vic2NyaXB0cyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva0VuZCkgIT09IFwiKVwiKVxuICAgICAgeyByZXR1cm4gZXhwciB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVzdWx0LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSAtMTsgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSAtMTsgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH07XG5cbiAgcHAkMy5wYXJzZVN1YnNjcmlwdHMgPSBmdW5jdGlvbihiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMpIHtcbiAgICB2YXIgbWF5YmVBc3luY0Fycm93ID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgYmFzZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBiYXNlLm5hbWUgPT09IFwiYXN5bmNcIiAmJlxuICAgICAgICB0aGlzLmxhc3RUb2tFbmQgPT09IGJhc2UuZW5kICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuaW5wdXQuc2xpY2UoYmFzZS5zdGFydCwgYmFzZS5lbmQpID09PSBcImFzeW5jXCI7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIG1heWJlQXN5bmNBcnJvdyk7XG4gICAgICBpZiAoZWxlbWVudCA9PT0gYmFzZSB8fCBlbGVtZW50LnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikgeyByZXR1cm4gZWxlbWVudCB9XG4gICAgICBiYXNlID0gZWxlbWVudDtcbiAgICB9XG4gIH07XG5cbiAgcHAkMy5wYXJzZVN1YnNjcmlwdCA9IGZ1bmN0aW9uKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgbWF5YmVBc3luY0Fycm93KSB7XG4gICAgdmFyIGNvbXB1dGVkID0gdGhpcy5lYXQodHlwZXMuYnJhY2tldEwpO1xuICAgIGlmIChjb21wdXRlZCB8fCB0aGlzLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICAgIG5vZGUucHJvcGVydHkgPSBjb21wdXRlZCA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlSWRlbnQodGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IFwibmV2ZXJcIik7XG4gICAgICBub2RlLmNvbXB1dGVkID0gISFjb21wdXRlZDtcbiAgICAgIGlmIChjb21wdXRlZCkgeyB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7IH1cbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQodHlwZXMucGFyZW5MKSkge1xuICAgICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycywgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICAgIHZhciBleHByTGlzdCA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcy5wYXJlblIsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAobWF5YmVBc3luY0Fycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICAgIGlmICh0aGlzLmF3YWl0SWRlbnRQb3MgPiAwKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0SWRlbnRQb3MsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0LCB0cnVlKVxuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzLmF3YWl0UG9zO1xuICAgICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcyB8fCB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQxLmNhbGxlZSA9IGJhc2U7XG4gICAgICBub2RlJDEuYXJndW1lbnRzID0gZXhwckxpc3Q7XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuYmFja1F1b3RlKSB7XG4gICAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQyLnRhZyA9IGJhc2U7XG4gICAgICBub2RlJDIucXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGUoe2lzVGFnZ2VkOiB0cnVlfSk7XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBiYXNlXG4gIH07XG5cblxuICBwcCQzLnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc2xhc2gpIHsgdGhpcy5yZWFkUmVnZXhwKCk7IH1cblxuICAgIHZhciBub2RlLCBjYW5CZUFycm93ID0gdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXJ0O1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgY2FzZSB0eXBlcy5fc3VwZXI6XG4gICAgICBpZiAoIXRoaXMuYWxsb3dTdXBlcilcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBrZXl3b3JkIG91dHNpZGUgYSBtZXRob2RcIik7IH1cbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgJiYgIXRoaXMuYWxsb3dEaXJlY3RTdXBlcilcbiAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwic3VwZXIoKSBjYWxsIG91dHNpZGUgY29uc3RydWN0b3Igb2YgYSBzdWJjbGFzc1wiKTsgfVxuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuZG90ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2tldEwgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5wYXJlbkwpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTdXBlclwiKVxuXG4gICAgY2FzZSB0eXBlcy5fdGhpczpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIilcblxuICAgIGNhc2UgdHlwZXMubmFtZTpcbiAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZUlkZW50KGZhbHNlKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhY29udGFpbnNFc2MgJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLl9mdW5jdGlvbikpXG4gICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIDAsIGZhbHNlLCB0cnVlKSB9XG4gICAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICBpZiAodGhpcy5lYXQodHlwZXMuYXJyb3cpKVxuICAgICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBbaWRdLCBmYWxzZSkgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmIHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSAmJiAhY29udGFpbnNFc2MpIHtcbiAgICAgICAgICBpZCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgIXRoaXMuZWF0KHR5cGVzLmFycm93KSlcbiAgICAgICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIHRydWUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpZFxuXG4gICAgY2FzZSB0eXBlcy5yZWdleHA6XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZSA9IHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLnZhbHVlKTtcbiAgICAgIG5vZGUucmVnZXggPSB7cGF0dGVybjogdmFsdWUucGF0dGVybiwgZmxhZ3M6IHZhbHVlLmZsYWdzfTtcbiAgICAgIHJldHVybiBub2RlXG5cbiAgICBjYXNlIHR5cGVzLm51bTogY2FzZSB0eXBlcy5zdHJpbmc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSlcblxuICAgIGNhc2UgdHlwZXMuX251bGw6IGNhc2UgdHlwZXMuX3RydWU6IGNhc2UgdHlwZXMuX2ZhbHNlOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy50eXBlID09PSB0eXBlcy5fbnVsbCA/IG51bGwgOiB0aGlzLnR5cGUgPT09IHR5cGVzLl90cnVlO1xuICAgICAgbm9kZS5yYXcgPSB0aGlzLnR5cGUua2V5d29yZDtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcblxuICAgIGNhc2UgdHlwZXMucGFyZW5MOlxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydCwgZXhwciA9IHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KTtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwICYmICF0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIpKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gc3RhcnQ7IH1cbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHN0YXJ0OyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwclxuXG4gICAgY2FzZSB0eXBlcy5icmFja2V0TDpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLmJyYWNrZXRSLCB0cnVlLCB0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheUV4cHJlc3Npb25cIilcblxuICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmooZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpXG5cbiAgICBjYXNlIHR5cGVzLl9mdW5jdGlvbjpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIDApXG5cbiAgICBjYXNlIHR5cGVzLl9jbGFzczpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3ModGhpcy5zdGFydE5vZGUoKSwgZmFsc2UpXG5cbiAgICBjYXNlIHR5cGVzLl9uZXc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU5ldygpXG5cbiAgICBjYXNlIHR5cGVzLmJhY2tRdW90ZTpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVGVtcGxhdGUoKVxuXG4gICAgY2FzZSB0eXBlcy5faW1wb3J0OlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJJbXBvcnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5leHBlY3RlZCgpXG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VFeHBySW1wb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpOyBcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHlwZXMucGFyZW5MOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VEeW5hbWljSW1wb3J0KG5vZGUpXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfTtcblxuICBwcCQzLnBhcnNlRHluYW1pY0ltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTsgXG5cbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuXG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5wYXJlblIpKSB7XG4gICAgICB2YXIgZXJyb3JQb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmNvbW1hKSAmJiB0aGlzLmVhdCh0eXBlcy5wYXJlblIpKSB7XG4gICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShlcnJvclBvcywgXCJUcmFpbGluZyBjb21tYSBpcyBub3QgYWxsb3dlZCBpbiBpbXBvcnQoKVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChlcnJvclBvcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydEV4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQzLnBhcnNlTGl0ZXJhbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICBub2RlLnJhdyA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgIGlmIChub2RlLnJhdy5jaGFyQ29kZUF0KG5vZGUucmF3Lmxlbmd0aCAtIDEpID09PSAxMTApIHsgbm9kZS5iaWdpbnQgPSBub2RlLnJhdy5zbGljZSgwLCAtMSk7IH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIHZhciB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgcmV0dXJuIHZhbFxuICB9O1xuXG4gIHBwJDMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGNhbkJlQXJyb3cpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIHZhbCwgYWxsb3dUcmFpbGluZ0NvbW1hID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDg7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgdmFyIGlubmVyU3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lclN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgIHZhciBleHByTGlzdCA9IFtdLCBmaXJzdCA9IHRydWUsIGxhc3RJc0NvbW1hID0gZmFsc2U7XG4gICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgc3ByZWFkU3RhcnQ7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5SKSB7XG4gICAgICAgIGZpcnN0ID8gZmlyc3QgPSBmYWxzZSA6IHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5wYXJlblIsIHRydWUpKSB7XG4gICAgICAgICAgbGFzdElzQ29tbWEgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICAgIHNwcmVhZFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVJlc3RCaW5kaW5nKCkpKTtcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdGhpcy5wYXJzZVBhcmVuSXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaW5uZXJFbmRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lckVuZExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuXG4gICAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5hcnJvdykpIHtcbiAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFycm93TGlzdChzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KVxuICAgICAgfVxuXG4gICAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCB8fCBsYXN0SXNDb21tYSkgeyB0aGlzLnVuZXhwZWN0ZWQodGhpcy5sYXN0VG9rU3RhcnQpOyB9XG4gICAgICBpZiAoc3ByZWFkU3RhcnQpIHsgdGhpcy51bmV4cGVjdGVkKHNwcmVhZFN0YXJ0KTsgfVxuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzLmF3YWl0UG9zO1xuXG4gICAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgICB2YWwuZXhwcmVzc2lvbnMgPSBleHByTGlzdDtcbiAgICAgICAgdGhpcy5maW5pc2hOb2RlQXQodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBpbm5lckVuZFBvcywgaW5uZXJFbmRMb2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgICB2YXIgcGFyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgcGFyLmV4cHJlc3Npb24gPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VQYXJlbkl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1cbiAgfTtcblxuICBwcCQzLnBhcnNlUGFyZW5BcnJvd0xpc3QgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdClcbiAgfTtcblxuXG4gIHZhciBlbXB0eSQxID0gW107XG5cbiAgcHAkMy5wYXJzZU5ldyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIG5ld1wiKTsgfVxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB2YXIgbWV0YSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgICAgbm9kZS5tZXRhID0gbWV0YTtcbiAgICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgICAgaWYgKG5vZGUucHJvcGVydHkubmFtZSAhPT0gXCJ0YXJnZXRcIiB8fCBjb250YWluc0VzYylcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5wcm9wZXJ0eS5zdGFydCwgXCJUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciBuZXcgaXMgbmV3LnRhcmdldFwiKTsgfVxuICAgICAgaWYgKCF0aGlzLmluTm9uQXJyb3dGdW5jdGlvbigpKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIm5ldy50YXJnZXQgY2FuIG9ubHkgYmUgdXNlZCBpbiBmdW5jdGlvbnNcIik7IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIilcbiAgICB9XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBpc0ltcG9ydCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX2ltcG9ydDtcbiAgICBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMucGFyc2VFeHByQXRvbSgpLCBzdGFydFBvcywgc3RhcnRMb2MsIHRydWUpO1xuICAgIGlmIChpc0ltcG9ydCAmJiBub2RlLmNhbGxlZS50eXBlID09PSBcIkltcG9ydEV4cHJlc3Npb25cIikge1xuICAgICAgdGhpcy5yYWlzZShzdGFydFBvcywgXCJDYW5ub3QgdXNlIG5ldyB3aXRoIGltcG9ydCgpXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lYXQodHlwZXMucGFyZW5MKSkgeyBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcy5wYXJlblIsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4LCBmYWxzZSk7IH1cbiAgICBlbHNlIHsgbm9kZS5hcmd1bWVudHMgPSBlbXB0eSQxOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIilcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbihyZWYpIHtcbiAgICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7XG5cbiAgICB2YXIgZWxlbSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuaW52YWxpZFRlbXBsYXRlKSB7XG4gICAgICBpZiAoIWlzVGFnZ2VkKSB7XG4gICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkJhZCBlc2NhcGUgc2VxdWVuY2UgaW4gdW50YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTtcbiAgICAgIH1cbiAgICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICAgIHJhdzogdGhpcy52YWx1ZSxcbiAgICAgICAgY29va2VkOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgICByYXc6IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIiksXG4gICAgICAgIGNvb2tlZDogdGhpcy52YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgZWxlbS50YWlsID0gdGhpcy50eXBlID09PSB0eXBlcy5iYWNrUXVvdGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VUZW1wbGF0ZSA9IGZ1bmN0aW9uKHJlZikge1xuICAgIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7IGlmICggaXNUYWdnZWQgPT09IHZvaWQgMCApIGlzVGFnZ2VkID0gZmFsc2U7XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtdO1xuICAgIHZhciBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDogaXNUYWdnZWR9KTtcbiAgICBub2RlLnF1YXNpcyA9IFtjdXJFbHRdO1xuICAgIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVvZikgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpOyB9XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5kb2xsYXJCcmFjZUwpO1xuICAgICAgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VFeHByZXNzaW9uKCkpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VSKTtcbiAgICAgIG5vZGUucXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSkpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpXG4gIH07XG5cbiAgcHAkMy5pc0FzeW5jUHJvcCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcHJvcC5rZXkubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuYnJhY2tldEwgfHwgdGhpcy50eXBlLmtleXdvcmQgfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuc3RhcikpICYmXG4gICAgICAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZU9iaiA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlLCBwcm9wSGFzaCA9IHt9O1xuICAgIG5vZGUucHJvcGVydGllcyA9IFtdO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgdmFyIHByb3AgPSB0aGlzLnBhcnNlUHJvcGVydHkoaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmICghaXNQYXR0ZXJuKSB7IHRoaXMuY2hlY2tQcm9wQ2xhc2gocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpOyB9XG4gICAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1BhdHRlcm4gPyBcIk9iamVjdFBhdHRlcm5cIiA6IFwiT2JqZWN0RXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VQcm9wZXJ0eSA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBwcm9wID0gdGhpcy5zdGFydE5vZGUoKSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYztcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlJlc3RFbGVtZW50XCIpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDwgMCkge1xuICAgICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKSB7XG4gICAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiU3ByZWFkRWxlbWVudFwiKVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgICBwcm9wLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgICAgaWYgKGlzUGF0dGVybiB8fCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGFydDtcbiAgICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1BhdHRlcm4pXG4gICAgICAgIHsgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTsgfVxuICAgIH1cbiAgICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgaWYgKCFpc1BhdHRlcm4gJiYgIWNvbnRhaW5zRXNjICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFpc0dlbmVyYXRvciAmJiB0aGlzLmlzQXN5bmNQcm9wKHByb3ApKSB7XG4gICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgIGlzR2VuZXJhdG9yID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3AsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0FzeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucGFyc2VQcm9wZXJ0eVZhbHVlKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJQcm9wZXJ0eVwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24ocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYykge1xuICAgIGlmICgoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb2xvbilcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5jb2xvbikpIHtcbiAgICAgIHByb3AudmFsdWUgPSBpc1BhdHRlcm4gPyB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgICAgcHJvcC5tZXRob2QgPSB0cnVlO1xuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuICAgIH0gZWxzZSBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiZcbiAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgICAgICAgICAgICAocHJvcC5rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBwcm9wLmtleS5uYW1lID09PSBcInNldFwiKSAmJlxuICAgICAgICAgICAgICAgKHRoaXMudHlwZSAhPT0gdHlwZXMuY29tbWEgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZVIpKSB7XG4gICAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcHJvcC5raW5kID0gcHJvcC5rZXkubmFtZTtcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChmYWxzZSk7XG4gICAgICB2YXIgcGFyYW1Db3VudCA9IHByb3Aua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICAgICAgaWYgKHByb3AudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBwcm9wLnZhbHVlLnN0YXJ0O1xuICAgICAgICBpZiAocHJvcC5raW5kID09PSBcImdldFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJzZXRcIiAmJiBwcm9wLnZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocHJvcC52YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQocHJvcC5rZXkpO1xuICAgICAgaWYgKHByb3Aua2V5Lm5hbWUgPT09IFwiYXdhaXRcIiAmJiAhdGhpcy5hd2FpdElkZW50UG9zKVxuICAgICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IHN0YXJ0UG9zOyB9XG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcm9wLmtleSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZXEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSB0aGlzLnN0YXJ0OyB9XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC52YWx1ZSA9IHByb3Aua2V5O1xuICAgICAgfVxuICAgICAgcHJvcC5zaG9ydGhhbmQgPSB0cnVlO1xuICAgIH0gZWxzZSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cbiAgcHAkMy5wYXJzZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5icmFja2V0TCkpIHtcbiAgICAgICAgcHJvcC5jb21wdXRlZCA9IHRydWU7XG4gICAgICAgIHByb3Aua2V5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcbiAgICAgICAgcmV0dXJuIHByb3Aua2V5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wLmtleSA9IHRoaXMudHlwZSA9PT0gdHlwZXMubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnQodGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IFwibmV2ZXJcIilcbiAgfTtcblxuXG4gIHBwJDMuaW5pdEZ1bmN0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUuaWQgPSBudWxsO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyBub2RlLmdlbmVyYXRvciA9IG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSBmYWxzZTsgfVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZU1ldGhvZCA9IGZ1bmN0aW9uKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd0RpcmVjdFN1cGVyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICAgIHsgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikgfCBTQ09QRV9TVVBFUiB8IChhbGxvd0RpcmVjdFN1cGVyID8gU0NPUEVfRElSRUNUX1NVUEVSIDogMCkpO1xuXG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlLCB0cnVlKTtcblxuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cblxuICBwcCQzLnBhcnNlQXJyb3dFeHByZXNzaW9uID0gZnVuY3Rpb24obm9kZSwgcGFyYW1zLCBpc0FzeW5jKSB7XG4gICAgdmFyIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuXG4gICAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgZmFsc2UpIHwgU0NPUEVfQVJST1cpO1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCkgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuXG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnRvQXNzaWduYWJsZUxpc3QocGFyYW1zLCB0cnVlKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIHRydWUsIGZhbHNlKTtcblxuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIilcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VGdW5jdGlvbkJvZHkgPSBmdW5jdGlvbihub2RlLCBpc0Fycm93RnVuY3Rpb24sIGlzTWV0aG9kKSB7XG4gICAgdmFyIGlzRXhwcmVzc2lvbiA9IGlzQXJyb3dGdW5jdGlvbiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlTDtcbiAgICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3QsIHVzZVN0cmljdCA9IGZhbHNlO1xuXG4gICAgaWYgKGlzRXhwcmVzc2lvbikge1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSB0cnVlO1xuICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub25TaW1wbGUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiAhdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcyk7XG4gICAgICBpZiAoIW9sZFN0cmljdCB8fCBub25TaW1wbGUpIHtcbiAgICAgICAgdXNlU3RyaWN0ID0gdGhpcy5zdHJpY3REaXJlY3RpdmUodGhpcy5lbmQpO1xuICAgICAgICBpZiAodXNlU3RyaWN0ICYmIG5vblNpbXBsZSlcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIklsbGVnYWwgJ3VzZSBzdHJpY3QnIGRpcmVjdGl2ZSBpbiBmdW5jdGlvbiB3aXRoIG5vbi1zaW1wbGUgcGFyYW1ldGVyIGxpc3RcIik7IH1cbiAgICAgIH1cbiAgICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgICBpZiAodXNlU3RyaWN0KSB7IHRoaXMuc3RyaWN0ID0gdHJ1ZTsgfVxuXG4gICAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsICFvbGRTdHJpY3QgJiYgIXVzZVN0cmljdCAmJiAhaXNBcnJvd0Z1bmN0aW9uICYmICFpc01ldGhvZCAmJiB0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKSk7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5LmJvZHkpO1xuICAgICAgdGhpcy5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgfVxuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG5cbiAgICBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5pZCkgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBCSU5EX09VVFNJREUpOyB9XG4gICAgdGhpcy5zdHJpY3QgPSBvbGRTdHJpY3Q7XG4gIH07XG5cbiAgcHAkMy5pc1NpbXBsZVBhcmFtTGlzdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICAgIGlmIChwYXJhbS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgeyByZXR1cm4gZmFsc2VcbiAgICB9IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG5cbiAgcHAkMy5jaGVja1BhcmFtcyA9IGZ1bmN0aW9uKG5vZGUsIGFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBuYW1lSGFzaCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5jaGVja0xWYWwocGFyYW0sIEJJTkRfVkFSLCBhbGxvd0R1cGxpY2F0ZXMgPyBudWxsIDogbmFtZUhhc2gpO1xuICAgIH1cbiAgfTtcblxuXG4gIHBwJDMucGFyc2VFeHByTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHksIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBlbHQgPSAodm9pZCAwKTtcbiAgICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpXG4gICAgICAgIHsgZWx0ID0gbnVsbDsgfVxuICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICBlbHQgPSB0aGlzLnBhcnNlU3ByZWFkKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA8IDApXG4gICAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0OyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgfVxuICAgICAgZWx0cy5wdXNoKGVsdCk7XG4gICAgfVxuICAgIHJldHVybiBlbHRzXG4gIH07XG5cbiAgcHAkMy5jaGVja1VucmVzZXJ2ZWQgPSBmdW5jdGlvbihyZWYpIHtcbiAgICB2YXIgc3RhcnQgPSByZWYuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IHJlZi5lbmQ7XG4gICAgdmFyIG5hbWUgPSByZWYubmFtZTtcblxuICAgIGlmICh0aGlzLmluR2VuZXJhdG9yICYmIG5hbWUgPT09IFwieWllbGRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ3lpZWxkJyBhcyBpZGVudGlmaWVyIGluc2lkZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgIGlmICh0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgaWYgKHRoaXMua2V5d29yZHMudGVzdChuYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZShzdGFydCwgKFwiVW5leHBlY3RlZCBrZXl3b3JkICdcIiArIG5hbWUgKyBcIidcIikpOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgJiZcbiAgICAgIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCkuaW5kZXhPZihcIlxcXFxcIikgIT09IC0xKSB7IHJldHVybiB9XG4gICAgdmFyIHJlID0gdGhpcy5zdHJpY3QgPyB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgOiB0aGlzLnJlc2VydmVkV29yZHM7XG4gICAgaWYgKHJlLnRlc3QobmFtZSkpIHtcbiAgICAgIGlmICghdGhpcy5pbkFzeW5jICYmIG5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSBrZXl3b3JkICdhd2FpdCcgb3V0c2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCAoXCJUaGUga2V5d29yZCAnXCIgKyBuYW1lICsgXCInIGlzIHJlc2VydmVkXCIpKTtcbiAgICB9XG4gIH07XG5cblxuICBwcCQzLnBhcnNlSWRlbnQgPSBmdW5jdGlvbihsaWJlcmFsLCBpc0JpbmRpbmcpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSkge1xuICAgICAgbm9kZS5uYW1lID0gdGhpcy52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5rZXl3b3JkKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnR5cGUua2V5d29yZDtcblxuICAgICAgaWYgKChub2RlLm5hbWUgPT09IFwiY2xhc3NcIiB8fCBub2RlLm5hbWUgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgICAodGhpcy5sYXN0VG9rRW5kICE9PSB0aGlzLmxhc3RUb2tTdGFydCArIDEgfHwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubGFzdFRva1N0YXJ0KSAhPT0gNDYpKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHRoaXMubmV4dCghIWxpYmVyYWwpO1xuICAgIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIik7XG4gICAgaWYgKCFsaWJlcmFsKSB7XG4gICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChub2RlKTtcbiAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiYXdhaXRcIiAmJiAhdGhpcy5hd2FpdElkZW50UG9zKVxuICAgICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IG5vZGUuc3RhcnQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VZaWVsZCA9IGZ1bmN0aW9uKG5vSW4pIHtcbiAgICBpZiAoIXRoaXMueWllbGRQb3MpIHsgdGhpcy55aWVsZFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zZW1pIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RhciAmJiAhdGhpcy50eXBlLnN0YXJ0c0V4cHIpKSB7XG4gICAgICBub2RlLmRlbGVnYXRlID0gZmFsc2U7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5kZWxlZ2F0ZSA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VBd2FpdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5hd2FpdFBvcykgeyB0aGlzLmF3YWl0UG9zID0gdGhpcy5zdGFydDsgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkF3YWl0RXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHZhciBwcCQ0ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuXG4gIHBwJDQucmFpc2UgPSBmdW5jdGlvbihwb3MsIG1lc3NhZ2UpIHtcbiAgICB2YXIgbG9jID0gZ2V0TGluZUluZm8odGhpcy5pbnB1dCwgcG9zKTtcbiAgICBtZXNzYWdlICs9IFwiIChcIiArIGxvYy5saW5lICsgXCI6XCIgKyBsb2MuY29sdW1uICsgXCIpXCI7XG4gICAgdmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlKTtcbiAgICBlcnIucG9zID0gcG9zOyBlcnIubG9jID0gbG9jOyBlcnIucmFpc2VkQXQgPSB0aGlzLnBvcztcbiAgICB0aHJvdyBlcnJcbiAgfTtcblxuICBwcCQ0LnJhaXNlUmVjb3ZlcmFibGUgPSBwcCQ0LnJhaXNlO1xuXG4gIHBwJDQuY3VyUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmN1ckxpbmUsIHRoaXMucG9zIC0gdGhpcy5saW5lU3RhcnQpXG4gICAgfVxuICB9O1xuXG4gIHZhciBwcCQ1ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICB2YXIgU2NvcGUgPSBmdW5jdGlvbiBTY29wZShmbGFncykge1xuICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB0aGlzLnZhciA9IFtdO1xuICAgIHRoaXMubGV4aWNhbCA9IFtdO1xuICAgIHRoaXMuZnVuY3Rpb25zID0gW107XG4gIH07XG5cblxuICBwcCQ1LmVudGVyU2NvcGUgPSBmdW5jdGlvbihmbGFncykge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wdXNoKG5ldyBTY29wZShmbGFncykpO1xuICB9O1xuXG4gIHBwJDUuZXhpdFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xuICB9O1xuXG4gIHBwJDUudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUgPSBmdW5jdGlvbihzY29wZSkge1xuICAgIHJldHVybiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgfHwgIXRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVE9QKVxuICB9O1xuXG4gIHBwJDUuZGVjbGFyZU5hbWUgPSBmdW5jdGlvbihuYW1lLCBiaW5kaW5nVHlwZSwgcG9zKSB7XG4gICAgdmFyIHJlZGVjbGFyZWQgPSBmYWxzZTtcbiAgICBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfTEVYSUNBTCkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICAgIHJlZGVjbGFyZWQgPSBzY29wZS5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlLnZhci5pbmRleE9mKG5hbWUpID4gLTE7XG4gICAgICBzY29wZS5sZXhpY2FsLnB1c2gobmFtZSk7XG4gICAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9UT1ApKVxuICAgICAgICB7IGRlbGV0ZSB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV07IH1cbiAgICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX1NJTVBMRV9DQVRDSCkge1xuICAgICAgdmFyIHNjb3BlJDEgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgICAgc2NvcGUkMS5sZXhpY2FsLnB1c2gobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9GVU5DVElPTikge1xuICAgICAgdmFyIHNjb3BlJDIgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgICAgaWYgKHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhcilcbiAgICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlJDIudmFyLmluZGV4T2YobmFtZSkgPiAtMTsgfVxuICAgICAgc2NvcGUkMi5mdW5jdGlvbnMucHVzaChuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgc2NvcGUkMyA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgICAgaWYgKHNjb3BlJDMubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgJiYgISgoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1NJTVBMRV9DQVRDSCkgJiYgc2NvcGUkMy5sZXhpY2FsWzBdID09PSBuYW1lKSB8fFxuICAgICAgICAgICAgIXRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUoc2NvcGUkMykgJiYgc2NvcGUkMy5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgICAgcmVkZWNsYXJlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzY29wZSQzLnZhci5wdXNoKG5hbWUpO1xuICAgICAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gICAgICAgIGlmIChzY29wZSQzLmZsYWdzICYgU0NPUEVfVkFSKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZGVjbGFyZWQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgKFwiSWRlbnRpZmllciAnXCIgKyBuYW1lICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWRcIikpOyB9XG4gIH07XG5cbiAgcHAkNS5jaGVja0xvY2FsRXhwb3J0ID0gZnVuY3Rpb24oaWQpIHtcbiAgICBpZiAodGhpcy5zY29wZVN0YWNrWzBdLmxleGljYWwuaW5kZXhPZihpZC5uYW1lKSA9PT0gLTEgJiZcbiAgICAgICAgdGhpcy5zY29wZVN0YWNrWzBdLnZhci5pbmRleE9mKGlkLm5hbWUpID09PSAtMSkge1xuICAgICAgdGhpcy51bmRlZmluZWRFeHBvcnRzW2lkLm5hbWVdID0gaWQ7XG4gICAgfVxuICB9O1xuXG4gIHBwJDUuY3VycmVudFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMV1cbiAgfTtcblxuICBwcCQ1LmN1cnJlbnRWYXJTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSKSB7IHJldHVybiBzY29wZSB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDUuY3VycmVudFRoaXNTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSICYmICEoc2NvcGUuZmxhZ3MgJiBTQ09QRV9BUlJPVykpIHsgcmV0dXJuIHNjb3BlIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlKHBhcnNlciwgcG9zLCBsb2MpIHtcbiAgICB0aGlzLnR5cGUgPSBcIlwiO1xuICAgIHRoaXMuc3RhcnQgPSBwb3M7XG4gICAgdGhpcy5lbmQgPSAwO1xuICAgIGlmIChwYXJzZXIub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHBhcnNlciwgbG9jKTsgfVxuICAgIGlmIChwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlKVxuICAgICAgeyB0aGlzLnNvdXJjZUZpbGUgPSBwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlOyB9XG4gICAgaWYgKHBhcnNlci5vcHRpb25zLnJhbmdlcylcbiAgICAgIHsgdGhpcy5yYW5nZSA9IFtwb3MsIDBdOyB9XG4gIH07XG5cblxuICB2YXIgcHAkNiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgcHAkNi5zdGFydE5vZGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5zdGFydCwgdGhpcy5zdGFydExvYylcbiAgfTtcblxuICBwcCQ2LnN0YXJ0Tm9kZUF0ID0gZnVuY3Rpb24ocG9zLCBsb2MpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgcG9zLCBsb2MpXG4gIH07XG5cblxuICBmdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgIG5vZGUuZW5kID0gcG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyBub2RlLmxvYy5lbmQgPSBsb2M7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcylcbiAgICAgIHsgbm9kZS5yYW5nZVsxXSA9IHBvczsgfVxuICAgIHJldHVybiBub2RlXG4gIH1cblxuICBwcCQ2LmZpbmlzaE5vZGUgPSBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKVxuICB9O1xuXG5cbiAgcHAkNi5maW5pc2hOb2RlQXQgPSBmdW5jdGlvbihub2RlLCB0eXBlLCBwb3MsIGxvYykge1xuICAgIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYylcbiAgfTtcblxuXG4gIHZhciBUb2tDb250ZXh0ID0gZnVuY3Rpb24gVG9rQ29udGV4dCh0b2tlbiwgaXNFeHByLCBwcmVzZXJ2ZVNwYWNlLCBvdmVycmlkZSwgZ2VuZXJhdG9yKSB7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMuaXNFeHByID0gISFpc0V4cHI7XG4gICAgdGhpcy5wcmVzZXJ2ZVNwYWNlID0gISFwcmVzZXJ2ZVNwYWNlO1xuICAgIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICB0aGlzLmdlbmVyYXRvciA9ICEhZ2VuZXJhdG9yO1xuICB9O1xuXG4gIHZhciB0eXBlcyQxID0ge1xuICAgIGJfc3RhdDogbmV3IFRva0NvbnRleHQoXCJ7XCIsIGZhbHNlKSxcbiAgICBiX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwie1wiLCB0cnVlKSxcbiAgICBiX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiJHtcIiwgZmFsc2UpLFxuICAgIHBfc3RhdDogbmV3IFRva0NvbnRleHQoXCIoXCIsIGZhbHNlKSxcbiAgICBwX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCB0cnVlKSxcbiAgICBxX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiYFwiLCB0cnVlLCB0cnVlLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gcC50cnlSZWFkVGVtcGxhdGVUb2tlbigpOyB9KSxcbiAgICBmX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgZmFsc2UpLFxuICAgIGZfZXhwcjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlKSxcbiAgICBmX2V4cHJfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUsIGZhbHNlLCBudWxsLCB0cnVlKSxcbiAgICBmX2dlbjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSwgZmFsc2UsIG51bGwsIHRydWUpXG4gIH07XG5cbiAgdmFyIHBwJDcgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHBwJDcuaW5pdGlhbENvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gW3R5cGVzJDEuYl9zdGF0XVxuICB9O1xuXG4gIHBwJDcuYnJhY2VJc0Jsb2NrID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKHBhcmVudCA9PT0gdHlwZXMkMS5mX2V4cHIgfHwgcGFyZW50ID09PSB0eXBlcyQxLmZfc3RhdClcbiAgICAgIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuY29sb24gJiYgKHBhcmVudCA9PT0gdHlwZXMkMS5iX3N0YXQgfHwgcGFyZW50ID09PSB0eXBlcyQxLmJfZXhwcikpXG4gICAgICB7IHJldHVybiAhcGFyZW50LmlzRXhwciB9XG5cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9yZXR1cm4gfHwgcHJldlR5cGUgPT09IHR5cGVzLm5hbWUgJiYgdGhpcy5leHByQWxsb3dlZClcbiAgICAgIHsgcmV0dXJuIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkgfVxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX2Vsc2UgfHwgcHJldlR5cGUgPT09IHR5cGVzLnNlbWkgfHwgcHJldlR5cGUgPT09IHR5cGVzLmVvZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMucGFyZW5SIHx8IHByZXZUeXBlID09PSB0eXBlcy5hcnJvdylcbiAgICAgIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKVxuICAgICAgeyByZXR1cm4gcGFyZW50ID09PSB0eXBlcyQxLmJfc3RhdCB9XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fdmFyIHx8IHByZXZUeXBlID09PSB0eXBlcy5fY29uc3QgfHwgcHJldlR5cGUgPT09IHR5cGVzLm5hbWUpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuICF0aGlzLmV4cHJBbGxvd2VkXG4gIH07XG5cbiAgcHAkNy5pbkdlbmVyYXRvckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMTsgaS0tKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dFtpXTtcbiAgICAgIGlmIChjb250ZXh0LnRva2VuID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHsgcmV0dXJuIGNvbnRleHQuZ2VuZXJhdG9yIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkNy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB2YXIgdXBkYXRlLCB0eXBlID0gdGhpcy50eXBlO1xuICAgIGlmICh0eXBlLmtleXdvcmQgJiYgcHJldlR5cGUgPT09IHR5cGVzLmRvdClcbiAgICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gICAgZWxzZSBpZiAodXBkYXRlID0gdHlwZS51cGRhdGVDb250ZXh0KVxuICAgICAgeyB1cGRhdGUuY2FsbCh0aGlzLCBwcmV2VHlwZSk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSB0eXBlLmJlZm9yZUV4cHI7IH1cbiAgfTtcblxuXG4gIHR5cGVzLnBhcmVuUi51cGRhdGVDb250ZXh0ID0gdHlwZXMuYnJhY2VSLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jb250ZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICBpZiAob3V0ID09PSB0eXBlcyQxLmJfc3RhdCAmJiB0aGlzLmN1ckNvbnRleHQoKS50b2tlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSAhb3V0LmlzRXhwcjtcbiAgfTtcblxuICB0eXBlcy5icmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdGhpcy5jb250ZXh0LnB1c2godGhpcy5icmFjZUlzQmxvY2socHJldlR5cGUpID8gdHlwZXMkMS5iX3N0YXQgOiB0eXBlcyQxLmJfZXhwcik7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMuZG9sbGFyQnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmJfdG1wbCk7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMucGFyZW5MLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBzdGF0ZW1lbnRQYXJlbnMgPSBwcmV2VHlwZSA9PT0gdHlwZXMuX2lmIHx8IHByZXZUeXBlID09PSB0eXBlcy5fZm9yIHx8IHByZXZUeXBlID09PSB0eXBlcy5fd2l0aCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX3doaWxlO1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHN0YXRlbWVudFBhcmVucyA/IHR5cGVzJDEucF9zdGF0IDogdHlwZXMkMS5wX2V4cHIpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzLmluY0RlYy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIH07XG5cbiAgdHlwZXMuX2Z1bmN0aW9uLnVwZGF0ZUNvbnRleHQgPSB0eXBlcy5fY2xhc3MudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgaWYgKHByZXZUeXBlLmJlZm9yZUV4cHIgJiYgcHJldlR5cGUgIT09IHR5cGVzLnNlbWkgJiYgcHJldlR5cGUgIT09IHR5cGVzLl9lbHNlICYmXG4gICAgICAgICEocHJldlR5cGUgPT09IHR5cGVzLl9yZXR1cm4gJiYgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSkgJiZcbiAgICAgICAgISgocHJldlR5cGUgPT09IHR5cGVzLmNvbG9uIHx8IHByZXZUeXBlID09PSB0eXBlcy5icmFjZUwpICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcyQxLmJfc3RhdCkpXG4gICAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuZl9leHByKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5mX3N0YXQpOyB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHR5cGVzLmJhY2tRdW90ZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcyQxLnFfdG1wbClcbiAgICAgIHsgdGhpcy5jb250ZXh0LnBvcCgpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLnFfdG1wbCk7IH1cbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gIH07XG5cbiAgdHlwZXMuc3Rhci51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbikge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7XG4gICAgICBpZiAodGhpcy5jb250ZXh0W2luZGV4XSA9PT0gdHlwZXMkMS5mX2V4cHIpXG4gICAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzJDEuZl9leHByX2dlbjsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHRoaXMuY29udGV4dFtpbmRleF0gPSB0eXBlcyQxLmZfZ2VuOyB9XG4gICAgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzLm5hbWUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIGFsbG93ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgcHJldlR5cGUgIT09IHR5cGVzLmRvdCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwib2ZcIiAmJiAhdGhpcy5leHByQWxsb3dlZCB8fFxuICAgICAgICAgIHRoaXMudmFsdWUgPT09IFwieWllbGRcIiAmJiB0aGlzLmluR2VuZXJhdG9yQ29udGV4dCgpKVxuICAgICAgICB7IGFsbG93ZWQgPSB0cnVlOyB9XG4gICAgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSBhbGxvd2VkO1xuICB9O1xuXG5cbiAgdmFyIGVjbWE5QmluYXJ5UHJvcGVydGllcyA9IFwiQVNDSUkgQVNDSUlfSGV4X0RpZ2l0IEFIZXggQWxwaGFiZXRpYyBBbHBoYSBBbnkgQXNzaWduZWQgQmlkaV9Db250cm9sIEJpZGlfQyBCaWRpX01pcnJvcmVkIEJpZGlfTSBDYXNlX0lnbm9yYWJsZSBDSSBDYXNlZCBDaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZCBDV0NGIENoYW5nZXNfV2hlbl9DYXNlbWFwcGVkIENXQ00gQ2hhbmdlc19XaGVuX0xvd2VyY2FzZWQgQ1dMIENoYW5nZXNfV2hlbl9ORktDX0Nhc2Vmb2xkZWQgQ1dLQ0YgQ2hhbmdlc19XaGVuX1RpdGxlY2FzZWQgQ1dUIENoYW5nZXNfV2hlbl9VcHBlcmNhc2VkIENXVSBEYXNoIERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQgREkgRGVwcmVjYXRlZCBEZXAgRGlhY3JpdGljIERpYSBFbW9qaSBFbW9qaV9Db21wb25lbnQgRW1vamlfTW9kaWZpZXIgRW1vamlfTW9kaWZpZXJfQmFzZSBFbW9qaV9QcmVzZW50YXRpb24gRXh0ZW5kZXIgRXh0IEdyYXBoZW1lX0Jhc2UgR3JfQmFzZSBHcmFwaGVtZV9FeHRlbmQgR3JfRXh0IEhleF9EaWdpdCBIZXggSURTX0JpbmFyeV9PcGVyYXRvciBJRFNCIElEU19UcmluYXJ5X09wZXJhdG9yIElEU1QgSURfQ29udGludWUgSURDIElEX1N0YXJ0IElEUyBJZGVvZ3JhcGhpYyBJZGVvIEpvaW5fQ29udHJvbCBKb2luX0MgTG9naWNhbF9PcmRlcl9FeGNlcHRpb24gTE9FIExvd2VyY2FzZSBMb3dlciBNYXRoIE5vbmNoYXJhY3Rlcl9Db2RlX1BvaW50IE5DaGFyIFBhdHRlcm5fU3ludGF4IFBhdF9TeW4gUGF0dGVybl9XaGl0ZV9TcGFjZSBQYXRfV1MgUXVvdGF0aW9uX01hcmsgUU1hcmsgUmFkaWNhbCBSZWdpb25hbF9JbmRpY2F0b3IgUkkgU2VudGVuY2VfVGVybWluYWwgU1Rlcm0gU29mdF9Eb3R0ZWQgU0QgVGVybWluYWxfUHVuY3R1YXRpb24gVGVybSBVbmlmaWVkX0lkZW9ncmFwaCBVSWRlbyBVcHBlcmNhc2UgVXBwZXIgVmFyaWF0aW9uX1NlbGVjdG9yIFZTIFdoaXRlX1NwYWNlIHNwYWNlIFhJRF9Db250aW51ZSBYSURDIFhJRF9TdGFydCBYSURTXCI7XG4gIHZhciBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTlCaW5hcnlQcm9wZXJ0aWVzICsgXCIgRXh0ZW5kZWRfUGljdG9ncmFwaGljXCI7XG4gIHZhciBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTEwQmluYXJ5UHJvcGVydGllcztcbiAgdmFyIHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzID0ge1xuICAgIDk6IGVjbWE5QmluYXJ5UHJvcGVydGllcyxcbiAgICAxMDogZWNtYTEwQmluYXJ5UHJvcGVydGllcyxcbiAgICAxMTogZWNtYTExQmluYXJ5UHJvcGVydGllc1xuICB9O1xuXG4gIHZhciB1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzID0gXCJDYXNlZF9MZXR0ZXIgTEMgQ2xvc2VfUHVuY3R1YXRpb24gUGUgQ29ubmVjdG9yX1B1bmN0dWF0aW9uIFBjIENvbnRyb2wgQ2MgY250cmwgQ3VycmVuY3lfU3ltYm9sIFNjIERhc2hfUHVuY3R1YXRpb24gUGQgRGVjaW1hbF9OdW1iZXIgTmQgZGlnaXQgRW5jbG9zaW5nX01hcmsgTWUgRmluYWxfUHVuY3R1YXRpb24gUGYgRm9ybWF0IENmIEluaXRpYWxfUHVuY3R1YXRpb24gUGkgTGV0dGVyIEwgTGV0dGVyX051bWJlciBObCBMaW5lX1NlcGFyYXRvciBabCBMb3dlcmNhc2VfTGV0dGVyIExsIE1hcmsgTSBDb21iaW5pbmdfTWFyayBNYXRoX1N5bWJvbCBTbSBNb2RpZmllcl9MZXR0ZXIgTG0gTW9kaWZpZXJfU3ltYm9sIFNrIE5vbnNwYWNpbmdfTWFyayBNbiBOdW1iZXIgTiBPcGVuX1B1bmN0dWF0aW9uIFBzIE90aGVyIEMgT3RoZXJfTGV0dGVyIExvIE90aGVyX051bWJlciBObyBPdGhlcl9QdW5jdHVhdGlvbiBQbyBPdGhlcl9TeW1ib2wgU28gUGFyYWdyYXBoX1NlcGFyYXRvciBacCBQcml2YXRlX1VzZSBDbyBQdW5jdHVhdGlvbiBQIHB1bmN0IFNlcGFyYXRvciBaIFNwYWNlX1NlcGFyYXRvciBacyBTcGFjaW5nX01hcmsgTWMgU3Vycm9nYXRlIENzIFN5bWJvbCBTIFRpdGxlY2FzZV9MZXR0ZXIgTHQgVW5hc3NpZ25lZCBDbiBVcHBlcmNhc2VfTGV0dGVyIEx1XCI7XG5cbiAgdmFyIGVjbWE5U2NyaXB0VmFsdWVzID0gXCJBZGxhbSBBZGxtIEFob20gQWhvbSBBbmF0b2xpYW5fSGllcm9nbHlwaHMgSGx1dyBBcmFiaWMgQXJhYiBBcm1lbmlhbiBBcm1uIEF2ZXN0YW4gQXZzdCBCYWxpbmVzZSBCYWxpIEJhbXVtIEJhbXUgQmFzc2FfVmFoIEJhc3MgQmF0YWsgQmF0ayBCZW5nYWxpIEJlbmcgQmhhaWtzdWtpIEJoa3MgQm9wb21vZm8gQm9wbyBCcmFobWkgQnJhaCBCcmFpbGxlIEJyYWkgQnVnaW5lc2UgQnVnaSBCdWhpZCBCdWhkIENhbmFkaWFuX0Fib3JpZ2luYWwgQ2FucyBDYXJpYW4gQ2FyaSBDYXVjYXNpYW5fQWxiYW5pYW4gQWdoYiBDaGFrbWEgQ2FrbSBDaGFtIENoYW0gQ2hlcm9rZWUgQ2hlciBDb21tb24gWnl5eSBDb3B0aWMgQ29wdCBRYWFjIEN1bmVpZm9ybSBYc3V4IEN5cHJpb3QgQ3BydCBDeXJpbGxpYyBDeXJsIERlc2VyZXQgRHNydCBEZXZhbmFnYXJpIERldmEgRHVwbG95YW4gRHVwbCBFZ3lwdGlhbl9IaWVyb2dseXBocyBFZ3lwIEVsYmFzYW4gRWxiYSBFdGhpb3BpYyBFdGhpIEdlb3JnaWFuIEdlb3IgR2xhZ29saXRpYyBHbGFnIEdvdGhpYyBHb3RoIEdyYW50aGEgR3JhbiBHcmVlayBHcmVrIEd1amFyYXRpIEd1anIgR3VybXVraGkgR3VydSBIYW4gSGFuaSBIYW5ndWwgSGFuZyBIYW51bm9vIEhhbm8gSGF0cmFuIEhhdHIgSGVicmV3IEhlYnIgSGlyYWdhbmEgSGlyYSBJbXBlcmlhbF9BcmFtYWljIEFybWkgSW5oZXJpdGVkIFppbmggUWFhaSBJbnNjcmlwdGlvbmFsX1BhaGxhdmkgUGhsaSBJbnNjcmlwdGlvbmFsX1BhcnRoaWFuIFBydGkgSmF2YW5lc2UgSmF2YSBLYWl0aGkgS3RoaSBLYW5uYWRhIEtuZGEgS2F0YWthbmEgS2FuYSBLYXlhaF9MaSBLYWxpIEtoYXJvc2h0aGkgS2hhciBLaG1lciBLaG1yIEtob2praSBLaG9qIEtodWRhd2FkaSBTaW5kIExhbyBMYW9vIExhdGluIExhdG4gTGVwY2hhIExlcGMgTGltYnUgTGltYiBMaW5lYXJfQSBMaW5hIExpbmVhcl9CIExpbmIgTGlzdSBMaXN1IEx5Y2lhbiBMeWNpIEx5ZGlhbiBMeWRpIE1haGFqYW5pIE1haGogTWFsYXlhbGFtIE1seW0gTWFuZGFpYyBNYW5kIE1hbmljaGFlYW4gTWFuaSBNYXJjaGVuIE1hcmMgTWFzYXJhbV9Hb25kaSBHb25tIE1lZXRlaV9NYXllayBNdGVpIE1lbmRlX0tpa2FrdWkgTWVuZCBNZXJvaXRpY19DdXJzaXZlIE1lcmMgTWVyb2l0aWNfSGllcm9nbHlwaHMgTWVybyBNaWFvIFBscmQgTW9kaSBNb2RpIE1vbmdvbGlhbiBNb25nIE1ybyBNcm9vIE11bHRhbmkgTXVsdCBNeWFubWFyIE15bXIgTmFiYXRhZWFuIE5iYXQgTmV3X1RhaV9MdWUgVGFsdSBOZXdhIE5ld2EgTmtvIE5rb28gTnVzaHUgTnNodSBPZ2hhbSBPZ2FtIE9sX0NoaWtpIE9sY2sgT2xkX0h1bmdhcmlhbiBIdW5nIE9sZF9JdGFsaWMgSXRhbCBPbGRfTm9ydGhfQXJhYmlhbiBOYXJiIE9sZF9QZXJtaWMgUGVybSBPbGRfUGVyc2lhbiBYcGVvIE9sZF9Tb3V0aF9BcmFiaWFuIFNhcmIgT2xkX1R1cmtpYyBPcmtoIE9yaXlhIE9yeWEgT3NhZ2UgT3NnZSBPc21hbnlhIE9zbWEgUGFoYXdoX0htb25nIEhtbmcgUGFsbXlyZW5lIFBhbG0gUGF1X0Npbl9IYXUgUGF1YyBQaGFnc19QYSBQaGFnIFBob2VuaWNpYW4gUGhueCBQc2FsdGVyX1BhaGxhdmkgUGhscCBSZWphbmcgUmpuZyBSdW5pYyBSdW5yIFNhbWFyaXRhbiBTYW1yIFNhdXJhc2h0cmEgU2F1ciBTaGFyYWRhIFNocmQgU2hhdmlhbiBTaGF3IFNpZGRoYW0gU2lkZCBTaWduV3JpdGluZyBTZ253IFNpbmhhbGEgU2luaCBTb3JhX1NvbXBlbmcgU29yYSBTb3lvbWJvIFNveW8gU3VuZGFuZXNlIFN1bmQgU3lsb3RpX05hZ3JpIFN5bG8gU3lyaWFjIFN5cmMgVGFnYWxvZyBUZ2xnIFRhZ2JhbndhIFRhZ2IgVGFpX0xlIFRhbGUgVGFpX1RoYW0gTGFuYSBUYWlfVmlldCBUYXZ0IFRha3JpIFRha3IgVGFtaWwgVGFtbCBUYW5ndXQgVGFuZyBUZWx1Z3UgVGVsdSBUaGFhbmEgVGhhYSBUaGFpIFRoYWkgVGliZXRhbiBUaWJ0IFRpZmluYWdoIFRmbmcgVGlyaHV0YSBUaXJoIFVnYXJpdGljIFVnYXIgVmFpIFZhaWkgV2FyYW5nX0NpdGkgV2FyYSBZaSBZaWlpIFphbmFiYXphcl9TcXVhcmUgWmFuYlwiO1xuICB2YXIgZWNtYTEwU2NyaXB0VmFsdWVzID0gZWNtYTlTY3JpcHRWYWx1ZXMgKyBcIiBEb2dyYSBEb2dyIEd1bmphbGFfR29uZGkgR29uZyBIYW5pZmlfUm9oaW5neWEgUm9oZyBNYWthc2FyIE1ha2EgTWVkZWZhaWRyaW4gTWVkZiBPbGRfU29nZGlhbiBTb2dvIFNvZ2RpYW4gU29nZFwiO1xuICB2YXIgZWNtYTExU2NyaXB0VmFsdWVzID0gZWNtYTEwU2NyaXB0VmFsdWVzICsgXCIgRWx5bWFpYyBFbHltIE5hbmRpbmFnYXJpIE5hbmQgTnlpYWtlbmdfUHVhY2h1ZV9IbW9uZyBIbW5wIFdhbmNobyBXY2hvXCI7XG4gIHZhciB1bmljb2RlU2NyaXB0VmFsdWVzID0ge1xuICAgIDk6IGVjbWE5U2NyaXB0VmFsdWVzLFxuICAgIDEwOiBlY21hMTBTY3JpcHRWYWx1ZXMsXG4gICAgMTE6IGVjbWExMVNjcmlwdFZhbHVlc1xuICB9O1xuXG4gIHZhciBkYXRhID0ge307XG4gIGZ1bmN0aW9uIGJ1aWxkVW5pY29kZURhdGEoZWNtYVZlcnNpb24pIHtcbiAgICB2YXIgZCA9IGRhdGFbZWNtYVZlcnNpb25dID0ge1xuICAgICAgYmluYXJ5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlQmluYXJ5UHJvcGVydGllc1tlY21hVmVyc2lvbl0gKyBcIiBcIiArIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgICAgbm9uQmluYXJ5OiB7XG4gICAgICAgIEdlbmVyYWxfQ2F0ZWdvcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgICAgICBTY3JpcHQ6IHdvcmRzUmVnZXhwKHVuaWNvZGVTY3JpcHRWYWx1ZXNbZWNtYVZlcnNpb25dKVxuICAgICAgfVxuICAgIH07XG4gICAgZC5ub25CaW5hcnkuU2NyaXB0X0V4dGVuc2lvbnMgPSBkLm5vbkJpbmFyeS5TY3JpcHQ7XG5cbiAgICBkLm5vbkJpbmFyeS5nYyA9IGQubm9uQmluYXJ5LkdlbmVyYWxfQ2F0ZWdvcnk7XG4gICAgZC5ub25CaW5hcnkuc2MgPSBkLm5vbkJpbmFyeS5TY3JpcHQ7XG4gICAgZC5ub25CaW5hcnkuc2N4ID0gZC5ub25CaW5hcnkuU2NyaXB0X0V4dGVuc2lvbnM7XG4gIH1cbiAgYnVpbGRVbmljb2RlRGF0YSg5KTtcbiAgYnVpbGRVbmljb2RlRGF0YSgxMCk7XG4gIGJ1aWxkVW5pY29kZURhdGEoMTEpO1xuXG4gIHZhciBwcCQ4ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICB2YXIgUmVnRXhwVmFsaWRhdGlvblN0YXRlID0gZnVuY3Rpb24gUmVnRXhwVmFsaWRhdGlvblN0YXRlKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMudmFsaWRGbGFncyA9IFwiZ2ltXCIgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IFwidXlcIiA6IFwiXCIpICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgPyBcInNcIiA6IFwiXCIpO1xuICAgIHRoaXMudW5pY29kZVByb3BlcnRpZXMgPSBkYXRhW3BhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExID8gMTEgOiBwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbl07XG4gICAgdGhpcy5zb3VyY2UgPSBcIlwiO1xuICAgIHRoaXMuZmxhZ3MgPSBcIlwiO1xuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuc3dpdGNoVSA9IGZhbHNlO1xuICAgIHRoaXMuc3dpdGNoTiA9IGZhbHNlO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgdGhpcy5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHRoaXMubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5udW1DYXB0dXJpbmdQYXJlbnMgPSAwO1xuICAgIHRoaXMubWF4QmFja1JlZmVyZW5jZSA9IDA7XG4gICAgdGhpcy5ncm91cE5hbWVzID0gW107XG4gICAgdGhpcy5iYWNrUmVmZXJlbmNlTmFtZXMgPSBbXTtcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKHN0YXJ0LCBwYXR0ZXJuLCBmbGFncykge1xuICAgIHZhciB1bmljb2RlID0gZmxhZ3MuaW5kZXhPZihcInVcIikgIT09IC0xO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydCB8IDA7XG4gICAgdGhpcy5zb3VyY2UgPSBwYXR0ZXJuICsgXCJcIjtcbiAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgdGhpcy5zd2l0Y2hVID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gICAgdGhpcy5zd2l0Y2hOID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDk7XG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5yYWlzZSA9IGZ1bmN0aW9uIHJhaXNlIChtZXNzYWdlKSB7XG4gICAgdGhpcy5wYXJzZXIucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCAoXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogL1wiICsgKHRoaXMuc291cmNlKSArIFwiLzogXCIgKyBtZXNzYWdlKSk7XG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIGF0IChpKSB7XG4gICAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIGlmIChpID49IGwpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoIXRoaXMuc3dpdGNoVSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsKSB7XG4gICAgICByZXR1cm4gY1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IHMuY2hhckNvZGVBdChpICsgMSk7XG4gICAgcmV0dXJuIG5leHQgPj0gMHhEQzAwICYmIG5leHQgPD0gMHhERkZGID8gKGMgPDwgMTApICsgbmV4dCAtIDB4MzVGREMwMCA6IGNcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLm5leHRJbmRleCA9IGZ1bmN0aW9uIG5leHRJbmRleCAoaSkge1xuICAgIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICBpZiAoaSA+PSBsKSB7XG4gICAgICByZXR1cm4gbFxuICAgIH1cbiAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKSwgbmV4dDtcbiAgICBpZiAoIXRoaXMuc3dpdGNoVSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsIHx8XG4gICAgICAgIChuZXh0ID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweERDMDAgfHwgbmV4dCA+IDB4REZGRikge1xuICAgICAgcmV0dXJuIGkgKyAxXG4gICAgfVxuICAgIHJldHVybiBpICsgMlxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIGN1cnJlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmF0KHRoaXMucG9zKVxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubG9va2FoZWFkID0gZnVuY3Rpb24gbG9va2FoZWFkICgpIHtcbiAgICByZXR1cm4gdGhpcy5hdCh0aGlzLm5leHRJbmRleCh0aGlzLnBvcykpXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gYWR2YW5jZSAoKSB7XG4gICAgdGhpcy5wb3MgPSB0aGlzLm5leHRJbmRleCh0aGlzLnBvcyk7XG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbiBlYXQgKGNoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudCgpID09PSBjaCkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBmdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyhjaCkge1xuICAgIGlmIChjaCA8PSAweEZGRkYpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpIH1cbiAgICBjaCAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjaCA+PiAxMCkgKyAweEQ4MDAsIChjaCAmIDB4MDNGRikgKyAweERDMDApXG4gIH1cblxuICBwcCQ4LnZhbGlkYXRlUmVnRXhwRmxhZ3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciB2YWxpZEZsYWdzID0gc3RhdGUudmFsaWRGbGFncztcbiAgICB2YXIgZmxhZ3MgPSBzdGF0ZS5mbGFncztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbGFnID0gZmxhZ3MuY2hhckF0KGkpO1xuICAgICAgaWYgKHZhbGlkRmxhZ3MuaW5kZXhPZihmbGFnKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdGF0ZS5zdGFydCwgXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGZsYWdzLmluZGV4T2YoZmxhZywgaSArIDEpID4gLTEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdGF0ZS5zdGFydCwgXCJEdXBsaWNhdGUgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDgudmFsaWRhdGVSZWdFeHBQYXR0ZXJuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcblxuICAgIGlmICghc3RhdGUuc3dpdGNoTiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YXRlLnN3aXRjaE4gPSB0cnVlO1xuICAgICAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX3BhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLnBvcyA9IDA7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuICAgIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyA9IDA7XG4gICAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IDA7XG4gICAgc3RhdGUuZ3JvdXBOYW1lcy5sZW5ndGggPSAwO1xuICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBvcyAhPT0gc3RhdGUuc291cmNlLmxlbmd0aCkge1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDI5ICkpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJVbm1hdGNoZWQgJyknXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDVEICkgfHwgc3RhdGUuZWF0KDB4N0QgKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPiBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgY2FwdHVyZSByZWZlcmVuY2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9kaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICAgIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyApKSB7XG4gICAgICB0aGlzLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIk5vdGhpbmcgdG8gcmVwZWF0XCIpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4N0IgKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2FsdGVybmF0aXZlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhdGUuc291cmNlLmxlbmd0aCAmJiB0aGlzLnJlZ2V4cF9lYXRUZXJtKHN0YXRlKSlcbiAgICAgIHsgfVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdFRlcm0gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRBc3NlcnRpb24oc3RhdGUpKSB7XG4gICAgICBpZiAoc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlICYmIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHF1YW50aWZpZXJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnN3aXRjaFUgPyB0aGlzLnJlZ2V4cF9lYXRBdG9tKHN0YXRlKSA6IHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkQXRvbShzdGF0ZSkpIHtcbiAgICAgIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRBc3NlcnRpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcblxuICAgIGlmIChzdGF0ZS5lYXQoMHg1RSApIHx8IHN0YXRlLmVhdCgweDI0ICkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmVhdCgweDVDICkpIHtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg0MiApIHx8IHN0YXRlLmVhdCgweDYyICkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5lYXQoMHgyOCApICYmIHN0YXRlLmVhdCgweDNGICkpIHtcbiAgICAgIHZhciBsb29rYmVoaW5kID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgbG9va2JlaGluZCA9IHN0YXRlLmVhdCgweDNDICk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4M0QgKSB8fCBzdGF0ZS5lYXQoMHgyMSApKSB7XG4gICAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5lYXQoMHgyOSApKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gIWxvb2tiZWhpbmQ7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0UXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gICAgaWYgKCBub0Vycm9yID09PSB2b2lkIDAgKSBub0Vycm9yID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllclByZWZpeChzdGF0ZSwgbm9FcnJvcikpIHtcbiAgICAgIHN0YXRlLmVhdCgweDNGICk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4ID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgc3RhdGUuZWF0KDB4MkEgKSB8fFxuICAgICAgc3RhdGUuZWF0KDB4MkIgKSB8fFxuICAgICAgc3RhdGUuZWF0KDB4M0YgKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgbm9FcnJvcilcbiAgICApXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4N0IgKSkge1xuICAgICAgdmFyIG1pbiA9IDAsIG1heCA9IC0xO1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICAgIG1pbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDJDICkgJiYgdGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgICAgICBtYXggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDdEICkpIHtcbiAgICAgICAgICBpZiAobWF4ICE9PSAtMSAmJiBtYXggPCBtaW4gJiYgIW5vRXJyb3IpIHtcbiAgICAgICAgICAgIHN0YXRlLnJhaXNlKFwibnVtYmVycyBvdXQgb2Ygb3JkZXIgaW4ge30gcXVhbnRpZmllclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgIW5vRXJyb3IpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbmNvbXBsZXRlIHF1YW50aWZpZXJcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0QXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzKHN0YXRlKSB8fFxuICAgICAgc3RhdGUuZWF0KDB4MkUgKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpXG4gICAgKVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEF0b21Fc2NhcGUoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4MjggKSkge1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDNGICkgJiYgc3RhdGUuZWF0KDB4M0EgKSkge1xuICAgICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5lYXQoMHgyOSApKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyOCApKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZ3JvdXBTcGVjaWZpZXIoc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4M0YgKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyOSApKSB7XG4gICAgICAgIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyArPSAxO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdEV4dGVuZGVkQXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHN0YXRlLmVhdCgweDJFICkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRFeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXIoc3RhdGUpXG4gICAgKVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc1N5bnRheENoYXJhY3RlcihjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzU3ludGF4Q2hhcmFjdGVyKGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGNoID09PSAweDI0ICB8fFxuICAgICAgY2ggPj0gMHgyOCAgJiYgY2ggPD0gMHgyQiAgfHxcbiAgICAgIGNoID09PSAweDJFICB8fFxuICAgICAgY2ggPT09IDB4M0YgIHx8XG4gICAgICBjaCA+PSAweDVCICAmJiBjaCA8PSAweDVFICB8fFxuICAgICAgY2ggPj0gMHg3QiAgJiYgY2ggPD0gMHg3RCBcbiAgICApXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IDA7XG4gICAgd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgIT09IC0xICYmICFpc1N5bnRheENoYXJhY3RlcihjaCkpIHtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRFeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoXG4gICAgICBjaCAhPT0gLTEgJiZcbiAgICAgIGNoICE9PSAweDI0ICAmJlxuICAgICAgIShjaCA+PSAweDI4ICAmJiBjaCA8PSAweDJCICkgJiZcbiAgICAgIGNoICE9PSAweDJFICAmJlxuICAgICAgY2ggIT09IDB4M0YgICYmXG4gICAgICBjaCAhPT0gMHg1QiAgJiZcbiAgICAgIGNoICE9PSAweDVFICAmJlxuICAgICAgY2ggIT09IDB4N0MgXG4gICAgKSB7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9ncm91cFNwZWNpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDNGICkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICAgIGlmIChzdGF0ZS5ncm91cE5hbWVzLmluZGV4T2Yoc3RhdGUubGFzdFN0cmluZ1ZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkR1cGxpY2F0ZSBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZ3JvdXBOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgIH1cbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRHcm91cE5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgaWYgKHN0YXRlLmVhdCgweDNDICkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0UgKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydChzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0KHN0YXRlKSkge1xuICAgICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG5cbiAgICBpZiAoY2ggPT09IDB4NUMgICYmIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHtcbiAgICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgcmV0dXJuIGlzSWRlbnRpZmllclN0YXJ0KGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAgfHwgY2ggPT09IDB4NUYgXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG5cbiAgICBpZiAoY2ggPT09IDB4NUMgICYmIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHtcbiAgICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkge1xuICAgIHJldHVybiBpc0lkZW50aWZpZXJDaGFyKGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAgfHwgY2ggPT09IDB4NUYgIHx8IGNoID09PSAweDIwMEMgIHx8IGNoID09PSAweDIwMEQgXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRBdG9tRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoc3RhdGUpIHx8XG4gICAgICAoc3RhdGUuc3dpdGNoTiAmJiB0aGlzLnJlZ2V4cF9lYXRLR3JvdXBOYW1lKHN0YXRlKSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDYzICkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0QmFja1JlZmVyZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlKHN0YXRlKSkge1xuICAgICAgdmFyIG4gPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICBpZiAobiA+IHN0YXRlLm1heEJhY2tSZWZlcmVuY2UpIHtcbiAgICAgICAgICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKG4gPD0gc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdEtHcm91cE5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHg2QiApKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkge1xuICAgICAgICBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXMucHVzaChzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIG5hbWVkIHJlZmVyZW5jZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q29udHJvbEVzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENDb250cm9sTGV0dGVyKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0WmVybyhzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlKSB8fFxuICAgICAgKCFzdGF0ZS5zd2l0Y2hVICYmIHRoaXMucmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUoc3RhdGUpXG4gICAgKVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRDQ29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg2MyApKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0WmVybyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzMCAgJiYgIWlzRGVjaW1hbERpZ2l0KHN0YXRlLmxvb2thaGVhZCgpKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggPT09IDB4NzQgKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA5OyBcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg2RSApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEE7IFxuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDc2ICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQjsgXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NjYgKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBDOyBcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg3MiApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEQ7IFxuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc0NvbnRyb2xMZXR0ZXIoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNDb250cm9sTGV0dGVyKGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChjaCA+PSAweDQxICAmJiBjaCA8PSAweDVBICkgfHxcbiAgICAgIChjaCA+PSAweDYxICAmJiBjaCA8PSAweDdBIClcbiAgICApXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAgIGlmIChzdGF0ZS5lYXQoMHg3NSApKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICAgIHZhciBsZWFkID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiBsZWFkID49IDB4RDgwMCAmJiBsZWFkIDw9IDB4REJGRikge1xuICAgICAgICAgIHZhciBsZWFkU3Vycm9nYXRlRW5kID0gc3RhdGUucG9zO1xuICAgICAgICAgIGlmIChzdGF0ZS5lYXQoMHg1QyApICYmIHN0YXRlLmVhdCgweDc1ICkgJiYgdGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICAgICAgICB2YXIgdHJhaWwgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgICAgICBpZiAodHJhaWwgPj0gMHhEQzAwICYmIHRyYWlsIDw9IDB4REZGRikge1xuICAgICAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAobGVhZCAtIDB4RDgwMCkgKiAweDQwMCArICh0cmFpbCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5wb3MgPSBsZWFkU3Vycm9nYXRlRW5kO1xuICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGxlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgc3RhdGUuc3dpdGNoVSAmJlxuICAgICAgICBzdGF0ZS5lYXQoMHg3QiApICYmXG4gICAgICAgIHRoaXMucmVnZXhwX2VhdEhleERpZ2l0cyhzdGF0ZSkgJiZcbiAgICAgICAgc3RhdGUuZWF0KDB4N0QgKSAmJlxuICAgICAgICBpc1ZhbGlkVW5pY29kZShzdGF0ZS5sYXN0SW50VmFsdWUpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1ZhbGlkVW5pY29kZShjaCkge1xuICAgIHJldHVybiBjaCA+PSAwICYmIGNoIDw9IDB4MTBGRkZGXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MkYgKSkge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJGOyBcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggIT09IDB4NjMgICYmICghc3RhdGUuc3dpdGNoTiB8fCBjaCAhPT0gMHg2QiApKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoID49IDB4MzEgICYmIGNoIDw9IDB4MzkgKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCApO1xuICAgICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICB9IHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpID49IDB4MzAgICYmIGNoIDw9IDB4MzkgKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcblxuICAgIGlmIChpc0NoYXJhY3RlckNsYXNzRXNjYXBlKGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gLTE7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHN0YXRlLnN3aXRjaFUgJiZcbiAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmXG4gICAgICAoY2ggPT09IDB4NTAgIHx8IGNoID09PSAweDcwIClcbiAgICApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgaWYgKFxuICAgICAgICBzdGF0ZS5lYXQoMHg3QiApICYmXG4gICAgICAgIHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbihzdGF0ZSkgJiZcbiAgICAgICAgc3RhdGUuZWF0KDB4N0QgKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHg2NCAgfHxcbiAgICAgIGNoID09PSAweDQ0ICB8fFxuICAgICAgY2ggPT09IDB4NzMgIHx8XG4gICAgICBjaCA9PT0gMHg1MyAgfHxcbiAgICAgIGNoID09PSAweDc3ICB8fFxuICAgICAgY2ggPT09IDB4NTcgXG4gICAgKVxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0QgKSkge1xuICAgICAgdmFyIG5hbWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUoc3RhdGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG5cbiAgICBpZiAodGhpcy5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlKSkge1xuICAgICAgdmFyIG5hbWVPclZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSwgbmFtZU9yVmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDgucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFoYXMoc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5LCBuYW1lKSlcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbiAgICBpZiAoIXN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeVtuYW1lXS50ZXN0KHZhbHVlKSlcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IHZhbHVlXCIpOyB9XG4gIH07XG4gIHBwJDgucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSwgbmFtZU9yVmFsdWUpIHtcbiAgICBpZiAoIXN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLmJpbmFyeS50ZXN0KG5hbWVPclZhbHVlKSlcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgd2hpbGUgKGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbiAgfTtcbiAgZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB7XG4gICAgcmV0dXJuIGlzQ29udHJvbExldHRlcihjaCkgfHwgY2ggPT09IDB4NUYgXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKGNoKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSAhPT0gXCJcIlxuICB9O1xuICBmdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoKSB7XG4gICAgcmV0dXJuIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkgfHwgaXNEZWNpbWFsRGlnaXQoY2gpXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZShzdGF0ZSlcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDVCICkpIHtcbiAgICAgIHN0YXRlLmVhdCgweDVFICk7XG4gICAgICB0aGlzLnJlZ2V4cF9jbGFzc1JhbmdlcyhzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4NUQgKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9jbGFzc1JhbmdlcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICAgIHZhciBsZWZ0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDJEICkgJiYgdGhpcy5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgICAgICB2YXIgcmlnaHQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmIChsZWZ0ID09PSAtMSB8fCByaWdodCA9PT0gLTEpKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCAhPT0gLTEgJiYgcmlnaHQgIT09IC0xICYmIGxlZnQgPiByaWdodCkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRDbGFzc0F0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyApKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NFc2NhcGUoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICB2YXIgY2gkMSA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICAgICAgaWYgKGNoJDEgPT09IDB4NjMgIHx8IGlzT2N0YWxEaWdpdChjaCQxKSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjbGFzcyBlc2NhcGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggIT09IDB4NUQgKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q2xhc3NFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAgIGlmIChzdGF0ZS5lYXQoMHg2MiApKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA4OyBcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4MkQgKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRDsgXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICghc3RhdGUuc3dpdGNoVSAmJiBzdGF0ZS5lYXQoMHg2MyApKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKVxuICAgIClcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNEZWNpbWFsRGlnaXQoY2gpIHx8IGNoID09PSAweDVGICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggJSAweDIwO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4NzggKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCAyKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCApO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxuICB9O1xuICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgIHJldHVybiBjaCA+PSAweDMwICAmJiBjaCA8PSAweDM5IFxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0SGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHdoaWxlIChpc0hleERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG4gIH07XG4gIGZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGNoID49IDB4MzAgICYmIGNoIDw9IDB4MzkgKSB8fFxuICAgICAgKGNoID49IDB4NDEgICYmIGNoIDw9IDB4NDYgKSB8fFxuICAgICAgKGNoID49IDB4NjEgICYmIGNoIDw9IDB4NjYgKVxuICAgIClcbiAgfVxuICBmdW5jdGlvbiBoZXhUb0ludChjaCkge1xuICAgIGlmIChjaCA+PSAweDQxICAmJiBjaCA8PSAweDQ2ICkge1xuICAgICAgcmV0dXJuIDEwICsgKGNoIC0gMHg0MSApXG4gICAgfVxuICAgIGlmIChjaCA+PSAweDYxICAmJiBjaCA8PSAweDY2ICkge1xuICAgICAgcmV0dXJuIDEwICsgKGNoIC0gMHg2MSApXG4gICAgfVxuICAgIHJldHVybiBjaCAtIDB4MzAgXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgIHZhciBuMSA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgICB2YXIgbjIgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIGlmIChuMSA8PSAzICYmIHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjEgKiA2NCArIG4yICogOCArIHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDggKyBuMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRPY3RhbERpZ2l0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoIC0gMHgzMDsgXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgICByZXR1cm4gY2ggPj0gMHgzMCAgJiYgY2ggPD0gMHgzNyBcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUsIGxlbmd0aCkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cblxuICB2YXIgVG9rZW4gPSBmdW5jdGlvbiBUb2tlbihwKSB7XG4gICAgdGhpcy50eXBlID0gcC50eXBlO1xuICAgIHRoaXMudmFsdWUgPSBwLnZhbHVlO1xuICAgIHRoaXMuc3RhcnQgPSBwLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gcC5lbmQ7XG4gICAgaWYgKHAub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHAsIHAuc3RhcnRMb2MsIHAuZW5kTG9jKTsgfVxuICAgIGlmIChwLm9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyB0aGlzLnJhbmdlID0gW3Auc3RhcnQsIHAuZW5kXTsgfVxuICB9O1xuXG5cbiAgdmFyIHBwJDkgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5cbiAgcHAkOS5uZXh0ID0gZnVuY3Rpb24oaWdub3JlRXNjYXBlU2VxdWVuY2VJbktleXdvcmQpIHtcbiAgICBpZiAoIWlnbm9yZUVzY2FwZVNlcXVlbmNlSW5LZXl3b3JkICYmIHRoaXMudHlwZS5rZXl3b3JkICYmIHRoaXMuY29udGFpbnNFc2MpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIFwiICsgdGhpcy50eXBlLmtleXdvcmQpOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vblRva2VuKVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25Ub2tlbihuZXcgVG9rZW4odGhpcykpOyB9XG5cbiAgICB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLmVuZDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgdGhpcy5sYXN0VG9rRW5kTG9jID0gdGhpcy5lbmRMb2M7XG4gICAgdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gIH07XG5cbiAgcHAkOS5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiBuZXcgVG9rZW4odGhpcylcbiAgfTtcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICB7IHBwJDlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzJDEuZ2V0VG9rZW4oKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdG9rZW4udHlwZSA9PT0gdHlwZXMuZW9mLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgfVxuXG5cbiAgcHAkOS5jdXJDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dFt0aGlzLmNvbnRleHQubGVuZ3RoIC0gMV1cbiAgfTtcblxuXG4gIHBwJDkubmV4dFRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1ckNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAoIWN1ckNvbnRleHQgfHwgIWN1ckNvbnRleHQucHJlc2VydmVTcGFjZSkgeyB0aGlzLnNraXBTcGFjZSgpOyB9XG5cbiAgICB0aGlzLnN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5zdGFydExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTsgfVxuICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5lb2YpIH1cblxuICAgIGlmIChjdXJDb250ZXh0Lm92ZXJyaWRlKSB7IHJldHVybiBjdXJDb250ZXh0Lm92ZXJyaWRlKHRoaXMpIH1cbiAgICBlbHNlIHsgdGhpcy5yZWFkVG9rZW4odGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKTsgfVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuID0gZnVuY3Rpb24oY29kZSkge1xuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgfHwgY29kZSA9PT0gOTIgKVxuICAgICAgeyByZXR1cm4gdGhpcy5yZWFkV29yZCgpIH1cblxuICAgIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY29kZSlcbiAgfTtcblxuICBwcCQ5LmZ1bGxDaGFyQ29kZUF0UG9zID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmIChjb2RlIDw9IDB4ZDdmZiB8fCBjb2RlID49IDB4ZTAwMCkgeyByZXR1cm4gY29kZSB9XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICByZXR1cm4gKGNvZGUgPDwgMTApICsgbmV4dCAtIDB4MzVmZGMwMFxuICB9O1xuXG4gIHBwJDkuc2tpcEJsb2NrQ29tbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpO1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zLCBlbmQgPSB0aGlzLmlucHV0LmluZGV4T2YoXCIqL1wiLCB0aGlzLnBvcyArPSAyKTtcbiAgICBpZiAoZW5kID09PSAtMSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zIC0gMiwgXCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiKTsgfVxuICAgIHRoaXMucG9zID0gZW5kICsgMjtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWtHLmV4ZWModGhpcy5pbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgdGhpcy5wb3MpIHtcbiAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KHRydWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG4gIH07XG5cbiAgcHAkOS5za2lwTGluZUNvbW1lbnQgPSBmdW5jdGlvbihzdGFydFNraXApIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKz0gc3RhcnRTa2lwKTtcbiAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhaXNOZXdMaW5lKGNoKSkge1xuICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KGZhbHNlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCB0aGlzLnBvcyksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbiAgfTtcblxuXG4gIHBwJDkuc2tpcFNwYWNlID0gZnVuY3Rpb24oKSB7XG4gICAgbG9vcDogd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICBjYXNlIDMyOiBjYXNlIDE2MDogXG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDEzOlxuICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEwKSB7XG4gICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMDogY2FzZSA4MjMyOiBjYXNlIDgyMzM6XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA0NzogXG4gICAgICAgIHN3aXRjaCAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkpIHtcbiAgICAgICAgY2FzZSA0MjogXG4gICAgICAgICAgdGhpcy5za2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrIGxvb3BcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNoID4gOCAmJiBjaCA8IDE0IHx8IGNoID49IDU3NjAgJiYgbm9uQVNDSUl3aGl0ZXNwYWNlLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKSB7XG4gICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICBwcCQ5LmZpbmlzaFRva2VuID0gZnVuY3Rpb24odHlwZSwgdmFsKSB7XG4gICAgdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTsgfVxuICAgIHZhciBwcmV2VHlwZSA9IHRoaXMudHlwZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSB2YWw7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbnRleHQocHJldlR5cGUpO1xuICB9O1xuXG5cbiAgcHAkOS5yZWFkVG9rZW5fZG90ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSB7IHJldHVybiB0aGlzLnJlYWROdW1iZXIodHJ1ZSkgfVxuICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBuZXh0ID09PSA0NiAmJiBuZXh0MiA9PT0gNDYpIHsgXG4gICAgICB0aGlzLnBvcyArPSAzO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZWxsaXBzaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5kb3QpXG4gICAgfVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX3NsYXNoID0gZnVuY3Rpb24oKSB7IFxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKHRoaXMuZXhwckFsbG93ZWQpIHsgKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMucmVhZFJlZ2V4cCgpIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuc2xhc2gsIDEpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwID0gZnVuY3Rpb24oY29kZSkgeyBcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIHZhciBzaXplID0gMTtcbiAgICB2YXIgdG9rZW50eXBlID0gY29kZSA9PT0gNDIgPyB0eXBlcy5zdGFyIDogdHlwZXMubW9kdWxvO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmIGNvZGUgPT09IDQyICYmIG5leHQgPT09IDQyKSB7XG4gICAgICArK3NpemU7XG4gICAgICB0b2tlbnR5cGUgPSB0eXBlcy5zdGFyc3RhcjtcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCBzaXplICsgMSkgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHRva2VudHlwZSwgc2l6ZSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9waXBlX2FtcCA9IGZ1bmN0aW9uKGNvZGUpIHsgXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcy5sb2dpY2FsT1IgOiB0eXBlcy5sb2dpY2FsQU5ELCAyKSB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmJpdHdpc2VPUiA6IHR5cGVzLmJpdHdpc2VBTkQsIDEpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fY2FyZXQgPSBmdW5jdGlvbigpIHsgXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYml0d2lzZVhPUiwgMSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9wbHVzX21pbiA9IGZ1bmN0aW9uKGNvZGUpIHsgXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKG5leHQgPT09IDQ1ICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiAmJlxuICAgICAgICAgICh0aGlzLmxhc3RUb2tFbmQgPT09IDAgfHwgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMucG9zKSkpKSB7XG4gICAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDMpO1xuICAgICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuaW5jRGVjLCAyKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucGx1c01pbiwgMSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9sdF9ndCA9IGZ1bmN0aW9uKGNvZGUpIHsgXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICB2YXIgc2l6ZSA9IDE7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIHNpemUgPSBjb2RlID09PSA2MiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgPyAzIDogMjtcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyBzaXplKSA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCBzaXplICsgMSkgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYml0U2hpZnQsIHNpemUpXG4gICAgfVxuICAgIGlmIChuZXh0ID09PSAzMyAmJiBjb2RlID09PSA2MCAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNDUgJiZcbiAgICAgICAgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMykgPT09IDQ1KSB7XG4gICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCg0KTtcbiAgICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgc2l6ZSA9IDI7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5yZWxhdGlvbmFsLCBzaXplKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX2VxX2V4Y2wgPSBmdW5jdGlvbihjb2RlKSB7IFxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmVxdWFsaXR5LCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjEgPyAzIDogMikgfVxuICAgIGlmIChjb2RlID09PSA2MSAmJiBuZXh0ID09PSA2MiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyBcbiAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5hcnJvdylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyB0eXBlcy5lcSA6IHR5cGVzLnByZWZpeCwgMSlcbiAgfTtcblxuICBwcCQ5LmdldFRva2VuRnJvbUNvZGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSA0NjogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZG90KClcblxuICAgIGNhc2UgNDA6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnBhcmVuTClcbiAgICBjYXNlIDQxOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5wYXJlblIpXG4gICAgY2FzZSA1OTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc2VtaSlcbiAgICBjYXNlIDQ0OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5jb21tYSlcbiAgICBjYXNlIDkxOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0TClcbiAgICBjYXNlIDkzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0UilcbiAgICBjYXNlIDEyMzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VMKVxuICAgIGNhc2UgMTI1OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZVIpXG4gICAgY2FzZSA1ODogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29sb24pXG4gICAgY2FzZSA2MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucXVlc3Rpb24pXG5cbiAgICBjYXNlIDk2OiBcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IGJyZWFrIH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpXG5cbiAgICBjYXNlIDQ4OiBcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigxNikgfSBcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgICBpZiAobmV4dCA9PT0gMTExIHx8IG5leHQgPT09IDc5KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcig4KSB9IFxuICAgICAgICBpZiAobmV4dCA9PT0gOTggfHwgbmV4dCA9PT0gNjYpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDIpIH0gXG4gICAgICB9XG5cbiAgICBjYXNlIDQ5OiBjYXNlIDUwOiBjYXNlIDUxOiBjYXNlIDUyOiBjYXNlIDUzOiBjYXNlIDU0OiBjYXNlIDU1OiBjYXNlIDU2OiBjYXNlIDU3OiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWROdW1iZXIoZmFsc2UpXG5cbiAgICBjYXNlIDM0OiBjYXNlIDM5OiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcoY29kZSlcblxuXG4gICAgY2FzZSA0NzogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fc2xhc2goKVxuXG4gICAgY2FzZSAzNzogY2FzZSA0MjogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwKGNvZGUpXG5cbiAgICBjYXNlIDEyNDogY2FzZSAzODogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGlwZV9hbXAoY29kZSlcblxuICAgIGNhc2UgOTQ6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2NhcmV0KClcblxuICAgIGNhc2UgNDM6IGNhc2UgNDU6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BsdXNfbWluKGNvZGUpXG5cbiAgICBjYXNlIDYwOiBjYXNlIDYyOiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9sdF9ndChjb2RlKVxuXG4gICAgY2FzZSA2MTogY2FzZSAzMzogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZXFfZXhjbChjb2RlKVxuXG4gICAgY2FzZSAxMjY6IFxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucHJlZml4LCAxKVxuICAgIH1cblxuICAgIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmckMShjb2RlKSArIFwiJ1wiKTtcbiAgfTtcblxuICBwcCQ5LmZpbmlzaE9wID0gZnVuY3Rpb24odHlwZSwgc2l6ZSkge1xuICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIHNpemUpO1xuICAgIHRoaXMucG9zICs9IHNpemU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKVxuICB9O1xuXG4gIHBwJDkucmVhZFJlZ2V4cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7IH1cbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgIGlmIChsaW5lQnJlYWsudGVzdChjaCkpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgICBpZiAoIWVzY2FwZWQpIHtcbiAgICAgICAgaWYgKGNoID09PSBcIltcIikgeyBpbkNsYXNzID0gdHJ1ZTsgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gXCJdXCIgJiYgaW5DbGFzcykgeyBpbkNsYXNzID0gZmFsc2U7IH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwiL1wiICYmICFpbkNsYXNzKSB7IGJyZWFrIH1cbiAgICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICAgIH0gZWxzZSB7IGVzY2FwZWQgPSBmYWxzZTsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICB9XG4gICAgdmFyIHBhdHRlcm4gPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICAgKyt0aGlzLnBvcztcbiAgICB2YXIgZmxhZ3NTdGFydCA9IHRoaXMucG9zO1xuICAgIHZhciBmbGFncyA9IHRoaXMucmVhZFdvcmQxKCk7XG4gICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy51bmV4cGVjdGVkKGZsYWdzU3RhcnQpOyB9XG5cbiAgICB2YXIgc3RhdGUgPSB0aGlzLnJlZ2V4cFN0YXRlIHx8ICh0aGlzLnJlZ2V4cFN0YXRlID0gbmV3IFJlZ0V4cFZhbGlkYXRpb25TdGF0ZSh0aGlzKSk7XG4gICAgc3RhdGUucmVzZXQoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKTtcbiAgICB0aGlzLnZhbGlkYXRlUmVnRXhwRmxhZ3Moc3RhdGUpO1xuICAgIHRoaXMudmFsaWRhdGVSZWdFeHBQYXR0ZXJuKHN0YXRlKTtcblxuICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnJlZ2V4cCwge3BhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncywgdmFsdWU6IHZhbHVlfSlcbiAgfTtcblxuXG4gIHBwJDkucmVhZEludCA9IGZ1bmN0aW9uKHJhZGl4LCBsZW4pIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgdG90YWwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSkge1xuICAgICAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLCB2YWwgPSAodm9pZCAwKTtcbiAgICAgIGlmIChjb2RlID49IDk3KSB7IHZhbCA9IGNvZGUgLSA5NyArIDEwOyB9IFxuICAgICAgZWxzZSBpZiAoY29kZSA+PSA2NSkgeyB2YWwgPSBjb2RlIC0gNjUgKyAxMDsgfSBcbiAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgeyB2YWwgPSBjb2RlIC0gNDg7IH0gXG4gICAgICBlbHNlIHsgdmFsID0gSW5maW5pdHk7IH1cbiAgICAgIGlmICh2YWwgPj0gcmFkaXgpIHsgYnJlYWsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHRvdGFsID0gdG90YWwgKiByYWRpeCArIHZhbDtcbiAgICB9XG4gICAgaWYgKHRoaXMucG9zID09PSBzdGFydCB8fCBsZW4gIT0gbnVsbCAmJiB0aGlzLnBvcyAtIHN0YXJ0ICE9PSBsZW4pIHsgcmV0dXJuIG51bGwgfVxuXG4gICAgcmV0dXJuIHRvdGFsXG4gIH07XG5cbiAgcHAkOS5yZWFkUmFkaXhOdW1iZXIgPSBmdW5jdGlvbihyYWRpeCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgIHRoaXMucG9zICs9IDI7IFxuICAgIHZhciB2YWwgPSB0aGlzLnJlYWRJbnQocmFkaXgpO1xuICAgIGlmICh2YWwgPT0gbnVsbCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQgKyAyLCBcIkV4cGVjdGVkIG51bWJlciBpbiByYWRpeCBcIiArIHJhZGl4KTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTEwKSB7XG4gICAgICB2YWwgPSB0eXBlb2YgQmlnSW50ICE9PSBcInVuZGVmaW5lZFwiID8gQmlnSW50KHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSkgOiBudWxsO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsKVxuICB9O1xuXG5cbiAgcHAkOS5yZWFkTnVtYmVyID0gZnVuY3Rpb24oc3RhcnRzV2l0aERvdCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgIGlmICghc3RhcnRzV2l0aERvdCAmJiB0aGlzLnJlYWRJbnQoMTApID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgICB2YXIgb2N0YWwgPSB0aGlzLnBvcyAtIHN0YXJ0ID49IDIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gNDg7XG4gICAgaWYgKG9jdGFsICYmIHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKCFvY3RhbCAmJiAhc3RhcnRzV2l0aERvdCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgbmV4dCA9PT0gMTEwKSB7XG4gICAgICB2YXIgc3RyJDEgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICB2YXIgdmFsJDEgPSB0eXBlb2YgQmlnSW50ICE9PSBcInVuZGVmaW5lZFwiID8gQmlnSW50KHN0ciQxKSA6IG51bGw7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwkMSlcbiAgICB9XG4gICAgaWYgKG9jdGFsICYmIC9bODldLy50ZXN0KHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSkpIHsgb2N0YWwgPSBmYWxzZTsgfVxuICAgIGlmIChuZXh0ID09PSA0NiAmJiAhb2N0YWwpIHsgXG4gICAgICArK3RoaXMucG9zO1xuICAgICAgdGhpcy5yZWFkSW50KDEwKTtcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIH1cbiAgICBpZiAoKG5leHQgPT09IDY5IHx8IG5leHQgPT09IDEwMSkgJiYgIW9jdGFsKSB7IFxuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkgeyArK3RoaXMucG9zOyB9IFxuICAgICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG5cbiAgICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICAgIHZhciB2YWwgPSBvY3RhbCA/IHBhcnNlSW50KHN0ciwgOCkgOiBwYXJzZUZsb2F0KHN0cik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwpXG4gIH07XG5cblxuICBwcCQ5LnJlYWRDb2RlUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLCBjb2RlO1xuXG4gICAgaWYgKGNoID09PSAxMjMpIHsgXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgdmFyIGNvZGVQb3MgPSArK3RoaXMucG9zO1xuICAgICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIodGhpcy5pbnB1dC5pbmRleE9mKFwifVwiLCB0aGlzLnBvcykgLSB0aGlzLnBvcyk7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgaWYgKGNvZGUgPiAweDEwRkZGRikgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihjb2RlUG9zLCBcIkNvZGUgcG9pbnQgb3V0IG9mIGJvdW5kc1wiKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcig0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfTtcblxuICBmdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyQxKGNvZGUpIHtcbiAgICBpZiAoY29kZSA8PSAweEZGRkYpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgfVxuICAgIGNvZGUgLT0gMHgxMDAwMDtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweEQ4MDAsIChjb2RlICYgMTAyMykgKyAweERDMDApXG4gIH1cblxuICBwcCQ5LnJlYWRTdHJpbmcgPSBmdW5jdGlvbihxdW90ZSkge1xuICAgIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gKyt0aGlzLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IHF1b3RlKSB7IGJyZWFrIH1cbiAgICAgIGlmIChjaCA9PT0gOTIpIHsgXG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKGZhbHNlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmV3TGluZShjaCwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEwKSkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcysrKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5zdHJpbmcsIG91dClcbiAgfTtcblxuXG4gIHZhciBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUiA9IHt9O1xuXG4gIHBwJDkudHJ5UmVhZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluVGVtcGxhdGVFbGVtZW50ID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5yZWFkVG1wbFRva2VuKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyID09PSBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUikge1xuICAgICAgICB0aGlzLnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IGZhbHNlO1xuICB9O1xuXG4gIHBwJDkuaW52YWxpZFN0cmluZ1Rva2VuID0gZnVuY3Rpb24ocG9zaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5pblRlbXBsYXRlRWxlbWVudCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgdGhyb3cgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1JcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yYWlzZShwb3NpdGlvbiwgbWVzc2FnZSk7XG4gICAgfVxuICB9O1xuXG4gIHBwJDkucmVhZFRtcGxUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7IH1cbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IDk2IHx8IGNoID09PSAzNiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTIzKSB7IFxuICAgICAgICBpZiAodGhpcy5wb3MgPT09IHRoaXMuc3RhcnQgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMudGVtcGxhdGUgfHwgdGhpcy50eXBlID09PSB0eXBlcy5pbnZhbGlkVGVtcGxhdGUpKSB7XG4gICAgICAgICAgaWYgKGNoID09PSAzNikge1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmRvbGxhckJyYWNlTClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJhY2tRdW90ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy50ZW1wbGF0ZSwgb3V0KVxuICAgICAgfVxuICAgICAgaWYgKGNoID09PSA5MikgeyBcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICBvdXQgKz0gdGhpcy5yZWFkRXNjYXBlZENoYXIodHJ1ZSk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTApIHsgKyt0aGlzLnBvczsgfVxuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIG91dCArPSBcIlxcblwiO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDkucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICg7IHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGg7IHRoaXMucG9zKyspIHtcbiAgICAgIHN3aXRjaCAodGhpcy5pbnB1dFt0aGlzLnBvc10pIHtcbiAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgIGlmICh0aGlzLmlucHV0W3RoaXMucG9zICsgMV0gIT09IFwie1wiKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiYFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5pbnZhbGlkVGVtcGxhdGUsIHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpKVxuXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7XG4gIH07XG5cblxuICBwcCQ5LnJlYWRFc2NhcGVkQ2hhciA9IGZ1bmN0aW9uKGluVGVtcGxhdGUpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgKyt0aGlzLnBvcztcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAxMTA6IHJldHVybiBcIlxcblwiIFxuICAgIGNhc2UgMTE0OiByZXR1cm4gXCJcXHJcIiBcbiAgICBjYXNlIDEyMDogcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSGV4Q2hhcigyKSkgXG4gICAgY2FzZSAxMTc6IHJldHVybiBjb2RlUG9pbnRUb1N0cmluZyQxKHRoaXMucmVhZENvZGVQb2ludCgpKSBcbiAgICBjYXNlIDExNjogcmV0dXJuIFwiXFx0XCIgXG4gICAgY2FzZSA5ODogcmV0dXJuIFwiXFxiXCIgXG4gICAgY2FzZSAxMTg6IHJldHVybiBcIlxcdTAwMGJcIiBcbiAgICBjYXNlIDEwMjogcmV0dXJuIFwiXFxmXCIgXG4gICAgY2FzZSAxMzogaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH0gXG4gICAgY2FzZSAxMDogXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zOyArK3RoaXMuY3VyTGluZTsgfVxuICAgICAgcmV0dXJuIFwiXCJcbiAgICBjYXNlIDU2OlxuICAgIGNhc2UgNTc6XG4gICAgICBpZiAoaW5UZW1wbGF0ZSkge1xuICAgICAgICB2YXIgY29kZVBvcyA9IHRoaXMucG9zIC0gMTtcblxuICAgICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihcbiAgICAgICAgICBjb2RlUG9zLFxuICAgICAgICAgIFwiSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgaW4gdGVtcGxhdGUgc3RyaW5nXCJcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTUpIHtcbiAgICAgICAgdmFyIG9jdGFsU3RyID0gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MgLSAxLCAzKS5tYXRjaCgvXlswLTddKy8pWzBdO1xuICAgICAgICB2YXIgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIGlmIChvY3RhbCA+IDI1NSkge1xuICAgICAgICAgIG9jdGFsU3RyID0gb2N0YWxTdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zICs9IG9jdGFsU3RyLmxlbmd0aCAtIDE7XG4gICAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKChvY3RhbFN0ciAhPT0gXCIwXCIgfHwgY2ggPT09IDU2IHx8IGNoID09PSA1NykgJiYgKHRoaXMuc3RyaWN0IHx8IGluVGVtcGxhdGUpKSB7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgICAgICB0aGlzLnBvcyAtIDEgLSBvY3RhbFN0ci5sZW5ndGgsXG4gICAgICAgICAgICBpblRlbXBsYXRlXG4gICAgICAgICAgICAgID8gXCJPY3RhbCBsaXRlcmFsIGluIHRlbXBsYXRlIHN0cmluZ1wiXG4gICAgICAgICAgICAgIDogXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG9jdGFsKVxuICAgICAgfVxuICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgcmV0dXJuIFwiXCJcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKVxuICAgIH1cbiAgfTtcblxuXG4gIHBwJDkucmVhZEhleENoYXIgPSBmdW5jdGlvbihsZW4pIHtcbiAgICB2YXIgY29kZVBvcyA9IHRoaXMucG9zO1xuICAgIHZhciBuID0gdGhpcy5yZWFkSW50KDE2LCBsZW4pO1xuICAgIGlmIChuID09PSBudWxsKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIik7IH1cbiAgICByZXR1cm4gblxuICB9O1xuXG5cbiAgcHAkOS5yZWFkV29yZDEgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG4gICAgdmFyIHdvcmQgPSBcIlwiLCBmaXJzdCA9IHRydWUsIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB2YXIgYXN0cmFsID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gICAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKTtcbiAgICAgIGlmIChpc0lkZW50aWZpZXJDaGFyKGNoLCBhc3RyYWwpKSB7XG4gICAgICAgIHRoaXMucG9zICs9IGNoIDw9IDB4ZmZmZiA/IDEgOiAyO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHsgXG4gICAgICAgIHRoaXMuY29udGFpbnNFc2MgPSB0cnVlO1xuICAgICAgICB3b3JkICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICB2YXIgZXNjU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKSAhPT0gMTE3KSBcbiAgICAgICAgICB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKHRoaXMucG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7IH1cbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgdmFyIGVzYyA9IHRoaXMucmVhZENvZGVQb2ludCgpO1xuICAgICAgICBpZiAoIShmaXJzdCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcikoZXNjLCBhc3RyYWwpKVxuICAgICAgICAgIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oZXNjU3RhcnQsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTsgfVxuICAgICAgICB3b3JkICs9IGNvZGVQb2ludFRvU3RyaW5nJDEoZXNjKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB3b3JkICsgdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcylcbiAgfTtcblxuXG4gIHBwJDkucmVhZFdvcmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgd29yZCA9IHRoaXMucmVhZFdvcmQxKCk7XG4gICAgdmFyIHR5cGUgPSB0eXBlcy5uYW1lO1xuICAgIGlmICh0aGlzLmtleXdvcmRzLnRlc3Qod29yZCkpIHtcbiAgICAgIHR5cGUgPSBrZXl3b3JkcyQxW3dvcmRdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCB3b3JkKVxuICB9O1xuXG5cbiAgdmFyIHZlcnNpb24gPSBcIjcuMS4wXCI7XG5cbiAgUGFyc2VyLmFjb3JuID0ge1xuICAgIFBhcnNlcjogUGFyc2VyLFxuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgZGVmYXVsdE9wdGlvbnM6IGRlZmF1bHRPcHRpb25zLFxuICAgIFBvc2l0aW9uOiBQb3NpdGlvbixcbiAgICBTb3VyY2VMb2NhdGlvbjogU291cmNlTG9jYXRpb24sXG4gICAgZ2V0TGluZUluZm86IGdldExpbmVJbmZvLFxuICAgIE5vZGU6IE5vZGUsXG4gICAgVG9rZW5UeXBlOiBUb2tlblR5cGUsXG4gICAgdG9rVHlwZXM6IHR5cGVzLFxuICAgIGtleXdvcmRUeXBlczoga2V5d29yZHMkMSxcbiAgICBUb2tDb250ZXh0OiBUb2tDb250ZXh0LFxuICAgIHRva0NvbnRleHRzOiB0eXBlcyQxLFxuICAgIGlzSWRlbnRpZmllckNoYXI6IGlzSWRlbnRpZmllckNoYXIsXG4gICAgaXNJZGVudGlmaWVyU3RhcnQ6IGlzSWRlbnRpZmllclN0YXJ0LFxuICAgIFRva2VuOiBUb2tlbixcbiAgICBpc05ld0xpbmU6IGlzTmV3TGluZSxcbiAgICBsaW5lQnJlYWs6IGxpbmVCcmVhayxcbiAgICBsaW5lQnJlYWtHOiBsaW5lQnJlYWtHLFxuICAgIG5vbkFTQ0lJd2hpdGVzcGFjZTogbm9uQVNDSUl3aGl0ZXNwYWNlXG4gIH07XG5cblxuICBmdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBQYXJzZXIucGFyc2UoaW5wdXQsIG9wdGlvbnMpXG4gIH1cblxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpXG4gIH1cblxuXG4gIGZ1bmN0aW9uIHRva2VuaXplcihpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBQYXJzZXIudG9rZW5pemVyKGlucHV0LCBvcHRpb25zKVxuICB9XG5cbiAgZXhwb3J0cy5Ob2RlID0gTm9kZTtcbiAgZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG4gIGV4cG9ydHMuUG9zaXRpb24gPSBQb3NpdGlvbjtcbiAgZXhwb3J0cy5Tb3VyY2VMb2NhdGlvbiA9IFNvdXJjZUxvY2F0aW9uO1xuICBleHBvcnRzLlRva0NvbnRleHQgPSBUb2tDb250ZXh0O1xuICBleHBvcnRzLlRva2VuID0gVG9rZW47XG4gIGV4cG9ydHMuVG9rZW5UeXBlID0gVG9rZW5UeXBlO1xuICBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gIGV4cG9ydHMuZ2V0TGluZUluZm8gPSBnZXRMaW5lSW5mbztcbiAgZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gaXNJZGVudGlmaWVyQ2hhcjtcbiAgZXhwb3J0cy5pc0lkZW50aWZpZXJTdGFydCA9IGlzSWRlbnRpZmllclN0YXJ0O1xuICBleHBvcnRzLmlzTmV3TGluZSA9IGlzTmV3TGluZTtcbiAgZXhwb3J0cy5rZXl3b3JkVHlwZXMgPSBrZXl3b3JkcyQxO1xuICBleHBvcnRzLmxpbmVCcmVhayA9IGxpbmVCcmVhaztcbiAgZXhwb3J0cy5saW5lQnJlYWtHID0gbGluZUJyZWFrRztcbiAgZXhwb3J0cy5ub25BU0NJSXdoaXRlc3BhY2UgPSBub25BU0NJSXdoaXRlc3BhY2U7XG4gIGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbiAgZXhwb3J0cy5wYXJzZUV4cHJlc3Npb25BdCA9IHBhcnNlRXhwcmVzc2lvbkF0O1xuICBleHBvcnRzLnRva0NvbnRleHRzID0gdHlwZXMkMTtcbiAgZXhwb3J0cy50b2tUeXBlcyA9IHR5cGVzO1xuICBleHBvcnRzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG5cbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG59LHt9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmZ1bmN0aW9uIGdsV2lyZXRhcChnbCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBjb250ZXh0TmFtZSA9ICdnbCcsXG4gICAgdGhyb3dHZXRFcnJvcixcbiAgICB1c2VUcmFja2FibGVQcmltaXRpdmVzLFxuICAgIHJlYWRQaXhlbHNGaWxlLFxuICAgIHJlY29yZGluZyA9IFtdLFxuICAgIHZhcmlhYmxlcyA9IHt9LFxuICAgIG9uUmVhZFBpeGVscyxcbiAgICBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwLFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoZ2wsIHsgZ2V0OiBsaXN0ZW4gfSk7XG4gIGNvbnN0IGNvbnRleHRWYXJpYWJsZXMgPSBbXTtcbiAgY29uc3QgZW50aXR5TmFtZXMgPSB7fTtcbiAgbGV0IGltYWdlQ291bnQgPSAwO1xuICBsZXQgaW5kZW50ID0gJyc7XG4gIGxldCByZWFkUGl4ZWxzVmFyaWFibGVOYW1lO1xuICByZXR1cm4gcHJveHk7XG4gIGZ1bmN0aW9uIGxpc3RlbihvYmosIHByb3BlcnR5KSB7XG4gICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgY2FzZSAnYWRkQ29tbWVudCc6IHJldHVybiBhZGRDb21tZW50O1xuICAgICAgY2FzZSAnY2hlY2tUaHJvd0Vycm9yJzogcmV0dXJuIGNoZWNrVGhyb3dFcnJvcjtcbiAgICAgIGNhc2UgJ2dldFJlYWRQaXhlbHNWYXJpYWJsZU5hbWUnOiByZXR1cm4gcmVhZFBpeGVsc1ZhcmlhYmxlTmFtZTtcbiAgICAgIGNhc2UgJ2luc2VydFZhcmlhYmxlJzogcmV0dXJuIGluc2VydFZhcmlhYmxlO1xuICAgICAgY2FzZSAncmVzZXQnOiByZXR1cm4gcmVzZXQ7XG4gICAgICBjYXNlICdzZXRJbmRlbnQnOiByZXR1cm4gc2V0SW5kZW50O1xuICAgICAgY2FzZSAndG9TdHJpbmcnOiByZXR1cm4gdG9TdHJpbmc7XG4gICAgICBjYXNlICdnZXRDb250ZXh0VmFyaWFibGVOYW1lJzogcmV0dXJuIGdldENvbnRleHRWYXJpYWJsZU5hbWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ2xbcHJvcGVydHldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7IFxuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICAgICAgY2FzZSAnZ2V0RXJyb3InOlxuICAgICAgICAgICAgaWYgKHRocm93R2V0RXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWlmICgke2NvbnRleHROYW1lfS5nZXRFcnJvcigpICE9PSAke2NvbnRleHROYW1lfS5OT05FKSB0aHJvdyBuZXcgRXJyb3IoJ2Vycm9yJyk7YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9JHtjb250ZXh0TmFtZX0uZ2V0RXJyb3IoKTtgKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2wuZ2V0RXJyb3IoKTtcbiAgICAgICAgICBjYXNlICdnZXRFeHRlbnNpb24nOiB7XG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBgJHtjb250ZXh0TmFtZX1WYXJpYWJsZXMke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofWA7XG4gICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHt2YXJpYWJsZU5hbWV9ID0gJHtjb250ZXh0TmFtZX0uZ2V0RXh0ZW5zaW9uKCcke2FyZ3VtZW50c1swXX0nKTtgKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbihhcmd1bWVudHNbMF0pO1xuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbiAmJiB0eXBlb2YgZXh0ZW5zaW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBjb25zdCB0YXBwZWRFeHRlbnNpb24gPSBnbEV4dGVuc2lvbldpcmV0YXAoZXh0ZW5zaW9uLCB7XG4gICAgICAgICAgICAgICAgZ2V0RW50aXR5LFxuICAgICAgICAgICAgICAgIHVzZVRyYWNrYWJsZVByaW1pdGl2ZXMsXG4gICAgICAgICAgICAgICAgcmVjb3JkaW5nLFxuICAgICAgICAgICAgICAgIGNvbnRleHROYW1lOiB2YXJpYWJsZU5hbWUsXG4gICAgICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgaW5kZW50LFxuICAgICAgICAgICAgICAgIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLnB1c2godGFwcGVkRXh0ZW5zaW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcHBlZEV4dGVuc2lvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3JlYWRQaXhlbHMnOlxuICAgICAgICAgICAgY29uc3QgaSA9IGNvbnRleHRWYXJpYWJsZXMuaW5kZXhPZihhcmd1bWVudHNbNl0pO1xuICAgICAgICAgICAgbGV0IHRhcmdldFZhcmlhYmxlTmFtZTtcbiAgICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBnZXRWYXJpYWJsZU5hbWUoYXJndW1lbnRzWzZdKTtcbiAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFZhcmlhYmxlTmFtZSA9IHZhcmlhYmxlTmFtZTtcbiAgICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9JHt2YXJpYWJsZU5hbWV9YCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VmFyaWFibGVOYW1lID0gYCR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofWA7XG4gICAgICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKGFyZ3VtZW50c1s2XSk7XG4gICAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7dGFyZ2V0VmFyaWFibGVOYW1lfSA9IG5ldyAke2FyZ3VtZW50c1s2XS5jb25zdHJ1Y3Rvci5uYW1lfSgke2FyZ3VtZW50c1s2XS5sZW5ndGh9KTtgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0VmFyaWFibGVOYW1lID0gYCR7Y29udGV4dE5hbWV9VmFyaWFibGUke2l9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRQaXhlbHNWYXJpYWJsZU5hbWUgPSB0YXJnZXRWYXJpYWJsZU5hbWU7XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudEFzU3RyaW5ncyA9IFtcbiAgICAgICAgICAgICAgYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgICBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICAgIGFyZ3VtZW50c1syXSxcbiAgICAgICAgICAgICAgYXJndW1lbnRzWzNdLFxuICAgICAgICAgICAgICBnZXRFbnRpdHkoYXJndW1lbnRzWzRdKSxcbiAgICAgICAgICAgICAgZ2V0RW50aXR5KGFyZ3VtZW50c1s1XSksXG4gICAgICAgICAgICAgIHRhcmdldFZhcmlhYmxlTmFtZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0ke2NvbnRleHROYW1lfS5yZWFkUGl4ZWxzKCR7YXJndW1lbnRBc1N0cmluZ3Muam9pbignLCAnKX0pO2ApO1xuICAgICAgICAgICAgaWYgKHJlYWRQaXhlbHNGaWxlKSB7XG4gICAgICAgICAgICAgIHdyaXRlUFBNKGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblJlYWRQaXhlbHMpIHtcbiAgICAgICAgICAgICAgb25SZWFkUGl4ZWxzKHRhcmdldFZhcmlhYmxlTmFtZSwgYXJndW1lbnRBc1N0cmluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdsLnJlYWRQaXhlbHMuYXBwbHkoZ2wsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgY2FzZSAnZHJhd0J1ZmZlcnMnOlxuICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fSR7Y29udGV4dE5hbWV9LmRyYXdCdWZmZXJzKFske2FyZ3VtZW50c1RvU3RyaW5nKGFyZ3VtZW50c1swXSwgeyBjb250ZXh0TmFtZSwgY29udGV4dFZhcmlhYmxlcywgZ2V0RW50aXR5LCBhZGRWYXJpYWJsZSwgdmFyaWFibGVzLCBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwIH0gKX1dKTtgKTtcbiAgICAgICAgICAgIHJldHVybiBnbC5kcmF3QnVmZmVycyhhcmd1bWVudHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBnbFtwcm9wZXJ0eV0uYXBwbHkoZ2wsIGFyZ3VtZW50cyk7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHJlc3VsdCkge1xuICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9JHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBpZiAodXNlVHJhY2thYmxlUHJpbWl0aXZlcyAmJiBjb250ZXh0VmFyaWFibGVzLmluZGV4T2YodHJhY2thYmxlUHJpbWl0aXZlKHJlc3VsdCkpID09PSAtMSkge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9ID0gJHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLnB1c2gocmVzdWx0ID0gdHJhY2thYmxlUHJpbWl0aXZlKHJlc3VsdCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofSA9ICR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgZW50aXR5TmFtZXNbZ2xbcHJvcGVydHldXSA9IHByb3BlcnR5O1xuICAgIHJldHVybiBnbFtwcm9wZXJ0eV07XG4gIH1cbiAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHJlY29yZGluZy5qb2luKCdcXG4nKTtcbiAgfVxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB3aGlsZSAocmVjb3JkaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlY29yZGluZy5wb3AoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW5zZXJ0VmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICB2YXJpYWJsZXNbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRFbnRpdHkodmFsdWUpIHtcbiAgICBjb25zdCBuYW1lID0gZW50aXR5TmFtZXNbdmFsdWVdO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gY29udGV4dE5hbWUgKyAnLicgKyBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gc2V0SW5kZW50KHNwYWNlcykge1xuICAgIGluZGVudCA9ICcgJy5yZXBlYXQoc3BhY2VzKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRWYXJpYWJsZSh2YWx1ZSwgc291cmNlKSB7XG4gICAgY29uc3QgdmFyaWFibGVOYW1lID0gYCR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofWA7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7dmFyaWFibGVOYW1lfSA9ICR7c291cmNlfTtgKTtcbiAgICBjb250ZXh0VmFyaWFibGVzLnB1c2godmFsdWUpO1xuICAgIHJldHVybiB2YXJpYWJsZU5hbWU7XG4gIH1cbiAgZnVuY3Rpb24gd3JpdGVQUE0od2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHNvdXJjZVZhcmlhYmxlID0gYCR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofWA7XG4gICAgY29uc3QgaW1hZ2VWYXJpYWJsZSA9IGBpbWFnZURhdHVtJHtpbWFnZUNvdW50fWA7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWxldCAke2ltYWdlVmFyaWFibGV9ID0gW1wiUDNcXFxcbiMgJHtyZWFkUGl4ZWxzRmlsZX0ucHBtXFxcXG5cIiwgJHt3aWR0aH0sICcgJywgJHtoZWlnaHR9LCBcIlxcXFxuMjU1XFxcXG5cIl0uam9pbihcIlwiKTtgKTtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Zm9yIChsZXQgaSA9IDA7IGkgPCAke2ltYWdlVmFyaWFibGV9Lmxlbmd0aDsgaSArPSA0KSB7YCk7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fSAgJHtpbWFnZVZhcmlhYmxlfSArPSAke3NvdXJjZVZhcmlhYmxlfVtpXSArICcgJyArICR7c291cmNlVmFyaWFibGV9W2kgKyAxXSArICcgJyArICR7c291cmNlVmFyaWFibGV9W2kgKyAyXSArICcgJztgKTtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9fWApO1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1pZiAodHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIpIHtgKTtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9ICByZXF1aXJlKCdmcycpLndyaXRlRmlsZVN5bmMoJy4vJHtyZWFkUGl4ZWxzRmlsZX0ucHBtJywgJHtpbWFnZVZhcmlhYmxlfSk7YCk7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fX1gKTtcbiAgICBpbWFnZUNvdW50Kys7XG4gIH1cbiAgZnVuY3Rpb24gYWRkQ29tbWVudCh2YWx1ZSkge1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0vLyAke3ZhbHVlfWApO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrVGhyb3dFcnJvcigpIHtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9KCgpID0+IHtcbiR7aW5kZW50fWNvbnN0IGVycm9yID0gJHtjb250ZXh0TmFtZX0uZ2V0RXJyb3IoKTtcbiR7aW5kZW50fWlmIChlcnJvciAhPT0gJHtjb250ZXh0TmFtZX0uTk9ORSkge1xuJHtpbmRlbnR9ICBjb25zdCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGdsKTtcbiR7aW5kZW50fSAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuJHtpbmRlbnR9ICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiR7aW5kZW50fSAgICBpZiAoJHtjb250ZXh0TmFtZX1bbmFtZV0gPT09IGVycm9yKSB7XG4ke2luZGVudH0gICAgICB0aHJvdyBuZXcgRXJyb3IoJyR7Y29udGV4dE5hbWV9IHRocmV3ICcgKyBuYW1lKTtcbiR7aW5kZW50fSAgICB9XG4ke2luZGVudH0gIH1cbiR7aW5kZW50fX1cbiR7aW5kZW50fX0pKCk7YCk7XG4gIH1cbiAgZnVuY3Rpb24gbWV0aG9kQ2FsbFRvU3RyaW5nKG1ldGhvZCwgYXJncykge1xuICAgIHJldHVybiBgJHtjb250ZXh0TmFtZX0uJHttZXRob2R9KCR7YXJndW1lbnRzVG9TdHJpbmcoYXJncywgeyBjb250ZXh0TmFtZSwgY29udGV4dFZhcmlhYmxlcywgZ2V0RW50aXR5LCBhZGRWYXJpYWJsZSwgdmFyaWFibGVzLCBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwIH0pfSlgO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VmFyaWFibGVOYW1lKHZhbHVlKSB7XG4gICAgaWYgKHZhcmlhYmxlcykge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhcmlhYmxlcykge1xuICAgICAgICBpZiAodmFyaWFibGVzW25hbWVdID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29udGV4dFZhcmlhYmxlTmFtZSh2YWx1ZSkge1xuICAgIGNvbnN0IGkgPSBjb250ZXh0VmFyaWFibGVzLmluZGV4T2YodmFsdWUpO1xuICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtpfWA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdsRXh0ZW5zaW9uV2lyZXRhcChleHRlbnNpb24sIG9wdGlvbnMpIHtcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoZXh0ZW5zaW9uLCB7IGdldDogbGlzdGVuIH0pO1xuICBjb25zdCBleHRlbnNpb25FbnRpdHlOYW1lcyA9IHt9O1xuICBjb25zdCB7XG4gICAgY29udGV4dE5hbWUsXG4gICAgY29udGV4dFZhcmlhYmxlcyxcbiAgICBnZXRFbnRpdHksXG4gICAgdXNlVHJhY2thYmxlUHJpbWl0aXZlcyxcbiAgICByZWNvcmRpbmcsXG4gICAgdmFyaWFibGVzLFxuICAgIGluZGVudCxcbiAgICBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwLFxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHByb3h5O1xuICBmdW5jdGlvbiBsaXN0ZW4ob2JqLCBwcm9wZXJ0eSkge1xuICAgIGlmICh0eXBlb2Ygb2JqW3Byb3BlcnR5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICAgICAgY2FzZSAnZHJhd0J1ZmZlcnNXRUJHTCc6XG4gICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9JHtjb250ZXh0TmFtZX0uZHJhd0J1ZmZlcnNXRUJHTChbJHthcmd1bWVudHNUb1N0cmluZyhhcmd1bWVudHNbMF0sIHsgY29udGV4dE5hbWUsIGNvbnRleHRWYXJpYWJsZXMsIGdldEVudGl0eTogZ2V0RXh0ZW5zaW9uRW50aXR5LCBhZGRWYXJpYWJsZSwgdmFyaWFibGVzLCBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwIH0pfV0pO2ApO1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbi5kcmF3QnVmZmVyc1dFQkdMKGFyZ3VtZW50c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IGV4dGVuc2lvbltwcm9wZXJ0eV0uYXBwbHkoZXh0ZW5zaW9uLCBhcmd1bWVudHMpO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiByZXN1bHQpIHtcbiAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fSR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgaWYgKHVzZVRyYWNrYWJsZVByaW1pdGl2ZXMgJiYgY29udGV4dFZhcmlhYmxlcy5pbmRleE9mKHRyYWNrYWJsZVByaW1pdGl2ZShyZXN1bHQpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofSA9ICR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKHJlc3VsdCA9IHRyYWNrYWJsZVByaW1pdGl2ZShyZXN1bHQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1jb25zdCAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtjb250ZXh0VmFyaWFibGVzLmxlbmd0aH0gPSAke21ldGhvZENhbGxUb1N0cmluZyhwcm9wZXJ0eSwgYXJndW1lbnRzKX07YCk7XG4gICAgICAgICAgICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1jb25zdCAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtjb250ZXh0VmFyaWFibGVzLmxlbmd0aH0gPSAke21ldGhvZENhbGxUb1N0cmluZyhwcm9wZXJ0eSwgYXJndW1lbnRzKX07YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG4gICAgZXh0ZW5zaW9uRW50aXR5TmFtZXNbZXh0ZW5zaW9uW3Byb3BlcnR5XV0gPSBwcm9wZXJ0eTtcbiAgICByZXR1cm4gZXh0ZW5zaW9uW3Byb3BlcnR5XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEV4dGVuc2lvbkVudGl0eSh2YWx1ZSkge1xuICAgIGlmIChleHRlbnNpb25FbnRpdHlOYW1lcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBgJHtjb250ZXh0TmFtZX0uJHtleHRlbnNpb25FbnRpdHlOYW1lc1t2YWx1ZV19YDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEVudGl0eSh2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXRob2RDYWxsVG9TdHJpbmcobWV0aG9kLCBhcmdzKSB7XG4gICAgcmV0dXJuIGAke2NvbnRleHROYW1lfS4ke21ldGhvZH0oJHthcmd1bWVudHNUb1N0cmluZyhhcmdzLCB7IGNvbnRleHROYW1lLCBjb250ZXh0VmFyaWFibGVzLCBnZXRFbnRpdHk6IGdldEV4dGVuc2lvbkVudGl0eSwgYWRkVmFyaWFibGUsIHZhcmlhYmxlcywgb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCB9KX0pYDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZhcmlhYmxlKHZhbHVlLCBzb3VyY2UpIHtcbiAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9YDtcbiAgICBjb250ZXh0VmFyaWFibGVzLnB1c2godmFsdWUpO1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1jb25zdCAke3ZhcmlhYmxlTmFtZX0gPSAke3NvdXJjZX07YCk7XG4gICAgcmV0dXJuIHZhcmlhYmxlTmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcmd1bWVudHNUb1N0cmluZyhhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgdmFyaWFibGVzLCBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwIH0gPSBvcHRpb25zO1xuICByZXR1cm4gKEFycmF5LmZyb20oYXJncykubWFwKChhcmcpID0+IHtcbiAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBnZXRWYXJpYWJsZU5hbWUoYXJnKTtcbiAgICBpZiAodmFyaWFibGVOYW1lKSB7XG4gICAgICByZXR1cm4gdmFyaWFibGVOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gYXJndW1lbnRUb1N0cmluZyhhcmcsIG9wdGlvbnMpO1xuICB9KS5qb2luKCcsICcpKTtcblxuICBmdW5jdGlvbiBnZXRWYXJpYWJsZU5hbWUodmFsdWUpIHtcbiAgICBpZiAodmFyaWFibGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFyaWFibGVzKSB7XG4gICAgICAgIGlmICghdmFyaWFibGVzLmhhc093blByb3BlcnR5KG5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgaWYgKHZhcmlhYmxlc1tuYW1lXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCkge1xuICAgICAgcmV0dXJuIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcmd1bWVudFRvU3RyaW5nKGFyZywgb3B0aW9ucykge1xuICBjb25zdCB7IGNvbnRleHROYW1lLCBjb250ZXh0VmFyaWFibGVzLCBnZXRFbnRpdHksIGFkZFZhcmlhYmxlLCBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwIH0gPSBvcHRpb25zO1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH1cbiAgaWYgKGFyZyA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH1cbiAgY29uc3QgaSA9IGNvbnRleHRWYXJpYWJsZXMuaW5kZXhPZihhcmcpO1xuICBpZiAoaSA+IC0xKSB7XG4gICAgcmV0dXJuIGAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtpfWA7XG4gIH1cbiAgc3dpdGNoIChhcmcuY29uc3RydWN0b3IubmFtZSkge1xuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICBjb25zdCBoYXNMaW5lcyA9IC9cXG4vLnRlc3QoYXJnKTtcbiAgICAgIGNvbnN0IGhhc1NpbmdsZVF1b3RlcyA9IC8nLy50ZXN0KGFyZyk7XG4gICAgICBjb25zdCBoYXNEb3VibGVRdW90ZXMgPSAvXCIvLnRlc3QoYXJnKTtcbiAgICAgIGlmIChoYXNMaW5lcykge1xuICAgICAgICByZXR1cm4gJ2AnICsgYXJnICsgJ2AnO1xuICAgICAgfSBlbHNlIGlmIChoYXNTaW5nbGVRdW90ZXMgJiYgIWhhc0RvdWJsZVF1b3Rlcykge1xuICAgICAgICByZXR1cm4gJ1wiJyArIGFyZyArICdcIic7XG4gICAgICB9IGVsc2UgaWYgKCFoYXNTaW5nbGVRdW90ZXMgJiYgaGFzRG91YmxlUXVvdGVzKSB7XG4gICAgICAgIHJldHVybiBcIidcIiArIGFyZyArIFwiJ1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdcXCcnICsgYXJnICsgJ1xcJyc7XG4gICAgICB9XG4gICAgY2FzZSAnTnVtYmVyJzogcmV0dXJuIGdldEVudGl0eShhcmcpO1xuICAgIGNhc2UgJ0Jvb2xlYW4nOiByZXR1cm4gZ2V0RW50aXR5KGFyZyk7XG4gICAgY2FzZSAnQXJyYXknOlxuICAgICAgcmV0dXJuIGFkZFZhcmlhYmxlKGFyZywgYG5ldyAke2FyZy5jb25zdHJ1Y3Rvci5uYW1lfShbJHtBcnJheS5mcm9tKGFyZykuam9pbignLCcpfV0pYCk7XG4gICAgY2FzZSAnRmxvYXQzMkFycmF5JzpcbiAgICBjYXNlICdVaW50OEFycmF5JzpcbiAgICBjYXNlICdVaW50MTZBcnJheSc6XG4gICAgY2FzZSAnSW50MzJBcnJheSc6XG4gICAgICByZXR1cm4gYWRkVmFyaWFibGUoYXJnLCBgbmV3ICR7YXJnLmNvbnN0cnVjdG9yLm5hbWV9KCR7SlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbShhcmcpKX0pYCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbnRpYXRpb25TdHJpbmcgPSBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwKGFyZyk7XG4gICAgICAgIGlmIChpbnN0YW50aWF0aW9uU3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRpb25TdHJpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIGFyZ3VtZW50IHR5cGUgJHthcmcuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFja2FibGVQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyB2YWx1ZS5jb25zdHJ1Y3Rvcih2YWx1ZSk7XG59XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgZ2xXaXJldGFwLCBnbEV4dGVuc2lvbldpcmV0YXAgfTtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGdsV2lyZXRhcC5nbEV4dGVuc2lvbldpcmV0YXAgPSBnbEV4dGVuc2lvbldpcmV0YXA7XG4gIHdpbmRvdy5nbFdpcmV0YXAgPSBnbFdpcmV0YXA7XG59XG5cbn0se31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuZnVuY3Rpb24gc2V0dXBBcmd1bWVudHMoYXJncykge1xuICBjb25zdCBuZXdBcmd1bWVudHMgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgIGlmIChhcmcudG9BcnJheSkge1xuICAgICAgbmV3QXJndW1lbnRzW2ldID0gYXJnLnRvQXJyYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3QXJndW1lbnRzW2ldID0gYXJnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3QXJndW1lbnRzO1xufVxuXG5mdW5jdGlvbiBtb2NrMUQoKSB7XG4gIGNvbnN0IGFyZ3MgPSBzZXR1cEFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICBjb25zdCByb3cgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMub3V0cHV0LngpO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMub3V0cHV0Lng7IHgrKykge1xuICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgIHRoaXMudGhyZWFkLnkgPSAwO1xuICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgIHJvd1t4XSA9IHRoaXMuX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIHJldHVybiByb3c7XG59XG5cbmZ1bmN0aW9uIG1vY2syRCgpIHtcbiAgY29uc3QgYXJncyA9IHNldHVwQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gIGNvbnN0IG1hdHJpeCA9IG5ldyBBcnJheSh0aGlzLm91dHB1dC55KTtcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLm91dHB1dC55OyB5KyspIHtcbiAgICBjb25zdCByb3cgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMub3V0cHV0LngpO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5vdXRwdXQueDsgeCsrKSB7XG4gICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xuICAgICAgdGhpcy50aHJlYWQueiA9IDA7XG4gICAgICByb3dbeF0gPSB0aGlzLl9mbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgbWF0cml4W3ldID0gcm93O1xuICB9XG4gIHJldHVybiBtYXRyaXg7XG59XG5cbmZ1bmN0aW9uIG1vY2syREdyYXBoaWNhbCgpIHtcbiAgY29uc3QgYXJncyA9IHNldHVwQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5vdXRwdXQueTsgeSsrKSB7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLm91dHB1dC54OyB4KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICB0aGlzLnRocmVhZC56ID0gMDtcbiAgICAgIHRoaXMuX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb2NrM0QoKSB7XG4gIGNvbnN0IGFyZ3MgPSBzZXR1cEFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICBjb25zdCBjdWJlID0gbmV3IEFycmF5KHRoaXMub3V0cHV0LnopO1xuICBmb3IgKGxldCB6ID0gMDsgeiA8IHRoaXMub3V0cHV0Lno7IHorKykge1xuICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBBcnJheSh0aGlzLm91dHB1dC55KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMub3V0cHV0Lnk7IHkrKykge1xuICAgICAgY29uc3Qgcm93ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm91dHB1dC54KTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5vdXRwdXQueDsgeCsrKSB7XG4gICAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgICB0aGlzLnRocmVhZC55ID0geTtcbiAgICAgICAgdGhpcy50aHJlYWQueiA9IHo7XG4gICAgICAgIHJvd1t4XSA9IHRoaXMuX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgbWF0cml4W3ldID0gcm93O1xuICAgIH1cbiAgICBjdWJlW3pdID0gbWF0cml4O1xuICB9XG4gIHJldHVybiBjdWJlO1xufVxuXG5mdW5jdGlvbiBhcGlEZWNvcmF0ZShrZXJuZWwpIHtcbiAga2VybmVsLnNldE91dHB1dCA9IChvdXRwdXQpID0+IHtcbiAgICBrZXJuZWwub3V0cHV0ID0gc2V0dXBPdXRwdXQob3V0cHV0KTtcbiAgICBpZiAoa2VybmVsLmdyYXBoaWNhbCkge1xuICAgICAgc2V0dXBHcmFwaGljYWwoa2VybmVsKTtcbiAgICB9XG4gIH07XG4gIGtlcm5lbC50b0pTT04gPSAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgdXNhYmxlIHdpdGggZ3B1TW9jaycpO1xuICB9O1xuICBrZXJuZWwuc2V0Q29uc3RhbnRzID0gKGZsYWcpID0+IHtcbiAgICBrZXJuZWwuY29uc3RhbnRzID0gZmxhZztcbiAgICByZXR1cm4ga2VybmVsO1xuICB9O1xuICBrZXJuZWwuc2V0R3JhcGhpY2FsID0gKGZsYWcpID0+IHtcbiAgICBrZXJuZWwuZ3JhcGhpY2FsID0gZmxhZztcbiAgICByZXR1cm4ga2VybmVsO1xuICB9O1xuICBrZXJuZWwuc2V0Q2FudmFzID0gKGZsYWcpID0+IHtcbiAgICBrZXJuZWwuY2FudmFzID0gZmxhZztcbiAgICByZXR1cm4ga2VybmVsO1xuICB9O1xuICBrZXJuZWwuc2V0Q29udGV4dCA9IChmbGFnKSA9PiB7XG4gICAga2VybmVsLmNvbnRleHQgPSBmbGFnO1xuICAgIHJldHVybiBrZXJuZWw7XG4gIH07XG4gIGtlcm5lbC5kZXN0cm95ID0gKCkgPT4ge307XG4gIGtlcm5lbC52YWxpZGF0ZVNldHRpbmdzID0gKCkgPT4ge307XG4gIGlmIChrZXJuZWwuZ3JhcGhpY2FsICYmIGtlcm5lbC5vdXRwdXQpIHtcbiAgICBzZXR1cEdyYXBoaWNhbChrZXJuZWwpO1xuICB9XG4gIGtlcm5lbC5leGVjID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmUoa2VybmVsLmFwcGx5KGtlcm5lbCwgYXJndW1lbnRzKSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBrZXJuZWwuZ2V0UGl4ZWxzID0gKGZsaXApID0+IHtcbiAgICBjb25zdCB7eCwgeX0gPSBrZXJuZWwub3V0cHV0O1xuICAgIHJldHVybiBmbGlwID8gZmxpcFBpeGVscyhrZXJuZWwuX2ltYWdlRGF0YS5kYXRhLCB4LCB5KSA6IGtlcm5lbC5faW1hZ2VEYXRhLmRhdGEuc2xpY2UoMCk7XG4gIH07XG4gIGtlcm5lbC5jb2xvciA9IGZ1bmN0aW9uKHIsIGcsIGIsIGEpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhID0gMTtcbiAgICB9XG5cbiAgICByID0gTWF0aC5mbG9vcihyICogMjU1KTtcbiAgICBnID0gTWF0aC5mbG9vcihnICogMjU1KTtcbiAgICBiID0gTWF0aC5mbG9vcihiICogMjU1KTtcbiAgICBhID0gTWF0aC5mbG9vcihhICogMjU1KTtcblxuICAgIGNvbnN0IHdpZHRoID0ga2VybmVsLm91dHB1dC54O1xuICAgIGNvbnN0IGhlaWdodCA9IGtlcm5lbC5vdXRwdXQueTtcblxuICAgIGNvbnN0IHggPSBrZXJuZWwudGhyZWFkLng7XG4gICAgY29uc3QgeSA9IGhlaWdodCAtIGtlcm5lbC50aHJlYWQueSAtIDE7XG5cbiAgICBjb25zdCBpbmRleCA9IHggKyB5ICogd2lkdGg7XG5cbiAgICBrZXJuZWwuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAwXSA9IHI7XG4gICAga2VybmVsLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgMV0gPSBnO1xuICAgIGtlcm5lbC5fY29sb3JEYXRhW2luZGV4ICogNCArIDJdID0gYjtcbiAgICBrZXJuZWwuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAzXSA9IGE7XG4gIH07XG5cbiAgY29uc3QgbW9ja01ldGhvZCA9ICgpID0+IGtlcm5lbDtcbiAgY29uc3QgbWV0aG9kcyA9IFtcbiAgICAnc2V0V2FyblZhclVzYWdlJyxcbiAgICAnc2V0QXJndW1lbnRUeXBlcycsXG4gICAgJ3NldFRhY3RpYycsXG4gICAgJ3NldE9wdGltaXplRmxvYXRNZW1vcnknLFxuICAgICdzZXREZWJ1ZycsXG4gICAgJ3NldExvb3BNYXhJdGVyYXRpb25zJyxcbiAgICAnc2V0Q29uc3RhbnRUeXBlcycsXG4gICAgJ3NldEZ1bmN0aW9ucycsXG4gICAgJ3NldE5hdGl2ZUZ1bmN0aW9ucycsXG4gICAgJ3NldEluamVjdGVkTmF0aXZlJyxcbiAgICAnc2V0UGlwZWxpbmUnLFxuICAgICdzZXRQcmVjaXNpb24nLFxuICAgICdzZXRPdXRwdXRUb1RleHR1cmUnLFxuICAgICdzZXRJbW11dGFibGUnLFxuICAgICdzZXRTdHJpY3RJbnRlZ2VycycsXG4gICAgJ3NldER5bmFtaWNPdXRwdXQnLFxuICAgICdzZXRIYXJkY29kZUNvbnN0YW50cycsXG4gICAgJ3NldER5bmFtaWNBcmd1bWVudHMnLFxuICAgICdzZXRVc2VMZWdhY3lFbmNvZGVyJyxcbiAgICAnc2V0V2FyblZhclVzYWdlJyxcbiAgICAnYWRkU3ViS2VybmVsJyxcbiAgXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAga2VybmVsW21ldGhvZHNbaV1dID0gbW9ja01ldGhvZDtcbiAgfVxuICByZXR1cm4ga2VybmVsO1xufVxuXG5mdW5jdGlvbiBzZXR1cEdyYXBoaWNhbChrZXJuZWwpIHtcbiAgY29uc3Qge3gsIHl9ID0ga2VybmVsLm91dHB1dDtcbiAgaWYgKGtlcm5lbC5jb250ZXh0ICYmIGtlcm5lbC5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoeCAqIHkgKiA0KTtcbiAgICBrZXJuZWwuX2ltYWdlRGF0YSA9IGtlcm5lbC5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh4LCB5KTtcbiAgICBrZXJuZWwuX2NvbG9yRGF0YSA9IGRhdGE7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh4ICogeSAqIDQpO1xuICAgIGtlcm5lbC5faW1hZ2VEYXRhID0geyBkYXRhIH07XG4gICAga2VybmVsLl9jb2xvckRhdGEgPSBkYXRhO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldHVwT3V0cHV0KG91dHB1dCkge1xuICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgaWYgKG91dHB1dC5sZW5ndGgpIHtcbiAgICBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gMykge1xuICAgICAgY29uc3QgW3gseSx6XSA9IG91dHB1dDtcbiAgICAgIHJlc3VsdCA9IHsgeCwgeSwgeiB9O1xuICAgIH0gZWxzZSBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgW3gseV0gPSBvdXRwdXQ7XG4gICAgICByZXN1bHQgPSB7IHgsIHkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW3hdID0gb3V0cHV0O1xuICAgICAgcmVzdWx0ID0geyB4IH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IG91dHB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBncHVNb2NrKGZuLCBzZXR0aW5ncyA9IHt9KSB7XG4gIGNvbnN0IG91dHB1dCA9IHNldHRpbmdzLm91dHB1dCA/IHNldHVwT3V0cHV0KHNldHRpbmdzLm91dHB1dCkgOiBudWxsO1xuICBmdW5jdGlvbiBrZXJuZWwoKSB7XG4gICAgaWYgKGtlcm5lbC5vdXRwdXQueikge1xuICAgICAgcmV0dXJuIG1vY2szRC5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIGlmIChrZXJuZWwub3V0cHV0LnkpIHtcbiAgICAgIGlmIChrZXJuZWwuZ3JhcGhpY2FsKSB7XG4gICAgICAgIHJldHVybiBtb2NrMkRHcmFwaGljYWwuYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vY2syRC5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtb2NrMUQuYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuICBrZXJuZWwuX2ZuID0gZm47XG4gIGtlcm5lbC5jb25zdGFudHMgPSBzZXR0aW5ncy5jb25zdGFudHMgfHwgbnVsbDtcbiAga2VybmVsLmNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0IHx8IG51bGw7XG4gIGtlcm5lbC5jYW52YXMgPSBzZXR0aW5ncy5jYW52YXMgfHwgbnVsbDtcbiAga2VybmVsLmdyYXBoaWNhbCA9IHNldHRpbmdzLmdyYXBoaWNhbCB8fCBmYWxzZTtcbiAga2VybmVsLl9pbWFnZURhdGEgPSBudWxsO1xuICBrZXJuZWwuX2NvbG9yRGF0YSA9IG51bGw7XG4gIGtlcm5lbC5vdXRwdXQgPSBvdXRwdXQ7XG4gIGtlcm5lbC50aHJlYWQgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHo6IDBcbiAgfTtcbiAgcmV0dXJuIGFwaURlY29yYXRlKGtlcm5lbCk7XG59XG5cbmZ1bmN0aW9uIGZsaXBQaXhlbHMocGl4ZWxzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGNvbnN0IGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyIHwgMDsgXG4gIGNvbnN0IGJ5dGVzUGVyUm93ID0gd2lkdGggKiA0O1xuICBjb25zdCB0ZW1wID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogNCk7XG4gIGNvbnN0IHJlc3VsdCA9IHBpeGVscy5zbGljZSgwKTtcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCBoYWxmSGVpZ2h0OyArK3kpIHtcbiAgICBjb25zdCB0b3BPZmZzZXQgPSB5ICogYnl0ZXNQZXJSb3c7XG4gICAgY29uc3QgYm90dG9tT2Zmc2V0ID0gKGhlaWdodCAtIHkgLSAxKSAqIGJ5dGVzUGVyUm93O1xuXG4gICAgdGVtcC5zZXQocmVzdWx0LnN1YmFycmF5KHRvcE9mZnNldCwgdG9wT2Zmc2V0ICsgYnl0ZXNQZXJSb3cpKTtcblxuICAgIHJlc3VsdC5jb3B5V2l0aGluKHRvcE9mZnNldCwgYm90dG9tT2Zmc2V0LCBib3R0b21PZmZzZXQgKyBieXRlc1BlclJvdyk7XG5cbiAgICByZXN1bHQuc2V0KHRlbXAsIGJvdHRvbU9mZnNldCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdwdU1vY2tcbn07XG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5mdW5jdGlvbiBhbGlhcyhuYW1lLCBzb3VyY2UpIHtcbiAgY29uc3QgZm5TdHJpbmcgPSBzb3VyY2UudG9TdHJpbmcoKTtcbiAgcmV0dXJuIG5ldyBGdW5jdGlvbihgcmV0dXJuIGZ1bmN0aW9uICR7IG5hbWUgfSAoJHsgdXRpbHMuZ2V0QXJndW1lbnROYW1lc0Zyb21TdHJpbmcoZm5TdHJpbmcpLmpvaW4oJywgJykgfSkge1xuICAkeyB1dGlscy5nZXRGdW5jdGlvbkJvZHlGcm9tU3RyaW5nKGZuU3RyaW5nKSB9XG59YCkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFsaWFzXG59O1xufSx7XCIuL3V0aWxzXCI6MTE0fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IEZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tbm9kZScpO1xuXG5jbGFzcyBDUFVGdW5jdGlvbk5vZGUgZXh0ZW5kcyBGdW5jdGlvbk5vZGUge1xuICBhc3RGdW5jdGlvbihhc3QsIHJldEFycikge1xuXG4gICAgaWYgKCF0aGlzLmlzUm9vdEtlcm5lbCkge1xuICAgICAgcmV0QXJyLnB1c2goJ2Z1bmN0aW9uJyk7XG4gICAgICByZXRBcnIucHVzaCgnICcpO1xuICAgICAgcmV0QXJyLnB1c2godGhpcy5uYW1lKTtcbiAgICAgIHJldEFyci5wdXNoKCcoJyk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50TmFtZSA9IHRoaXMuYXJndW1lbnROYW1lc1tpXTtcblxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnLCAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXRBcnIucHVzaCgndXNlcl8nKTtcbiAgICAgICAgcmV0QXJyLnB1c2goYXJndW1lbnROYW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0QXJyLnB1c2goJykge1xcbicpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LmJvZHkuYm9keS5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5ib2R5LmJvZHlbaV0sIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnXFxuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzUm9vdEtlcm5lbCkge1xuICAgICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdFJldHVyblN0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnJldHVyblR5cGUgfHwgdGhpcy5nZXRUeXBlKGFzdC5hcmd1bWVudCk7XG5cbiAgICBpZiAoIXRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgdGhpcy5yZXR1cm5UeXBlID0gdHlwZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1Jvb3RLZXJuZWwpIHtcbiAgICAgIHJldEFyci5wdXNoKHRoaXMubGVhZGluZ1JldHVyblN0YXRlbWVudCk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJztcXG4nKTtcbiAgICAgIHJldEFyci5wdXNoKHRoaXMuZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50KTtcbiAgICAgIHJldEFyci5wdXNoKCdjb250aW51ZTtcXG4nKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdWJLZXJuZWwpIHtcbiAgICAgIHJldEFyci5wdXNoKGBzdWJLZXJuZWxSZXN1bHRfJHsgdGhpcy5uYW1lIH0gPSBgKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnOycpO1xuICAgICAgcmV0QXJyLnB1c2goYHJldHVybiBzdWJLZXJuZWxSZXN1bHRfJHsgdGhpcy5uYW1lIH07YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKCdyZXR1cm4gJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJzsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdExpdGVyYWwoYXN0LCByZXRBcnIpIHtcblxuICAgIGlmIChpc05hTihhc3QudmFsdWUpKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KFxuICAgICAgICAnTm9uLW51bWVyaWMgbGl0ZXJhbCBub3Qgc3VwcG9ydGVkIDogJyArIGFzdC52YWx1ZSxcbiAgICAgICAgYXN0XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldEFyci5wdXNoKGFzdC52YWx1ZSk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0QmluYXJ5RXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIHJldEFyci5wdXNoKCcoJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKGFzdC5vcGVyYXRvcik7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RJZGVudGlmaWVyRXhwcmVzc2lvbihpZHROb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoaWR0Tm9kZS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG4gICAgICAgICdJZGVudGlmaWVyRXhwcmVzc2lvbiAtIG5vdCBhbiBJZGVudGlmaWVyJyxcbiAgICAgICAgaWR0Tm9kZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGlkdE5vZGUubmFtZSkge1xuICAgICAgY2FzZSAnSW5maW5pdHknOlxuICAgICAgICByZXRBcnIucHVzaCgnSW5maW5pdHknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGhpcy5jb25zdGFudHMgJiYgdGhpcy5jb25zdGFudHMuaGFzT3duUHJvcGVydHkoaWR0Tm9kZS5uYW1lKSkge1xuICAgICAgICAgIHJldEFyci5wdXNoKCdjb25zdGFudHNfJyArIGlkdE5vZGUubmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ3VzZXJfJyArIGlkdE5vZGUubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0Rm9yU3RhdGVtZW50KGZvck5vZGUsIHJldEFycikge1xuICAgIGlmIChmb3JOb2RlLnR5cGUgIT09ICdGb3JTdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIGZvciBzdGF0ZW1lbnQnLCBmb3JOb2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0QXJyID0gW107XG4gICAgY29uc3QgdGVzdEFyciA9IFtdO1xuICAgIGNvbnN0IHVwZGF0ZUFyciA9IFtdO1xuICAgIGNvbnN0IGJvZHlBcnIgPSBbXTtcbiAgICBsZXQgaXNTYWZlID0gbnVsbDtcblxuICAgIGlmIChmb3JOb2RlLmluaXQpIHtcbiAgICAgIHRoaXMucHVzaFN0YXRlKCdpbi1mb3ItbG9vcC1pbml0Jyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS5pbml0LCBpbml0QXJyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5pdEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5pdEFycltpXS5pbmNsdWRlcyAmJiBpbml0QXJyW2ldLmluY2x1ZGVzKCcsJykpIHtcbiAgICAgICAgICBpc1NhZmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wb3BTdGF0ZSgnaW4tZm9yLWxvb3AtaW5pdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc1NhZmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZm9yTm9kZS50ZXN0KSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS50ZXN0LCB0ZXN0QXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZvck5vZGUudXBkYXRlKSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS51cGRhdGUsIHVwZGF0ZUFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmb3JOb2RlLmJvZHkpIHtcbiAgICAgIHRoaXMucHVzaFN0YXRlKCdsb29wLWJvZHknKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLmJvZHksIGJvZHlBcnIpO1xuICAgICAgdGhpcy5wb3BTdGF0ZSgnbG9vcC1ib2R5Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzU2FmZSA9PT0gbnVsbCkge1xuICAgICAgaXNTYWZlID0gdGhpcy5pc1NhZmUoZm9yTm9kZS5pbml0KSAmJiB0aGlzLmlzU2FmZShmb3JOb2RlLnRlc3QpO1xuICAgIH1cblxuICAgIGlmIChpc1NhZmUpIHtcbiAgICAgIHJldEFyci5wdXNoKGBmb3IgKCR7aW5pdEFyci5qb2luKCcnKX07JHt0ZXN0QXJyLmpvaW4oJycpfTske3VwZGF0ZUFyci5qb2luKCcnKX0pe1xcbmApO1xuICAgICAgcmV0QXJyLnB1c2goYm9keUFyci5qb2luKCcnKSk7XG4gICAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpVmFyaWFibGVOYW1lID0gdGhpcy5nZXRJbnRlcm5hbFZhcmlhYmxlTmFtZSgnc2FmZUknKTtcbiAgICAgIGlmIChpbml0QXJyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0QXJyLnB1c2goaW5pdEFyci5qb2luKCcnKSwgJztcXG4nKTtcbiAgICAgIH1cbiAgICAgIHJldEFyci5wdXNoKGBmb3IgKGxldCAke2lWYXJpYWJsZU5hbWV9PTA7JHtpVmFyaWFibGVOYW1lfTxMT09QX01BWDske2lWYXJpYWJsZU5hbWV9Kyspe1xcbmApO1xuICAgICAgaWYgKHRlc3RBcnIubGVuZ3RoID4gMCkge1xuICAgICAgICByZXRBcnIucHVzaChgaWYgKCEke3Rlc3RBcnIuam9pbignJyl9KSBicmVhaztcXG5gKTtcbiAgICAgIH1cbiAgICAgIHJldEFyci5wdXNoKGJvZHlBcnIuam9pbignJykpO1xuICAgICAgcmV0QXJyLnB1c2goYFxcbiR7dXBkYXRlQXJyLmpvaW4oJycpfTtgKTtcbiAgICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RXaGlsZVN0YXRlbWVudCh3aGlsZU5vZGUsIHJldEFycikge1xuICAgIGlmICh3aGlsZU5vZGUudHlwZSAhPT0gJ1doaWxlU3RhdGVtZW50Jykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcbiAgICAgICAgJ0ludmFsaWQgd2hpbGUgc3RhdGVtZW50JyxcbiAgICAgICAgd2hpbGVOb2RlXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldEFyci5wdXNoKCdmb3IgKGxldCBpID0gMDsgaSA8IExPT1BfTUFYOyBpKyspIHsnKTtcbiAgICByZXRBcnIucHVzaCgnaWYgKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyh3aGlsZU5vZGUudGVzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKSB7XFxuJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKHdoaWxlTm9kZS5ib2R5LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCd9IGVsc2Uge1xcbicpO1xuICAgIHJldEFyci5wdXNoKCdicmVhaztcXG4nKTtcbiAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0RG9XaGlsZVN0YXRlbWVudChkb1doaWxlTm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKGRvV2hpbGVOb2RlLnR5cGUgIT09ICdEb1doaWxlU3RhdGVtZW50Jykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcbiAgICAgICAgJ0ludmFsaWQgd2hpbGUgc3RhdGVtZW50JyxcbiAgICAgICAgZG9XaGlsZU5vZGVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0QXJyLnB1c2goJ2ZvciAobGV0IGkgPSAwOyBpIDwgTE9PUF9NQVg7IGkrKykgeycpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhkb1doaWxlTm9kZS5ib2R5LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCdpZiAoIScpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhkb1doaWxlTm9kZS50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpIHtcXG4nKTtcbiAgICByZXRBcnIucHVzaCgnYnJlYWs7XFxuJyk7XG4gICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcblxuICB9XG5cbiAgYXN0QXNzaWdubWVudEV4cHJlc3Npb24oYXNzTm9kZSwgcmV0QXJyKSB7XG4gICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLmdldERlY2xhcmF0aW9uKGFzc05vZGUubGVmdCk7XG4gICAgaWYgKGRlY2xhcmF0aW9uICYmICFkZWNsYXJhdGlvbi5hc3NpZ25hYmxlKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBWYXJpYWJsZSAke2Fzc05vZGUubGVmdC5uYW1lfSBpcyBub3QgYXNzaWduYWJsZSBoZXJlYCwgYXNzTm9kZSk7XG4gICAgfVxuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLmxlZnQsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goYXNzTm9kZS5vcGVyYXRvcik7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUucmlnaHQsIHJldEFycik7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEJsb2NrU3RhdGVtZW50KGJOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAodGhpcy5pc1N0YXRlKCdsb29wLWJvZHknKSkge1xuICAgICAgdGhpcy5wdXNoU3RhdGUoJ2Jsb2NrLWJvZHknKTsgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJOb2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGJOb2RlLmJvZHlbaV0sIHJldEFycik7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcFN0YXRlKCdibG9jay1ib2R5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKCd7XFxuJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJOb2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGJOb2RlLmJvZHlbaV0sIHJldEFycik7XG4gICAgICB9XG4gICAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0VmFyaWFibGVEZWNsYXJhdGlvbih2YXJEZWNOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaChgJHt2YXJEZWNOb2RlLmtpbmR9IGApO1xuICAgIGNvbnN0IHsgZGVjbGFyYXRpb25zIH0gPSB2YXJEZWNOb2RlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgcmV0QXJyLnB1c2goJywnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb25zW2ldO1xuICAgICAgY29uc3QgaW5mbyA9IHRoaXMuZ2V0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24uaWQpO1xuICAgICAgaWYgKCFpbmZvLnZhbHVlVHlwZSkge1xuICAgICAgICBpbmZvLnZhbHVlVHlwZSA9IHRoaXMuZ2V0VHlwZShkZWNsYXJhdGlvbi5pbml0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhkZWNsYXJhdGlvbiwgcmV0QXJyKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzU3RhdGUoJ2luLWZvci1sb29wLWluaXQnKSkge1xuICAgICAgcmV0QXJyLnB1c2goJzsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdElmU3RhdGVtZW50KGlmTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJ2lmICgnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLnRlc3QsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICBpZiAoaWZOb2RlLmNvbnNlcXVlbnQudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaCgnIHtcXG4nKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCdcXG59XFxuJyk7XG4gICAgfVxuXG4gICAgaWYgKGlmTm9kZS5hbHRlcm5hdGUpIHtcbiAgICAgIHJldEFyci5wdXNoKCdlbHNlICcpO1xuICAgICAgaWYgKGlmTm9kZS5hbHRlcm5hdGUudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50JyB8fCBpZk5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09ICdJZlN0YXRlbWVudCcpIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXRBcnIucHVzaCgnIHtcXG4nKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCdcXG59XFxuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG5cbiAgfVxuXG4gIGFzdFN3aXRjaFN0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIGNvbnN0IHsgZGlzY3JpbWluYW50LCBjYXNlcyB9ID0gYXN0O1xuICAgIHJldEFyci5wdXNoKCdzd2l0Y2ggKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhkaXNjcmltaW5hbnQsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJykge1xcbicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjYXNlc1tpXS50ZXN0ID09PSBudWxsKSB7XG4gICAgICAgIHJldEFyci5wdXNoKCdkZWZhdWx0OlxcbicpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoY2FzZXNbaV0uY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgICAgaWYgKGNhc2VzW2ldLmNvbnNlcXVlbnQgJiYgY2FzZXNbaV0uY29uc2VxdWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ2JyZWFrO1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goJ2Nhc2UgJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoY2FzZXNbaV0udGVzdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc6XFxuJyk7XG4gICAgICBpZiAoY2FzZXNbaV0uY29uc2VxdWVudCAmJiBjYXNlc1tpXS5jb25zZXF1ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGNhc2VzW2ldLmNvbnNlcXVlbnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCdicmVhaztcXG4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJ1xcbn0nKTtcbiAgfVxuXG4gIGFzdFRoaXNFeHByZXNzaW9uKHROb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnX3RoaXMnKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0TWVtYmVyRXhwcmVzc2lvbihtTm9kZSwgcmV0QXJyKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmF0dXJlLFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BlcnR5LFxuICAgICAgeFByb3BlcnR5LFxuICAgICAgeVByb3BlcnR5LFxuICAgICAgelByb3BlcnR5LFxuICAgICAgbmFtZSxcbiAgICAgIG9yaWdpblxuICAgIH0gPSB0aGlzLmdldE1lbWJlckV4cHJlc3Npb25EZXRhaWxzKG1Ob2RlKTtcbiAgICBzd2l0Y2ggKHNpZ25hdHVyZSkge1xuICAgICAgY2FzZSAndGhpcy50aHJlYWQudmFsdWUnOlxuICAgICAgICByZXRBcnIucHVzaChgX3RoaXMudGhyZWFkLiR7IG5hbWUgfWApO1xuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgY2FzZSAndGhpcy5vdXRwdXQudmFsdWUnOlxuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdvdXRwdXRYJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdvdXRwdXRZJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdvdXRwdXRaJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIG1Ob2RlKTtcbiAgICAgIGNhc2UgJ3ZhbHVlW10nOlxuICAgICAgY2FzZSAndmFsdWVbXVtdJzpcbiAgICAgIGNhc2UgJ3ZhbHVlW11bXVtdJzpcbiAgICAgIGNhc2UgJ3ZhbHVlLnZhbHVlJzpcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gJ01hdGgnKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goTWF0aFtuYW1lXSk7XG4gICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8keyBuYW1lIH1bMF1gKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8keyBuYW1lIH1bMV1gKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8keyBuYW1lIH1bMl1gKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8keyBuYW1lIH1bM11gKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2YWx1ZS52YWx1ZVtdJzogXG4gICAgICAgIGlmICh0aGlzLnJlbW92ZUlzdGFuYnVsQ292ZXJhZ2UpIHtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldEFyci5wdXNoKGAke21Ob2RlLm9iamVjdC5vYmplY3QubmFtZX0uJHttTm9kZS5vYmplY3QucHJvcGVydHkubmFtZX1bJHttTm9kZS5wcm9wZXJ0eS52YWx1ZX1dYCk7XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICBjYXNlICd2YWx1ZS52YWx1ZVtdW10nOiBcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlSXN0YW5idWxDb3ZlcmFnZSkge1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0QXJyLnB1c2goYCR7bU5vZGUub2JqZWN0Lm9iamVjdC5vYmplY3QubmFtZX0uJHttTm9kZS5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWV9WyR7bU5vZGUub2JqZWN0LnByb3BlcnR5LnZhbHVlfV1bJHttTm9kZS5wcm9wZXJ0eS52YWx1ZX1dYCk7XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZSc6XG4gICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdJzpcbiAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXSc6XG4gICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXSc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZm4oKVtdJzpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKG1Ob2RlLnByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuICAgIH1cblxuICAgIGlmICghbU5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgICAgICByZXRBcnIucHVzaChgJHtvcmlnaW59XyR7bmFtZX1gKTtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1hcmt1cE5hbWUgPSBgJHtvcmlnaW59XyR7bmFtZX1gO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICBjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoMSknOlxuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoNCknOlxuICAgICAgY2FzZSAnSFRNTEltYWdlJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxldCBzaXplO1xuICAgICAgICBsZXQgaXNJbnB1dDtcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHtcbiAgICAgICAgICBjb25zdCBjb25zdGFudCA9IHRoaXMuY29uc3RhbnRzW25hbWVdO1xuICAgICAgICAgIGlzSW5wdXQgPSB0aGlzLmNvbnN0YW50VHlwZXNbbmFtZV0gPT09ICdJbnB1dCc7XG4gICAgICAgICAgc2l6ZSA9IGlzSW5wdXQgPyBjb25zdGFudC5zaXplIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0lucHV0ID0gdGhpcy5pc0lucHV0KG5hbWUpO1xuICAgICAgICAgIHNpemUgPSBpc0lucHV0ID8gdGhpcy5hcmd1bWVudFNpemVzW3RoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKG5hbWUpXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0QXJyLnB1c2goYCR7IG1hcmt1cE5hbWUgfWApO1xuICAgICAgICBpZiAoelByb3BlcnR5ICYmIHlQcm9wZXJ0eSkge1xuICAgICAgICAgIGlmIChpc0lucHV0KSB7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnWygnKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaChgKiR7IHRoaXMuZHluYW1pY0FyZ3VtZW50cyA/ICcob3V0cHV0WSAqIG91dHB1dFgpJyA6IHNpemVbMV0gKiBzaXplWzBdIH0pKyhgKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh5UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaChgKiR7IHRoaXMuZHluYW1pY0FyZ3VtZW50cyA/ICdvdXRwdXRYJyA6IHNpemVbMF0gfSkrYCk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoeFByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh5UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh4UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh5UHJvcGVydHkpIHtcbiAgICAgICAgICBpZiAoaXNJbnB1dCkge1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ1soJyk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoeVByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goYCokeyB0aGlzLmR5bmFtaWNBcmd1bWVudHMgPyAnb3V0cHV0WCcgOiBzaXplWzBdIH0pK2ApO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHhQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoeVByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoeFByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHhQcm9wZXJ0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh4UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0Q2FsbEV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICBpZiAoYXN0LnR5cGUgIT09ICdDYWxsRXhwcmVzc2lvbicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1Vua25vd24gQ2FsbEV4cHJlc3Npb24nLCBhc3QpO1xuICAgIH1cbiAgICBsZXQgZnVuY3Rpb25OYW1lID0gdGhpcy5hc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKGFzdC5jYWxsZWUpO1xuXG4gICAgaWYgKHRoaXMuY2FsbGVkRnVuY3Rpb25zLmluZGV4T2YoZnVuY3Rpb25OYW1lKSA8IDApIHtcbiAgICAgIHRoaXMuY2FsbGVkRnVuY3Rpb25zLnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc01hdGhGdW5jdGlvbiA9IHRoaXMuaXNBc3RNYXRoRnVuY3Rpb24oYXN0KTtcblxuICAgIGlmICh0aGlzLm9uRnVuY3Rpb25DYWxsKSB7XG4gICAgICB0aGlzLm9uRnVuY3Rpb25DYWxsKHRoaXMubmFtZSwgZnVuY3Rpb25OYW1lLCBhc3QuYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXRBcnIucHVzaChmdW5jdGlvbk5hbWUpO1xuXG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICBjb25zdCB0YXJnZXRUeXBlcyA9IHRoaXMubG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzKGZ1bmN0aW9uTmFtZSkgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QuYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBhcmd1bWVudCA9IGFzdC5hcmd1bWVudHNbaV07XG5cbiAgICAgIGxldCBhcmd1bWVudFR5cGUgPSB0aGlzLmdldFR5cGUoYXJndW1lbnQpO1xuICAgICAgaWYgKCF0YXJnZXRUeXBlc1tpXSkge1xuICAgICAgICB0aGlzLnRyaWdnZXJJbXBseUFyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGksIGFyZ3VtZW50VHlwZSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICByZXRBcnIucHVzaCgnLCAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyknKTtcblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RBcnJheUV4cHJlc3Npb24oYXJyTm9kZSwgcmV0QXJyKSB7XG4gICAgY29uc3QgYXJyTGVuID0gYXJyTm9kZS5lbGVtZW50cy5sZW5ndGg7XG5cbiAgICByZXRBcnIucHVzaCgnbmV3IEZsb2F0MzJBcnJheShbJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJMZW47ICsraSkge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHJldEFyci5wdXNoKCcsICcpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3ViTm9kZSA9IGFyck5vZGUuZWxlbWVudHNbaV07XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoc3ViTm9kZSwgcmV0QXJyKVxuICAgIH1cbiAgICByZXRBcnIucHVzaCgnXSknKTtcblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3REZWJ1Z2dlclN0YXRlbWVudChhcnJOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnZGVidWdnZXI7Jyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ1BVRnVuY3Rpb25Ob2RlXG59O1xufSx7XCIuLi9mdW5jdGlvbi1ub2RlXCI6MTB9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGNvbnN0YW50c1RvU3RyaW5nKGNvbnN0YW50cywgdHlwZXMpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gdHlwZXMpIHtcbiAgICBpZiAoIXR5cGVzLmhhc093blByb3BlcnR5KG5hbWUpKSBjb250aW51ZTtcbiAgICBjb25zdCB0eXBlID0gdHlwZXNbbmFtZV07XG4gICAgY29uc3QgY29uc3RhbnQgPSBjb25zdGFudHNbbmFtZV07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgICAgcmVzdWx0cy5wdXNoKGAke25hbWV9OiR7Y29uc3RhbnR9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICByZXN1bHRzLnB1c2goYCR7bmFtZX06bmV3ICR7Y29uc3RhbnQuY29uc3RydWN0b3IubmFtZX0oJHtKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKGNvbnN0YW50KSl9KWApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGB7ICR7IHJlc3VsdHMuam9pbigpIH0gfWA7XG59XG5cbmZ1bmN0aW9uIGNwdUtlcm5lbFN0cmluZyhjcHVLZXJuZWwsIG5hbWUpIHtcbiAgY29uc3QgaGVhZGVyID0gW107XG4gIGNvbnN0IHRoaXNQcm9wZXJ0aWVzID0gW107XG4gIGNvbnN0IGJlZm9yZVJldHVybiA9IFtdO1xuXG4gIGNvbnN0IHVzZUZ1bmN0aW9uS2V5d29yZCA9ICEvXmZ1bmN0aW9uLy50ZXN0KGNwdUtlcm5lbC5jb2xvci50b1N0cmluZygpKTtcblxuICBoZWFkZXIucHVzaChcbiAgICAnICBjb25zdCB7IGNvbnRleHQsIGNhbnZhcywgY29uc3RhbnRzOiBpbmNvbWluZ0NvbnN0YW50cyB9ID0gc2V0dGluZ3M7JyxcbiAgICBgICBjb25zdCBvdXRwdXQgPSBuZXcgSW50MzJBcnJheSgke0pTT04uc3RyaW5naWZ5KEFycmF5LmZyb20oY3B1S2VybmVsLm91dHB1dCkpfSk7YCxcbiAgICBgICBjb25zdCBfY29uc3RhbnRUeXBlcyA9ICR7SlNPTi5zdHJpbmdpZnkoY3B1S2VybmVsLmNvbnN0YW50VHlwZXMpfTtgLFxuICAgIGAgIGNvbnN0IF9jb25zdGFudHMgPSAke2NvbnN0YW50c1RvU3RyaW5nKGNwdUtlcm5lbC5jb25zdGFudHMsIGNwdUtlcm5lbC5jb25zdGFudFR5cGVzKX07YCxcbiAgKTtcblxuICB0aGlzUHJvcGVydGllcy5wdXNoKFxuICAgICcgICAgY29uc3RhbnRzOiBfY29uc3RhbnRzLCcsXG4gICAgJyAgICBjb250ZXh0LCcsXG4gICAgJyAgICBvdXRwdXQsJyxcbiAgICAnICAgIHRocmVhZDoge3g6IDAsIHk6IDAsIHo6IDB9LCcsXG4gICk7XG5cbiAgaWYgKGNwdUtlcm5lbC5ncmFwaGljYWwpIHtcbiAgICBoZWFkZXIucHVzaChgICBjb25zdCBfaW1hZ2VEYXRhID0gY29udGV4dC5jcmVhdGVJbWFnZURhdGEoJHtjcHVLZXJuZWwub3V0cHV0WzBdfSwgJHtjcHVLZXJuZWwub3V0cHV0WzFdfSk7YCk7XG4gICAgaGVhZGVyLnB1c2goYCAgY29uc3QgX2NvbG9yRGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSgke2NwdUtlcm5lbC5vdXRwdXRbMF19ICogJHtjcHVLZXJuZWwub3V0cHV0WzFdfSAqIDQpO2ApO1xuXG4gICAgY29uc3QgY29sb3JGbiA9IHV0aWxzLmZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nKCh1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnKSArIGNwdUtlcm5lbC5jb2xvci50b1N0cmluZygpLCB7XG4gICAgICB0aGlzTG9va3VwOiAocHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgY2FzZSAnX2NvbG9yRGF0YSc6XG4gICAgICAgICAgICByZXR1cm4gJ19jb2xvckRhdGEnO1xuICAgICAgICAgIGNhc2UgJ19pbWFnZURhdGEnOlxuICAgICAgICAgICAgcmV0dXJuICdfaW1hZ2VEYXRhJztcbiAgICAgICAgICBjYXNlICdvdXRwdXQnOlxuICAgICAgICAgICAgcmV0dXJuICdvdXRwdXQnO1xuICAgICAgICAgIGNhc2UgJ3RocmVhZCc6XG4gICAgICAgICAgICByZXR1cm4gJ3RoaXMudGhyZWFkJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY3B1S2VybmVsW3Byb3BlcnR5TmFtZV0pO1xuICAgICAgfSxcbiAgICAgIGZpbmREZXBlbmRlbmN5OiAob2JqZWN0LCBuYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgZ2V0UGl4ZWxzRm4gPSB1dGlscy5mbGF0dGVuRnVuY3Rpb25Ub1N0cmluZygodXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJykgKyBjcHVLZXJuZWwuZ2V0UGl4ZWxzLnRvU3RyaW5nKCksIHtcbiAgICAgIHRoaXNMb29rdXA6IChwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICBjYXNlICdfY29sb3JEYXRhJzpcbiAgICAgICAgICAgIHJldHVybiAnX2NvbG9yRGF0YSc7XG4gICAgICAgICAgY2FzZSAnX2ltYWdlRGF0YSc6XG4gICAgICAgICAgICByZXR1cm4gJ19pbWFnZURhdGEnO1xuICAgICAgICAgIGNhc2UgJ291dHB1dCc6XG4gICAgICAgICAgICByZXR1cm4gJ291dHB1dCc7XG4gICAgICAgICAgY2FzZSAndGhyZWFkJzpcbiAgICAgICAgICAgIHJldHVybiAndGhpcy50aHJlYWQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjcHVLZXJuZWxbcHJvcGVydHlOYW1lXSk7XG4gICAgICB9LFxuICAgICAgZmluZERlcGVuZGVuY3k6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzUHJvcGVydGllcy5wdXNoKFxuICAgICAgJyAgICBfaW1hZ2VEYXRhLCcsXG4gICAgICAnICAgIF9jb2xvckRhdGEsJyxcbiAgICAgIGAgICAgY29sb3I6ICR7Y29sb3JGbn0sYCxcbiAgICApO1xuXG4gICAgYmVmb3JlUmV0dXJuLnB1c2goXG4gICAgICBgICBrZXJuZWwuZ2V0UGl4ZWxzID0gJHtnZXRQaXhlbHNGbn07YFxuICAgICk7XG4gIH1cblxuICBjb25zdCBjb25zdGFudFR5cGVzID0gW107XG4gIGNvbnN0IGNvbnN0YW50S2V5cyA9IE9iamVjdC5rZXlzKGNwdUtlcm5lbC5jb25zdGFudFR5cGVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25zdGFudEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdGFudFR5cGVzLnB1c2goY3B1S2VybmVsLmNvbnN0YW50VHlwZXNbY29uc3RhbnRLZXlzXSk7XG4gIH1cbiAgaWYgKGNwdUtlcm5lbC5hcmd1bWVudFR5cGVzLmluZGV4T2YoJ0hUTUxJbWFnZUFycmF5JykgIT09IC0xIHx8IGNvbnN0YW50VHlwZXMuaW5kZXhPZignSFRNTEltYWdlQXJyYXknKSAhPT0gLTEpIHtcbiAgICBjb25zdCBmbGF0dGVuZWRJbWFnZVRvM0RBcnJheSA9IHV0aWxzLmZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nKCh1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnKSArIGNwdUtlcm5lbC5faW1hZ2VUbzNEQXJyYXkudG9TdHJpbmcoKSwge1xuICAgICAgZG9Ob3REZWZpbmU6IFsnY2FudmFzJ10sXG4gICAgICBmaW5kRGVwZW5kZW5jeTogKG9iamVjdCwgbmFtZSkgPT4ge1xuICAgICAgICBpZiAob2JqZWN0ID09PSAndGhpcycpIHtcbiAgICAgICAgICByZXR1cm4gKHVzZUZ1bmN0aW9uS2V5d29yZCA/ICdmdW5jdGlvbiAnIDogJycpICsgY3B1S2VybmVsW25hbWVdLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgdGhpc0xvb2t1cDogKHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIGNhc2UgJ2NhbnZhcyc6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgICByZXR1cm4gJ2NvbnRleHQnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgYmVmb3JlUmV0dXJuLnB1c2goZmxhdHRlbmVkSW1hZ2VUbzNEQXJyYXkpO1xuICAgIHRoaXNQcm9wZXJ0aWVzLnB1c2goYCAgICBfbWVkaWFUbzJEQXJyYXksYCk7XG4gICAgdGhpc1Byb3BlcnRpZXMucHVzaChgICAgIF9pbWFnZVRvM0RBcnJheSxgKTtcbiAgfSBlbHNlIGlmIChjcHVLZXJuZWwuYXJndW1lbnRUeXBlcy5pbmRleE9mKCdIVE1MSW1hZ2UnKSAhPT0gLTEgfHwgY29uc3RhbnRUeXBlcy5pbmRleE9mKCdIVE1MSW1hZ2UnKSAhPT0gLTEpIHtcbiAgICBjb25zdCBmbGF0dGVuZWRJbWFnZVRvMkRBcnJheSA9IHV0aWxzLmZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nKCh1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnKSArIGNwdUtlcm5lbC5fbWVkaWFUbzJEQXJyYXkudG9TdHJpbmcoKSwge1xuICAgICAgZmluZERlcGVuZGVuY3k6IChvYmplY3QsIG5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgdGhpc0xvb2t1cDogKHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIGNhc2UgJ2NhbnZhcyc6XG4gICAgICAgICAgICByZXR1cm4gJ3NldHRpbmdzLmNhbnZhcyc7XG4gICAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgICByZXR1cm4gJ3NldHRpbmdzLmNvbnRleHQnO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5oYW5kbGVkIHRoaXNMb29rdXAnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBiZWZvcmVSZXR1cm4ucHVzaChmbGF0dGVuZWRJbWFnZVRvMkRBcnJheSk7XG4gICAgdGhpc1Byb3BlcnRpZXMucHVzaChgICAgIF9tZWRpYVRvMkRBcnJheSxgKTtcbiAgfVxuXG4gIHJldHVybiBgZnVuY3Rpb24oc2V0dGluZ3MpIHtcbiR7IGhlYWRlci5qb2luKCdcXG4nKSB9XG4gIGZvciAoY29uc3QgcCBpbiBfY29uc3RhbnRUeXBlcykge1xuICAgIGlmICghX2NvbnN0YW50VHlwZXMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IHR5cGUgPSBfY29uc3RhbnRUeXBlc1twXTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICBpZiAoaW5jb21pbmdDb25zdGFudHMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ2NvbnN0YW50ICcgKyBwICsgJyBvZiB0eXBlICcgKyB0eXBlICsgJyBjYW5ub3QgYmUgcmVzaWduZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFpbmNvbWluZ0NvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb25zdGFudCAnICsgcCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIF9jb25zdGFudHNbcF0gPSBpbmNvbWluZ0NvbnN0YW50c1twXTtcbiAgfVxuICBjb25zdCBrZXJuZWwgPSAoZnVuY3Rpb24oKSB7XG4ke2NwdUtlcm5lbC5fa2VybmVsU3RyaW5nfVxuICB9KVxuICAgIC5hcHBseSh7ICR7dGhpc1Byb3BlcnRpZXMuam9pbignXFxuJyl9IH0pO1xuICAkeyBiZWZvcmVSZXR1cm4uam9pbignXFxuJykgfVxuICByZXR1cm4ga2VybmVsO1xufWA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcHVLZXJuZWxTdHJpbmdcbn07XG59LHtcIi4uLy4uL3V0aWxzXCI6MTE0fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IEtlcm5lbCB9ID0gcmVxdWlyZSgnLi4va2VybmVsJyk7XG5jb25zdCB7IEZ1bmN0aW9uQnVpbGRlciB9ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tYnVpbGRlcicpO1xuY29uc3QgeyBDUFVGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tbm9kZScpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgY3B1S2VybmVsU3RyaW5nIH0gPSByZXF1aXJlKCcuL2tlcm5lbC1zdHJpbmcnKTtcblxuY2xhc3MgQ1BVS2VybmVsIGV4dGVuZHMgS2VybmVsIHtcbiAgc3RhdGljIGdldEZlYXR1cmVzKCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVzO1xuICB9XG4gIHN0YXRpYyBnZXQgZmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAga2VybmVsTWFwOiB0cnVlLFxuICAgICAgaXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGlzQ29udGV4dE1hdGNoKGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGdldCBtb2RlKCkge1xuICAgIHJldHVybiAnY3B1JztcbiAgfVxuXG4gIHN0YXRpYyBuYXRpdmVGdW5jdGlvbkFyZ3VtZW50cygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBuYXRpdmVGdW5jdGlvblJldHVyblR5cGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBMb29raW5nIHVwIG5hdGl2ZSBmdW5jdGlvbiByZXR1cm4gdHlwZSBub3Qgc3VwcG9ydGVkIG9uICR7dGhpcy5uYW1lfWApO1xuICB9XG5cbiAgc3RhdGljIGNvbWJpbmVLZXJuZWxzKGNvbWJpbmVkS2VybmVsKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVkS2VybmVsO1xuICB9XG5cbiAgc3RhdGljIGdldFNpZ25hdHVyZShrZXJuZWwsIGFyZ3VtZW50VHlwZXMpIHtcbiAgICByZXR1cm4gJ2NwdScgKyAoYXJndW1lbnRUeXBlcy5sZW5ndGggPiAwID8gJzonICsgYXJndW1lbnRUeXBlcy5qb2luKCcsJykgOiAnJyk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc291cmNlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5tZXJnZVNldHRpbmdzKHNvdXJjZS5zZXR0aW5ncyB8fCBzZXR0aW5ncyk7XG5cbiAgICB0aGlzLl9pbWFnZURhdGEgPSBudWxsO1xuICAgIHRoaXMuX2NvbG9yRGF0YSA9IG51bGw7XG4gICAgdGhpcy5fa2VybmVsU3RyaW5nID0gbnVsbDtcbiAgICB0aGlzLl9wcmVwZW5kZWRTdHJpbmcgPSBbXTtcbiAgICB0aGlzLnRocmVhZCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgejogMFxuICAgIH07XG4gICAgdGhpcy50cmFuc2xhdGVkU291cmNlcyA9IG51bGw7XG4gIH1cblxuICBpbml0Q2FudmFzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMCwgMCk7XG4gICAgfVxuICB9XG5cbiAgaW5pdENvbnRleHQoKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcykgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIH1cblxuICBpbml0UGx1Z2lucyhzZXR0aW5ncykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhbGlkYXRlU2V0dGluZ3MoYXJncykge1xuICAgIGlmICghdGhpcy5vdXRwdXQgfHwgdGhpcy5vdXRwdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRvIG91dHB1dCBvbmx5IHN1cHBvcnRlZCBmb3Iga2VybmVscyB3aXRoIG9ubHkgb25lIGlucHV0Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFyZ1R5cGUgPSB1dGlscy5nZXRWYXJpYWJsZVR5cGUoYXJnc1swXSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICBpZiAoYXJnVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgICB0aGlzLm91dHB1dCA9IHV0aWxzLmdldERpbWVuc2lvbnMoYXJnVHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdOdW1iZXJUZXh0dXJlJyB8fCBhcmdUeXBlID09PSAnQXJyYXlUZXh0dXJlKDQpJykge1xuICAgICAgICB0aGlzLm91dHB1dCA9IGFyZ3NbMF0ub3V0cHV0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRvIG91dHB1dCBub3Qgc3VwcG9ydGVkIGZvciBpbnB1dCB0eXBlOiAnICsgYXJnVHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICBpZiAodGhpcy5vdXRwdXQubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3V0cHV0IG11c3QgaGF2ZSAyIGRpbWVuc2lvbnMgb24gZ3JhcGhpY2FsIG1vZGUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrT3V0cHV0KCk7XG4gIH1cblxuICB0cmFuc2xhdGVTb3VyY2UoKSB7XG4gICAgdGhpcy5sZWFkaW5nUmV0dXJuU3RhdGVtZW50ID0gdGhpcy5vdXRwdXQubGVuZ3RoID4gMSA/ICdyZXN1bHRYW3hdID0gJyA6ICdyZXN1bHRbeF0gPSAnO1xuICAgIGlmICh0aGlzLnN1Yktlcm5lbHMpIHtcbiAgICAgIGNvbnN0IGZvbGxvd2luZ1JldHVyblN0YXRlbWVudCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG5hbWVcbiAgICAgICAgfSA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgICAgZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50LnB1c2godGhpcy5vdXRwdXQubGVuZ3RoID4gMSA/IGByZXN1bHRYXyR7IG5hbWUgfVt4XSA9IHN1Yktlcm5lbFJlc3VsdF8keyBuYW1lIH07XFxuYCA6IGByZXN1bHRfJHsgbmFtZSB9W3hdID0gc3ViS2VybmVsUmVzdWx0XyR7IG5hbWUgfTtcXG5gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50ID0gZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50LmpvaW4oJycpO1xuICAgIH1cbiAgICBjb25zdCBmdW5jdGlvbkJ1aWxkZXIgPSBGdW5jdGlvbkJ1aWxkZXIuZnJvbUtlcm5lbCh0aGlzLCBDUFVGdW5jdGlvbk5vZGUpO1xuICAgIHRoaXMudHJhbnNsYXRlZFNvdXJjZXMgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0UHJvdG90eXBlcygna2VybmVsJyk7XG4gICAgaWYgKCF0aGlzLmdyYXBoaWNhbCAmJiAhdGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICB0aGlzLnJldHVyblR5cGUgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0S2VybmVsUmVzdWx0VHlwZSgpO1xuICAgIH1cbiAgfVxuXG4gIGJ1aWxkKCkge1xuICAgIGlmICh0aGlzLmJ1aWx0KSByZXR1cm47XG4gICAgdGhpcy5zZXR1cENvbnN0YW50cygpO1xuICAgIHRoaXMuc2V0dXBBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICB0aGlzLnZhbGlkYXRlU2V0dGluZ3MoYXJndW1lbnRzKTtcbiAgICB0aGlzLnRyYW5zbGF0ZVNvdXJjZSgpO1xuXG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNhbnZhcyxcbiAgICAgICAgb3V0cHV0XG4gICAgICB9ID0gdGhpcztcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gY2FudmFzIGF2YWlsYWJsZSBmb3IgdXNpbmcgZ3JhcGhpY2FsIG91dHB1dCcpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lkdGggPSBvdXRwdXRbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSBvdXRwdXRbMV0gfHwgMTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuX2ltYWdlRGF0YSA9IHRoaXMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLl9jb2xvckRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXJuZWxTdHJpbmcgPSB0aGlzLmdldEtlcm5lbFN0cmluZygpO1xuICAgIHRoaXMua2VybmVsU3RyaW5nID0ga2VybmVsU3RyaW5nO1xuXG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdGdW5jdGlvbiBvdXRwdXQ6Jyk7XG4gICAgICBjb25zb2xlLmxvZyhrZXJuZWxTdHJpbmcpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLnJ1biA9IG5ldyBGdW5jdGlvbihbXSwga2VybmVsU3RyaW5nKS5iaW5kKHRoaXMpKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgY29tcGlsaW5nIHRoZSBqYXZhc2NyaXB0OiAnLCBlKTtcbiAgICB9XG4gICAgdGhpcy5idWlsZFNpZ25hdHVyZShhcmd1bWVudHMpO1xuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICB9XG5cbiAgY29sb3IociwgZywgYiwgYSkge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGEgPSAxO1xuICAgIH1cblxuICAgIHIgPSBNYXRoLmZsb29yKHIgKiAyNTUpO1xuICAgIGcgPSBNYXRoLmZsb29yKGcgKiAyNTUpO1xuICAgIGIgPSBNYXRoLmZsb29yKGIgKiAyNTUpO1xuICAgIGEgPSBNYXRoLmZsb29yKGEgKiAyNTUpO1xuXG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLm91dHB1dFsxXTtcblxuICAgIGNvbnN0IHggPSB0aGlzLnRocmVhZC54O1xuICAgIGNvbnN0IHkgPSBoZWlnaHQgLSB0aGlzLnRocmVhZC55IC0gMTtcblxuICAgIGNvbnN0IGluZGV4ID0geCArIHkgKiB3aWR0aDtcblxuICAgIHRoaXMuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAwXSA9IHI7XG4gICAgdGhpcy5fY29sb3JEYXRhW2luZGV4ICogNCArIDFdID0gZztcbiAgICB0aGlzLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgMl0gPSBiO1xuICAgIHRoaXMuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAzXSA9IGE7XG4gIH1cblxuICBnZXRLZXJuZWxTdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2tlcm5lbFN0cmluZyAhPT0gbnVsbCkgcmV0dXJuIHRoaXMuX2tlcm5lbFN0cmluZztcblxuICAgIGxldCBrZXJuZWxUaHJlYWRTdHJpbmcgPSBudWxsO1xuICAgIGxldCB7XG4gICAgICB0cmFuc2xhdGVkU291cmNlc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICh0cmFuc2xhdGVkU291cmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0cmFuc2xhdGVkU291cmNlcyA9IHRyYW5zbGF0ZWRTb3VyY2VzLmZpbHRlcihmbiA9PiB7XG4gICAgICAgIGlmICgvXmZ1bmN0aW9uLy50ZXN0KGZuKSkgcmV0dXJuIGZuO1xuICAgICAgICBrZXJuZWxUaHJlYWRTdHJpbmcgPSBmbjtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtlcm5lbFRocmVhZFN0cmluZyA9IHRyYW5zbGF0ZWRTb3VyY2VzLnNoaWZ0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9rZXJuZWxTdHJpbmcgPSBgICBjb25zdCBMT09QX01BWCA9ICR7IHRoaXMuX2dldExvb3BNYXhTdHJpbmcoKSB9O1xuICAkeyB0aGlzLmluamVjdGVkTmF0aXZlIHx8ICcnIH1cbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAkeyB0aGlzLl9yZXN1bHRLZXJuZWxIZWFkZXIoKSB9XG4gICR7IHRoaXMuX3Byb2Nlc3NDb25zdGFudHMoKSB9XG4gIHJldHVybiAoJHsgdGhpcy5hcmd1bWVudE5hbWVzLm1hcChhcmd1bWVudE5hbWUgPT4gJ3VzZXJfJyArIGFyZ3VtZW50TmFtZSkuam9pbignLCAnKSB9KSA9PiB7XG4gICAgJHsgdGhpcy5fcHJlcGVuZGVkU3RyaW5nLmpvaW4oJycpIH1cbiAgICAkeyB0aGlzLl9lYXJseVRocm93cygpIH1cbiAgICAkeyB0aGlzLl9wcm9jZXNzQXJndW1lbnRzKCkgfVxuICAgICR7IHRoaXMuZ3JhcGhpY2FsID8gdGhpcy5fZ3JhcGhpY2FsS2VybmVsQm9keShrZXJuZWxUaHJlYWRTdHJpbmcpIDogdGhpcy5fcmVzdWx0S2VybmVsQm9keShrZXJuZWxUaHJlYWRTdHJpbmcpIH1cbiAgICAkeyB0cmFuc2xhdGVkU291cmNlcy5sZW5ndGggPiAwID8gdHJhbnNsYXRlZFNvdXJjZXMuam9pbignXFxuJykgOiAnJyB9XG4gIH07YDtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBjcHVLZXJuZWxTdHJpbmcodGhpcyk7XG4gIH1cblxuICBfZ2V0TG9vcE1heFN0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb29wTWF4SXRlcmF0aW9ucyA/XG4gICAgICBgICR7IHBhcnNlSW50KHRoaXMubG9vcE1heEl0ZXJhdGlvbnMpIH07YCA6XG4gICAgICAnIDEwMDA7J1xuICAgICk7XG4gIH1cblxuICBfcHJvY2Vzc0NvbnN0YW50cygpIHtcbiAgICBpZiAoIXRoaXMuY29uc3RhbnRzKSByZXR1cm4gJyc7XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBwIGluIHRoaXMuY29uc3RhbnRzKSB7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy5jb25zdGFudFR5cGVzW3BdO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ0hUTUxDYW52YXMnOlxuICAgICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgICBjYXNlICdIVE1MVmlkZW8nOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLl9tZWRpYVRvMkRBcnJheSh0aGlzLmNvbnN0YW50cy4ke3B9KTtcXG5gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSFRNTEltYWdlQXJyYXknOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLl9pbWFnZVRvM0RBcnJheSh0aGlzLmNvbnN0YW50cy4ke3B9KTtcXG5gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSW5wdXQnOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLmNvbnN0YW50cy4ke3B9LnZhbHVlO1xcbmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLmNvbnN0YW50cy4ke3B9O1xcbmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICB9XG5cbiAgX2Vhcmx5VGhyb3dzKCkge1xuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkgcmV0dXJuICcnO1xuICAgIGlmICh0aGlzLmltbXV0YWJsZSkgcmV0dXJuICcnO1xuICAgIGlmICghdGhpcy5waXBlbGluZSkgcmV0dXJuICcnO1xuICAgIGNvbnN0IGFycmF5QXJndW1lbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmFyZ3VtZW50VHlwZXNbaV0gPT09ICdBcnJheScpIHtcbiAgICAgICAgYXJyYXlBcmd1bWVudHMucHVzaCh0aGlzLmFyZ3VtZW50TmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXJyYXlBcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgY29uc3QgY2hlY2tzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheUFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXJndW1lbnROYW1lID0gYXJyYXlBcmd1bWVudHNbaV07XG4gICAgICBjb25zdCBjaGVja1N1Yktlcm5lbHMgPSB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgdXNlcl8ke2FyZ3VtZW50TmFtZX0gPT09IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfWApLmpvaW4oJyB8fCAnKTtcbiAgICAgIGNoZWNrcy5wdXNoKGB1c2VyXyR7YXJndW1lbnROYW1lfSA9PT0gcmVzdWx0JHtjaGVja1N1Yktlcm5lbHMgPyBgIHx8ICR7Y2hlY2tTdWJLZXJuZWxzfWAgOiAnJ31gKTtcbiAgICB9XG4gICAgcmV0dXJuIGBpZiAoJHtjaGVja3Muam9pbignIHx8ICcpfSkgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFycmF5cyBhcmUgdGhlIHNhbWUuICBVc2UgaW1tdXRhYmxlID0gdHJ1ZScpO2A7XG4gIH1cblxuICBfcHJvY2Vzc0FyZ3VtZW50cygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJndW1lbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gYHVzZXJfJHt0aGlzLmFyZ3VtZW50TmFtZXNbaV19YDtcbiAgICAgIHN3aXRjaCAodGhpcy5hcmd1bWVudFR5cGVzW2ldKSB7XG4gICAgICAgIGNhc2UgJ0hUTUxDYW52YXMnOlxuICAgICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgICBjYXNlICdIVE1MVmlkZW8nOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgJHt2YXJpYWJsZU5hbWV9ID0gdGhpcy5fbWVkaWFUbzJEQXJyYXkoJHt2YXJpYWJsZU5hbWV9KTtcXG5gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSFRNTEltYWdlQXJyYXknOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgJHt2YXJpYWJsZU5hbWV9ID0gdGhpcy5faW1hZ2VUbzNEQXJyYXkoJHt2YXJpYWJsZU5hbWV9KTtcXG5gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSW5wdXQnOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgJHt2YXJpYWJsZU5hbWV9ID0gJHt2YXJpYWJsZU5hbWV9LnZhbHVlO1xcbmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMSknOlxuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMiknOlxuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMyknOlxuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoNCknOlxuICAgICAgICBjYXNlICdOdW1iZXJUZXh0dXJlJzpcbiAgICAgICAgY2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG4gICAgICAgICAgcmVzdWx0LnB1c2goYFxuICAgIGlmICgke3ZhcmlhYmxlTmFtZX0udG9BcnJheSkge1xuICAgICAgaWYgKCFfdGhpcy50ZXh0dXJlQ2FjaGUpIHtcbiAgICAgICAgX3RoaXMudGV4dHVyZUNhY2hlID0gW107XG4gICAgICAgIF90aGlzLmFycmF5Q2FjaGUgPSBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHR1cmVJbmRleCA9IF90aGlzLnRleHR1cmVDYWNoZS5pbmRleE9mKCR7dmFyaWFibGVOYW1lfSk7XG4gICAgICBpZiAodGV4dHVyZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAke3ZhcmlhYmxlTmFtZX0gPSBfdGhpcy5hcnJheUNhY2hlW3RleHR1cmVJbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy50ZXh0dXJlQ2FjaGUucHVzaCgke3ZhcmlhYmxlTmFtZX0pO1xuICAgICAgICAke3ZhcmlhYmxlTmFtZX0gPSAke3ZhcmlhYmxlTmFtZX0udG9BcnJheSgpO1xuICAgICAgICBfdGhpcy5hcnJheUNhY2hlLnB1c2goJHt2YXJpYWJsZU5hbWV9KTtcbiAgICAgIH1cbiAgICB9YCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gIH1cblxuICBfbWVkaWFUbzJEQXJyYXkobWVkaWEpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBjb25zdCB3aWR0aCA9IG1lZGlhLndpZHRoID4gMCA/IG1lZGlhLndpZHRoIDogbWVkaWEudmlkZW9XaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBtZWRpYS5oZWlnaHQgPiAwID8gbWVkaWEuaGVpZ2h0IDogbWVkaWEudmlkZW9IZWlnaHQ7XG4gICAgaWYgKGNhbnZhcy53aWR0aCA8IHdpZHRoKSB7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgaWYgKGNhbnZhcy5oZWlnaHQgPCBoZWlnaHQpIHtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICBjdHguZHJhd0ltYWdlKG1lZGlhLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCBwaXhlbHNEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgIGNvbnN0IGltYWdlQXJyYXkgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAobGV0IHkgPSBoZWlnaHQgLSAxOyB5ID49IDA7IHktLSkge1xuICAgICAgY29uc3Qgcm93ID0gaW1hZ2VBcnJheVt5XSA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgY29uc3QgcGl4ZWwgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBwaXhlbFswXSA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7IFxuICAgICAgICBwaXhlbFsxXSA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7IFxuICAgICAgICBwaXhlbFsyXSA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7IFxuICAgICAgICBwaXhlbFszXSA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7IFxuICAgICAgICByb3dbeF0gPSBwaXhlbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGltYWdlQXJyYXk7XG4gIH1cblxuICBnZXRQaXhlbHMoZmxpcCkge1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMub3V0cHV0O1xuICAgIHJldHVybiBmbGlwID8gdXRpbHMuZmxpcFBpeGVscyh0aGlzLl9pbWFnZURhdGEuZGF0YSwgd2lkdGgsIGhlaWdodCkgOiB0aGlzLl9pbWFnZURhdGEuZGF0YS5zbGljZSgwKTtcbiAgfVxuXG4gIF9pbWFnZVRvM0RBcnJheShpbWFnZXMpIHtcbiAgICBjb25zdCBpbWFnZXNBcnJheSA9IG5ldyBBcnJheShpbWFnZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaW1hZ2VzQXJyYXlbaV0gPSB0aGlzLl9tZWRpYVRvMkRBcnJheShpbWFnZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VzQXJyYXk7XG4gIH1cblxuICBfcmVzdWx0S2VybmVsSGVhZGVyKCkge1xuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkgcmV0dXJuICcnO1xuICAgIGlmICh0aGlzLmltbXV0YWJsZSkgcmV0dXJuICcnO1xuICAgIGlmICghdGhpcy5waXBlbGluZSkgcmV0dXJuICcnO1xuICAgIHN3aXRjaCAodGhpcy5vdXRwdXQubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLl9tdXRhYmxlS2VybmVsMURSZXN1bHRzKCk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLl9tdXRhYmxlS2VybmVsMkRSZXN1bHRzKCk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLl9tdXRhYmxlS2VybmVsM0RSZXN1bHRzKCk7XG4gICAgfVxuICB9XG5cbiAgX3Jlc3VsdEtlcm5lbEJvZHkoa2VybmVsU3RyaW5nKSB7XG4gICAgc3dpdGNoICh0aGlzLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuICghdGhpcy5pbW11dGFibGUgJiYgdGhpcy5waXBlbGluZSA/IHRoaXMuX3Jlc3VsdE11dGFibGVLZXJuZWwxRExvb3Aoa2VybmVsU3RyaW5nKSA6IHRoaXMuX3Jlc3VsdEltbXV0YWJsZUtlcm5lbDFETG9vcChrZXJuZWxTdHJpbmcpKSArIHRoaXMuX2tlcm5lbE91dHB1dCgpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gKCF0aGlzLmltbXV0YWJsZSAmJiB0aGlzLnBpcGVsaW5lID8gdGhpcy5fcmVzdWx0TXV0YWJsZUtlcm5lbDJETG9vcChrZXJuZWxTdHJpbmcpIDogdGhpcy5fcmVzdWx0SW1tdXRhYmxlS2VybmVsMkRMb29wKGtlcm5lbFN0cmluZykpICsgdGhpcy5fa2VybmVsT3V0cHV0KCk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiAoIXRoaXMuaW1tdXRhYmxlICYmIHRoaXMucGlwZWxpbmUgPyB0aGlzLl9yZXN1bHRNdXRhYmxlS2VybmVsM0RMb29wKGtlcm5lbFN0cmluZykgOiB0aGlzLl9yZXN1bHRJbW11dGFibGVLZXJuZWwzRExvb3Aoa2VybmVsU3RyaW5nKSkgKyB0aGlzLl9rZXJuZWxPdXRwdXQoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgc2l6ZSBrZXJuZWwnKTtcbiAgICB9XG4gIH1cblxuICBfZ3JhcGhpY2FsS2VybmVsQm9keShrZXJuZWxUaHJlYWRTdHJpbmcpIHtcbiAgICBzd2l0Y2ggKHRoaXMub3V0cHV0Lmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY2FsS2VybmVsMkRMb29wKGtlcm5lbFRocmVhZFN0cmluZykgKyB0aGlzLl9ncmFwaGljYWxPdXRwdXQoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgc2l6ZSBrZXJuZWwnKTtcbiAgICB9XG4gIH1cblxuICBfZ3JhcGhpY2FsT3V0cHV0KCkge1xuICAgIHJldHVybiBgXG4gICAgdGhpcy5faW1hZ2VEYXRhLmRhdGEuc2V0KHRoaXMuX2NvbG9yRGF0YSk7XG4gICAgdGhpcy5jb250ZXh0LnB1dEltYWdlRGF0YSh0aGlzLl9pbWFnZURhdGEsIDAsIDApO1xuICAgIHJldHVybjtgXG4gIH1cblxuICBfZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCkge1xuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIHJldHVybiAnRmxvYXQzMkFycmF5JztcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgcmV0dXJuICdBcnJheSc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcbiAgICAgICAgICByZXR1cm4gJ0Zsb2F0MzJBcnJheSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgcmV0dXJuVHlwZSAkeyB0aGlzLnJldHVyblR5cGUgfWApO1xuICAgIH1cbiAgfVxuXG4gIF9yZXN1bHRJbW11dGFibGVLZXJuZWwxRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0cHV0WDsgeCsrKSB7XG4gICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgIHRoaXMudGhyZWFkLnkgPSAwO1xuICAgICAgdGhpcy50aHJlYWQueiA9IDA7XG4gICAgICAkeyBrZXJuZWxTdHJpbmcgfVxuICAgIH1gO1xuICB9XG5cbiAgX211dGFibGVLZXJuZWwxRFJlc3VsdHMoKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfWA7XG4gIH1cblxuICBfcmVzdWx0TXV0YWJsZUtlcm5lbDFETG9vcChrZXJuZWxTdHJpbmcpIHtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICB0aGlzLnRocmVhZC55ID0gMDtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9yZXN1bHRJbW11dGFibGVLZXJuZWwyRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCBvdXRwdXRZID0gX3RoaXMub3V0cHV0WzFdO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShvdXRwdXRZKTtcbiAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgY29uc3QgcmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH0gPSBuZXcgQXJyYXkob3V0cHV0WSk7XFxuYCkuam9pbignICAgICcpIH1cbiAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgbGV0IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9O1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRwdXRZOyB5KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICBjb25zdCByZXN1bHRYID0gcmVzdWx0W3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xuICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFhfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcnKSB9XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9tdXRhYmxlS2VybmVsMkRSZXN1bHRzKCkge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yU3RyaW5nID0gdGhpcy5fZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCk7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3Qgb3V0cHV0WSA9IF90aGlzLm91dHB1dFsxXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkob3V0cHV0WSk7XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3IEFycmF5KG91dHB1dFkpO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0cHV0WTsgeSsrKSB7XG4gICAgICBjb25zdCByZXN1bHRYID0gcmVzdWx0W3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xuICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFhfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcnKSB9XG4gICAgfWA7XG4gIH1cblxuICBfcmVzdWx0TXV0YWJsZUtlcm5lbDJETG9vcChrZXJuZWxTdHJpbmcpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvclN0cmluZyA9IHRoaXMuX2dldEtlcm5lbFJlc3VsdFR5cGVDb25zdHJ1Y3RvclN0cmluZygpO1xuICAgIHJldHVybiBgICBjb25zdCBvdXRwdXRYID0gX3RoaXMub3V0cHV0WzBdO1xuICAgIGNvbnN0IG91dHB1dFkgPSBfdGhpcy5vdXRwdXRbMV07XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRwdXRZOyB5KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICBjb25zdCByZXN1bHRYID0gcmVzdWx0W3ldO1xuICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFhfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcnKSB9XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9ncmFwaGljYWxLZXJuZWwyRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3Qgb3V0cHV0WSA9IF90aGlzLm91dHB1dFsxXTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dHB1dFk7IHkrKykge1xuICAgICAgdGhpcy50aHJlYWQueiA9IDA7XG4gICAgICB0aGlzLnRocmVhZC55ID0geTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0cHV0WDsgeCsrKSB7XG4gICAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgICAkeyBrZXJuZWxTdHJpbmcgfVxuICAgICAgfVxuICAgIH1gO1xuICB9XG5cbiAgX3Jlc3VsdEltbXV0YWJsZUtlcm5lbDNETG9vcChrZXJuZWxTdHJpbmcpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvclN0cmluZyA9IHRoaXMuX2dldEtlcm5lbFJlc3VsdFR5cGVDb25zdHJ1Y3RvclN0cmluZygpO1xuICAgIHJldHVybiBgICBjb25zdCBvdXRwdXRYID0gX3RoaXMub3V0cHV0WzBdO1xuICAgIGNvbnN0IG91dHB1dFkgPSBfdGhpcy5vdXRwdXRbMV07XG4gICAgY29uc3Qgb3V0cHV0WiA9IF90aGlzLm91dHB1dFsyXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkob3V0cHV0Wik7XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3IEFycmF5KG91dHB1dFopO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgIGZvciAobGV0IHogPSAwOyB6IDwgb3V0cHV0WjsgeisrKSB7XG4gICAgICB0aGlzLnRocmVhZC56ID0gejtcbiAgICAgIGNvbnN0IHJlc3VsdFkgPSByZXN1bHRbel0gPSBuZXcgQXJyYXkob3V0cHV0WSk7XG4gICAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgY29uc3QgcmVzdWx0WV8keyBzdWJLZXJuZWwubmFtZSB9ID0gcmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9W3pdID0gbmV3IEFycmF5KG91dHB1dFkpO1xcbmApLmpvaW4oJyAgICAgICcpIH1cbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0cHV0WTsgeSsrKSB7XG4gICAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xuICAgICAgICBjb25zdCByZXN1bHRYID0gcmVzdWx0WVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcbiAgICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFhfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdFlfJHtzdWJLZXJuZWwubmFtZX1beV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XFxuYCkuam9pbignICAgICAgICAnKSB9XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0cHV0WDsgeCsrKSB7XG4gICAgICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1gO1xuICB9XG5cbiAgX211dGFibGVLZXJuZWwzRFJlc3VsdHMoKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCBvdXRwdXRZID0gX3RoaXMub3V0cHV0WzFdO1xuICAgIGNvbnN0IG91dHB1dFogPSBfdGhpcy5vdXRwdXRbMl07XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KG91dHB1dFopO1xuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IG5ldyBBcnJheShvdXRwdXRaKTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBsZXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH07XFxuYCkuam9pbignICAgICcpIH1cbiAgICBmb3IgKGxldCB6ID0gMDsgeiA8IG91dHB1dFo7IHorKykge1xuICAgICAgY29uc3QgcmVzdWx0WSA9IHJlc3VsdFt6XSA9IG5ldyBBcnJheShvdXRwdXRZKTtcbiAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRZXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1bel0gPSBuZXcgQXJyYXkob3V0cHV0WSk7XFxuYCkuam9pbignICAgICAgJykgfVxuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRwdXRZOyB5KyspIHtcbiAgICAgICAgY29uc3QgcmVzdWx0WCA9IHJlc3VsdFlbeV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XG4gICAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRYXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRZXyR7c3ViS2VybmVsLm5hbWV9W3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xcbmApLmpvaW4oJyAgICAgICAgJykgfVxuICAgICAgfVxuICAgIH1gO1xuICB9XG5cbiAgX3Jlc3VsdE11dGFibGVLZXJuZWwzRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3Qgb3V0cHV0WSA9IF90aGlzLm91dHB1dFsxXTtcbiAgICBjb25zdCBvdXRwdXRaID0gX3RoaXMub3V0cHV0WzJdO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgb3V0cHV0WjsgeisrKSB7XG4gICAgICB0aGlzLnRocmVhZC56ID0gejtcbiAgICAgIGNvbnN0IHJlc3VsdFkgPSByZXN1bHRbel07XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dHB1dFk7IHkrKykge1xuICAgICAgICB0aGlzLnRocmVhZC55ID0geTtcbiAgICAgICAgY29uc3QgcmVzdWx0WCA9IHJlc3VsdFlbeV07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0cHV0WDsgeCsrKSB7XG4gICAgICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1gO1xuICB9XG5cbiAgX2tlcm5lbE91dHB1dCgpIHtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykge1xuICAgICAgcmV0dXJuICdcXG4gICAgcmV0dXJuIHJlc3VsdDsnO1xuICAgIH1cbiAgICByZXR1cm4gYFxcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAkeyB0aGlzLnN1Yktlcm5lbHMubWFwKHN1Yktlcm5lbCA9PiBgJHsgc3ViS2VybmVsLnByb3BlcnR5IH06IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9YCkuam9pbignLFxcbiAgICAgICcpIH1cbiAgICB9O2A7XG4gIH1cblxuICBfbWFwU3ViS2VybmVscyhmbikge1xuICAgIHJldHVybiB0aGlzLnN1Yktlcm5lbHMgPT09IG51bGwgPyBbJyddIDpcbiAgICAgIHRoaXMuc3ViS2VybmVscy5tYXAoZm4pO1xuICB9XG5cbiAgZGVzdHJveShyZW1vdmVDYW52YXNSZWZlcmVuY2UpIHtcbiAgICBpZiAocmVtb3ZlQ2FudmFzUmVmZXJlbmNlKSB7XG4gICAgICBkZWxldGUgdGhpcy5jYW52YXM7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGRlc3Ryb3lDb250ZXh0KGNvbnRleHQpIHt9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGpzb24gPSBzdXBlci50b0pTT04oKTtcbiAgICBqc29uLmZ1bmN0aW9uTm9kZXMgPSBGdW5jdGlvbkJ1aWxkZXIuZnJvbUtlcm5lbCh0aGlzLCBDUFVGdW5jdGlvbk5vZGUpLnRvSlNPTigpO1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgc2V0T3V0cHV0KG91dHB1dCkge1xuICAgIHN1cGVyLnNldE91dHB1dChvdXRwdXQpO1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMub3V0cHV0O1xuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgdGhpcy5faW1hZ2VEYXRhID0gdGhpcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuX2NvbG9yRGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIH1cbiAgfVxuXG4gIHByZXBlbmRTdHJpbmcodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fa2VybmVsU3RyaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0tlcm5lbCBhbHJlYWR5IGJ1aWx0Jyk7XG4gICAgdGhpcy5fcHJlcGVuZGVkU3RyaW5nLnB1c2godmFsdWUpO1xuICB9XG5cbiAgaGFzUHJlcGVuZFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wcmVwZW5kZWRTdHJpbmcuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ1BVS2VybmVsXG59O1xufSx7XCIuLi8uLi91dGlsc1wiOjExNCxcIi4uL2Z1bmN0aW9uLWJ1aWxkZXJcIjo5LFwiLi4va2VybmVsXCI6MzYsXCIuL2Z1bmN0aW9uLW5vZGVcIjo2LFwiLi9rZXJuZWwtc3RyaW5nXCI6N31dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY2xhc3MgRnVuY3Rpb25CdWlsZGVyIHtcbiAgc3RhdGljIGZyb21LZXJuZWwoa2VybmVsLCBGdW5jdGlvbk5vZGUsIGV4dHJhTm9kZU9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBrZXJuZWxBcmd1bWVudHMsXG4gICAgICBrZXJuZWxDb25zdGFudHMsXG4gICAgICBhcmd1bWVudE5hbWVzLFxuICAgICAgYXJndW1lbnRTaXplcyxcbiAgICAgIGFyZ3VtZW50Qml0UmF0aW9zLFxuICAgICAgY29uc3RhbnRzLFxuICAgICAgY29uc3RhbnRCaXRSYXRpb3MsXG4gICAgICBkZWJ1ZyxcbiAgICAgIGxvb3BNYXhJdGVyYXRpb25zLFxuICAgICAgbmF0aXZlRnVuY3Rpb25zLFxuICAgICAgb3V0cHV0LFxuICAgICAgb3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgIHByZWNpc2lvbixcbiAgICAgIHBsdWdpbnMsXG4gICAgICBzb3VyY2UsXG4gICAgICBzdWJLZXJuZWxzLFxuICAgICAgZnVuY3Rpb25zLFxuICAgICAgbGVhZGluZ1JldHVyblN0YXRlbWVudCxcbiAgICAgIGZvbGxvd2luZ1JldHVyblN0YXRlbWVudCxcbiAgICAgIGR5bmFtaWNBcmd1bWVudHMsXG4gICAgICBkeW5hbWljT3V0cHV0LFxuICAgICAgb25Jc3RhbmJ1bENvdmVyYWdlVmFyaWFibGUsXG4gICAgICByZW1vdmVJc3RhbmJ1bENvdmVyYWdlLFxuICAgIH0gPSBrZXJuZWw7XG5cbiAgICBjb25zdCBhcmd1bWVudFR5cGVzID0gbmV3IEFycmF5KGtlcm5lbEFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGNvbnN0IGNvbnN0YW50VHlwZXMgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsQXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmd1bWVudFR5cGVzW2ldID0ga2VybmVsQXJndW1lbnRzW2ldLnR5cGU7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxDb25zdGFudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtlcm5lbENvbnN0YW50ID0ga2VybmVsQ29uc3RhbnRzW2ldO1xuICAgICAgY29uc3RhbnRUeXBlc1trZXJuZWxDb25zdGFudC5uYW1lXSA9IGtlcm5lbENvbnN0YW50LnR5cGU7XG4gICAgfVxuXG4gICAgY29uc3QgbmVlZHNBcmd1bWVudFR5cGUgPSAoZnVuY3Rpb25OYW1lLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlci5uZWVkc0FyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGluZGV4KTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXNzaWduQXJndW1lbnRUeXBlID0gKGZ1bmN0aW9uTmFtZSwgaW5kZXgsIHR5cGUpID0+IHtcbiAgICAgIGZ1bmN0aW9uQnVpbGRlci5hc3NpZ25Bcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpbmRleCwgdHlwZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGxvb2t1cFJldHVyblR5cGUgPSAoZnVuY3Rpb25OYW1lLCBhc3QsIHJlcXVlc3RpbmdOb2RlKSA9PiB7XG4gICAgICByZXR1cm4gZnVuY3Rpb25CdWlsZGVyLmxvb2t1cFJldHVyblR5cGUoZnVuY3Rpb25OYW1lLCBhc3QsIHJlcXVlc3RpbmdOb2RlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgbG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzID0gKGZ1bmN0aW9uTmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlci5sb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMoZnVuY3Rpb25OYW1lKTtcbiAgICB9O1xuXG4gICAgY29uc3QgbG9va3VwRnVuY3Rpb25Bcmd1bWVudE5hbWUgPSAoZnVuY3Rpb25OYW1lLCBhcmd1bWVudEluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gZnVuY3Rpb25CdWlsZGVyLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyA9IChmdW5jdGlvbk5hbWUsIGFyZ3VtZW50TmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlci5sb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8oZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUpO1xuICAgIH07XG5cbiAgICBjb25zdCB0cmlnZ2VySW1wbHlBcmd1bWVudFR5cGUgPSAoZnVuY3Rpb25OYW1lLCBpLCBhcmd1bWVudFR5cGUsIHJlcXVlc3RpbmdOb2RlKSA9PiB7XG4gICAgICBmdW5jdGlvbkJ1aWxkZXIuYXNzaWduQXJndW1lbnRUeXBlKGZ1bmN0aW9uTmFtZSwgaSwgYXJndW1lbnRUeXBlLCByZXF1ZXN0aW5nTm9kZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHRyaWdnZXJJbXBseUFyZ3VtZW50Qml0UmF0aW8gPSAoZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCkgPT4ge1xuICAgICAgZnVuY3Rpb25CdWlsZGVyLmFzc2lnbkFyZ3VtZW50Qml0UmF0aW8oZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uRnVuY3Rpb25DYWxsID0gKGZ1bmN0aW9uTmFtZSwgY2FsbGVlRnVuY3Rpb25OYW1lLCBhcmdzKSA9PiB7XG4gICAgICBmdW5jdGlvbkJ1aWxkZXIudHJhY2tGdW5jdGlvbkNhbGwoZnVuY3Rpb25OYW1lLCBjYWxsZWVGdW5jdGlvbk5hbWUsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbk5lc3RlZEZ1bmN0aW9uID0gKGFzdCwgcmV0dXJuVHlwZSkgPT4ge1xuICAgICAgY29uc3QgYXJndW1lbnROYW1lcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3VtZW50TmFtZXMucHVzaChhc3QucGFyYW1zW2ldLm5hbWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmVzdGVkRnVuY3Rpb24gPSBuZXcgRnVuY3Rpb25Ob2RlKG51bGwsIE9iamVjdC5hc3NpZ24oe30sIG5vZGVPcHRpb25zLCB7XG4gICAgICAgIHJldHVyblR5cGU6IG51bGwsXG4gICAgICAgIGFzdCxcbiAgICAgICAgbmFtZTogYXN0LmlkLm5hbWUsXG4gICAgICAgIGFyZ3VtZW50TmFtZXMsXG4gICAgICAgIGxvb2t1cFJldHVyblR5cGUsXG4gICAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyxcbiAgICAgICAgbG9va3VwRnVuY3Rpb25Bcmd1bWVudE5hbWUsXG4gICAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyxcbiAgICAgICAgbmVlZHNBcmd1bWVudFR5cGUsXG4gICAgICAgIGFzc2lnbkFyZ3VtZW50VHlwZSxcbiAgICAgICAgdHJpZ2dlckltcGx5QXJndW1lbnRUeXBlLFxuICAgICAgICB0cmlnZ2VySW1wbHlBcmd1bWVudEJpdFJhdGlvLFxuICAgICAgICBvbkZ1bmN0aW9uQ2FsbCxcbiAgICAgIH0pKTtcbiAgICAgIG5lc3RlZEZ1bmN0aW9uLnRyYWNlRnVuY3Rpb25BU1QoYXN0KTtcbiAgICAgIGZ1bmN0aW9uQnVpbGRlci5hZGRGdW5jdGlvbk5vZGUobmVzdGVkRnVuY3Rpb24pO1xuICAgIH07XG5cbiAgICBjb25zdCBub2RlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgaXNSb290S2VybmVsOiBmYWxzZSxcbiAgICAgIG9uTmVzdGVkRnVuY3Rpb24sXG4gICAgICBsb29rdXBSZXR1cm5UeXBlLFxuICAgICAgbG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzLFxuICAgICAgbG9va3VwRnVuY3Rpb25Bcmd1bWVudE5hbWUsXG4gICAgICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8sXG4gICAgICBuZWVkc0FyZ3VtZW50VHlwZSxcbiAgICAgIGFzc2lnbkFyZ3VtZW50VHlwZSxcbiAgICAgIHRyaWdnZXJJbXBseUFyZ3VtZW50VHlwZSxcbiAgICAgIHRyaWdnZXJJbXBseUFyZ3VtZW50Qml0UmF0aW8sXG4gICAgICBvbkZ1bmN0aW9uQ2FsbCxcbiAgICAgIG9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlOiBvbklzdGFuYnVsQ292ZXJhZ2VWYXJpYWJsZSA/IChuYW1lKSA9PiBvbklzdGFuYnVsQ292ZXJhZ2VWYXJpYWJsZShuYW1lLCBrZXJuZWwpIDogbnVsbCxcbiAgICAgIHJlbW92ZUlzdGFuYnVsQ292ZXJhZ2UsXG4gICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgICAgcHJlY2lzaW9uLFxuICAgICAgY29uc3RhbnRzLFxuICAgICAgY29uc3RhbnRUeXBlcyxcbiAgICAgIGNvbnN0YW50Qml0UmF0aW9zLFxuICAgICAgZGVidWcsXG4gICAgICBsb29wTWF4SXRlcmF0aW9ucyxcbiAgICAgIG91dHB1dCxcbiAgICAgIHBsdWdpbnMsXG4gICAgICBkeW5hbWljQXJndW1lbnRzLFxuICAgICAgZHluYW1pY091dHB1dCxcbiAgICB9LCBleHRyYU5vZGVPcHRpb25zIHx8IHt9KTtcblxuICAgIGNvbnN0IHJvb3ROb2RlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGVPcHRpb25zLCB7XG4gICAgICBpc1Jvb3RLZXJuZWw6IHRydWUsXG4gICAgICBuYW1lOiAna2VybmVsJyxcbiAgICAgIGFyZ3VtZW50TmFtZXMsXG4gICAgICBhcmd1bWVudFR5cGVzLFxuICAgICAgYXJndW1lbnRTaXplcyxcbiAgICAgIGFyZ3VtZW50Qml0UmF0aW9zLFxuICAgICAgbGVhZGluZ1JldHVyblN0YXRlbWVudCxcbiAgICAgIGZvbGxvd2luZ1JldHVyblN0YXRlbWVudCxcbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JyAmJiBzb3VyY2UuZnVuY3Rpb25Ob2Rlcykge1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkJ1aWxkZXIoKS5mcm9tSlNPTihzb3VyY2UuZnVuY3Rpb25Ob2RlcywgRnVuY3Rpb25Ob2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCByb290Tm9kZSA9IG5ldyBGdW5jdGlvbk5vZGUoc291cmNlLCByb290Tm9kZU9wdGlvbnMpO1xuXG4gICAgbGV0IGZ1bmN0aW9uTm9kZXMgPSBudWxsO1xuICAgIGlmIChmdW5jdGlvbnMpIHtcbiAgICAgIGZ1bmN0aW9uTm9kZXMgPSBmdW5jdGlvbnMubWFwKChmbikgPT4gbmV3IEZ1bmN0aW9uTm9kZShmbi5zb3VyY2UsIHtcbiAgICAgICAgcmV0dXJuVHlwZTogZm4ucmV0dXJuVHlwZSxcbiAgICAgICAgYXJndW1lbnRUeXBlczogZm4uYXJndW1lbnRUeXBlcyxcbiAgICAgICAgb3V0cHV0LFxuICAgICAgICBwbHVnaW5zLFxuICAgICAgICBjb25zdGFudHMsXG4gICAgICAgIGNvbnN0YW50VHlwZXMsXG4gICAgICAgIGNvbnN0YW50Qml0UmF0aW9zLFxuICAgICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgIGxvb2t1cFJldHVyblR5cGUsXG4gICAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyxcbiAgICAgICAgbG9va3VwRnVuY3Rpb25Bcmd1bWVudE5hbWUsXG4gICAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyxcbiAgICAgICAgbmVlZHNBcmd1bWVudFR5cGUsXG4gICAgICAgIGFzc2lnbkFyZ3VtZW50VHlwZSxcbiAgICAgICAgdHJpZ2dlckltcGx5QXJndW1lbnRUeXBlLFxuICAgICAgICB0cmlnZ2VySW1wbHlBcmd1bWVudEJpdFJhdGlvLFxuICAgICAgICBvbkZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgb25OZXN0ZWRGdW5jdGlvbixcbiAgICAgICAgb25Jc3RhbmJ1bENvdmVyYWdlVmFyaWFibGU6IG9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlID8gKG5hbWUpID0+IG9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlKG5hbWUsIGtlcm5lbCkgOiBudWxsLFxuICAgICAgICByZW1vdmVJc3RhbmJ1bENvdmVyYWdlLFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGxldCBzdWJLZXJuZWxOb2RlcyA9IG51bGw7XG4gICAgaWYgKHN1Yktlcm5lbHMpIHtcbiAgICAgIHN1Yktlcm5lbE5vZGVzID0gc3ViS2VybmVscy5tYXAoKHN1Yktlcm5lbCkgPT4ge1xuICAgICAgICBjb25zdCB7IG5hbWUsIHNvdXJjZSB9ID0gc3ViS2VybmVsO1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uTm9kZShzb3VyY2UsIE9iamVjdC5hc3NpZ24oe30sIG5vZGVPcHRpb25zLCB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBpc1N1Yktlcm5lbDogdHJ1ZSxcbiAgICAgICAgICBpc1Jvb3RLZXJuZWw6IGZhbHNlLFxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBmdW5jdGlvbkJ1aWxkZXIgPSBuZXcgRnVuY3Rpb25CdWlsZGVyKHtcbiAgICAgIGtlcm5lbCxcbiAgICAgIHJvb3ROb2RlLFxuICAgICAgZnVuY3Rpb25Ob2RlcyxcbiAgICAgIG5hdGl2ZUZ1bmN0aW9ucyxcbiAgICAgIHN1Yktlcm5lbE5vZGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb25CdWlsZGVyO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICAgIHRoaXMua2VybmVsID0gc2V0dGluZ3Mua2VybmVsO1xuICAgIHRoaXMucm9vdE5vZGUgPSBzZXR0aW5ncy5yb290Tm9kZTtcbiAgICB0aGlzLmZ1bmN0aW9uTm9kZXMgPSBzZXR0aW5ncy5mdW5jdGlvbk5vZGVzIHx8IFtdO1xuICAgIHRoaXMuc3ViS2VybmVsTm9kZXMgPSBzZXR0aW5ncy5zdWJLZXJuZWxOb2RlcyB8fCBbXTtcbiAgICB0aGlzLm5hdGl2ZUZ1bmN0aW9ucyA9IHNldHRpbmdzLm5hdGl2ZUZ1bmN0aW9ucyB8fCBbXTtcbiAgICB0aGlzLmZ1bmN0aW9uTWFwID0ge307XG4gICAgdGhpcy5uYXRpdmVGdW5jdGlvbk5hbWVzID0gW107XG4gICAgdGhpcy5sb29rdXBDaGFpbiA9IFtdO1xuICAgIHRoaXMuZnVuY3Rpb25Ob2RlRGVwZW5kZW5jaWVzID0ge307XG4gICAgdGhpcy5mdW5jdGlvbkNhbGxzID0ge307XG5cbiAgICBpZiAodGhpcy5yb290Tm9kZSkge1xuICAgICAgdGhpcy5mdW5jdGlvbk1hcFsna2VybmVsJ10gPSB0aGlzLnJvb3ROb2RlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZ1bmN0aW9uTm9kZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mdW5jdGlvbk5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25NYXBbdGhpcy5mdW5jdGlvbk5vZGVzW2ldLm5hbWVdID0gdGhpcy5mdW5jdGlvbk5vZGVzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN1Yktlcm5lbE5vZGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5mdW5jdGlvbk1hcFt0aGlzLnN1Yktlcm5lbE5vZGVzW2ldLm5hbWVdID0gdGhpcy5zdWJLZXJuZWxOb2Rlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5uYXRpdmVGdW5jdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uYXRpdmVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmF0aXZlRnVuY3Rpb24gPSB0aGlzLm5hdGl2ZUZ1bmN0aW9uc1tpXTtcbiAgICAgICAgdGhpcy5uYXRpdmVGdW5jdGlvbk5hbWVzLnB1c2gobmF0aXZlRnVuY3Rpb24ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYWRkRnVuY3Rpb25Ob2RlKGZ1bmN0aW9uTm9kZSkge1xuICAgIGlmICghZnVuY3Rpb25Ob2RlLm5hbWUpIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb25Ob2RlLm5hbWUgbmVlZHMgc2V0Jyk7XG4gICAgdGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbk5vZGUubmFtZV0gPSBmdW5jdGlvbk5vZGU7XG4gICAgaWYgKGZ1bmN0aW9uTm9kZS5pc1Jvb3RLZXJuZWwpIHtcbiAgICAgIHRoaXMucm9vdE5vZGUgPSBmdW5jdGlvbk5vZGU7XG4gICAgfVxuICB9XG5cbiAgdHJhY2VGdW5jdGlvbkNhbGxzKGZ1bmN0aW9uTmFtZSwgcmV0TGlzdCkge1xuICAgIGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZSB8fCAna2VybmVsJztcbiAgICByZXRMaXN0ID0gcmV0TGlzdCB8fCBbXTtcblxuICAgIGlmICh0aGlzLm5hdGl2ZUZ1bmN0aW9uTmFtZXMuaW5kZXhPZihmdW5jdGlvbk5hbWUpID4gLTEpIHtcbiAgICAgIGlmIChyZXRMaXN0LmluZGV4T2YoZnVuY3Rpb25OYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0TGlzdC5wdXNoKGZ1bmN0aW9uTmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0TGlzdDtcbiAgICB9XG5cbiAgICBjb25zdCBmdW5jdGlvbk5vZGUgPSB0aGlzLmZ1bmN0aW9uTWFwW2Z1bmN0aW9uTmFtZV07XG4gICAgaWYgKGZ1bmN0aW9uTm9kZSkge1xuICAgICAgY29uc3QgZnVuY3Rpb25JbmRleCA9IHJldExpc3QuaW5kZXhPZihmdW5jdGlvbk5hbWUpO1xuICAgICAgaWYgKGZ1bmN0aW9uSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldExpc3QucHVzaChmdW5jdGlvbk5hbWUpO1xuICAgICAgICBmdW5jdGlvbk5vZGUudG9TdHJpbmcoKTsgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVuY3Rpb25Ob2RlLmNhbGxlZEZ1bmN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRoaXMudHJhY2VGdW5jdGlvbkNhbGxzKGZ1bmN0aW9uTm9kZS5jYWxsZWRGdW5jdGlvbnNbaV0sIHJldExpc3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZXBlbmRhbnRGdW5jdGlvbk5hbWUgPSByZXRMaXN0LnNwbGljZShmdW5jdGlvbkluZGV4LCAxKVswXTtcbiAgICAgICAgcmV0TGlzdC5wdXNoKGRlcGVuZGFudEZ1bmN0aW9uTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldExpc3Q7XG4gIH1cblxuICBnZXRQcm90b3R5cGVTdHJpbmcoZnVuY3Rpb25OYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJvdG90eXBlcyhmdW5jdGlvbk5hbWUpLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgZ2V0UHJvdG90eXBlcyhmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAodGhpcy5yb290Tm9kZSkge1xuICAgICAgdGhpcy5yb290Tm9kZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQcm90b3R5cGVzRnJvbUZ1bmN0aW9uTmFtZXModGhpcy50cmFjZUZ1bmN0aW9uQ2FsbHMoZnVuY3Rpb25OYW1lLCBbXSkucmV2ZXJzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJvdG90eXBlc0Zyb21GdW5jdGlvbk5hbWVzKE9iamVjdC5rZXlzKHRoaXMuZnVuY3Rpb25NYXApKTtcbiAgfVxuXG4gIGdldFN0cmluZ0Zyb21GdW5jdGlvbk5hbWVzKGZ1bmN0aW9uTGlzdCkge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVuY3Rpb25MaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbkxpc3RbaV1dO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgcmV0LnB1c2godGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbkxpc3RbaV1dLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgZ2V0UHJvdG90eXBlc0Zyb21GdW5jdGlvbk5hbWVzKGZ1bmN0aW9uTGlzdCkge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVuY3Rpb25MaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbkxpc3RbaV07XG4gICAgICBjb25zdCBmdW5jdGlvbkluZGV4ID0gdGhpcy5uYXRpdmVGdW5jdGlvbk5hbWVzLmluZGV4T2YoZnVuY3Rpb25OYW1lKTtcbiAgICAgIGlmIChmdW5jdGlvbkluZGV4ID4gLTEpIHtcbiAgICAgICAgcmV0LnB1c2godGhpcy5uYXRpdmVGdW5jdGlvbnNbZnVuY3Rpb25JbmRleF0uc291cmNlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbk5hbWVdO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgcmV0LnB1c2gobm9kZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFjZUZ1bmN0aW9uQ2FsbHModGhpcy5yb290Tm9kZS5uYW1lKS5yZXZlcnNlKCkubWFwKG5hbWUgPT4ge1xuICAgICAgY29uc3QgbmF0aXZlSW5kZXggPSB0aGlzLm5hdGl2ZUZ1bmN0aW9ucy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKG5hdGl2ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHNvdXJjZTogdGhpcy5uYXRpdmVGdW5jdGlvbnNbbmF0aXZlSW5kZXhdLnNvdXJjZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmZ1bmN0aW9uTWFwW25hbWVdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uTWFwW25hbWVdLnRvSlNPTigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmdW5jdGlvbiAkeyBuYW1lIH0gbm90IGZvdW5kYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmcm9tSlNPTihqc29uRnVuY3Rpb25Ob2RlcywgRnVuY3Rpb25Ob2RlKSB7XG4gICAgdGhpcy5mdW5jdGlvbk1hcCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbkZ1bmN0aW9uTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGpzb25GdW5jdGlvbk5vZGUgPSBqc29uRnVuY3Rpb25Ob2Rlc1tpXTtcbiAgICAgIHRoaXMuZnVuY3Rpb25NYXBbanNvbkZ1bmN0aW9uTm9kZS5zZXR0aW5ncy5uYW1lXSA9IG5ldyBGdW5jdGlvbk5vZGUoanNvbkZ1bmN0aW9uTm9kZS5hc3QsIGpzb25GdW5jdGlvbk5vZGUuc2V0dGluZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldFN0cmluZyhmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdHJpbmdGcm9tRnVuY3Rpb25OYW1lcyh0aGlzLnRyYWNlRnVuY3Rpb25DYWxscyhmdW5jdGlvbk5hbWUpLnJldmVyc2UoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFN0cmluZ0Zyb21GdW5jdGlvbk5hbWVzKE9iamVjdC5rZXlzKHRoaXMuZnVuY3Rpb25NYXApKTtcbiAgfVxuXG4gIGxvb2t1cFJldHVyblR5cGUoZnVuY3Rpb25OYW1lLCBhc3QsIHJlcXVlc3RpbmdOb2RlKSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnQ2FsbEV4cHJlc3Npb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIGFzdCB0eXBlIG9mIFwiQ2FsbEV4cHJlc3Npb25cIiwgYnV0IGlzICR7IGFzdC50eXBlIH1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzTmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvb2t1cE5hdGl2ZUZ1bmN0aW9uUmV0dXJuVHlwZShmdW5jdGlvbk5hbWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faXNGdW5jdGlvbihmdW5jdGlvbk5hbWUpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5fZ2V0RnVuY3Rpb24oZnVuY3Rpb25OYW1lKTtcbiAgICAgIGlmIChub2RlLnJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucmV0dXJuVHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb29rdXBDaGFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLmxvb2t1cENoYWluW2ldLmFzdCA9PT0gYXN0KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5hcmd1bWVudFR5cGVzLmxlbmd0aCA9PT0gMCAmJiBhc3QuYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGFzdC5hcmd1bWVudHM7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJncy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9va3VwQ2hhaW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiByZXF1ZXN0aW5nTm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgYXN0OiBhcmdzW2ldLFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdGluZ05vZGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50VHlwZXNbal0gPSByZXF1ZXN0aW5nTm9kZS5nZXRUeXBlKGFyZ3Nbal0pO1xuICAgICAgICAgICAgICAgIHRoaXMubG9va3VwQ2hhaW4ucG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucmV0dXJuVHlwZSA9IG5vZGUuZ2V0VHlwZShub2RlLmdldEpzQVNUKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NpcmNsaWNhbCBsb2dpYyBkZXRlY3RlZCEnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb29rdXBDaGFpbi5wdXNoKHtcbiAgICAgICAgICBuYW1lOiByZXF1ZXN0aW5nTm9kZS5uYW1lLFxuICAgICAgICAgIGFzdCxcbiAgICAgICAgICByZXF1ZXN0aW5nTm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHlwZSA9IG5vZGUuZ2V0VHlwZShub2RlLmdldEpzQVNUKCkpO1xuICAgICAgICB0aGlzLmxvb2t1cENoYWluLnBvcCgpO1xuICAgICAgICByZXR1cm4gbm9kZS5yZXR1cm5UeXBlID0gdHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgbmV3IEVycm9yKGBGdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uTWFwW2Z1bmN0aW9uTmFtZV07XG4gIH1cblxuICBfaXNGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmZ1bmN0aW9uTWFwW2Z1bmN0aW9uTmFtZV0pO1xuICB9XG5cbiAgX2dldE5hdGl2ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uYXRpdmVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLm5hdGl2ZUZ1bmN0aW9uc1tpXS5uYW1lID09PSBmdW5jdGlvbk5hbWUpIHJldHVybiB0aGlzLm5hdGl2ZUZ1bmN0aW9uc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBfaXNOYXRpdmVGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9nZXROYXRpdmVGdW5jdGlvbihmdW5jdGlvbk5hbWUpKTtcbiAgfVxuXG4gIF9sb29rdXBOYXRpdmVGdW5jdGlvblJldHVyblR5cGUoZnVuY3Rpb25OYW1lKSB7XG4gICAgbGV0IG5hdGl2ZUZ1bmN0aW9uID0gdGhpcy5fZ2V0TmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKTtcbiAgICBpZiAobmF0aXZlRnVuY3Rpb24pIHtcbiAgICAgIHJldHVybiBuYXRpdmVGdW5jdGlvbi5yZXR1cm5UeXBlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5hdGl2ZSBmdW5jdGlvbiAkeyBmdW5jdGlvbk5hbWUgfSBub3QgZm91bmRgKTtcbiAgfVxuXG4gIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyhmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAodGhpcy5faXNOYXRpdmVGdW5jdGlvbihmdW5jdGlvbk5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0TmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKS5hcmd1bWVudFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faXNGdW5jdGlvbihmdW5jdGlvbk5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RnVuY3Rpb24oZnVuY3Rpb25OYW1lKS5hcmd1bWVudFR5cGVzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpLmFyZ3VtZW50TmFtZXNbYXJndW1lbnRJbmRleF07XG4gIH1cblxuICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8oZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvbiBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucm9vdE5vZGUubmFtZSA9PT0gZnVuY3Rpb25OYW1lKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5yb290Tm9kZS5hcmd1bWVudE5hbWVzLmluZGV4T2YoYXJndW1lbnROYW1lKTtcbiAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Tm9kZS5hcmd1bWVudEJpdFJhdGlvc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgY29uc3QgaSA9IG5vZGUuYXJndW1lbnROYW1lcy5pbmRleE9mKGFyZ3VtZW50TmFtZSk7XG4gICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyZ3VtZW50IG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBiaXRSYXRpbyA9IG5vZGUuYXJndW1lbnRCaXRSYXRpb3NbaV07XG4gICAgaWYgKHR5cGVvZiBiaXRSYXRpbyAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXJndW1lbnQgYml0IHJhdGlvIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gYml0UmF0aW87XG4gIH1cblxuICBuZWVkc0FyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGkpIHtcbiAgICBpZiAoIXRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGZuTm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgcmV0dXJuICFmbk5vZGUuYXJndW1lbnRUeXBlc1tpXTtcbiAgfVxuXG4gIGFzc2lnbkFyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGksIGFyZ3VtZW50VHlwZSwgcmVxdWVzdGluZ05vZGUpIHtcbiAgICBpZiAoIXRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkgcmV0dXJuO1xuICAgIGNvbnN0IGZuTm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgaWYgKCFmbk5vZGUuYXJndW1lbnRUeXBlc1tpXSkge1xuICAgICAgZm5Ob2RlLmFyZ3VtZW50VHlwZXNbaV0gPSBhcmd1bWVudFR5cGU7XG4gICAgfVxuICB9XG5cbiAgYXNzaWduQXJndW1lbnRCaXRSYXRpbyhmdW5jdGlvbk5hbWUsIGFyZ3VtZW50TmFtZSwgY2FsbGVlRnVuY3Rpb25OYW1lLCBhcmd1bWVudEluZGV4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgaWYgKHRoaXMuX2lzTmF0aXZlRnVuY3Rpb24oY2FsbGVlRnVuY3Rpb25OYW1lKSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY2FsbGVlTm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGNhbGxlZUZ1bmN0aW9uTmFtZSk7XG4gICAgY29uc3QgaSA9IG5vZGUuYXJndW1lbnROYW1lcy5pbmRleE9mKGFyZ3VtZW50TmFtZSk7XG4gICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50ICR7YXJndW1lbnROYW1lfSBub3QgZm91bmQgaW4gYXJndW1lbnRzIGZyb20gZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9YCk7XG4gICAgfVxuICAgIGNvbnN0IGJpdFJhdGlvID0gbm9kZS5hcmd1bWVudEJpdFJhdGlvc1tpXTtcbiAgICBpZiAodHlwZW9mIGJpdFJhdGlvICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXQgcmF0aW8gZm9yIGFyZ3VtZW50ICR7YXJndW1lbnROYW1lfSBub3QgZm91bmQgaW4gZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9YCk7XG4gICAgfVxuICAgIGlmICghY2FsbGVlTm9kZS5hcmd1bWVudEJpdFJhdGlvcykge1xuICAgICAgY2FsbGVlTm9kZS5hcmd1bWVudEJpdFJhdGlvcyA9IG5ldyBBcnJheShjYWxsZWVOb2RlLmFyZ3VtZW50TmFtZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgY2FsbGVlQml0UmF0aW8gPSBjYWxsZWVOb2RlLmFyZ3VtZW50Qml0UmF0aW9zW2ldO1xuICAgIGlmICh0eXBlb2YgY2FsbGVlQml0UmF0aW8gPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoY2FsbGVlQml0UmF0aW8gIT09IGJpdFJhdGlvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wYXRpYmxlIGJpdCByYXRpbyBmb3VuZCBhdCBmdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0gYXQgYXJndW1lbnQgJHthcmd1bWVudE5hbWV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGVlQml0UmF0aW87XG4gICAgfVxuICAgIGNhbGxlZU5vZGUuYXJndW1lbnRCaXRSYXRpb3NbaV0gPSBiaXRSYXRpbztcbiAgICByZXR1cm4gYml0UmF0aW87XG4gIH1cblxuICB0cmFja0Z1bmN0aW9uQ2FsbChmdW5jdGlvbk5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSwgYXJncykge1xuICAgIGlmICghdGhpcy5mdW5jdGlvbk5vZGVEZXBlbmRlbmNpZXNbZnVuY3Rpb25OYW1lXSkge1xuICAgICAgdGhpcy5mdW5jdGlvbk5vZGVEZXBlbmRlbmNpZXNbZnVuY3Rpb25OYW1lXSA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuZnVuY3Rpb25DYWxsc1tmdW5jdGlvbk5hbWVdID0gW107XG4gICAgfVxuICAgIHRoaXMuZnVuY3Rpb25Ob2RlRGVwZW5kZW5jaWVzW2Z1bmN0aW9uTmFtZV0uYWRkKGNhbGxlZUZ1bmN0aW9uTmFtZSk7XG4gICAgdGhpcy5mdW5jdGlvbkNhbGxzW2Z1bmN0aW9uTmFtZV0ucHVzaChhcmdzKTtcbiAgfVxuXG4gIGdldEtlcm5lbFJlc3VsdFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdE5vZGUucmV0dXJuVHlwZSB8fCB0aGlzLnJvb3ROb2RlLmdldFR5cGUodGhpcy5yb290Tm9kZS5hc3QpO1xuICB9XG5cbiAgZ2V0U3ViS2VybmVsUmVzdWx0VHlwZShpbmRleCkge1xuICAgIGNvbnN0IHN1Yktlcm5lbE5vZGUgPSB0aGlzLnN1Yktlcm5lbE5vZGVzW2luZGV4XTtcbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgZnVuY3Rpb25DYWxsSW5kZXggPSAwOyBmdW5jdGlvbkNhbGxJbmRleCA8IHRoaXMucm9vdE5vZGUuZnVuY3Rpb25DYWxscy5sZW5ndGg7IGZ1bmN0aW9uQ2FsbEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IHRoaXMucm9vdE5vZGUuZnVuY3Rpb25DYWxsc1tmdW5jdGlvbkNhbGxJbmRleF07XG4gICAgICBpZiAoZnVuY3Rpb25DYWxsLmFzdC5jYWxsZWUubmFtZSA9PT0gc3ViS2VybmVsTm9kZS5uYW1lKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1Yktlcm5lbCAkeyBzdWJLZXJuZWxOb2RlLm5hbWUgfSBuZXZlciBjYWxsZWQgYnkga2VybmVsYCk7XG4gICAgfVxuICAgIHJldHVybiBzdWJLZXJuZWxOb2RlLnJldHVyblR5cGUgfHwgc3ViS2VybmVsTm9kZS5nZXRUeXBlKHN1Yktlcm5lbE5vZGUuZ2V0SnNBU1QoKSk7XG4gIH1cblxuICBnZXRSZXR1cm5UeXBlcygpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBbdGhpcy5yb290Tm9kZS5uYW1lXTogdGhpcy5yb290Tm9kZS5nZXRUeXBlKHRoaXMucm9vdE5vZGUuYXN0KSxcbiAgICB9O1xuICAgIGNvbnN0IGxpc3QgPSB0aGlzLnRyYWNlRnVuY3Rpb25DYWxscyh0aGlzLnJvb3ROb2RlLm5hbWUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gbGlzdFtpXTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTm9kZSA9IHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25OYW1lXTtcbiAgICAgIHJlc3VsdFtmdW5jdGlvbk5hbWVdID0gZnVuY3Rpb25Ob2RlLmdldFR5cGUoZnVuY3Rpb25Ob2RlLmFzdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEZ1bmN0aW9uQnVpbGRlclxufTtcbn0se31dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IGFjb3JuID0gcmVxdWlyZSgnYWNvcm4nKTtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCB7IEZ1bmN0aW9uVHJhY2VyIH0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uLXRyYWNlcicpO1xuXG5jbGFzcyBGdW5jdGlvbk5vZGUge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgaWYgKCFzb3VyY2UgJiYgIXNldHRpbmdzLmFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgcGFyYW1ldGVyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmFzdCA9IG51bGw7XG4gICAgdGhpcy5uYW1lID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBzZXR0aW5ncy5pc1Jvb3RLZXJuZWwgP1xuICAgICAgJ2tlcm5lbCcgOlxuICAgICAgKHNldHRpbmdzLm5hbWUgfHwgdXRpbHMuZ2V0RnVuY3Rpb25OYW1lRnJvbVN0cmluZyhzb3VyY2UpKSA6IG51bGw7XG4gICAgdGhpcy5jYWxsZWRGdW5jdGlvbnMgPSBbXTtcbiAgICB0aGlzLmNvbnN0YW50cyA9IHt9O1xuICAgIHRoaXMuY29uc3RhbnRUeXBlcyA9IHt9O1xuICAgIHRoaXMuY29uc3RhbnRCaXRSYXRpb3MgPSB7fTtcbiAgICB0aGlzLmlzUm9vdEtlcm5lbCA9IGZhbHNlO1xuICAgIHRoaXMuaXNTdWJLZXJuZWwgPSBmYWxzZTtcbiAgICB0aGlzLmRlYnVnID0gbnVsbDtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5pZGVudGlmaWVycyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0cyA9IG51bGw7XG4gICAgdGhpcy5mdW5jdGlvbkNhbGxzID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgIHRoaXMubmVlZHNBcmd1bWVudFR5cGUgPSBudWxsO1xuICAgIHRoaXMuYXNzaWduQXJndW1lbnRUeXBlID0gbnVsbDtcbiAgICB0aGlzLmxvb2t1cFJldHVyblR5cGUgPSBudWxsO1xuICAgIHRoaXMubG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzID0gbnVsbDtcbiAgICB0aGlzLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyA9IG51bGw7XG4gICAgdGhpcy50cmlnZ2VySW1wbHlBcmd1bWVudFR5cGUgPSBudWxsO1xuICAgIHRoaXMudHJpZ2dlckltcGx5QXJndW1lbnRCaXRSYXRpbyA9IG51bGw7XG4gICAgdGhpcy5vbk5lc3RlZEZ1bmN0aW9uID0gbnVsbDtcbiAgICB0aGlzLm9uRnVuY3Rpb25DYWxsID0gbnVsbDtcbiAgICB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkgPSBudWxsO1xuICAgIHRoaXMucHJlY2lzaW9uID0gbnVsbDtcbiAgICB0aGlzLmxvb3BNYXhJdGVyYXRpb25zID0gbnVsbDtcbiAgICB0aGlzLmFyZ3VtZW50TmFtZXMgPSAodHlwZW9mIHRoaXMuc291cmNlID09PSAnc3RyaW5nJyA/IHV0aWxzLmdldEFyZ3VtZW50TmFtZXNGcm9tU3RyaW5nKHRoaXMuc291cmNlKSA6IG51bGwpO1xuICAgIHRoaXMuYXJndW1lbnRUeXBlcyA9IFtdO1xuICAgIHRoaXMuYXJndW1lbnRTaXplcyA9IFtdO1xuICAgIHRoaXMuYXJndW1lbnRCaXRSYXRpb3MgPSBudWxsO1xuICAgIHRoaXMucmV0dXJuVHlwZSA9IG51bGw7XG4gICAgdGhpcy5vdXRwdXQgPSBbXTtcbiAgICB0aGlzLnBsdWdpbnMgPSBudWxsO1xuICAgIHRoaXMubGVhZGluZ1JldHVyblN0YXRlbWVudCA9IG51bGw7XG4gICAgdGhpcy5mb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY091dHB1dCA9IG51bGw7XG4gICAgdGhpcy5keW5hbWljQXJndW1lbnRzID0gbnVsbDtcbiAgICB0aGlzLnN0cmljdFR5cGluZ0NoZWNraW5nID0gZmFsc2U7XG4gICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IG51bGw7XG4gICAgdGhpcy5vbklzdGFuYnVsQ292ZXJhZ2VWYXJpYWJsZSA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVJc3RhbmJ1bENvdmVyYWdlID0gZmFsc2U7XG5cbiAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgIGZvciAoY29uc3QgcCBpbiBzZXR0aW5ncykge1xuICAgICAgICBpZiAoIXNldHRpbmdzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgICAgdGhpc1twXSA9IHNldHRpbmdzW3BdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGl0ZXJhbFR5cGVzID0ge307XG5cbiAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgdGhpcy5fc3RyaW5nID0gbnVsbDtcbiAgICB0aGlzLl9pbnRlcm5hbFZhcmlhYmxlTmFtZXMgPSB7fTtcbiAgfVxuXG4gIHZhbGlkYXRlKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UgIT09ICdzdHJpbmcnICYmICF0aGlzLmFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzLnNvdXJjZSBub3QgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYXN0ICYmICF1dGlscy5pc0Z1bmN0aW9uU3RyaW5nKHRoaXMuc291cmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzLnNvdXJjZSBub3QgYSBmdW5jdGlvbiBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzLm5hbWUgY291bGQgbm90IGJlIHNldCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoID4gMCAmJiB0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoICE9PSB0aGlzLmFyZ3VtZW50TmFtZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyZ3VtZW50VHlwZXMgY291bnQgb2YgJHsgdGhpcy5hcmd1bWVudFR5cGVzLmxlbmd0aCB9IGV4Y2VlZHMgJHsgdGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aCB9YCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3V0cHV0Lmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhpcy5vdXRwdXQgaXMgbm90IGJpZyBlbm91Z2gnKTtcbiAgICB9XG4gIH1cblxuICBpc0lkZW50aWZpZXJDb25zdGFudChuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0YW50cykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgfVxuXG4gIGlzSW5wdXQoYXJndW1lbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJndW1lbnRUeXBlc1t0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihhcmd1bWVudE5hbWUpXSA9PT0gJ0lucHV0JztcbiAgfVxuXG4gIHB1c2hTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGVzLnB1c2goc3RhdGUpO1xuICB9XG5cbiAgcG9wU3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBvcFN0YXRlICR7IHN0YXRlIH0gd2hlbiBpbiAkeyB0aGlzLnN0YXRlIH1gKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZXMucG9wKCk7XG4gIH1cblxuICBpc1N0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IHN0YXRlO1xuICB9XG5cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlc1t0aGlzLnN0YXRlcy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0KSB7XG4gICAgaWYgKGFzdC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHJldHVybiBhc3QubmFtZTtcbiAgICB9IGVsc2UgaWYgKGFzdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSB7XG4gICAgICByZXR1cm4gJ3RoaXMnO1xuICAgIH1cblxuICAgIGlmIChhc3QudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgICBpZiAoYXN0Lm9iamVjdCAmJiBhc3QucHJvcGVydHkpIHtcbiAgICAgICAgaWYgKGFzdC5vYmplY3QuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiBhc3Qub2JqZWN0Lm5hbWVbMF0gPT09ICdfJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0LnByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgdGhpcy5hc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKGFzdC5vYmplY3QpICtcbiAgICAgICAgICAnLicgK1xuICAgICAgICAgIHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChhc3QucHJvcGVydHkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFzdC5oYXNPd25Qcm9wZXJ0eSgnZXhwcmVzc2lvbnMnKSkge1xuICAgICAgY29uc3QgZmlyc3RFeHByZXNzaW9uID0gYXN0LmV4cHJlc3Npb25zWzBdO1xuICAgICAgaWYgKGZpcnN0RXhwcmVzc2lvbi50eXBlID09PSAnTGl0ZXJhbCcgJiYgZmlyc3RFeHByZXNzaW9uLnZhbHVlID09PSAwICYmIGFzdC5leHByZXNzaW9ucy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChhc3QuZXhwcmVzc2lvbnNbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1Vua25vd24gYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbCcsIGFzdCk7XG4gIH1cblxuICBnZXRKc0FTVChpblBhcnNlcikge1xuICAgIGlmICh0aGlzLmFzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXN0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuc291cmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy50cmFjZUZ1bmN0aW9uQVNUKHRoaXMuc291cmNlKTtcbiAgICAgIHJldHVybiB0aGlzLmFzdCA9IHRoaXMuc291cmNlO1xuICAgIH1cblxuICAgIGluUGFyc2VyID0gaW5QYXJzZXIgfHwgYWNvcm47XG4gICAgaWYgKGluUGFyc2VyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgSlMgdG8gQVNUIHBhcnNlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IGFzdCA9IE9iamVjdC5mcmVlemUoaW5QYXJzZXIucGFyc2UoYGNvbnN0IHBhcnNlcl8keyB0aGlzLm5hbWUgfSA9ICR7IHRoaXMuc291cmNlIH07YCwge1xuICAgICAgbG9jYXRpb25zOiB0cnVlXG4gICAgfSkpO1xuICAgIGNvbnN0IGZ1bmN0aW9uQVNUID0gYXN0LmJvZHlbMF0uZGVjbGFyYXRpb25zWzBdLmluaXQ7XG4gICAgdGhpcy50cmFjZUZ1bmN0aW9uQVNUKGZ1bmN0aW9uQVNUKTtcblxuICAgIGlmICghYXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBKUyBjb2RlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXN0ID0gZnVuY3Rpb25BU1Q7XG4gIH1cblxuICB0cmFjZUZ1bmN0aW9uQVNUKGFzdCkge1xuICAgIGNvbnN0IHsgY29udGV4dHMsIGRlY2xhcmF0aW9ucywgZnVuY3Rpb25zLCBpZGVudGlmaWVycywgZnVuY3Rpb25DYWxscyB9ID0gbmV3IEZ1bmN0aW9uVHJhY2VyKGFzdCk7XG4gICAgdGhpcy5jb250ZXh0cyA9IGNvbnRleHRzO1xuICAgIHRoaXMuaWRlbnRpZmllcnMgPSBpZGVudGlmaWVycztcbiAgICB0aGlzLmZ1bmN0aW9uQ2FsbHMgPSBmdW5jdGlvbkNhbGxzO1xuICAgIHRoaXMuZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uc1tpXTtcbiAgICAgIGNvbnN0IHsgYXN0LCBpbkZvckxvb3BJbml0LCBpbkZvckxvb3BUZXN0IH0gPSBkZWNsYXJhdGlvbjtcbiAgICAgIGNvbnN0IHsgaW5pdCB9ID0gYXN0O1xuICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gdGhpcy5nZXREZXBlbmRlbmNpZXMoaW5pdCk7XG4gICAgICBsZXQgdmFsdWVUeXBlID0gbnVsbDtcblxuICAgICAgaWYgKGluRm9yTG9vcEluaXQgJiYgaW5Gb3JMb29wVGVzdCkge1xuICAgICAgICB2YWx1ZVR5cGUgPSAnSW50ZWdlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgIGNvbnN0IHJlYWxUeXBlID0gdGhpcy5nZXRUeXBlKGluaXQpO1xuICAgICAgICAgIHN3aXRjaCAocmVhbFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICAgICAgaWYgKGluaXQudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gcmVhbFR5cGU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gJ051bWJlcic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgICAgIHZhbHVlVHlwZSA9ICdOdW1iZXInO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHZhbHVlVHlwZSA9IHJlYWxUeXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVjbGFyYXRpb24udmFsdWVUeXBlID0gdmFsdWVUeXBlO1xuICAgICAgZGVjbGFyYXRpb24uZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgZGVjbGFyYXRpb24uaXNTYWZlID0gdGhpcy5pc1NhZmVEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5vbk5lc3RlZEZ1bmN0aW9uKGZ1bmN0aW9uc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0RGVjbGFyYXRpb24oYXN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpZGVudGlmaWVyID0gdGhpcy5pZGVudGlmaWVyc1tpXTtcbiAgICAgIGlmIChhc3QgPT09IGlkZW50aWZpZXIuYXN0KSB7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyLmRlY2xhcmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldFZhcmlhYmxlVHlwZShhc3QpIHtcbiAgICBpZiAoYXN0LnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhc3Qgb2YgJHthc3QudHlwZX0gbm90IFwiSWRlbnRpZmllclwiYCk7XG4gICAgfVxuICAgIGxldCB0eXBlID0gbnVsbDtcbiAgICBjb25zdCBhcmd1bWVudEluZGV4ID0gdGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YoYXN0Lm5hbWUpO1xuICAgIGlmIChhcmd1bWVudEluZGV4ID09PSAtMSkge1xuICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLmdldERlY2xhcmF0aW9uKGFzdCk7XG4gICAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uLnZhbHVlVHlwZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYXJndW1lbnRUeXBlID0gdGhpcy5hcmd1bWVudFR5cGVzW2FyZ3VtZW50SW5kZXhdO1xuICAgICAgaWYgKGFyZ3VtZW50VHlwZSkge1xuICAgICAgICB0eXBlID0gYXJndW1lbnRUeXBlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUgJiYgdGhpcy5zdHJpY3RUeXBpbmdDaGVja2luZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWNsYXJhdGlvbiBvZiAke25hbWV9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGdldExvb2t1cFR5cGUodHlwZSkge1xuICAgIGlmICghdHlwZUxvb2t1cE1hcC5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGVMb29rdXBNYXAgJHsgdHlwZSB9YCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlTG9va3VwTWFwW3R5cGVdO1xuICB9XG5cbiAgZ2V0Q29uc3RhbnRUeXBlKGNvbnN0YW50TmFtZSkge1xuICAgIGlmICh0aGlzLmNvbnN0YW50VHlwZXNbY29uc3RhbnROYW1lXSkge1xuICAgICAgY29uc3QgdHlwZSA9IHRoaXMuY29uc3RhbnRUeXBlc1tjb25zdGFudE5hbWVdO1xuICAgICAgaWYgKHR5cGUgPT09ICdGbG9hdCcpIHtcbiAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVHlwZSBmb3IgY29uc3RhbnQgXCIkeyBjb25zdGFudE5hbWUgfVwiIG5vdCBkZWNsYXJlZGApO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMuX3N0cmluZykgcmV0dXJuIHRoaXMuX3N0cmluZztcbiAgICByZXR1cm4gdGhpcy5fc3RyaW5nID0gdGhpcy5hc3RHZW5lcmljKHRoaXMuZ2V0SnNBU1QoKSwgW10pLmpvaW4oJycpLnRyaW0oKTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBjb25zdGFudHM6IHRoaXMuY29uc3RhbnRzLFxuICAgICAgY29uc3RhbnRUeXBlczogdGhpcy5jb25zdGFudFR5cGVzLFxuICAgICAgaXNSb290S2VybmVsOiB0aGlzLmlzUm9vdEtlcm5lbCxcbiAgICAgIGlzU3ViS2VybmVsOiB0aGlzLmlzU3ViS2VybmVsLFxuICAgICAgZGVidWc6IHRoaXMuZGVidWcsXG4gICAgICBvdXRwdXQ6IHRoaXMub3V0cHV0LFxuICAgICAgbG9vcE1heEl0ZXJhdGlvbnM6IHRoaXMubG9vcE1heEl0ZXJhdGlvbnMsXG4gICAgICBhcmd1bWVudE5hbWVzOiB0aGlzLmFyZ3VtZW50TmFtZXMsXG4gICAgICBhcmd1bWVudFR5cGVzOiB0aGlzLmFyZ3VtZW50VHlwZXMsXG4gICAgICBhcmd1bWVudFNpemVzOiB0aGlzLmFyZ3VtZW50U2l6ZXMsXG4gICAgICByZXR1cm5UeXBlOiB0aGlzLnJldHVyblR5cGUsXG4gICAgICBsZWFkaW5nUmV0dXJuU3RhdGVtZW50OiB0aGlzLmxlYWRpbmdSZXR1cm5TdGF0ZW1lbnQsXG4gICAgICBmb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQ6IHRoaXMuZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50LFxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXN0OiB0aGlzLmFzdCxcbiAgICAgIHNldHRpbmdzXG4gICAgfTtcbiAgfVxuXG4gIGdldFR5cGUoYXN0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXN0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3RbYXN0Lmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gICAgc3dpdGNoIChhc3QudHlwZSkge1xuICAgICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGFzdC5ib2R5KTtcbiAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6XG4gICAgICAgIHJldHVybiBgQXJyYXkoJHsgYXN0LmVsZW1lbnRzLmxlbmd0aCB9KWA7XG4gICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgICAgY29uc3QgbGl0ZXJhbEtleSA9IHRoaXMuYXN0S2V5KGFzdCk7XG4gICAgICAgIGlmICh0aGlzLmxpdGVyYWxUeXBlc1tsaXRlcmFsS2V5XSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxpdGVyYWxUeXBlc1tsaXRlcmFsS2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihhc3QudmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuICdMaXRlcmFsSW50ZWdlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoYXN0LnZhbHVlID09PSB0cnVlIHx8IGFzdC52YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gJ0Jvb2xlYW4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QubGVmdCk7XG4gICAgICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzpcbiAgICAgICAgICBpZiAodGhpcy5pc0FzdE1hdGhGdW5jdGlvbihhc3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ051bWJlcic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYXN0LmNhbGxlZSB8fCAhYXN0LmNhbGxlZS5uYW1lKSB7XG4gICAgICAgICAgICBpZiAoYXN0LmNhbGxlZS50eXBlID09PSAnU2VxdWVuY2VFeHByZXNzaW9uJyAmJiBhc3QuY2FsbGVlLmV4cHJlc3Npb25zW2FzdC5jYWxsZWUuZXhwcmVzc2lvbnMubGVuZ3RoIC0gMV0ucHJvcGVydHkubmFtZSkge1xuICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBhc3QuY2FsbGVlLmV4cHJlc3Npb25zW2FzdC5jYWxsZWUuZXhwcmVzc2lvbnMubGVuZ3RoIC0gMV0ucHJvcGVydHkubmFtZTtcbiAgICAgICAgICAgICAgdGhpcy5pbmZlckFyZ3VtZW50VHlwZXNJZk5lZWRlZChmdW5jdGlvbk5hbWUsIGFzdC5hcmd1bWVudHMpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rdXBSZXR1cm5UeXBlKGZ1bmN0aW9uTmFtZSwgYXN0LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdldFZhcmlhYmxlU2lnbmF0dXJlKGFzdC5jYWxsZWUsIHRydWUpID09PSAndGhpcy5jb2xvcicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmtub3duIGNhbGwgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhc3QuY2FsbGVlICYmIGFzdC5jYWxsZWUubmFtZSkge1xuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYXN0LmNhbGxlZS5uYW1lO1xuICAgICAgICAgICAgdGhpcy5pbmZlckFyZ3VtZW50VHlwZXNJZk5lZWRlZChmdW5jdGlvbk5hbWUsIGFzdC5hcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwUmV0dXJuVHlwZShmdW5jdGlvbk5hbWUsIGFzdCwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBnZXRUeXBlIFR5cGUgXCIkeyBhc3QudHlwZSB9XCJgLCBhc3QpO1xuICAgICAgICBjYXNlICdMb2dpY2FsRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuICdCb29sZWFuJztcbiAgICAgICAgY2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0Jvb2xlYW4nO1xuICAgICAgICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgICAgICBjYXNlICc8PCc6XG4gICAgICAgICAgICAgIGNhc2UgJz4+JzpcbiAgICAgICAgICAgICAgY2FzZSAnPj4+JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0ludGVnZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGFzdC5sZWZ0KTtcbiAgICAgICAgICBpZiAodGhpcy5pc1N0YXRlKCdza2lwLWxpdGVyYWwtY29ycmVjdGlvbicpKSByZXR1cm4gdHlwZTtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuICAgICAgICAgICAgY29uc3QgcmlnaHRUeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5yaWdodCk7XG4gICAgICAgICAgICBpZiAocmlnaHRUeXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG4gICAgICAgICAgICAgIGlmIChhc3QubGVmdC52YWx1ZSAlIDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0ludGVnZXInO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnRmxvYXQnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmlnaHRUeXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZUxvb2t1cE1hcFt0eXBlXSB8fCB0eXBlO1xuICAgICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGFzdC5hcmd1bWVudCk7XG4gICAgICAgIGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgICAgaWYgKGFzdC5vcGVyYXRvciA9PT0gJ34nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ludGVnZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGFzdC5hcmd1bWVudCk7XG4gICAgICAgIGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nOiB7XG4gICAgICAgICAgY29uc3QgZGVjbGFyYXRpb25zID0gYXN0LmRlY2xhcmF0aW9ucztcbiAgICAgICAgICBsZXQgbGFzdFR5cGU7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNsYXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb25zW2ldO1xuICAgICAgICAgICAgbGFzdFR5cGUgPSB0aGlzLmdldFR5cGUoZGVjbGFyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWxhc3RUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmFibGUgdG8gZmluZCB0eXBlIGZvciBkZWNsYXJhdGlvbmAsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsYXN0VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0b3InOlxuICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdGhpcy5nZXREZWNsYXJhdGlvbihhc3QuaWQpO1xuICAgICAgICAgIGlmICghZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuYWJsZSB0byBmaW5kIGRlY2xhcmF0b3JgLCBhc3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZGVjbGFyYXRpb24udmFsdWVUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmFibGUgdG8gZmluZCBkZWNsYXJhdG9yIHZhbHVlVHlwZWAsIGFzdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uLnZhbHVlVHlwZTtcbiAgICAgICAgY2FzZSAnSWRlbnRpZmllcic6XG4gICAgICAgICAgaWYgKGFzdC5uYW1lID09PSAnSW5maW5pdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gJ051bWJlcic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmlzQXN0VmFyaWFibGUoYXN0KSkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy5nZXRWYXJpYWJsZVNpZ25hdHVyZShhc3QpO1xuICAgICAgICAgICAgaWYgKHNpZ25hdHVyZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDaGVja1ZhcmlhYmxlVHlwZShhc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmZpbmRJZGVudGlmaWVyT3JpZ2luKGFzdCk7XG4gICAgICAgICAgaWYgKG9yaWdpbiAmJiBvcmlnaW4uaW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShvcmlnaW4uaW5pdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdSZXR1cm5TdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmFyZ3VtZW50KTtcbiAgICAgICAgY2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6XG4gICAgICAgICAgaWYgKHRoaXMuaXNBc3RNYXRoRnVuY3Rpb24oYXN0KSkge1xuICAgICAgICAgICAgc3dpdGNoIChhc3QucHJvcGVydHkubmFtZSkge1xuICAgICAgICAgICAgICBjYXNlICdjZWlsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0ludGVnZXInO1xuICAgICAgICAgICAgICBjYXNlICdmbG9vcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICAgICAgY2FzZSAncm91bmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnSW50ZWdlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ051bWJlcic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmlzQXN0VmFyaWFibGUoYXN0KSkge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVTaWduYXR1cmUgPSB0aGlzLmdldFZhcmlhYmxlU2lnbmF0dXJlKGFzdCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHZhcmlhYmxlU2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlW10nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFR5cGUodGhpcy5nZXRDaGVja1ZhcmlhYmxlVHlwZShhc3Qub2JqZWN0KSk7XG4gICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlW11bXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENoZWNrVmFyaWFibGVUeXBlKGFzdC5vYmplY3Qub2JqZWN0KSk7XG4gICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlW11bXVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0KSk7XG4gICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlW11bXVtdW10nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFR5cGUodGhpcy5nZXRDaGVja1ZhcmlhYmxlVHlwZShhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0KSk7XG4gICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlLnRocmVhZC52YWx1ZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ3RoaXMudGhyZWFkLnZhbHVlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0ludGVnZXInO1xuICAgICAgICAgICAgICBjYXNlICd0aGlzLm91dHB1dC52YWx1ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHluYW1pY091dHB1dCA/ICdJbnRlZ2VyJyA6ICdMaXRlcmFsSW50ZWdlcic7XG4gICAgICAgICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25zdGFudFR5cGUoYXN0LnByb3BlcnR5Lm5hbWUpO1xuICAgICAgICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q29uc3RhbnRUeXBlKGFzdC5vYmplY3QucHJvcGVydHkubmFtZSkpO1xuICAgICAgICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW10nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFR5cGUodGhpcy5nZXRDb25zdGFudFR5cGUoYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHkubmFtZSkpO1xuICAgICAgICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENvbnN0YW50VHlwZShhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3QucHJvcGVydHkubmFtZSkpO1xuICAgICAgICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q29uc3RhbnRUeXBlKGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5vYmplY3QucHJvcGVydHkubmFtZSkpO1xuICAgICAgICAgICAgICBjYXNlICdmbigpW10nOlxuICAgICAgICAgICAgICBjYXNlICdmbigpW11bXSc6XG4gICAgICAgICAgICAgIGNhc2UgJ2ZuKClbXVtdW10nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFR5cGUodGhpcy5nZXRUeXBlKGFzdC5vYmplY3QpKTtcbiAgICAgICAgICAgICAgY2FzZSAndmFsdWUudmFsdWUnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQXN0TWF0aFZhcmlhYmxlKGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhc3QucHJvcGVydHkubmFtZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFR5cGUodGhpcy5nZXRDaGVja1ZhcmlhYmxlVHlwZShhc3Qub2JqZWN0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ1tdW10nOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5oYW5kbGVkIGdldFR5cGUgTWVtYmVyRXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuaGFuZGxlZCBnZXRUeXBlIE1lbWJlckV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICBjYXNlICdDb25kaXRpb25hbEV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmNvbnNlcXVlbnQpO1xuICAgICAgICBjYXNlICdGdW5jdGlvbkRlY2xhcmF0aW9uJzpcbiAgICAgICAgY2FzZSAnRnVuY3Rpb25FeHByZXNzaW9uJzpcbiAgICAgICAgICBjb25zdCBsYXN0UmV0dXJuID0gdGhpcy5maW5kTGFzdFJldHVybihhc3QuYm9keSk7XG4gICAgICAgICAgaWYgKGxhc3RSZXR1cm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUobGFzdFJldHVybik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdJZlN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuY29uc2VxdWVudCk7XG4gICAgICAgIGNhc2UgJ1NlcXVlbmNlRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuZXhwcmVzc2lvbnNbYXN0LmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgZ2V0VHlwZSBUeXBlIFwiJHsgYXN0LnR5cGUgfVwiYCwgYXN0KTtcbiAgICB9XG4gIH1cblxuICBnZXRDaGVja1ZhcmlhYmxlVHlwZShhc3QpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRWYXJpYWJsZVR5cGUoYXN0KTtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYCR7YXN0LnR5cGV9IGlzIG5vdCBkZWZpbmVkYCwgYXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBpbmZlckFyZ3VtZW50VHlwZXNJZk5lZWRlZChmdW5jdGlvbk5hbWUsIGFyZ3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5uZWVkc0FyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGkpKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoYXJnc1tpXSk7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5hYmxlIHRvIGluZmVyIGFyZ3VtZW50ICR7aX1gLCBhcmdzW2ldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXNzaWduQXJndW1lbnRUeXBlKGZ1bmN0aW9uTmFtZSwgaSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaXNBc3RNYXRoVmFyaWFibGUoYXN0KSB7XG4gICAgY29uc3QgbWF0aFByb3BlcnRpZXMgPSBbXG4gICAgICAnRScsXG4gICAgICAnUEknLFxuICAgICAgJ1NRUlQyJyxcbiAgICAgICdTUVJUMV8yJyxcbiAgICAgICdMTjInLFxuICAgICAgJ0xOMTAnLFxuICAgICAgJ0xPRzJFJyxcbiAgICAgICdMT0cxMEUnLFxuICAgIF07XG4gICAgcmV0dXJuIGFzdC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgJiZcbiAgICAgIGFzdC5vYmplY3QgJiYgYXN0Lm9iamVjdC50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgIGFzdC5vYmplY3QubmFtZSA9PT0gJ01hdGgnICYmXG4gICAgICBhc3QucHJvcGVydHkgJiZcbiAgICAgIGFzdC5wcm9wZXJ0eS50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgIG1hdGhQcm9wZXJ0aWVzLmluZGV4T2YoYXN0LnByb3BlcnR5Lm5hbWUpID4gLTE7XG4gIH1cblxuICBpc0FzdE1hdGhGdW5jdGlvbihhc3QpIHtcbiAgICBjb25zdCBtYXRoRnVuY3Rpb25zID0gW1xuICAgICAgJ2FicycsXG4gICAgICAnYWNvcycsXG4gICAgICAnYWNvc2gnLFxuICAgICAgJ2FzaW4nLFxuICAgICAgJ2FzaW5oJyxcbiAgICAgICdhdGFuJyxcbiAgICAgICdhdGFuMicsXG4gICAgICAnYXRhbmgnLFxuICAgICAgJ2NicnQnLFxuICAgICAgJ2NlaWwnLFxuICAgICAgJ2NsejMyJyxcbiAgICAgICdjb3MnLFxuICAgICAgJ2Nvc2gnLFxuICAgICAgJ2V4cG0xJyxcbiAgICAgICdleHAnLFxuICAgICAgJ2Zsb29yJyxcbiAgICAgICdmcm91bmQnLFxuICAgICAgJ2ltdWwnLFxuICAgICAgJ2xvZycsXG4gICAgICAnbG9nMicsXG4gICAgICAnbG9nMTAnLFxuICAgICAgJ2xvZzFwJyxcbiAgICAgICdtYXgnLFxuICAgICAgJ21pbicsXG4gICAgICAncG93JyxcbiAgICAgICdyYW5kb20nLFxuICAgICAgJ3JvdW5kJyxcbiAgICAgICdzaWduJyxcbiAgICAgICdzaW4nLFxuICAgICAgJ3NpbmgnLFxuICAgICAgJ3NxcnQnLFxuICAgICAgJ3RhbicsXG4gICAgICAndGFuaCcsXG4gICAgICAndHJ1bmMnLFxuICAgIF07XG4gICAgcmV0dXJuIGFzdC50eXBlID09PSAnQ2FsbEV4cHJlc3Npb24nICYmXG4gICAgICBhc3QuY2FsbGVlICYmXG4gICAgICBhc3QuY2FsbGVlLnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyAmJlxuICAgICAgYXN0LmNhbGxlZS5vYmplY3QgJiZcbiAgICAgIGFzdC5jYWxsZWUub2JqZWN0LnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJlxuICAgICAgYXN0LmNhbGxlZS5vYmplY3QubmFtZSA9PT0gJ01hdGgnICYmXG4gICAgICBhc3QuY2FsbGVlLnByb3BlcnR5ICYmXG4gICAgICBhc3QuY2FsbGVlLnByb3BlcnR5LnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJlxuICAgICAgbWF0aEZ1bmN0aW9ucy5pbmRleE9mKGFzdC5jYWxsZWUucHJvcGVydHkubmFtZSkgPiAtMTtcbiAgfVxuXG4gIGlzQXN0VmFyaWFibGUoYXN0KSB7XG4gICAgcmV0dXJuIGFzdC50eXBlID09PSAnSWRlbnRpZmllcicgfHwgYXN0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJztcbiAgfVxuXG4gIGlzU2FmZShhc3QpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NhZmVEZXBlbmRlbmNpZXModGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0KSk7XG4gIH1cblxuICBpc1NhZmVEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKSB7XG4gICAgcmV0dXJuIGRlcGVuZGVuY2llcyAmJiBkZXBlbmRlbmNpZXMuZXZlcnkgPyBkZXBlbmRlbmNpZXMuZXZlcnkoZGVwZW5kZW5jeSA9PiBkZXBlbmRlbmN5LmlzU2FmZSkgOiB0cnVlO1xuICB9XG5cbiAgZ2V0RGVwZW5kZW5jaWVzKGFzdCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpIHtcbiAgICBpZiAoIWRlcGVuZGVuY2llcykge1xuICAgICAgZGVwZW5kZW5jaWVzID0gW107XG4gICAgfVxuICAgIGlmICghYXN0KSByZXR1cm4gbnVsbDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhc3QpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3RbaV0sIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gICAgfVxuICAgIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmxlZnQsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LnJpZ2h0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gICAgICBjYXNlICdDb25kaXRpb25hbEV4cHJlc3Npb24nOlxuICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QudGVzdCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QuYWx0ZXJuYXRlLCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5jb25zZXF1ZW50LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goe1xuICAgICAgICAgIG9yaWdpbjogJ2xpdGVyYWwnLFxuICAgICAgICAgIHZhbHVlOiBhc3QudmFsdWUsXG4gICAgICAgICAgaXNTYWZlOiBpc05vdFNhZmUgPT09IHRydWUgPyBmYWxzZSA6IGFzdC52YWx1ZSA+IC1JbmZpbml0eSAmJiBhc3QudmFsdWUgPCBJbmZpbml0eSAmJiAhaXNOYU4oYXN0LnZhbHVlKVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0b3InOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmluaXQsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgIGNhc2UgJ0lkZW50aWZpZXInOlxuICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHRoaXMuZ2V0RGVjbGFyYXRpb24oYXN0KTtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogYXN0Lm5hbWUsXG4gICAgICAgICAgICBvcmlnaW46ICdkZWNsYXJhdGlvbicsXG4gICAgICAgICAgICBpc1NhZmU6IGlzTm90U2FmZSA/IGZhbHNlIDogdGhpcy5pc1NhZmVEZXBlbmRlbmNpZXMoZGVjbGFyYXRpb24uZGVwZW5kZW5jaWVzKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihhc3QubmFtZSkgPiAtMSkge1xuICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGFzdC5uYW1lLFxuICAgICAgICAgICAgb3JpZ2luOiAnYXJndW1lbnQnLFxuICAgICAgICAgICAgaXNTYWZlOiBmYWxzZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0cmljdFR5cGluZ0NoZWNraW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBpZGVudGlmaWVyIG9yaWdpbiBcIiR7YXN0Lm5hbWV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Z1bmN0aW9uRGVjbGFyYXRpb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmJvZHkuYm9keVthc3QuYm9keS5ib2R5Lmxlbmd0aCAtIDFdLCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICBjYXNlICdSZXR1cm5TdGF0ZW1lbnQnOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmFyZ3VtZW50LCBkZXBlbmRlbmNpZXMpO1xuICAgICAgY2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6XG4gICAgICBjYXNlICdMb2dpY2FsRXhwcmVzc2lvbic6XG4gICAgICAgIGlzTm90U2FmZSA9IChhc3Qub3BlcmF0b3IgPT09ICcvJyB8fCBhc3Qub3BlcmF0b3IgPT09ICcqJyk7XG4gICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5sZWZ0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5yaWdodCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgICAgY2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmFyZ3VtZW50LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5kZWNsYXJhdGlvbnMsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6XG4gICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICBvcmlnaW46ICdkZWNsYXJhdGlvbicsXG4gICAgICAgICAgaXNTYWZlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzpcbiAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goe1xuICAgICAgICAgIG9yaWdpbjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICBpc1NhZmU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgICAgY2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSB0aGlzLmdldE1lbWJlckV4cHJlc3Npb25EZXRhaWxzKGFzdCk7XG4gICAgICAgIHN3aXRjaCAoZGV0YWlscy5zaWduYXR1cmUpIHtcbiAgICAgICAgICBjYXNlICd2YWx1ZVtdJzpcbiAgICAgICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5vYmplY3QsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3ZhbHVlW11bXSc6XG4gICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3Qub2JqZWN0Lm9iamVjdCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmFsdWVbXVtdW10nOlxuICAgICAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0aGlzLm91dHB1dC52YWx1ZSc6XG4gICAgICAgICAgICBpZiAodGhpcy5keW5hbWljT3V0cHV0KSB7XG4gICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBkZXRhaWxzLm5hbWUsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiAnb3V0cHV0JyxcbiAgICAgICAgICAgICAgICBpc1NhZmU6IGZhbHNlLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICAgICAgaWYgKGRldGFpbHMucHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGRldGFpbHMucHJvcGVydHksIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRldGFpbHMueFByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhkZXRhaWxzLnhQcm9wZXJ0eSwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGV0YWlscy55UHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGRldGFpbHMueVByb3BlcnR5LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZXRhaWxzLnpQcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoZGV0YWlscy56UHJvcGVydHksIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdTZXF1ZW5jZUV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QuZXhwcmVzc2lvbnMsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgdHlwZSAkeyBhc3QudHlwZSB9IGluIGdldERlcGVuZGVuY2llc2AsIGFzdCk7XG4gICAgfVxuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cblxuICBnZXRWYXJpYWJsZVNpZ25hdHVyZShhc3QsIHJldHVyblJhd1ZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmlzQXN0VmFyaWFibGUoYXN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhc3Qgb2YgdHlwZSBcIiR7IGFzdC50eXBlIH1cIiBpcyBub3QgYSB2YXJpYWJsZSBzaWduYXR1cmVgKTtcbiAgICB9XG4gICAgaWYgKGFzdC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHJldHVybiAndmFsdWUnO1xuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSBbXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKCFhc3QpIGJyZWFrO1xuICAgICAgaWYgKGFzdC5jb21wdXRlZCkge1xuICAgICAgICBzaWduYXR1cmUucHVzaCgnW10nKTtcbiAgICAgIH0gZWxzZSBpZiAoYXN0LnR5cGUgPT09ICdUaGlzRXhwcmVzc2lvbicpIHtcbiAgICAgICAgc2lnbmF0dXJlLnVuc2hpZnQoJ3RoaXMnKTtcbiAgICAgIH0gZWxzZSBpZiAoYXN0LnByb3BlcnR5ICYmIGFzdC5wcm9wZXJ0eS5uYW1lKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBhc3QucHJvcGVydHkubmFtZSA9PT0gJ3gnIHx8XG4gICAgICAgICAgYXN0LnByb3BlcnR5Lm5hbWUgPT09ICd5JyB8fFxuICAgICAgICAgIGFzdC5wcm9wZXJ0eS5uYW1lID09PSAneidcbiAgICAgICAgKSB7XG4gICAgICAgICAgc2lnbmF0dXJlLnVuc2hpZnQocmV0dXJuUmF3VmFsdWUgPyAnLicgKyBhc3QucHJvcGVydHkubmFtZSA6ICcudmFsdWUnKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBhc3QucHJvcGVydHkubmFtZSA9PT0gJ2NvbnN0YW50cycgfHxcbiAgICAgICAgICBhc3QucHJvcGVydHkubmFtZSA9PT0gJ3RocmVhZCcgfHxcbiAgICAgICAgICBhc3QucHJvcGVydHkubmFtZSA9PT0gJ291dHB1dCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgc2lnbmF0dXJlLnVuc2hpZnQoJy4nICsgYXN0LnByb3BlcnR5Lm5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KHJldHVyblJhd1ZhbHVlID8gJy4nICsgYXN0LnByb3BlcnR5Lm5hbWUgOiAnLnZhbHVlJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXN0Lm5hbWUpIHtcbiAgICAgICAgc2lnbmF0dXJlLnVuc2hpZnQocmV0dXJuUmF3VmFsdWUgPyBhc3QubmFtZSA6ICd2YWx1ZScpO1xuICAgICAgfSBlbHNlIGlmIChhc3QuY2FsbGVlICYmIGFzdC5jYWxsZWUubmFtZSkge1xuICAgICAgICBzaWduYXR1cmUudW5zaGlmdChyZXR1cm5SYXdWYWx1ZSA/IGFzdC5jYWxsZWUubmFtZSArICcoKScgOiAnZm4oKScpO1xuICAgICAgfSBlbHNlIGlmIChhc3QuZWxlbWVudHMpIHtcbiAgICAgICAgc2lnbmF0dXJlLnVuc2hpZnQoJ1tdJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWduYXR1cmUudW5zaGlmdCgndW5rbm93bicpO1xuICAgICAgfVxuICAgICAgYXN0ID0gYXN0Lm9iamVjdDtcbiAgICB9XG5cbiAgICBjb25zdCBzaWduYXR1cmVTdHJpbmcgPSBzaWduYXR1cmUuam9pbignJyk7XG4gICAgaWYgKHJldHVyblJhd1ZhbHVlKSB7XG4gICAgICByZXR1cm4gc2lnbmF0dXJlU3RyaW5nO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbG93ZWRFeHByZXNzaW9ucyA9IFtcbiAgICAgICd2YWx1ZScsXG4gICAgICAndmFsdWVbXScsXG4gICAgICAndmFsdWVbXVtdJyxcbiAgICAgICd2YWx1ZVtdW11bXScsXG4gICAgICAndmFsdWVbXVtdW11bXScsXG4gICAgICAndmFsdWUudmFsdWUnLFxuICAgICAgJ3ZhbHVlLnZhbHVlW10nLCBcbiAgICAgICd2YWx1ZS52YWx1ZVtdW10nLCBcbiAgICAgICd2YWx1ZS50aHJlYWQudmFsdWUnLFxuICAgICAgJ3RoaXMudGhyZWFkLnZhbHVlJyxcbiAgICAgICd0aGlzLm91dHB1dC52YWx1ZScsXG4gICAgICAndGhpcy5jb25zdGFudHMudmFsdWUnLFxuICAgICAgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW10nLFxuICAgICAgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXScsXG4gICAgICAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW10nLFxuICAgICAgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdW10nLFxuICAgICAgJ2ZuKClbXScsXG4gICAgICAnZm4oKVtdW10nLFxuICAgICAgJ2ZuKClbXVtdW10nLFxuICAgICAgJ1tdW10nLFxuICAgIF07XG4gICAgaWYgKGFsbG93ZWRFeHByZXNzaW9ucy5pbmRleE9mKHNpZ25hdHVyZVN0cmluZykgPiAtMSkge1xuICAgICAgcmV0dXJuIHNpZ25hdHVyZVN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBidWlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpLmxlbmd0aCA+IDA7XG4gIH1cblxuICBhc3RHZW5lcmljKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKGFzdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnTlVMTCBhc3QnLCBhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhc3QpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdFtpXSwgcmV0QXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0Z1bmN0aW9uRGVjbGFyYXRpb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEZ1bmN0aW9uRGVjbGFyYXRpb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdGdW5jdGlvbkV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEZ1bmN0aW9uRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0UmV0dXJuU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0TGl0ZXJhbChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEJpbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdJZGVudGlmaWVyJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RJZGVudGlmaWVyRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RBc3NpZ25tZW50RXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEV4cHJlc3Npb25TdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdFbXB0eVN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0RW1wdHlTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdCbG9ja1N0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0QmxvY2tTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdJZlN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0SWZTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdTd2l0Y2hTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFN3aXRjaFN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0JyZWFrU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RCcmVha1N0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0NvbnRpbnVlU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RDb250aW51ZVN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0Rm9yU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFdoaWxlU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnRG9XaGlsZVN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0RG9XaGlsZVN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFZhcmlhYmxlRGVjbGFyYXRpb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0b3InOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFZhcmlhYmxlRGVjbGFyYXRvcihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1RoaXNFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RUaGlzRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1NlcXVlbmNlRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0U2VxdWVuY2VFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RVbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RVcGRhdGVFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnTG9naWNhbEV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdExvZ2ljYWxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RDYWxsRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0QXJyYXlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnRGVidWdnZXJTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdERlYnVnZ2VyU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RDb25kaXRpb25hbEV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmtub3duIGFzdCB0eXBlIDogJyArIGFzdC50eXBlLCBhc3QpO1xuICAgIH1cbiAgfVxuICBhc3RFcnJvck91dHB1dChlcnJvciwgYXN0KSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlYnVnU3RyaW5nID0gdXRpbHMuZ2V0QXN0U3RyaW5nKHRoaXMuc291cmNlLCBhc3QpO1xuICAgIGNvbnN0IGxlYWRpbmdTb3VyY2UgPSB0aGlzLnNvdXJjZS5zdWJzdHIoYXN0LnN0YXJ0KTtcbiAgICBjb25zdCBzcGxpdExpbmVzID0gbGVhZGluZ1NvdXJjZS5zcGxpdCgvXFxuLyk7XG4gICAgY29uc3QgbGluZUJlZm9yZSA9IHNwbGl0TGluZXMubGVuZ3RoID4gMCA/IHNwbGl0TGluZXNbc3BsaXRMaW5lcy5sZW5ndGggLSAxXSA6IDA7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgJHtlcnJvcn0gb24gbGluZSAkeyBzcGxpdExpbmVzLmxlbmd0aCB9LCBwb3NpdGlvbiAkeyBsaW5lQmVmb3JlLmxlbmd0aCB9OlxcbiAkeyBkZWJ1Z1N0cmluZyB9YCk7XG4gIH1cblxuICBhc3REZWJ1Z2dlclN0YXRlbWVudChhcnJOb2RlLCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0Q29uZGl0aW9uYWxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnTm90IGEgY29uZGl0aW9uYWwgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcoJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCc/Jyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCc6Jyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0RnVuY3Rpb24oYXN0LCByZXRBcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiYXN0RnVuY3Rpb25cIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgYXN0RnVuY3Rpb25EZWNsYXJhdGlvbihhc3QsIHJldEFycikge1xuICAgIGlmICh0aGlzLmlzQ2hpbGRGdW5jdGlvbihhc3QpKSB7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hc3RGdW5jdGlvbihhc3QsIHJldEFycik7XG4gIH1cbiAgYXN0RnVuY3Rpb25FeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKHRoaXMuaXNDaGlsZEZ1bmN0aW9uKGFzdCkpIHtcbiAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFzdEZ1bmN0aW9uKGFzdCwgcmV0QXJyKTtcbiAgfVxuICBpc0NoaWxkRnVuY3Rpb24oYXN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZnVuY3Rpb25zW2ldID09PSBhc3QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3RSZXR1cm5TdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdExpdGVyYWwoYXN0LCByZXRBcnIpIHtcbiAgICB0aGlzLmxpdGVyYWxUeXBlc1t0aGlzLmFzdEtleShhc3QpXSA9ICdOdW1iZXInO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0QmluYXJ5RXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0SWRlbnRpZmllckV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdEFzc2lnbm1lbnRFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RFeHByZXNzaW9uU3RhdGVtZW50KGVzTm9kZSwgcmV0QXJyKSB7XG4gICAgdGhpcy5hc3RHZW5lcmljKGVzTm9kZS5leHByZXNzaW9uLCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCc7Jyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RFbXB0eVN0YXRlbWVudChlTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RCbG9ja1N0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0SWZTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdFN3aXRjaFN0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0QnJlYWtTdGF0ZW1lbnQoYnJOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnYnJlYWs7Jyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RDb250aW51ZVN0YXRlbWVudChjck5vZGUsIHJldEFycikge1xuICAgIHJldEFyci5wdXNoKCdjb250aW51ZTtcXG4nKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdEZvclN0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0V2hpbGVTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdERvV2hpbGVTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdFZhcmlhYmxlRGVjbGFyYXRvcihpVmFyRGVjTm9kZSwgcmV0QXJyKSB7XG4gICAgdGhpcy5hc3RHZW5lcmljKGlWYXJEZWNOb2RlLmlkLCByZXRBcnIpO1xuICAgIGlmIChpVmFyRGVjTm9kZS5pbml0ICE9PSBudWxsKSB7XG4gICAgICByZXRBcnIucHVzaCgnPScpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGlWYXJEZWNOb2RlLmluaXQsIHJldEFycik7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0VGhpc0V4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGlzSXN0YW5idWxBU1QoYXN0KSB7XG4gICAgY29uc3QgdmFyaWFibGVTaWduYXR1cmUgPSB0aGlzLmdldFZhcmlhYmxlU2lnbmF0dXJlKGFzdCk7XG4gICAgcmV0dXJuIHZhcmlhYmxlU2lnbmF0dXJlID09PSAndmFsdWUudmFsdWVbXScgfHwgdmFyaWFibGVTaWduYXR1cmUgPT09ICd2YWx1ZS52YWx1ZVtdW10nO1xuICB9XG4gIGFzdFNlcXVlbmNlRXhwcmVzc2lvbihzTm9kZSwgcmV0QXJyKSB7XG4gICAgY29uc3QgeyBleHByZXNzaW9ucyB9ID0gc05vZGU7XG4gICAgY29uc3Qgc2VxdWVuY2VSZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gZXhwcmVzc2lvbnNbaV07XG4gICAgICBpZiAodGhpcy5yZW1vdmVJc3RhbmJ1bENvdmVyYWdlKSB7XG4gICAgICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09ICdVcGRhdGVFeHByZXNzaW9uJyAmJiB0aGlzLmlzSXN0YW5idWxBU1QoZXhwcmVzc2lvbi5hcmd1bWVudCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZXhwcmVzc2lvblJlc3VsdCA9IFtdO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGV4cHJlc3Npb24sIGV4cHJlc3Npb25SZXN1bHQpO1xuICAgICAgc2VxdWVuY2VSZXN1bHQucHVzaChleHByZXNzaW9uUmVzdWx0LmpvaW4oJycpKTtcbiAgICB9XG4gICAgaWYgKHNlcXVlbmNlUmVzdWx0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldEFyci5wdXNoKCcoJywgc2VxdWVuY2VSZXN1bHQuam9pbignLCcpLCAnKScpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaChzZXF1ZW5jZVJlc3VsdFswXSk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0VW5hcnlFeHByZXNzaW9uKHVOb2RlLCByZXRBcnIpIHtcbiAgICBjb25zdCB1bmFyeVJlc3VsdCA9IHRoaXMuY2hlY2tBbmRVcGNvbnZlcnRCaXR3aXNlVW5hcnkodU5vZGUsIHJldEFycik7XG4gICAgaWYgKHVuYXJ5UmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cblxuICAgIGlmICh1Tm9kZS5wcmVmaXgpIHtcbiAgICAgIHJldEFyci5wdXNoKHVOb2RlLm9wZXJhdG9yKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyh1Tm9kZS5hcmd1bWVudCwgcmV0QXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKHVOb2RlLmFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2godU5vZGUub3BlcmF0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjaGVja0FuZFVwY29udmVydEJpdHdpc2VVbmFyeSh1Tm9kZSwgcmV0QXJyKSB7fVxuXG4gIGFzdFVwZGF0ZUV4cHJlc3Npb24odU5vZGUsIHJldEFycikge1xuICAgIGlmICh0aGlzLnJlbW92ZUlzdGFuYnVsQ292ZXJhZ2UpIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuZ2V0VmFyaWFibGVTaWduYXR1cmUodU5vZGUuYXJndW1lbnQpO1xuICAgICAgaWYgKHRoaXMuaXNJc3RhbmJ1bEFTVCh1Tm9kZS5hcmd1bWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVOb2RlLnByZWZpeCkge1xuICAgICAgcmV0QXJyLnB1c2godU5vZGUub3BlcmF0b3IpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKHVOb2RlLmFyZ3VtZW50LCByZXRBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWModU5vZGUuYXJndW1lbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCh1Tm9kZS5vcGVyYXRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RMb2dpY2FsRXhwcmVzc2lvbihsb2dOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhsb2dOb2RlLmxlZnQsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2gobG9nTm9kZS5vcGVyYXRvcik7XG4gICAgdGhpcy5hc3RHZW5lcmljKGxvZ05vZGUucmlnaHQsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdE1lbWJlckV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdENhbGxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RBcnJheUV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgZ2V0TWVtYmVyRXhwcmVzc2lvbkRldGFpbHMoYXN0KSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYEV4cHJlc3Npb24gJHsgYXN0LnR5cGUgfSBub3QgYSBNZW1iZXJFeHByZXNzaW9uYCwgYXN0KTtcbiAgICB9XG4gICAgbGV0IG5hbWUgPSBudWxsO1xuICAgIGxldCB0eXBlID0gbnVsbDtcbiAgICBjb25zdCB2YXJpYWJsZVNpZ25hdHVyZSA9IHRoaXMuZ2V0VmFyaWFibGVTaWduYXR1cmUoYXN0KTtcbiAgICBzd2l0Y2ggKHZhcmlhYmxlU2lnbmF0dXJlKSB7XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSAndmFsdWUudGhyZWFkLnZhbHVlJzpcbiAgICAgIGNhc2UgJ3RoaXMudGhyZWFkLnZhbHVlJzpcbiAgICAgIGNhc2UgJ3RoaXMub3V0cHV0LnZhbHVlJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgICAgdHlwZTogJ0ludGVnZXInLFxuICAgICAgICAgICAgbmFtZTogYXN0LnByb3BlcnR5Lm5hbWVcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3ZhbHVlW10nOlxuICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3QubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBhc3Qub2JqZWN0Lm5hbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBvcmlnaW46ICd1c2VyJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLmdldFZhcmlhYmxlVHlwZShhc3Qub2JqZWN0KSxcbiAgICAgICAgICAgIHhQcm9wZXJ0eTogYXN0LnByb3BlcnR5XG4gICAgICAgIH07XG4gICAgICBjYXNlICd2YWx1ZVtdW10nOlxuICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3Qub2JqZWN0Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5vYmplY3QubmFtZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIG9yaWdpbjogJ3VzZXInLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0VmFyaWFibGVUeXBlKGFzdC5vYmplY3Qub2JqZWN0KSxcbiAgICAgICAgICAgIHlQcm9wZXJ0eTogYXN0Lm9iamVjdC5wcm9wZXJ0eSxcbiAgICAgICAgICAgIHhQcm9wZXJ0eTogYXN0LnByb3BlcnR5LFxuICAgICAgICB9O1xuICAgICAgY2FzZSAndmFsdWVbXVtdW10nOlxuICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5uYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgb3JpZ2luOiAndXNlcicsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0KSxcbiAgICAgICAgICAgIHpQcm9wZXJ0eTogYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3ZhbHVlW11bXVtdW10nOlxuICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5vYmplY3QubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm5hbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBvcmlnaW46ICd1c2VyJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLmdldFZhcmlhYmxlVHlwZShhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0KSxcbiAgICAgICAgICAgIHpQcm9wZXJ0eTogYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3ZhbHVlLnZhbHVlJzpcbiAgICAgICAgaWYgKHR5cGVvZiBhc3QucHJvcGVydHkubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQXN0TWF0aFZhcmlhYmxlKGFzdCkpIHtcbiAgICAgICAgICBuYW1lID0gYXN0LnByb3BlcnR5Lm5hbWU7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBvcmlnaW46ICdNYXRoJyxcbiAgICAgICAgICAgIHR5cGU6ICdOdW1iZXInLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYXN0LnByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIG5hbWUgPSBhc3Qub2JqZWN0Lm5hbWU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBwcm9wZXJ0eTogYXN0LnByb3BlcnR5Lm5hbWUsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiAndXNlcicsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnTnVtYmVyJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZSc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBhc3QucHJvcGVydHkubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5hbWUgPSBhc3QucHJvcGVydHkubmFtZTtcbiAgICAgICAgICB0eXBlID0gdGhpcy5nZXRDb25zdGFudFR5cGUobmFtZSk7XG4gICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdDb25zdGFudCBoYXMgbm8gdHlwZScsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG9yaWdpbjogJ2NvbnN0YW50cycsXG4gICAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXSc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBhc3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgIHR5cGUgPSB0aGlzLmdldENvbnN0YW50VHlwZShuYW1lKTtcbiAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0NvbnN0YW50IGhhcyBubyB0eXBlJywgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb3JpZ2luOiAnY29uc3RhbnRzJyxcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgeFByb3BlcnR5OiBhc3QucHJvcGVydHksXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdJzoge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHkubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5hbWUgPSBhc3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgIHR5cGUgPSB0aGlzLmdldENvbnN0YW50VHlwZShuYW1lKTtcbiAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0NvbnN0YW50IGhhcyBubyB0eXBlJywgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb3JpZ2luOiAnY29uc3RhbnRzJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICB5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdJzoge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWU7XG4gICAgICAgICAgdHlwZSA9IHRoaXMuZ2V0Q29uc3RhbnRUeXBlKG5hbWUpO1xuICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnQ29uc3RhbnQgaGFzIG5vIHR5cGUnLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBvcmlnaW46ICdjb25zdGFudHMnLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgIHpQcm9wZXJ0eTogYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2ZuKClbXSc6XG4gICAgICAgIGNhc2UgJ1tdW10nOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgICAgICBwcm9wZXJ0eTogYXN0LnByb3BlcnR5LFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ3ZhbHVlLnZhbHVlW10nOiBcbiAgICAgICAgICBpZiAodGhpcy5yZW1vdmVJc3RhbmJ1bENvdmVyYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlKGFzdC5vYmplY3Qub2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAndmFsdWUudmFsdWVbXVtdJzogXG4gICAgICAgICAgICBpZiAodGhpcy5yZW1vdmVJc3RhbmJ1bENvdmVyYWdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgIHRoaXMub25Jc3RhbmJ1bENvdmVyYWdlVmFyaWFibGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgfVxuICB9XG5cbiAgZmluZElkZW50aWZpZXJPcmlnaW4oYXN0VG9GaW5kKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBbdGhpcy5hc3RdO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGF0Tm9kZSA9IHN0YWNrWzBdO1xuICAgICAgaWYgKGF0Tm9kZS50eXBlID09PSAnVmFyaWFibGVEZWNsYXJhdG9yJyAmJiBhdE5vZGUuaWQgJiYgYXROb2RlLmlkLm5hbWUgJiYgYXROb2RlLmlkLm5hbWUgPT09IGFzdFRvRmluZC5uYW1lKSB7XG4gICAgICAgIHJldHVybiBhdE5vZGU7XG4gICAgICB9XG4gICAgICBzdGFjay5zaGlmdCgpO1xuICAgICAgaWYgKGF0Tm9kZS5hcmd1bWVudCkge1xuICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZS5hcmd1bWVudCk7XG4gICAgICB9IGVsc2UgaWYgKGF0Tm9kZS5ib2R5KSB7XG4gICAgICAgIHN0YWNrLnB1c2goYXROb2RlLmJvZHkpO1xuICAgICAgfSBlbHNlIGlmIChhdE5vZGUuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgIHN0YWNrLnB1c2goYXROb2RlLmRlY2xhcmF0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXROb2RlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0Tm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN0YWNrLnB1c2goYXROb2RlW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZpbmRMYXN0UmV0dXJuKGFzdCkge1xuICAgIGNvbnN0IHN0YWNrID0gW2FzdCB8fCB0aGlzLmFzdF07XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYXROb2RlID0gc3RhY2sucG9wKCk7XG4gICAgICBpZiAoYXROb2RlLnR5cGUgPT09ICdSZXR1cm5TdGF0ZW1lbnQnKSB7XG4gICAgICAgIHJldHVybiBhdE5vZGU7XG4gICAgICB9XG4gICAgICBpZiAoYXROb2RlLnR5cGUgPT09ICdGdW5jdGlvbkRlY2xhcmF0aW9uJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhdE5vZGUuYXJndW1lbnQpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuYXJndW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChhdE5vZGUuYm9keSkge1xuICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZS5ib2R5KTtcbiAgICAgIH0gZWxzZSBpZiAoYXROb2RlLmRlY2xhcmF0aW9ucykge1xuICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZS5kZWNsYXJhdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGF0Tm9kZSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdE5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXROb2RlLmNvbnNlcXVlbnQpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuY29uc2VxdWVudCk7XG4gICAgICB9IGVsc2UgaWYgKGF0Tm9kZS5jYXNlcykge1xuICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZS5jYXNlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0SW50ZXJuYWxWYXJpYWJsZU5hbWUobmFtZSkge1xuICAgIGlmICghdGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICB0aGlzLl9pbnRlcm5hbFZhcmlhYmxlTmFtZXNbbmFtZV0gPSAwO1xuICAgIH1cbiAgICB0aGlzLl9pbnRlcm5hbFZhcmlhYmxlTmFtZXNbbmFtZV0rKztcbiAgICBpZiAodGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzW25hbWVdID09PSAxKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUgKyB0aGlzLl9pbnRlcm5hbFZhcmlhYmxlTmFtZXNbbmFtZV07XG4gIH1cblxuICBhc3RLZXkoYXN0LCBzZXBhcmF0b3IgPSAnLCcpIHtcbiAgICBpZiAoIWFzdC5zdGFydCB8fCAhYXN0LmVuZCkgdGhyb3cgbmV3IEVycm9yKCdBU1Qgc3RhcnQgYW5kIGVuZCBuZWVkZWQnKTtcbiAgICByZXR1cm4gYCR7YXN0LnN0YXJ0fSR7c2VwYXJhdG9yfSR7YXN0LmVuZH1gO1xuICB9XG59XG5cbmNvbnN0IHR5cGVMb29rdXBNYXAgPSB7XG4gICdOdW1iZXInOiAnTnVtYmVyJyxcbiAgJ0Zsb2F0JzogJ0Zsb2F0JyxcbiAgJ0ludGVnZXInOiAnSW50ZWdlcicsXG4gICdBcnJheSc6ICdOdW1iZXInLFxuICAnQXJyYXkoMiknOiAnTnVtYmVyJyxcbiAgJ0FycmF5KDMpJzogJ051bWJlcicsXG4gICdBcnJheSg0KSc6ICdOdW1iZXInLFxuICAnQXJyYXkyRCc6ICdOdW1iZXInLFxuICAnQXJyYXkzRCc6ICdOdW1iZXInLFxuICAnSW5wdXQnOiAnTnVtYmVyJyxcbiAgJ0hUTUxDYW52YXMnOiAnQXJyYXkoNCknLFxuICAnSFRNTEltYWdlJzogJ0FycmF5KDQpJyxcbiAgJ0hUTUxWaWRlbyc6ICdBcnJheSg0KScsXG4gICdIVE1MSW1hZ2VBcnJheSc6ICdBcnJheSg0KScsXG4gICdOdW1iZXJUZXh0dXJlJzogJ051bWJlcicsXG4gICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogJ051bWJlcicsXG4gICdBcnJheTFEKDIpJzogJ0FycmF5KDIpJyxcbiAgJ0FycmF5MUQoMyknOiAnQXJyYXkoMyknLFxuICAnQXJyYXkxRCg0KSc6ICdBcnJheSg0KScsXG4gICdBcnJheTJEKDIpJzogJ0FycmF5KDIpJyxcbiAgJ0FycmF5MkQoMyknOiAnQXJyYXkoMyknLFxuICAnQXJyYXkyRCg0KSc6ICdBcnJheSg0KScsXG4gICdBcnJheTNEKDIpJzogJ0FycmF5KDIpJyxcbiAgJ0FycmF5M0QoMyknOiAnQXJyYXkoMyknLFxuICAnQXJyYXkzRCg0KSc6ICdBcnJheSg0KScsXG4gICdBcnJheVRleHR1cmUoMSknOiAnTnVtYmVyJyxcbiAgJ0FycmF5VGV4dHVyZSgyKSc6ICdBcnJheSgyKScsXG4gICdBcnJheVRleHR1cmUoMyknOiAnQXJyYXkoMyknLFxuICAnQXJyYXlUZXh0dXJlKDQpJzogJ0FycmF5KDQpJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBGdW5jdGlvbk5vZGVcbn07XG59LHtcIi4uL3V0aWxzXCI6MTE0LFwiLi9mdW5jdGlvbi10cmFjZXJcIjoxMSxcImFjb3JuXCI6MX1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5Lmxlbmd0aCA+IDAgPyBhcnJheVthcnJheS5sZW5ndGggLSAxXSA6IG51bGw7XG59XG5cbmNvbnN0IHN0YXRlcyA9IHtcbiAgdHJhY2tJZGVudGlmaWVyczogJ3RyYWNrSWRlbnRpZmllcnMnLFxuICBtZW1iZXJFeHByZXNzaW9uOiAnbWVtYmVyRXhwcmVzc2lvbicsXG4gIGluRm9yTG9vcEluaXQ6ICdpbkZvckxvb3BJbml0J1xufTtcblxuY2xhc3MgRnVuY3Rpb25UcmFjZXIge1xuICBjb25zdHJ1Y3Rvcihhc3QpIHtcbiAgICB0aGlzLnJ1bm5pbmdDb250ZXh0cyA9IFtdO1xuICAgIHRoaXMuZnVuY3Rpb25Db250ZXh0cyA9IFtdO1xuICAgIHRoaXMuY29udGV4dHMgPSBbXTtcbiAgICB0aGlzLmZ1bmN0aW9uQ2FsbHMgPSBbXTtcbiAgICB0aGlzLmRlY2xhcmF0aW9ucyA9IFtdO1xuICAgIHRoaXMuaWRlbnRpZmllcnMgPSBbXTtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICAgIHRoaXMucmV0dXJuU3RhdGVtZW50cyA9IFtdO1xuICAgIHRoaXMudHJhY2tlZElkZW50aWZpZXJzID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgIHRoaXMubmV3RnVuY3Rpb25Db250ZXh0KCk7XG4gICAgdGhpcy5zY2FuKGFzdCk7XG4gIH1cblxuICBpc1N0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzW3RoaXMuc3RhdGVzLmxlbmd0aCAtIDFdID09PSBzdGF0ZTtcbiAgfVxuXG4gIGhhc1N0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzLmluZGV4T2Yoc3RhdGUpID4gLTE7XG4gIH1cblxuICBwdXNoU3RhdGUoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgfVxuXG4gIHBvcFN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuaXNTdGF0ZShzdGF0ZSkpIHtcbiAgICAgIHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwb3AgdGhlIG5vbi1hY3RpdmUgc3RhdGUgXCIke3N0YXRlfVwiYCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGN1cnJlbnRGdW5jdGlvbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGxhc3QodGhpcy5mdW5jdGlvbkNvbnRleHRzKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50Q29udGV4dCgpIHtcbiAgICByZXR1cm4gbGFzdCh0aGlzLnJ1bm5pbmdDb250ZXh0cyk7XG4gIH1cblxuICBuZXdGdW5jdGlvbkNvbnRleHQoKSB7XG4gICAgY29uc3QgbmV3Q29udGV4dCA9IHsgJ0Bjb250ZXh0VHlwZSc6ICdmdW5jdGlvbicgfTtcbiAgICB0aGlzLmNvbnRleHRzLnB1c2gobmV3Q29udGV4dCk7XG4gICAgdGhpcy5mdW5jdGlvbkNvbnRleHRzLnB1c2gobmV3Q29udGV4dCk7XG4gIH1cblxuICBuZXdDb250ZXh0KHJ1bikge1xuICAgIGNvbnN0IG5ld0NvbnRleHQgPSBPYmplY3QuYXNzaWduKHsgJ0Bjb250ZXh0VHlwZSc6ICdjb25zdC9sZXQnIH0sIHRoaXMuY3VycmVudENvbnRleHQpO1xuICAgIHRoaXMuY29udGV4dHMucHVzaChuZXdDb250ZXh0KTtcbiAgICB0aGlzLnJ1bm5pbmdDb250ZXh0cy5wdXNoKG5ld0NvbnRleHQpO1xuICAgIHJ1bigpO1xuICAgIGNvbnN0IHsgY3VycmVudEZ1bmN0aW9uQ29udGV4dCB9ID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IHAgaW4gY3VycmVudEZ1bmN0aW9uQ29udGV4dCkge1xuICAgICAgaWYgKCFjdXJyZW50RnVuY3Rpb25Db250ZXh0Lmhhc093blByb3BlcnR5KHApIHx8IG5ld0NvbnRleHQuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICAgICAgbmV3Q29udGV4dFtwXSA9IGN1cnJlbnRGdW5jdGlvbkNvbnRleHRbcF07XG4gICAgfVxuICAgIHRoaXMucnVubmluZ0NvbnRleHRzLnBvcCgpO1xuICAgIHJldHVybiBuZXdDb250ZXh0O1xuICB9XG5cbiAgdXNlRnVuY3Rpb25Db250ZXh0KHJ1bikge1xuICAgIGNvbnN0IGZ1bmN0aW9uQ29udGV4dCA9IGxhc3QodGhpcy5mdW5jdGlvbkNvbnRleHRzKTtcbiAgICB0aGlzLnJ1bm5pbmdDb250ZXh0cy5wdXNoKGZ1bmN0aW9uQ29udGV4dCk7XG4gICAgcnVuKCk7XG4gICAgdGhpcy5ydW5uaW5nQ29udGV4dHMucG9wKCk7XG4gIH1cblxuICBnZXRJZGVudGlmaWVycyhydW4pIHtcbiAgICBjb25zdCB0cmFja2VkSWRlbnRpZmllcnMgPSB0aGlzLnRyYWNrZWRJZGVudGlmaWVycyA9IFtdO1xuICAgIHRoaXMucHVzaFN0YXRlKHN0YXRlcy50cmFja0lkZW50aWZpZXJzKTtcbiAgICBydW4oKTtcbiAgICB0aGlzLnRyYWNrZWRJZGVudGlmaWVycyA9IG51bGw7XG4gICAgdGhpcy5wb3BTdGF0ZShzdGF0ZXMudHJhY2tJZGVudGlmaWVycyk7XG4gICAgcmV0dXJuIHRyYWNrZWRJZGVudGlmaWVycztcbiAgfVxuXG4gIGdldERlY2xhcmF0aW9uKG5hbWUpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRDb250ZXh0LCBjdXJyZW50RnVuY3Rpb25Db250ZXh0LCBydW5uaW5nQ29udGV4dHMgfSA9IHRoaXM7XG4gICAgY29uc3QgZGVjbGFyYXRpb24gPSBjdXJyZW50Q29udGV4dFtuYW1lXSB8fCBjdXJyZW50RnVuY3Rpb25Db250ZXh0W25hbWVdIHx8IG51bGw7XG5cbiAgICBpZiAoXG4gICAgICAhZGVjbGFyYXRpb24gJiZcbiAgICAgIGN1cnJlbnRDb250ZXh0ID09PSBjdXJyZW50RnVuY3Rpb25Db250ZXh0ICYmXG4gICAgICBydW5uaW5nQ29udGV4dHMubGVuZ3RoID4gMFxuICAgICkge1xuICAgICAgY29uc3QgcHJldmlvdXNSdW5uaW5nQ29udGV4dCA9IHJ1bm5pbmdDb250ZXh0c1tydW5uaW5nQ29udGV4dHMubGVuZ3RoIC0gMl07XG4gICAgICBpZiAocHJldmlvdXNSdW5uaW5nQ29udGV4dFtuYW1lXSkge1xuICAgICAgICByZXR1cm4gcHJldmlvdXNSdW5uaW5nQ29udGV4dFtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVjbGFyYXRpb247XG4gIH1cblxuICBzY2FuKGFzdCkge1xuICAgIGlmICghYXN0KSByZXR1cm47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXN0KSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5zY2FuKGFzdFtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ1Byb2dyYW0nOlxuICAgICAgICB0aGlzLnVzZUZ1bmN0aW9uQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC5ib2R5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuICAgICAgICB0aGlzLm5ld0NvbnRleHQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2Nhbihhc3QuYm9keSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ0xvZ2ljYWxFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5sZWZ0KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5yaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QubGVmdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QucmlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuICAgICAgICBpZiAoYXN0Lm9wZXJhdG9yID09PSAnKysnKSB7XG4gICAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLmdldERlY2xhcmF0aW9uKGFzdC5hcmd1bWVudC5uYW1lKTtcbiAgICAgICAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLnN1Z2dlc3RlZFR5cGUgPSAnSW50ZWdlcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuYXJndW1lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuYXJndW1lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nOlxuICAgICAgICBpZiAoYXN0LmtpbmQgPT09ICd2YXInKSB7XG4gICAgICAgICAgdGhpcy51c2VGdW5jdGlvbkNvbnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgYXN0LmRlY2xhcmF0aW9ucyA9IHV0aWxzLm5vcm1hbGl6ZURlY2xhcmF0aW9ucyhhc3QpO1xuICAgICAgICAgICAgdGhpcy5zY2FuKGFzdC5kZWNsYXJhdGlvbnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzdC5kZWNsYXJhdGlvbnMgPSB1dGlscy5ub3JtYWxpemVEZWNsYXJhdGlvbnMoYXN0KTtcbiAgICAgICAgICB0aGlzLnNjYW4oYXN0LmRlY2xhcmF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0b3InOiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudENvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGluRm9yTG9vcEluaXQgPSB0aGlzLmhhc1N0YXRlKHN0YXRlcy5pbkZvckxvb3BJbml0KTtcbiAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB7XG4gICAgICAgICAgYXN0OiBhc3QsXG4gICAgICAgICAgY29udGV4dDogY3VycmVudENvbnRleHQsXG4gICAgICAgICAgbmFtZTogYXN0LmlkLm5hbWUsXG4gICAgICAgICAgb3JpZ2luOiAnZGVjbGFyYXRpb24nLFxuICAgICAgICAgIGluRm9yTG9vcEluaXQsXG4gICAgICAgICAgaW5Gb3JMb29wVGVzdDogbnVsbCxcbiAgICAgICAgICBhc3NpZ25hYmxlOiBjdXJyZW50Q29udGV4dCA9PT0gdGhpcy5jdXJyZW50RnVuY3Rpb25Db250ZXh0IHx8ICghaW5Gb3JMb29wSW5pdCAmJiAhY3VycmVudENvbnRleHQuaGFzT3duUHJvcGVydHkoYXN0LmlkLm5hbWUpKSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlOiBudWxsLFxuICAgICAgICAgIHZhbHVlVHlwZTogbnVsbCxcbiAgICAgICAgICBkZXBlbmRlbmNpZXM6IG51bGwsXG4gICAgICAgICAgaXNTYWZlOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWN1cnJlbnRDb250ZXh0W2FzdC5pZC5uYW1lXSkge1xuICAgICAgICAgIGN1cnJlbnRDb250ZXh0W2FzdC5pZC5uYW1lXSA9IGRlY2xhcmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zLnB1c2goZGVjbGFyYXRpb24pO1xuICAgICAgICB0aGlzLnNjYW4oYXN0LmlkKTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5pbml0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdGdW5jdGlvbkV4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnRnVuY3Rpb25EZWNsYXJhdGlvbic6XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmdDb250ZXh0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnNjYW4oYXN0LmJvZHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZnVuY3Rpb25zLnB1c2goYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0lmU3RhdGVtZW50JzpcbiAgICAgICAgdGhpcy5zY2FuKGFzdC50ZXN0KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5jb25zZXF1ZW50KTtcbiAgICAgICAgaWYgKGFzdC5hbHRlcm5hdGUpIHRoaXMuc2Nhbihhc3QuYWx0ZXJuYXRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdGb3JTdGF0ZW1lbnQnOiB7XG4gICAgICAgIGxldCB0ZXN0SWRlbnRpZmllcnM7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLm5ld0NvbnRleHQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucHVzaFN0YXRlKHN0YXRlcy5pbkZvckxvb3BJbml0KTtcbiAgICAgICAgICB0aGlzLnNjYW4oYXN0LmluaXQpO1xuICAgICAgICAgIHRoaXMucG9wU3RhdGUoc3RhdGVzLmluRm9yTG9vcEluaXQpO1xuXG4gICAgICAgICAgdGVzdElkZW50aWZpZXJzID0gdGhpcy5nZXRJZGVudGlmaWVycygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjYW4oYXN0LnRlc3QpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC51cGRhdGUpO1xuICAgICAgICAgIHRoaXMubmV3Q29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjYW4oYXN0LmJvZHkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGVzdElkZW50aWZpZXJzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwIGluIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChwID09PSAnQGNvbnRleHRUeXBlJykgY29udGludWU7XG4gICAgICAgICAgICBpZiAodGVzdElkZW50aWZpZXJzLmluZGV4T2YocCkgPiAtMSkge1xuICAgICAgICAgICAgICBjb250ZXh0W3BdLmluRm9yTG9vcFRlc3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0RvV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgY2FzZSAnV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICB0aGlzLm5ld0NvbnRleHQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2Nhbihhc3QuYm9keSk7XG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC50ZXN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSWRlbnRpZmllcic6IHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZShzdGF0ZXMudHJhY2tJZGVudGlmaWVycykpIHtcbiAgICAgICAgICB0aGlzLnRyYWNrZWRJZGVudGlmaWVycy5wdXNoKGFzdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkZW50aWZpZXJzLnB1c2goe1xuICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY3VycmVudENvbnRleHQsXG4gICAgICAgICAgZGVjbGFyYXRpb246IHRoaXMuZ2V0RGVjbGFyYXRpb24oYXN0Lm5hbWUpLFxuICAgICAgICAgIGFzdCxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnUmV0dXJuU3RhdGVtZW50JzpcbiAgICAgICAgdGhpcy5yZXR1cm5TdGF0ZW1lbnRzLnB1c2goYXN0KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5hcmd1bWVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKHN0YXRlcy5tZW1iZXJFeHByZXNzaW9uKTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5vYmplY3QpO1xuICAgICAgICB0aGlzLnNjYW4oYXN0LnByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZShzdGF0ZXMubWVtYmVyRXhwcmVzc2lvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRXhwcmVzc2lvblN0YXRlbWVudCc6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuZXhwcmVzc2lvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnU2VxdWVuY2VFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5leHByZXNzaW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQ2FsbEV4cHJlc3Npb24nOlxuICAgICAgICB0aGlzLmZ1bmN0aW9uQ2FsbHMucHVzaCh7XG4gICAgICAgICAgY29udGV4dDogdGhpcy5jdXJyZW50Q29udGV4dCxcbiAgICAgICAgICBhc3QsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjYW4oYXN0LmFyZ3VtZW50cyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXlFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5lbGVtZW50cyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5zY2FuKGFzdC50ZXN0KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5hbHRlcm5hdGUpO1xuICAgICAgICB0aGlzLnNjYW4oYXN0LmNvbnNlcXVlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1N3aXRjaFN0YXRlbWVudCc6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuZGlzY3JpbWluYW50KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5jYXNlcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnU3dpdGNoQ2FzZSc6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QudGVzdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuY29uc2VxdWVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdUaGlzRXhwcmVzc2lvbic6XG4gICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgIGNhc2UgJ0RlYnVnZ2VyU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ0VtcHR5U3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ0JyZWFrU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ0NvbnRpbnVlU3RhdGVtZW50JzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCB0eXBlIFwiJHthc3QudHlwZX1cImApO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRnVuY3Rpb25UcmFjZXIsXG59O1xufSx7XCIuLi91dGlsc1wiOjExNH1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgZ2xXaXJldGFwIH0gPSByZXF1aXJlKCdnbC13aXJldGFwJyk7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiB0b1N0cmluZ1dpdGhvdXRVdGlscyhmbikge1xuICByZXR1cm4gZm4udG9TdHJpbmcoKVxuICAgIC5yZXBsYWNlKCc9PicsICcnKVxuICAgIC5yZXBsYWNlKC9eZnVuY3Rpb24gLywgJycpXG4gICAgLnJlcGxhY2UoL3V0aWxzWy5dL2csICcvKnV0aWxzLiovJyk7XG59XG5cbmZ1bmN0aW9uIGdsS2VybmVsU3RyaW5nKEtlcm5lbCwgYXJncywgb3JpZ2luS2VybmVsLCBzZXR1cENvbnRleHRTdHJpbmcsIGRlc3Ryb3lDb250ZXh0U3RyaW5nKSB7XG4gIGlmICghb3JpZ2luS2VybmVsLmJ1aWx0KSB7XG4gICAgb3JpZ2luS2VybmVsLmJ1aWxkLmFwcGx5KG9yaWdpbktlcm5lbCwgYXJncyk7XG4gIH1cbiAgYXJncyA9IGFyZ3MgPyBBcnJheS5mcm9tKGFyZ3MpLm1hcChhcmcgPT4ge1xuICAgIHN3aXRjaCAodHlwZW9mIGFyZykge1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiBuZXcgQm9vbGVhbihhcmcpO1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXIoYXJnKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICB9KSA6IG51bGw7XG4gIGNvbnN0IHVwbG9hZGVkVmFsdWVzID0gW107XG4gIGNvbnN0IHBvc3RSZXN1bHQgPSBbXTtcbiAgY29uc3QgY29udGV4dCA9IGdsV2lyZXRhcChvcmlnaW5LZXJuZWwuY29udGV4dCwge1xuICAgIHVzZVRyYWNrYWJsZVByaW1pdGl2ZXM6IHRydWUsXG4gICAgb25SZWFkUGl4ZWxzOiAodGFyZ2V0TmFtZSkgPT4ge1xuICAgICAgaWYgKGtlcm5lbC5zdWJLZXJuZWxzKSB7XG4gICAgICAgIGlmICghc3ViS2VybmVsc1Jlc3VsdFZhcmlhYmxlU2V0dXApIHtcbiAgICAgICAgICBwb3N0UmVzdWx0LnB1c2goYCAgICBjb25zdCByZXN1bHQgPSB7IHJlc3VsdDogJHtnZXRSZW5kZXJTdHJpbmcodGFyZ2V0TmFtZSwga2VybmVsKX0gfTtgKTtcbiAgICAgICAgICBzdWJLZXJuZWxzUmVzdWx0VmFyaWFibGVTZXR1cCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBrZXJuZWwuc3ViS2VybmVsc1tzdWJLZXJuZWxzUmVzdWx0SW5kZXgrK10ucHJvcGVydHk7XG4gICAgICAgICAgcG9zdFJlc3VsdC5wdXNoKGAgICAgcmVzdWx0JHtpc05hTihwcm9wZXJ0eSkgPyAnLicgKyBwcm9wZXJ0eSA6IGBbJHtwcm9wZXJ0eX1dYH0gPSAke2dldFJlbmRlclN0cmluZyh0YXJnZXROYW1lLCBrZXJuZWwpfTtgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViS2VybmVsc1Jlc3VsdEluZGV4ID09PSBrZXJuZWwuc3ViS2VybmVscy5sZW5ndGgpIHtcbiAgICAgICAgICBwb3N0UmVzdWx0LnB1c2goJyAgICByZXR1cm4gcmVzdWx0OycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXROYW1lKSB7XG4gICAgICAgIHBvc3RSZXN1bHQucHVzaChgICAgIHJldHVybiAke2dldFJlbmRlclN0cmluZyh0YXJnZXROYW1lLCBrZXJuZWwpfTtgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvc3RSZXN1bHQucHVzaChgICAgIHJldHVybiBudWxsO2ApO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cDogKGFyZ3VtZW50KSA9PiB7XG4gICAgICBjb25zdCBhcmd1bWVudE5hbWUgPSBmaW5kS2VybmVsVmFsdWUoYXJndW1lbnQsIGtlcm5lbC5rZXJuZWxBcmd1bWVudHMsIFtdLCBjb250ZXh0LCB1cGxvYWRlZFZhbHVlcyk7XG4gICAgICBpZiAoYXJndW1lbnROYW1lKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudE5hbWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25zdGFudE5hbWUgPSBmaW5kS2VybmVsVmFsdWUoYXJndW1lbnQsIGtlcm5lbC5rZXJuZWxDb25zdGFudHMsIGNvbnN0YW50cyA/IE9iamVjdC5rZXlzKGNvbnN0YW50cykubWFwKGtleSA9PiBjb25zdGFudHNba2V5XSkgOiBbXSwgY29udGV4dCwgdXBsb2FkZWRWYWx1ZXMpO1xuICAgICAgaWYgKGNvbnN0YW50TmFtZSkge1xuICAgICAgICByZXR1cm4gY29uc3RhbnROYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9KTtcbiAgbGV0IHN1Yktlcm5lbHNSZXN1bHRWYXJpYWJsZVNldHVwID0gZmFsc2U7XG4gIGxldCBzdWJLZXJuZWxzUmVzdWx0SW5kZXggPSAwO1xuICBjb25zdCB7XG4gICAgc291cmNlLFxuICAgIGNhbnZhcyxcbiAgICBvdXRwdXQsXG4gICAgcGlwZWxpbmUsXG4gICAgZ3JhcGhpY2FsLFxuICAgIGxvb3BNYXhJdGVyYXRpb25zLFxuICAgIGNvbnN0YW50cyxcbiAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgIHByZWNpc2lvbixcbiAgICBmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSxcbiAgICBmdW5jdGlvbnMsXG4gICAgbmF0aXZlRnVuY3Rpb25zLFxuICAgIHN1Yktlcm5lbHMsXG4gICAgaW1tdXRhYmxlLFxuICAgIGFyZ3VtZW50VHlwZXMsXG4gICAgY29uc3RhbnRUeXBlcyxcbiAgICBrZXJuZWxBcmd1bWVudHMsXG4gICAga2VybmVsQ29uc3RhbnRzLFxuICAgIHRhY3RpYyxcbiAgfSA9IG9yaWdpbktlcm5lbDtcbiAgY29uc3Qga2VybmVsID0gbmV3IEtlcm5lbChzb3VyY2UsIHtcbiAgICBjYW52YXMsXG4gICAgY29udGV4dCxcbiAgICBjaGVja0NvbnRleHQ6IGZhbHNlLFxuICAgIG91dHB1dCxcbiAgICBwaXBlbGluZSxcbiAgICBncmFwaGljYWwsXG4gICAgbG9vcE1heEl0ZXJhdGlvbnMsXG4gICAgY29uc3RhbnRzLFxuICAgIG9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgcHJlY2lzaW9uLFxuICAgIGZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5LFxuICAgIGZ1bmN0aW9ucyxcbiAgICBuYXRpdmVGdW5jdGlvbnMsXG4gICAgc3ViS2VybmVscyxcbiAgICBpbW11dGFibGUsXG4gICAgYXJndW1lbnRUeXBlcyxcbiAgICBjb25zdGFudFR5cGVzLFxuICAgIHRhY3RpYyxcbiAgfSk7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgY29udGV4dC5zZXRJbmRlbnQoMik7XG4gIGtlcm5lbC5idWlsZC5hcHBseShrZXJuZWwsIGFyZ3MpO1xuICByZXN1bHQucHVzaChjb250ZXh0LnRvU3RyaW5nKCkpO1xuICBjb250ZXh0LnJlc2V0KCk7XG5cbiAga2VybmVsLmtlcm5lbEFyZ3VtZW50cy5mb3JFYWNoKChrZXJuZWxBcmd1bWVudCwgaSkgPT4ge1xuICAgIHN3aXRjaCAoa2VybmVsQXJndW1lbnQudHlwZSkge1xuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICBjYXNlICdBcnJheSc6XG4gICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICBjYXNlICdIVE1MQ2FudmFzJzpcbiAgICAgIGNhc2UgJ0hUTUxJbWFnZSc6XG4gICAgICBjYXNlICdIVE1MVmlkZW8nOlxuICAgICAgICBjb250ZXh0Lmluc2VydFZhcmlhYmxlKGB1cGxvYWRWYWx1ZV8ke2tlcm5lbEFyZ3VtZW50Lm5hbWV9YCwga2VybmVsQXJndW1lbnQudXBsb2FkVmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0hUTUxJbWFnZUFycmF5JzpcbiAgICAgICAgZm9yIChsZXQgaW1hZ2VJbmRleCA9IDA7IGltYWdlSW5kZXggPCBhcmdzW2ldLmxlbmd0aDsgaW1hZ2VJbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICBjb250ZXh0Lmluc2VydFZhcmlhYmxlKGB1cGxvYWRWYWx1ZV8ke2tlcm5lbEFyZ3VtZW50Lm5hbWV9WyR7aW1hZ2VJbmRleH1dYCwgYXJnW2ltYWdlSW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0lucHV0JzpcbiAgICAgICAgY29udGV4dC5pbnNlcnRWYXJpYWJsZShgdXBsb2FkVmFsdWVfJHtrZXJuZWxBcmd1bWVudC5uYW1lfWAsIGtlcm5lbEFyZ3VtZW50LnVwbG9hZFZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzpcbiAgICAgIGNhc2UgJ051bWJlclRleHR1cmUnOlxuICAgICAgY2FzZSAnQXJyYXkxRCgyKSc6XG4gICAgICBjYXNlICdBcnJheTFEKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5MUQoNCknOlxuICAgICAgY2FzZSAnQXJyYXkyRCgyKSc6XG4gICAgICBjYXNlICdBcnJheTJEKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5MkQoNCknOlxuICAgICAgY2FzZSAnQXJyYXkzRCgyKSc6XG4gICAgICBjYXNlICdBcnJheTNEKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5M0QoNCknOlxuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoMyknOlxuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcbiAgICAgICAgY29udGV4dC5pbnNlcnRWYXJpYWJsZShgdXBsb2FkVmFsdWVfJHtrZXJuZWxBcmd1bWVudC5uYW1lfWAsIGFyZ3NbaV0udGV4dHVyZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQga2VybmVsQXJndW1lbnRUeXBlIGluc2VydGlvbiBmb3IgZ2xXaXJldGFwIG9mIHR5cGUgJHtrZXJuZWxBcmd1bWVudC50eXBlfWApO1xuICAgIH1cbiAgfSk7XG4gIHJlc3VsdC5wdXNoKCcvKiogc3RhcnQgb2YgaW5qZWN0ZWQgZnVuY3Rpb25zICoqLycpO1xuICByZXN1bHQucHVzaChgZnVuY3Rpb24gJHt0b1N0cmluZ1dpdGhvdXRVdGlscyh1dGlscy5mbGF0dGVuVG8pfWApO1xuICByZXN1bHQucHVzaChgZnVuY3Rpb24gJHt0b1N0cmluZ1dpdGhvdXRVdGlscyh1dGlscy5mbGF0dGVuMmRBcnJheVRvKX1gKTtcbiAgcmVzdWx0LnB1c2goYGZ1bmN0aW9uICR7dG9TdHJpbmdXaXRob3V0VXRpbHModXRpbHMuZmxhdHRlbjNkQXJyYXlUbyl9YCk7XG4gIHJlc3VsdC5wdXNoKGBmdW5jdGlvbiAke3RvU3RyaW5nV2l0aG91dFV0aWxzKHV0aWxzLmZsYXR0ZW40ZEFycmF5VG8pfWApO1xuICByZXN1bHQucHVzaChgZnVuY3Rpb24gJHt0b1N0cmluZ1dpdGhvdXRVdGlscyh1dGlscy5pc0FycmF5KX1gKTtcbiAgaWYgKGtlcm5lbC5yZW5kZXJPdXRwdXQgIT09IGtlcm5lbC5yZW5kZXJUZXh0dXJlICYmIGtlcm5lbC5mb3JtYXRWYWx1ZXMpIHtcbiAgICByZXN1bHQucHVzaChcbiAgICAgIGAgIGNvbnN0IHJlbmRlck91dHB1dCA9IGZ1bmN0aW9uICR7dG9TdHJpbmdXaXRob3V0VXRpbHMoa2VybmVsLmZvcm1hdFZhbHVlcyl9O2BcbiAgICApO1xuICB9XG4gIHJlc3VsdC5wdXNoKCcvKiogZW5kIG9mIGluamVjdGVkIGZ1bmN0aW9ucyAqKi8nKTtcbiAgcmVzdWx0LnB1c2goYCAgY29uc3QgaW5uZXJLZXJuZWwgPSBmdW5jdGlvbiAoJHtrZXJuZWwua2VybmVsQXJndW1lbnRzLm1hcChrZXJuZWxBcmd1bWVudCA9PiBrZXJuZWxBcmd1bWVudC52YXJOYW1lKS5qb2luKCcsICcpfSkge2ApO1xuICBjb250ZXh0LnNldEluZGVudCg0KTtcbiAga2VybmVsLnJ1bi5hcHBseShrZXJuZWwsIGFyZ3MpO1xuICBpZiAoa2VybmVsLnJlbmRlcktlcm5lbHMpIHtcbiAgICBrZXJuZWwucmVuZGVyS2VybmVscygpO1xuICB9IGVsc2UgaWYgKGtlcm5lbC5yZW5kZXJPdXRwdXQpIHtcbiAgICBrZXJuZWwucmVuZGVyT3V0cHV0KCk7XG4gIH1cbiAgcmVzdWx0LnB1c2goJyAgICAvKiogc3RhcnQgc2V0dXAgdXBsb2FkcyBmb3Iga2VybmVsIHZhbHVlcyAqKi8nKTtcbiAga2VybmVsLmtlcm5lbEFyZ3VtZW50cy5mb3JFYWNoKGtlcm5lbEFyZ3VtZW50ID0+IHtcbiAgICByZXN1bHQucHVzaCgnICAgICcgKyBrZXJuZWxBcmd1bWVudC5nZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKS5zcGxpdCgnXFxuJykuam9pbignXFxuICAgICcpKTtcbiAgfSk7XG4gIHJlc3VsdC5wdXNoKCcgICAgLyoqIGVuZCBzZXR1cCB1cGxvYWRzIGZvciBrZXJuZWwgdmFsdWVzICoqLycpO1xuICByZXN1bHQucHVzaChjb250ZXh0LnRvU3RyaW5nKCkpO1xuICBpZiAoa2VybmVsLnJlbmRlck91dHB1dCA9PT0ga2VybmVsLnJlbmRlclRleHR1cmUpIHtcbiAgICBjb250ZXh0LnJlc2V0KCk7XG4gICAgaWYgKGtlcm5lbC5yZW5kZXJLZXJuZWxzKSB7XG4gICAgICBjb25zdCByZXN1bHRzID0ga2VybmVsLnJlbmRlcktlcm5lbHMoKTtcbiAgICAgIGNvbnN0IHRleHR1cmVOYW1lID0gY29udGV4dC5nZXRDb250ZXh0VmFyaWFibGVOYW1lKGtlcm5lbC50ZXh0dXJlLnRleHR1cmUpO1xuICAgICAgcmVzdWx0LnB1c2goYCAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiB7XG4gICAgICAgIHRleHR1cmU6ICR7IHRleHR1cmVOYW1lIH0sXG4gICAgICAgIHR5cGU6ICckeyByZXN1bHRzLnJlc3VsdC50eXBlIH0nLFxuICAgICAgICB0b0FycmF5OiAkeyBnZXRUb0FycmF5U3RyaW5nKHJlc3VsdHMucmVzdWx0LCB0ZXh0dXJlTmFtZSkgfVxuICAgICAgfSxgKTtcbiAgICAgIGNvbnN0IHsgc3ViS2VybmVscywgbWFwcGVkVGV4dHVyZXMgfSA9IGtlcm5lbDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gbWFwcGVkVGV4dHVyZXNbaV07XG4gICAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHN1Yktlcm5lbHNbaV07XG4gICAgICAgIGNvbnN0IHN1Yktlcm5lbFJlc3VsdCA9IHJlc3VsdHNbc3ViS2VybmVsLnByb3BlcnR5XTtcbiAgICAgICAgY29uc3Qgc3ViS2VybmVsVGV4dHVyZU5hbWUgPSBjb250ZXh0LmdldENvbnRleHRWYXJpYWJsZU5hbWUodGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgICAgcmVzdWx0LnB1c2goYFxuICAgICAgJHtzdWJLZXJuZWwucHJvcGVydHl9OiB7XG4gICAgICAgIHRleHR1cmU6ICR7IHN1Yktlcm5lbFRleHR1cmVOYW1lIH0sXG4gICAgICAgIHR5cGU6ICckeyBzdWJLZXJuZWxSZXN1bHQudHlwZSB9JyxcbiAgICAgICAgdG9BcnJheTogJHsgZ2V0VG9BcnJheVN0cmluZyhzdWJLZXJuZWxSZXN1bHQsIHN1Yktlcm5lbFRleHR1cmVOYW1lKSB9XG4gICAgICB9LGApO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goYCAgICB9O2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZW5kZXJlZCA9IGtlcm5lbC5yZW5kZXJPdXRwdXQoKTtcbiAgICAgIGNvbnN0IHRleHR1cmVOYW1lID0gY29udGV4dC5nZXRDb250ZXh0VmFyaWFibGVOYW1lKGtlcm5lbC50ZXh0dXJlLnRleHR1cmUpO1xuICAgICAgcmVzdWx0LnB1c2goYCAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0dXJlOiAkeyB0ZXh0dXJlTmFtZSB9LFxuICAgICAgICB0eXBlOiAnJHsgcmVuZGVyZWQudHlwZSB9JyxcbiAgICAgICAgdG9BcnJheTogJHsgZ2V0VG9BcnJheVN0cmluZyhyZW5kZXJlZCwgdGV4dHVyZU5hbWUpIH1cbiAgICAgIH07YCk7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5wdXNoKGAgICAgJHtkZXN0cm95Q29udGV4dFN0cmluZyA/ICdcXG4nICsgZGVzdHJveUNvbnRleHRTdHJpbmcgKyAnICAgICc6ICcnfWApO1xuICByZXN1bHQucHVzaChwb3N0UmVzdWx0LmpvaW4oJ1xcbicpKTtcbiAgcmVzdWx0LnB1c2goJyAgfTsnKTtcbiAgaWYgKGtlcm5lbC5ncmFwaGljYWwpIHtcbiAgICByZXN1bHQucHVzaChnZXRHZXRQaXhlbHNTdHJpbmcoa2VybmVsKSk7XG4gICAgcmVzdWx0LnB1c2goYCAgaW5uZXJLZXJuZWwuZ2V0UGl4ZWxzID0gZ2V0UGl4ZWxzO2ApO1xuICB9XG4gIHJlc3VsdC5wdXNoKCcgIHJldHVybiBpbm5lcktlcm5lbDsnKTtcblxuICBsZXQgY29uc3RhbnRzVXBsb2FkID0gW107XG4gIGtlcm5lbENvbnN0YW50cy5mb3JFYWNoKChrZXJuZWxDb25zdGFudCkgPT4ge1xuICAgIGNvbnN0YW50c1VwbG9hZC5wdXNoKGAkeyAga2VybmVsQ29uc3RhbnQuZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCl9YCk7XG4gIH0pO1xuICByZXR1cm4gYGZ1bmN0aW9uIGtlcm5lbChzZXR0aW5ncykge1xuICBjb25zdCB7IGNvbnRleHQsIGNvbnN0YW50cyB9ID0gc2V0dGluZ3M7XG4gICR7Y29uc3RhbnRzVXBsb2FkLmpvaW4oJycpfVxuICAke3NldHVwQ29udGV4dFN0cmluZyA/IHNldHVwQ29udGV4dFN0cmluZyA6ICcnfVxuJHtyZXN1bHQuam9pbignXFxuJyl9XG59YDtcbn1cblxuZnVuY3Rpb24gZ2V0UmVuZGVyU3RyaW5nKHRhcmdldE5hbWUsIGtlcm5lbCkge1xuICBjb25zdCByZWFkQmFja1ZhbHVlID0ga2VybmVsLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScgPyB0YXJnZXROYW1lIDogYG5ldyBGbG9hdDMyQXJyYXkoJHt0YXJnZXROYW1lfS5idWZmZXIpYDtcbiAgaWYgKGtlcm5lbC5vdXRwdXRbMl0pIHtcbiAgICByZXR1cm4gYHJlbmRlck91dHB1dCgke3JlYWRCYWNrVmFsdWV9LCAke2tlcm5lbC5vdXRwdXRbMF19LCAke2tlcm5lbC5vdXRwdXRbMV19LCAke2tlcm5lbC5vdXRwdXRbMl19KWA7XG4gIH1cbiAgaWYgKGtlcm5lbC5vdXRwdXRbMV0pIHtcbiAgICByZXR1cm4gYHJlbmRlck91dHB1dCgke3JlYWRCYWNrVmFsdWV9LCAke2tlcm5lbC5vdXRwdXRbMF19LCAke2tlcm5lbC5vdXRwdXRbMV19KWA7XG4gIH1cblxuICByZXR1cm4gYHJlbmRlck91dHB1dCgke3JlYWRCYWNrVmFsdWV9LCAke2tlcm5lbC5vdXRwdXRbMF19KWA7XG59XG5cbmZ1bmN0aW9uIGdldEdldFBpeGVsc1N0cmluZyhrZXJuZWwpIHtcbiAgY29uc3QgZ2V0UGl4ZWxzID0ga2VybmVsLmdldFBpeGVscy50b1N0cmluZygpO1xuICBjb25zdCB1c2VGdW5jdGlvbktleXdvcmQgPSAhL15mdW5jdGlvbi8udGVzdChnZXRQaXhlbHMpO1xuICByZXR1cm4gdXRpbHMuZmxhdHRlbkZ1bmN0aW9uVG9TdHJpbmcoYCR7dXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJ30keyBnZXRQaXhlbHMgfWAsIHtcbiAgICBmaW5kRGVwZW5kZW5jeTogKG9iamVjdCwgbmFtZSkgPT4ge1xuICAgICAgaWYgKG9iamVjdCA9PT0gJ3V0aWxzJykge1xuICAgICAgICByZXR1cm4gYGNvbnN0ICR7bmFtZX0gPSAke3V0aWxzW25hbWVdLnRvU3RyaW5nKCl9O2A7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHRoaXNMb29rdXA6IChwcm9wZXJ0eSkgPT4ge1xuICAgICAgaWYgKHByb3BlcnR5ID09PSAnY29udGV4dCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoa2VybmVsLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2VybmVsW3Byb3BlcnR5XSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCB0aGlzTG9va3VwICR7IHByb3BlcnR5IH1gKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRUb0FycmF5U3RyaW5nKGtlcm5lbFJlc3VsdCwgdGV4dHVyZU5hbWUpIHtcbiAgY29uc3QgdG9BcnJheSA9IGtlcm5lbFJlc3VsdC50b0FycmF5LnRvU3RyaW5nKCk7XG4gIGNvbnN0IHVzZUZ1bmN0aW9uS2V5d29yZCA9ICEvXmZ1bmN0aW9uLy50ZXN0KHRvQXJyYXkpO1xuICBjb25zdCBmbGF0dGVuZWRGdW5jdGlvbnMgPSB1dGlscy5mbGF0dGVuRnVuY3Rpb25Ub1N0cmluZyhgJHt1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnfSR7IHRvQXJyYXkgfWAsIHtcbiAgICBmaW5kRGVwZW5kZW5jeTogKG9iamVjdCwgbmFtZSkgPT4ge1xuICAgICAgaWYgKG9iamVjdCA9PT0gJ3V0aWxzJykge1xuICAgICAgICByZXR1cm4gYGNvbnN0ICR7bmFtZX0gPSAke3V0aWxzW25hbWVdLnRvU3RyaW5nKCl9O2A7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdCA9PT0gJ3RoaXMnKSB7XG4gICAgICAgIHJldHVybiBgJHt1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnfSR7a2VybmVsUmVzdWx0W25hbWVdLnRvU3RyaW5nKCl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5oYW5kbGVkIGZyb21PYmplY3QnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRoaXNMb29rdXA6IChwcm9wZXJ0eSwgaXNEZWNsYXJhdGlvbikgPT4ge1xuICAgICAgaWYgKHByb3BlcnR5ID09PSAndGV4dHVyZScpIHtcbiAgICAgICAgcmV0dXJuIHRleHR1cmVOYW1lO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BlcnR5ID09PSAnY29udGV4dCcpIHtcbiAgICAgICAgaWYgKGlzRGVjbGFyYXRpb24pIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gJ2dsJztcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ19mcmFtZWJ1ZmZlcicpIHtcbiAgICAgICAgcmV0dXJuICdfZnJhbWVidWZmZXInO1xuICAgICAgfVxuICAgICAgaWYgKGtlcm5lbFJlc3VsdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtlcm5lbFJlc3VsdFtwcm9wZXJ0eV0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgdGhpc0xvb2t1cCAkeyBwcm9wZXJ0eSB9YCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGAoKSA9PiB7XG4gIGxldCBfZnJhbWVidWZmZXI7XG4gICR7ZmxhdHRlbmVkRnVuY3Rpb25zfVxuICByZXR1cm4gdG9BcnJheSgpO1xuICB9YDtcbn1cblxuZnVuY3Rpb24gZmluZEtlcm5lbFZhbHVlKGFyZ3VtZW50LCBrZXJuZWxWYWx1ZXMsIHZhbHVlcywgY29udGV4dCwgdXBsb2FkZWRWYWx1ZXMpIHtcbiAgaWYgKGFyZ3VtZW50ID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgaWYgKGtlcm5lbFZhbHVlcyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAodHlwZW9mIGFyZ3VtZW50KSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChcbiAgICB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBhcmd1bWVudCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnRcbiAgKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtlcm5lbFZhbHVlID0ga2VybmVsVmFsdWVzW2ldO1xuICAgICAgaWYgKGtlcm5lbFZhbHVlLnR5cGUgIT09ICdIVE1MSW1hZ2VBcnJheScgJiYga2VybmVsVmFsdWUpIGNvbnRpbnVlO1xuICAgICAgaWYgKGtlcm5lbFZhbHVlLnVwbG9hZFZhbHVlICE9PSBhcmd1bWVudCkgY29udGludWU7XG4gICAgICBjb25zdCB2YXJpYWJsZUluZGV4ID0gdmFsdWVzW2ldLmluZGV4T2YoYXJndW1lbnQpO1xuICAgICAgaWYgKHZhcmlhYmxlSW5kZXggPT09IC0xKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGB1cGxvYWRWYWx1ZV8ke2tlcm5lbFZhbHVlLm5hbWV9WyR7dmFyaWFibGVJbmRleH1dYDtcbiAgICAgIGNvbnRleHQuaW5zZXJ0VmFyaWFibGUodmFyaWFibGVOYW1lLCBhcmd1bWVudCk7XG4gICAgICByZXR1cm4gdmFyaWFibGVOYW1lO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2VybmVsVmFsdWUgPSBrZXJuZWxWYWx1ZXNbaV07XG4gICAgaWYgKGFyZ3VtZW50ICE9PSBrZXJuZWxWYWx1ZS51cGxvYWRWYWx1ZSkgY29udGludWU7XG4gICAgY29uc3QgdmFyaWFibGUgPSBgdXBsb2FkVmFsdWVfJHtrZXJuZWxWYWx1ZS5uYW1lfWA7XG4gICAgY29udGV4dC5pbnNlcnRWYXJpYWJsZSh2YXJpYWJsZSwga2VybmVsVmFsdWUpO1xuICAgIHJldHVybiB2YXJpYWJsZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdsS2VybmVsU3RyaW5nXG59O1xufSx7XCIuLi8uLi91dGlsc1wiOjExNCxcImdsLXdpcmV0YXBcIjozfV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBLZXJuZWwgfSA9IHJlcXVpcmUoJy4uL2tlcm5lbCcpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXkyRmxvYXQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS0yLWZsb2F0Jyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5MkZsb2F0MkQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS0yLWZsb2F0LTJkJyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5MkZsb2F0M0QgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS0yLWZsb2F0LTNkJyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5M0Zsb2F0IH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktMy1mbG9hdCcpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTNGbG9hdDJEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktMy1mbG9hdC0yZCcpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTNGbG9hdDNEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktMy1mbG9hdC0zZCcpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTRGbG9hdCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTQtZmxvYXQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXk0RmxvYXQyRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTQtZmxvYXQtMmQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXk0RmxvYXQzRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTQtZmxvYXQtM2QnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9mbG9hdCcpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdDJEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvZmxvYXQtMmQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQzRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2Zsb2F0LTNkJyk7XG5jb25zdCB7IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL21lbW9yeS1vcHRpbWl6ZWQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkMkQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9tZW1vcnktb3B0aW1pemVkLTJkJyk7XG5jb25zdCB7IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDNEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvbWVtb3J5LW9wdGltaXplZC0zZCcpO1xuY29uc3QgeyBHTFRleHR1cmVVbnNpZ25lZCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL3Vuc2lnbmVkJyk7XG5jb25zdCB7IEdMVGV4dHVyZVVuc2lnbmVkMkQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS91bnNpZ25lZC0yZCcpO1xuY29uc3QgeyBHTFRleHR1cmVVbnNpZ25lZDNEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvdW5zaWduZWQtM2QnKTtcbmNvbnN0IHsgR0xUZXh0dXJlR3JhcGhpY2FsIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvZ3JhcGhpY2FsJyk7XG5cbmNsYXNzIEdMS2VybmVsIGV4dGVuZHMgS2VybmVsIHtcbiAgc3RhdGljIGdldCBtb2RlKCkge1xuICAgIHJldHVybiAnZ3B1JztcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc0Zsb2F0UmVhZCgpIHtcbiAgICBjb25zdCBrZXJuZWxTdHJpbmcgPSBgZnVuY3Rpb24ga2VybmVsRnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9YDtcbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgdGhpcyhrZXJuZWxTdHJpbmcsIHtcbiAgICAgIGNvbnRleHQ6IHRoaXMudGVzdENvbnRleHQsXG4gICAgICBjYW52YXM6IHRoaXMudGVzdENhbnZhcyxcbiAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgIG91dHB1dDogWzFdLFxuICAgICAgcHJlY2lzaW9uOiAnc2luZ2xlJyxcbiAgICAgIHJldHVyblR5cGU6ICdOdW1iZXInLFxuICAgICAgdGFjdGljOiAnc3BlZWQnLFxuICAgIH0pO1xuICAgIGtlcm5lbC5idWlsZCgpO1xuICAgIGtlcm5lbC5ydW4oKTtcbiAgICBjb25zdCByZXN1bHQgPSBrZXJuZWwucmVuZGVyT3V0cHV0KCk7XG4gICAga2VybmVsLmRlc3Ryb3kodHJ1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdFswXSA9PT0gMTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlKCkge1xuICAgIGZ1bmN0aW9uIGtlcm5lbEZ1bmN0aW9uKHYxLCB2Mikge1xuICAgICAgcmV0dXJuIHYxW3RoaXMudGhyZWFkLnhdIC8gdjJbdGhpcy50aHJlYWQueF07XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IG5ldyB0aGlzKGtlcm5lbEZ1bmN0aW9uLnRvU3RyaW5nKCksIHtcbiAgICAgIGNvbnRleHQ6IHRoaXMudGVzdENvbnRleHQsXG4gICAgICBjYW52YXM6IHRoaXMudGVzdENhbnZhcyxcbiAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgIG91dHB1dDogWzJdLFxuICAgICAgcmV0dXJuVHlwZTogJ051bWJlcicsXG4gICAgICBwcmVjaXNpb246ICd1bnNpZ25lZCcsXG4gICAgICB0YWN0aWM6ICdzcGVlZCcsXG4gICAgfSk7XG4gICAgY29uc3QgYXJncyA9IFtcbiAgICAgIFs2LCA2MDMwNDAxXSxcbiAgICAgIFszLCAzOTkxXVxuICAgIF07XG4gICAga2VybmVsLmJ1aWxkLmFwcGx5KGtlcm5lbCwgYXJncyk7XG4gICAga2VybmVsLnJ1bi5hcHBseShrZXJuZWwsIGFyZ3MpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbC5yZW5kZXJPdXRwdXQoKTtcbiAgICBrZXJuZWwuZGVzdHJveSh0cnVlKTtcbiAgICByZXR1cm4gcmVzdWx0WzBdID09PSAyICYmIHJlc3VsdFsxXSA9PT0gMTUxMTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc1NwZWVkVGFjdGljU3VwcG9ydGVkKCkge1xuICAgIGZ1bmN0aW9uIGtlcm5lbEZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWVbdGhpcy50aHJlYWQueF07XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IG5ldyB0aGlzKGtlcm5lbEZ1bmN0aW9uLnRvU3RyaW5nKCksIHtcbiAgICAgIGNvbnRleHQ6IHRoaXMudGVzdENvbnRleHQsXG4gICAgICBjYW52YXM6IHRoaXMudGVzdENhbnZhcyxcbiAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgIG91dHB1dDogWzRdLFxuICAgICAgcmV0dXJuVHlwZTogJ051bWJlcicsXG4gICAgICBwcmVjaXNpb246ICd1bnNpZ25lZCcsXG4gICAgICB0YWN0aWM6ICdzcGVlZCcsXG4gICAgfSk7XG4gICAgY29uc3QgYXJncyA9IFtcbiAgICAgIFswLCAxLCAyLCAzXVxuICAgIF07XG4gICAga2VybmVsLmJ1aWxkLmFwcGx5KGtlcm5lbCwgYXJncyk7XG4gICAga2VybmVsLnJ1bi5hcHBseShrZXJuZWwsIGFyZ3MpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbC5yZW5kZXJPdXRwdXQoKTtcbiAgICBrZXJuZWwuZGVzdHJveSh0cnVlKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChyZXN1bHRbMF0pID09PSAwICYmIE1hdGgucm91bmQocmVzdWx0WzFdKSA9PT0gMSAmJiBNYXRoLnJvdW5kKHJlc3VsdFsyXSkgPT09IDIgJiYgTWF0aC5yb3VuZChyZXN1bHRbM10pID09PSAzO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q2FudmFzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJ0ZXN0Q2FudmFzXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVzdENvbnRleHQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcInRlc3RDb250ZXh0XCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRGZWF0dXJlcygpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMudGVzdENvbnRleHQ7XG4gICAgY29uc3QgaXNEcmF3QnVmZmVycyA9IHRoaXMuZ2V0SXNEcmF3QnVmZmVycygpO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgIGlzRmxvYXRSZWFkOiB0aGlzLmdldElzRmxvYXRSZWFkKCksXG4gICAgICBpc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlOiB0aGlzLmdldElzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUoKSxcbiAgICAgIGlzU3BlZWRUYWN0aWNTdXBwb3J0ZWQ6IHRoaXMuZ2V0SXNTcGVlZFRhY3RpY1N1cHBvcnRlZCgpLFxuICAgICAgaXNUZXh0dXJlRmxvYXQ6IHRoaXMuZ2V0SXNUZXh0dXJlRmxvYXQoKSxcbiAgICAgIGlzRHJhd0J1ZmZlcnMsXG4gICAgICBrZXJuZWxNYXA6IGlzRHJhd0J1ZmZlcnMsXG4gICAgICBjaGFubmVsQ291bnQ6IHRoaXMuZ2V0Q2hhbm5lbENvdW50KCksXG4gICAgICBtYXhUZXh0dXJlU2l6ZTogdGhpcy5nZXRNYXhUZXh0dXJlU2l6ZSgpLFxuICAgICAgbG93SW50UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5MT1dfSU5UKSxcbiAgICAgIGxvd0Zsb2F0UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5MT1dfRkxPQVQpLFxuICAgICAgbWVkaXVtSW50UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fSU5UKSxcbiAgICAgIG1lZGl1bUZsb2F0UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQpLFxuICAgICAgaGlnaEludFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9JTlQpLFxuICAgICAgaGlnaEZsb2F0UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUKSxcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBzZXR1cEZlYXR1cmVDaGVja3MoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcInNldHVwRmVhdHVyZUNoZWNrc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0U2lnbmF0dXJlKGtlcm5lbCwgYXJndW1lbnRUeXBlcykge1xuICAgIHJldHVybiBrZXJuZWwuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKSArIChhcmd1bWVudFR5cGVzLmxlbmd0aCA+IDAgPyAnOicgKyBhcmd1bWVudFR5cGVzLmpvaW4oJywnKSA6ICcnKTtcbiAgfVxuXG4gIHNldEZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5KGZpeCkge1xuICAgIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBmaXg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRQcmVjaXNpb24oZmxhZykge1xuICAgIHRoaXMucHJlY2lzaW9uID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEZsb2F0VGV4dHVyZXMoZmxhZykge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdtZXRob2QnLCAnc2V0RmxvYXRUZXh0dXJlcycsICdzZXRPcHRpbWl6ZUZsb2F0TWVtb3J5Jyk7XG4gICAgdGhpcy5mbG9hdFRleHR1cmVzID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0YXRpYyBuYXRpdmVGdW5jdGlvbkFyZ3VtZW50cyhzb3VyY2UpIHtcbiAgICBjb25zdCBhcmd1bWVudFR5cGVzID0gW107XG4gICAgY29uc3QgYXJndW1lbnROYW1lcyA9IFtdO1xuICAgIGNvbnN0IHN0YXRlcyA9IFtdO1xuICAgIGNvbnN0IGlzU3RhcnRpbmdWYXJpYWJsZU5hbWUgPSAvXlthLXpBLVpfXS87XG4gICAgY29uc3QgaXNWYXJpYWJsZUNoYXIgPSAvW2EtekEtWl8wLTldLztcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGFyZ3VtZW50TmFtZSA9IG51bGw7XG4gICAgbGV0IGFyZ3VtZW50VHlwZSA9IG51bGw7XG4gICAgd2hpbGUgKGkgPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaGFyID0gc291cmNlW2ldO1xuICAgICAgY29uc3QgbmV4dENoYXIgPSBzb3VyY2VbaSArIDFdO1xuICAgICAgY29uc3Qgc3RhdGUgPSBzdGF0ZXMubGVuZ3RoID4gMCA/IHN0YXRlc1tzdGF0ZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuXG4gICAgICBpZiAoc3RhdGUgPT09ICdGVU5DVElPTl9BUkdVTUVOVFMnICYmIGNoYXIgPT09ICcvJyAmJiBuZXh0Q2hhciA9PT0gJyonKSB7XG4gICAgICAgIHN0YXRlcy5wdXNoKCdNVUxUSV9MSU5FX0NPTU1FTlQnKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdNVUxUSV9MSU5FX0NPTU1FTlQnICYmIGNoYXIgPT09ICcqJyAmJiBuZXh0Q2hhciA9PT0gJy8nKSB7XG4gICAgICAgIHN0YXRlcy5wb3AoKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdGVU5DVElPTl9BUkdVTUVOVFMnICYmIGNoYXIgPT09ICcvJyAmJiBuZXh0Q2hhciA9PT0gJy8nKSB7XG4gICAgICAgIHN0YXRlcy5wdXNoKCdDT01NRU5UJyk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnQ09NTUVOVCcgJiYgY2hhciA9PT0gJ1xcbicpIHtcbiAgICAgICAgc3RhdGVzLnBvcCgpO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gbnVsbCAmJiBjaGFyID09PSAnKCcpIHtcbiAgICAgICAgc3RhdGVzLnB1c2goJ0ZVTkNUSU9OX0FSR1VNRU5UUycpO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ0ZVTkNUSU9OX0FSR1VNRU5UUycpIHtcbiAgICAgICAgaWYgKGNoYXIgPT09ICcpJykge1xuICAgICAgICAgIHN0YXRlcy5wb3AoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJ2YnICYmIG5leHRDaGFyID09PSAnbCcgJiYgc291cmNlW2kgKyAyXSA9PT0gJ28nICYmIHNvdXJjZVtpICsgM10gPT09ICdhJyAmJiBzb3VyY2VbaSArIDRdID09PSAndCcgJiYgc291cmNlW2kgKyA1XSA9PT0gJyAnKSB7XG4gICAgICAgICAgc3RhdGVzLnB1c2goJ0RFQ0xBUkVfVkFSSUFCTEUnKTtcbiAgICAgICAgICBhcmd1bWVudFR5cGUgPSAnZmxvYXQnO1xuICAgICAgICAgIGFyZ3VtZW50TmFtZSA9ICcnO1xuICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnaScgJiYgbmV4dENoYXIgPT09ICduJyAmJiBzb3VyY2VbaSArIDJdID09PSAndCcgJiYgc291cmNlW2kgKyAzXSA9PT0gJyAnKSB7XG4gICAgICAgICAgc3RhdGVzLnB1c2goJ0RFQ0xBUkVfVkFSSUFCTEUnKTtcbiAgICAgICAgICBhcmd1bWVudFR5cGUgPSAnaW50JztcbiAgICAgICAgICBhcmd1bWVudE5hbWUgPSAnJztcbiAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ3YnICYmIG5leHRDaGFyID09PSAnZScgJiYgc291cmNlW2kgKyAyXSA9PT0gJ2MnICYmIHNvdXJjZVtpICsgM10gPT09ICcyJyAmJiBzb3VyY2VbaSArIDRdID09PSAnICcpIHtcbiAgICAgICAgICBzdGF0ZXMucHVzaCgnREVDTEFSRV9WQVJJQUJMRScpO1xuICAgICAgICAgIGFyZ3VtZW50VHlwZSA9ICd2ZWMyJztcbiAgICAgICAgICBhcmd1bWVudE5hbWUgPSAnJztcbiAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ3YnICYmIG5leHRDaGFyID09PSAnZScgJiYgc291cmNlW2kgKyAyXSA9PT0gJ2MnICYmIHNvdXJjZVtpICsgM10gPT09ICczJyAmJiBzb3VyY2VbaSArIDRdID09PSAnICcpIHtcbiAgICAgICAgICBzdGF0ZXMucHVzaCgnREVDTEFSRV9WQVJJQUJMRScpO1xuICAgICAgICAgIGFyZ3VtZW50VHlwZSA9ICd2ZWMzJztcbiAgICAgICAgICBhcmd1bWVudE5hbWUgPSAnJztcbiAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ3YnICYmIG5leHRDaGFyID09PSAnZScgJiYgc291cmNlW2kgKyAyXSA9PT0gJ2MnICYmIHNvdXJjZVtpICsgM10gPT09ICc0JyAmJiBzb3VyY2VbaSArIDRdID09PSAnICcpIHtcbiAgICAgICAgICBzdGF0ZXMucHVzaCgnREVDTEFSRV9WQVJJQUJMRScpO1xuICAgICAgICAgIGFyZ3VtZW50VHlwZSA9ICd2ZWM0JztcbiAgICAgICAgICBhcmd1bWVudE5hbWUgPSAnJztcbiAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdERUNMQVJFX1ZBUklBQkxFJykge1xuICAgICAgICBpZiAoYXJndW1lbnROYW1lID09PSAnJykge1xuICAgICAgICAgIGlmIChjaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzU3RhcnRpbmdWYXJpYWJsZU5hbWUudGVzdChjaGFyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YXJpYWJsZSBuYW1lIGlzIG5vdCBleHBlY3RlZCBzdHJpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJndW1lbnROYW1lICs9IGNoYXI7XG4gICAgICAgIGlmICghaXNWYXJpYWJsZUNoYXIudGVzdChuZXh0Q2hhcikpIHtcbiAgICAgICAgICBzdGF0ZXMucG9wKCk7XG4gICAgICAgICAgYXJndW1lbnROYW1lcy5wdXNoKGFyZ3VtZW50TmFtZSk7XG4gICAgICAgICAgYXJndW1lbnRUeXBlcy5wdXNoKHR5cGVNYXBbYXJndW1lbnRUeXBlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAoc3RhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR0xTTCBmdW5jdGlvbiB3YXMgbm90IHBhcnNhYmxlJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhcmd1bWVudE5hbWVzLFxuICAgICAgYXJndW1lbnRUeXBlcyxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIG5hdGl2ZUZ1bmN0aW9uUmV0dXJuVHlwZShzb3VyY2UpIHtcbiAgICByZXR1cm4gdHlwZU1hcFtzb3VyY2UubWF0Y2goL2ludHxmbG9hdHx2ZWNbMi00XS8pWzBdXTtcbiAgfVxuXG4gIHN0YXRpYyBjb21iaW5lS2VybmVscyhjb21iaW5lZEtlcm5lbCwgbGFzdEtlcm5lbCkge1xuICAgIGNvbWJpbmVkS2VybmVsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgY29uc3Qge1xuICAgICAgdGV4U2l6ZSxcbiAgICAgIGNvbnRleHQsXG4gICAgICB0aHJlYWREaW1cbiAgICB9ID0gbGFzdEtlcm5lbC50ZXhTaXplO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGxhc3RLZXJuZWwucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgY29uc3QgdyA9IHRleFNpemVbMF07XG4gICAgICBjb25zdCBoID0gTWF0aC5jZWlsKHRleFNpemVbMV0gLyA0KTtcbiAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkodyAqIGggKiA0ICogNCk7XG4gICAgICBjb250ZXh0LnJlYWRQaXhlbHMoMCwgMCwgdywgaCAqIDQsIGNvbnRleHQuUkdCQSwgY29udGV4dC5GTE9BVCwgcmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh0ZXhTaXplWzBdICogdGV4U2l6ZVsxXSAqIDQpO1xuICAgICAgY29udGV4dC5yZWFkUGl4ZWxzKDAsIDAsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIGNvbnRleHQuUkdCQSwgY29udGV4dC5VTlNJR05FRF9CWVRFLCBieXRlcyk7XG4gICAgICByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGJ5dGVzLmJ1ZmZlcik7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gcmVzdWx0LnN1YmFycmF5KDAsIHRocmVhZERpbVswXSAqIHRocmVhZERpbVsxXSAqIHRocmVhZERpbVsyXSk7XG5cbiAgICBpZiAobGFzdEtlcm5lbC5vdXRwdXQubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAobGFzdEtlcm5lbC5vdXRwdXQubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gdXRpbHMuc3BsaXRBcnJheShyZXN1bHQsIGxhc3RLZXJuZWwub3V0cHV0WzBdKTtcbiAgICB9IGVsc2UgaWYgKGxhc3RLZXJuZWwub3V0cHV0Lmxlbmd0aCA9PT0gMykge1xuICAgICAgY29uc3QgY3ViZSA9IHV0aWxzLnNwbGl0QXJyYXkocmVzdWx0LCBsYXN0S2VybmVsLm91dHB1dFswXSAqIGxhc3RLZXJuZWwub3V0cHV0WzFdKTtcbiAgICAgIHJldHVybiBjdWJlLm1hcChmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB1dGlscy5zcGxpdEFycmF5KHgsIGxhc3RLZXJuZWwub3V0cHV0WzBdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzb3VyY2UsIHNldHRpbmdzKTtcbiAgICB0aGlzLnRyYW5zZmVyVmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyT3V0cHV0ID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlclJhd091dHB1dCA9IG51bGw7XG4gICAgdGhpcy50ZXhTaXplID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zbGF0ZWRTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuY29tcGlsZWRGcmFnbWVudFNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5jb21waWxlZFZlcnRleFNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5zd2l0Y2hpbmdLZXJuZWxzID0gbnVsbDtcbiAgICB0aGlzLl90ZXh0dXJlU3dpdGNoZWQgPSBudWxsO1xuICAgIHRoaXMuX21hcHBlZFRleHR1cmVTd2l0Y2hlZCA9IG51bGw7XG4gIH1cblxuICBjaGVja1RleHR1cmVTaXplKCkge1xuICAgIGNvbnN0IHsgZmVhdHVyZXMgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgaWYgKHRoaXMudGV4U2l6ZVswXSA+IGZlYXR1cmVzLm1heFRleHR1cmVTaXplIHx8IHRoaXMudGV4U2l6ZVsxXSA+IGZlYXR1cmVzLm1heFRleHR1cmVTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRleHR1cmUgc2l6ZSBbJHt0aGlzLnRleFNpemVbMF19LCR7dGhpcy50ZXhTaXplWzFdfV0gZ2VuZXJhdGVkIGJ5IGtlcm5lbCBpcyBsYXJnZXIgdGhhbiBzdXBwb3J0ZWQgc2l6ZSBbJHtmZWF0dXJlcy5tYXhUZXh0dXJlU2l6ZX0sJHtmZWF0dXJlcy5tYXhUZXh0dXJlU2l6ZX1dYCk7XG4gICAgfVxuICB9XG5cbiAgdHJhbnNsYXRlU291cmNlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJ0cmFuc2xhdGVTb3VyY2VcIiBub3QgZGVmaW5lZCBvbiAke3RoaXMuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxuXG4gIHBpY2tSZW5kZXJTdHJhdGVneShhcmdzKSB7XG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICB0aGlzLnJlbmRlclJhd091dHB1dCA9IHRoaXMucmVhZFBhY2tlZFBpeGVsc1RvVWludDhBcnJheTtcbiAgICAgIHRoaXMudHJhbnNmZXJWYWx1ZXMgPSAocGl4ZWxzKSA9PiBwaXhlbHM7XG4gICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUdyYXBoaWNhbDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICd1bnNpZ25lZCcpIHtcbiAgICAgIHRoaXMucmVuZGVyUmF3T3V0cHV0ID0gdGhpcy5yZWFkUGFja2VkUGl4ZWxzVG9VaW50OEFycmF5O1xuICAgICAgdGhpcy50cmFuc2ZlclZhbHVlcyA9IHRoaXMucmVhZFBhY2tlZFBpeGVsc1RvRmxvYXQzMkFycmF5O1xuICAgICAgaWYgKHRoaXMucGlwZWxpbmUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJPdXRwdXQgPSB0aGlzLnJlbmRlclRleHR1cmU7XG4gICAgICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcktlcm5lbHMgPSB0aGlzLnJlbmRlcktlcm5lbHNUb1RleHR1cmVzO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZVVuc2lnbmVkM0Q7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVVbnNpZ25lZDJEO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlVW5zaWduZWQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RmFsbGJhY2soYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcktlcm5lbHMgPSB0aGlzLnJlbmRlcktlcm5lbHNUb0FycmF5cztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICAgIHRoaXMucmVuZGVyT3V0cHV0ID0gdGhpcy5yZW5kZXJWYWx1ZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlVW5zaWduZWQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDNEUGFja2VkRmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVVbnNpZ25lZDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0MkRQYWNrZWRGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZVVuc2lnbmVkO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0UGFja2VkRmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RmFsbGJhY2soYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgdGhpcy5yZW5kZXJSYXdPdXRwdXQgPSB0aGlzLnJlYWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5O1xuICAgICAgdGhpcy50cmFuc2ZlclZhbHVlcyA9IHRoaXMucmVhZEZsb2F0UGl4ZWxzVG9GbG9hdDMyQXJyYXk7XG4gICAgICBpZiAodGhpcy5waXBlbGluZSkge1xuICAgICAgICB0aGlzLnJlbmRlck91dHB1dCA9IHRoaXMucmVuZGVyVGV4dHVyZTtcbiAgICAgICAgaWYgKHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyS2VybmVscyA9IHRoaXMucmVuZGVyS2VybmVsc1RvVGV4dHVyZXM7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkM0Q7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQyRDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlRmxvYXQzRDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUZsb2F0MkQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVGbG9hdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSgyKSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDNEO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkyRmxvYXQyRDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMyknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQzRDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0MkQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTNGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDQpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5NEZsb2F0M0Q7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDJEO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPdXRwdXQgPSB0aGlzLnJlbmRlclZhbHVlcztcbiAgICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJLZXJuZWxzID0gdGhpcy5yZW5kZXJLZXJuZWxzVG9BcnJheXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkM0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RNZW1vcnlPcHRpbWl6ZWQzREZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkMkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RNZW1vcnlPcHRpbWl6ZWQyREZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0TWVtb3J5T3B0aW1pemVkRmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSgyKSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0M0RBcnJheTI7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0MkRBcnJheTI7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdEFycmF5MjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDMpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0M0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QzREFycmF5MztcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0MkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QyREFycmF5MztcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0O1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0QXJyYXkzO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoNCknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDNEQXJyYXk0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQyRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDJEQXJyYXk0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RBcnJheTQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVGbG9hdDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0M0RGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUZsb2F0MkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QyREZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlRmxvYXQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDIpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0M0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QzREFycmF5MjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0MkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QyREFycmF5MjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0O1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0QXJyYXkyO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMyknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDNEQXJyYXkzO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQyRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDJEQXJyYXkzO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RBcnJheTM7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSg0KSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0M0RBcnJheTQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0MkRBcnJheTQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdEFycmF5NDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHByZWNpc2lvbiBvZiBcIiR7dGhpcy5wcmVjaXNpb259XCJgKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCByZXR1cm4gdHlwZSBcIiR7dGhpcy5yZXR1cm5UeXBlfVwiYCk7XG4gIH1cblxuICBnZXRLZXJuZWxTdHJpbmcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFRleHR1cmUoKSB7XG4gICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdE51bWJlclRleHR1cmUoKTtcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEFycmF5MlRleHR1cmUoKTtcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEFycmF5M1RleHR1cmUoKTtcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEFycmF5NFRleHR1cmUoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHJldHVyblR5cGUgdHlwZSAkeyB0aGlzLnJldHVyblR5cGUgfWApO1xuICAgIH1cbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxOdW1iZXJUZXh0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsTnVtYmVyVGV4dHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5MlRleHR1cmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTJUZXh0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkzVGV4dHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5M1RleHR1cmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXk0VGV4dHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdEdyYXBoaWNhbCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdE1lbW9yeU9wdGltaXplZEZsb2F0cygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdFBhY2tlZFBpeGVscygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3RyaW5nKCkge1xuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEdyYXBoaWNhbCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICBpZiAodGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRNZW1vcnlPcHRpbWl6ZWRGbG9hdHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRUZXh0dXJlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRQYWNrZWRQaXhlbHMoKTtcbiAgICB9XG4gIH1cblxuICBnZXRNYWluUmVzdWx0TnVtYmVyVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxOdW1iZXJUZXh0dXJlKCkpICtcbiAgICAgIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsTnVtYmVyVGV4dHVyZSgpKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRBcnJheTJUZXh0dXJlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5MlRleHR1cmUoKSkgK1xuICAgICAgdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTJUZXh0dXJlKCkpO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEFycmF5M1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0S2VybmVsQXJyYXkzVGV4dHVyZSgpKSArXG4gICAgICB1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5M1RleHR1cmUoKSk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0QXJyYXk0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxBcnJheTRUZXh0dXJlKCkpICtcbiAgICAgIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXk0VGV4dHVyZSgpKTtcbiAgfVxuXG4gIGdldEZsb2F0VGFjdGljRGVjbGFyYXRpb24oKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4U2l6ZSwgdGhpcy50YWN0aWMpO1xuICAgIHJldHVybiBgcHJlY2lzaW9uICR7dmFyaWFibGVQcmVjaXNpb259IGZsb2F0O1xcbmA7XG4gIH1cblxuICBnZXRJbnRUYWN0aWNEZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gYHByZWNpc2lvbiAke3RoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcodGhpcy50ZXhTaXplLCB0aGlzLnRhY3RpYywgdHJ1ZSl9IGludDtcXG5gO1xuICB9XG5cbiAgZ2V0U2FtcGxlcjJEVGFjdGljRGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIGBwcmVjaXNpb24gJHt0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4U2l6ZSwgdGhpcy50YWN0aWMpfSBzYW1wbGVyMkQ7XFxuYDtcbiAgfVxuXG4gIGdldFNhbXBsZXIyREFycmF5VGFjdGljRGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIGBwcmVjaXNpb24gJHt0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4U2l6ZSwgdGhpcy50YWN0aWMpfSBzYW1wbGVyMkRBcnJheTtcXG5gO1xuICB9XG5cbiAgcmVuZGVyVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbW11dGFibGUgPyB0aGlzLnRleHR1cmUuY2xvbmUoKSA6IHRoaXMudGV4dHVyZTtcbiAgfVxuICByZWFkUGFja2VkUGl4ZWxzVG9VaW50OEFycmF5KCkge1xuICAgIGlmICh0aGlzLnByZWNpc2lvbiAhPT0gJ3Vuc2lnbmVkJykgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlcyB0aGlzLnByZWNpc2lvbiB0byBiZSBcInVuc2lnbmVkXCInKTtcbiAgICBjb25zdCB7XG4gICAgICB0ZXhTaXplLFxuICAgICAgY29udGV4dDogZ2xcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0ZXhTaXplWzBdICogdGV4U2l6ZVsxXSAqIDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVhZFBhY2tlZFBpeGVsc1RvRmxvYXQzMkFycmF5KCkge1xuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMucmVhZFBhY2tlZFBpeGVsc1RvVWludDhBcnJheSgpLmJ1ZmZlcik7XG4gIH1cblxuICByZWFkRmxvYXRQaXhlbHNUb0Zsb2F0MzJBcnJheSgpIHtcbiAgICBpZiAodGhpcy5wcmVjaXNpb24gIT09ICdzaW5nbGUnKSB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVzIHRoaXMucHJlY2lzaW9uIHRvIGJlIFwic2luZ2xlXCInKTtcbiAgICBjb25zdCB7XG4gICAgICB0ZXhTaXplLFxuICAgICAgY29udGV4dDogZ2xcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB3ID0gdGV4U2l6ZVswXTtcbiAgICBjb25zdCBoID0gdGV4U2l6ZVsxXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KHcgKiBoICogNCk7XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCB3LCBoLCBnbC5SR0JBLCBnbC5GTE9BVCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0UGl4ZWxzKGZsaXApIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0OiBnbCxcbiAgICAgIG91dHB1dFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IG91dHB1dDtcbiAgICBjb25zdCBwaXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KChmbGlwID8gcGl4ZWxzIDogdXRpbHMuZmxpcFBpeGVscyhwaXhlbHMsIHdpZHRoLCBoZWlnaHQpKS5idWZmZXIpO1xuICB9XG5cbiAgcmVuZGVyS2VybmVsc1RvQXJyYXlzKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHJlc3VsdDogdGhpcy5yZW5kZXJPdXRwdXQoKSxcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbdGhpcy5zdWJLZXJuZWxzW2ldLnByb3BlcnR5XSA9IHRoaXMubWFwcGVkVGV4dHVyZXNbaV0udG9BcnJheSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVuZGVyS2VybmVsc1RvVGV4dHVyZXMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcmVzdWx0OiB0aGlzLnJlbmRlck91dHB1dCgpLFxuICAgIH07XG4gICAgaWYgKHRoaXMuaW1tdXRhYmxlKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRbdGhpcy5zdWJLZXJuZWxzW2ldLnByb3BlcnR5XSA9IHRoaXMubWFwcGVkVGV4dHVyZXNbaV0uY2xvbmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W3RoaXMuc3ViS2VybmVsc1tpXS5wcm9wZXJ0eV0gPSB0aGlzLm1hcHBlZFRleHR1cmVzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVzZXRTd2l0Y2hpbmdLZXJuZWxzKCkge1xuICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSB0aGlzLnN3aXRjaGluZ0tlcm5lbHM7XG4gICAgdGhpcy5zd2l0Y2hpbmdLZXJuZWxzID0gbnVsbDtcbiAgICByZXR1cm4gZXhpc3RpbmdWYWx1ZTtcbiAgfVxuXG4gIHNldE91dHB1dChvdXRwdXQpIHtcbiAgICBjb25zdCBuZXdPdXRwdXQgPSB0aGlzLnRvS2VybmVsT3V0cHV0KG91dHB1dCk7XG4gICAgaWYgKHRoaXMucHJvZ3JhbSkge1xuICAgICAgaWYgKCF0aGlzLmR5bmFtaWNPdXRwdXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemluZyBhIGtlcm5lbCB3aXRoIGR5bmFtaWNPdXRwdXQ6IGZhbHNlIGlzIG5vdCBwb3NzaWJsZScpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3VGhyZWFkRGltID0gW25ld091dHB1dFswXSwgbmV3T3V0cHV0WzFdIHx8IDEsIG5ld091dHB1dFsyXSB8fCAxXTtcbiAgICAgIGNvbnN0IG5ld1RleFNpemUgPSB1dGlscy5nZXRLZXJuZWxUZXh0dXJlU2l6ZSh7XG4gICAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgICAgcHJlY2lzaW9uOiB0aGlzLnByZWNpc2lvbixcbiAgICAgIH0sIG5ld1RocmVhZERpbSk7XG4gICAgICBjb25zdCBvbGRUZXhTaXplID0gdGhpcy50ZXhTaXplO1xuICAgICAgaWYgKG9sZFRleFNpemUpIHtcbiAgICAgICAgY29uc3Qgb2xkUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZyhvbGRUZXhTaXplLCB0aGlzLnRhY3RpYyk7XG4gICAgICAgIGNvbnN0IG5ld1ByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcobmV3VGV4U2l6ZSwgdGhpcy50YWN0aWMpO1xuICAgICAgICBpZiAob2xkUHJlY2lzaW9uICE9PSBuZXdQcmVjaXNpb24pIHtcbiAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdQcmVjaXNpb24gcmVxdWlyZW1lbnQgY2hhbmdlZCwgYXNraW5nIEdQVSBpbnN0YW5jZSB0byByZWNvbXBpbGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zd2l0Y2hLZXJuZWxzKHtcbiAgICAgICAgICAgIHR5cGU6ICdvdXRwdXRQcmVjaXNpb25NaXNtYXRjaCcsXG4gICAgICAgICAgICBwcmVjaXNpb246IG5ld1ByZWNpc2lvbixcbiAgICAgICAgICAgIG5lZWRlZDogb3V0cHV0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm91dHB1dCA9IG5ld091dHB1dDtcbiAgICAgIHRoaXMudGhyZWFkRGltID0gbmV3VGhyZWFkRGltO1xuICAgICAgdGhpcy50ZXhTaXplID0gbmV3VGV4U2l6ZTtcbiAgICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgdGhpcy51cGRhdGVNYXhUZXhTaXplKCk7XG4gICAgICB0aGlzLmZyYW1lYnVmZmVyLndpZHRoID0gdGhpcy50ZXhTaXplWzBdO1xuICAgICAgdGhpcy5mcmFtZWJ1ZmZlci5oZWlnaHQgPSB0aGlzLnRleFNpemVbMV07XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLm1heFRleFNpemVbMF0sIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMubWF4VGV4U2l6ZVswXTtcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMubWF4VGV4U2l6ZVsxXTtcbiAgICAgIGlmICh0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlLmRlbGV0ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICAgIHRoaXMuX3NldHVwT3V0cHV0VGV4dHVyZSgpO1xuICAgICAgaWYgKHRoaXMubWFwcGVkVGV4dHVyZXMgJiYgdGhpcy5tYXBwZWRUZXh0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXBwZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXNbaV0uZGVsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXBwZWRUZXh0dXJlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NldHVwU3ViT3V0cHV0VGV4dHVyZXMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vdXRwdXQgPSBuZXdPdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbmRlclZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRWYWx1ZXMoXG4gICAgICB0aGlzLnRyYW5zZmVyVmFsdWVzKCksXG4gICAgICB0aGlzLm91dHB1dFswXSxcbiAgICAgIHRoaXMub3V0cHV0WzFdLFxuICAgICAgdGhpcy5vdXRwdXRbMl1cbiAgICApO1xuICB9XG4gIHN3aXRjaEtlcm5lbHMocmVhc29uKSB7XG4gICAgaWYgKHRoaXMuc3dpdGNoaW5nS2VybmVscykge1xuICAgICAgdGhpcy5zd2l0Y2hpbmdLZXJuZWxzLnB1c2gocmVhc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zd2l0Y2hpbmdLZXJuZWxzID0gW3JlYXNvbl07XG4gICAgfVxuICB9XG4gIGdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRleHR1cmVTaXplID0gdGhpcy50ZXhTaXplLCB0YWN0aWMgPSB0aGlzLnRhY3RpYywgaXNJbnQgPSBmYWxzZSkge1xuICAgIGlmICghdGFjdGljKSB7XG4gICAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuZmVhdHVyZXMuaXNTcGVlZFRhY3RpY1N1cHBvcnRlZCkgcmV0dXJuICdoaWdocCc7XG4gICAgICBjb25zdCBsb3cgPSB0aGlzLmNvbnN0cnVjdG9yLmZlYXR1cmVzW2lzSW50ID8gJ2xvd0ludFByZWNpc2lvbicgOiAnbG93RmxvYXRQcmVjaXNpb24nXTtcbiAgICAgIGNvbnN0IG1lZGl1bSA9IHRoaXMuY29uc3RydWN0b3IuZmVhdHVyZXNbaXNJbnQgPyAnbWVkaXVtSW50UHJlY2lzaW9uJyA6ICdtZWRpdW1GbG9hdFByZWNpc2lvbiddO1xuICAgICAgY29uc3QgaGlnaCA9IHRoaXMuY29uc3RydWN0b3IuZmVhdHVyZXNbaXNJbnQgPyAnaGlnaEludFByZWNpc2lvbicgOiAnaGlnaEZsb2F0UHJlY2lzaW9uJ107XG4gICAgICBjb25zdCByZXF1aXJlZFNpemUgPSBNYXRoLmxvZzIodGV4dHVyZVNpemVbMF0gKiB0ZXh0dXJlU2l6ZVsxXSk7XG4gICAgICBpZiAocmVxdWlyZWRTaXplIDw9IGxvdy5yYW5nZU1heCkge1xuICAgICAgICByZXR1cm4gJ2xvd3AnO1xuICAgICAgfSBlbHNlIGlmIChyZXF1aXJlZFNpemUgPD0gbWVkaXVtLnJhbmdlTWF4KSB7XG4gICAgICAgIHJldHVybiAnbWVkaXVtcCc7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVpcmVkU2l6ZSA8PSBoaWdoLnJhbmdlTWF4KSB7XG4gICAgICAgIHJldHVybiAnaGlnaHAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcmVxdWlyZWQgc2l6ZSBleGNlZWRzIHRoYXQgb2YgdGhlIGFiaWxpdHkgb2YgeW91ciBzeXN0ZW1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0YWN0aWMpIHtcbiAgICAgIGNhc2UgJ3NwZWVkJzpcbiAgICAgICAgcmV0dXJuICdsb3dwJztcbiAgICAgIGNhc2UgJ2JhbGFuY2VkJzpcbiAgICAgICAgcmV0dXJuICdtZWRpdW1wJztcbiAgICAgIGNhc2UgJ3ByZWNpc2lvbic6XG4gICAgICAgIHJldHVybiAnaGlnaHAnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRhY3RpYyBcIiR7dGFjdGljfVwiIHVzZSBcInNwZWVkXCIsIFwiYmFsYW5jZWRcIiwgXCJwcmVjaXNpb25cIiwgb3IgZW1wdHkgZm9yIGF1dG9gKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVUZXh0dXJlQXJndW1lbnRSZWZzKGtlcm5lbFZhbHVlLCBhcmcpIHtcbiAgICBpZiAoIXRoaXMuaW1tdXRhYmxlKSByZXR1cm47XG4gICAgaWYgKHRoaXMudGV4dHVyZS50ZXh0dXJlID09PSBhcmcudGV4dHVyZSkge1xuICAgICAgY29uc3QgeyBwcmV2QXJnIH0gPSBrZXJuZWxWYWx1ZTtcbiAgICAgIGlmIChwcmV2QXJnKSB7XG4gICAgICAgIGlmIChwcmV2QXJnLnRleHR1cmUuX3JlZnMgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLnRleHR1cmUuZGVsZXRlKCk7XG4gICAgICAgICAgdGhpcy50ZXh0dXJlID0gcHJldkFyZy5jbG9uZSgpO1xuICAgICAgICAgIHRoaXMuX3RleHR1cmVTd2l0Y2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkFyZy5kZWxldGUoKTtcbiAgICAgIH1cbiAgICAgIGtlcm5lbFZhbHVlLnByZXZBcmcgPSBhcmcuY2xvbmUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWFwcGVkVGV4dHVyZXMgJiYgdGhpcy5tYXBwZWRUZXh0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB7IG1hcHBlZFRleHR1cmVzIH0gPSB0aGlzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBwZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBtYXBwZWRUZXh0dXJlID0gbWFwcGVkVGV4dHVyZXNbaV07XG4gICAgICAgIGlmIChtYXBwZWRUZXh0dXJlLnRleHR1cmUgPT09IGFyZy50ZXh0dXJlKSB7XG4gICAgICAgICAgY29uc3QgeyBwcmV2QXJnIH0gPSBrZXJuZWxWYWx1ZTtcbiAgICAgICAgICBpZiAocHJldkFyZykge1xuICAgICAgICAgICAgaWYgKHByZXZBcmcudGV4dHVyZS5fcmVmcyA9PT0gMSkge1xuICAgICAgICAgICAgICBtYXBwZWRUZXh0dXJlLmRlbGV0ZSgpO1xuICAgICAgICAgICAgICBtYXBwZWRUZXh0dXJlc1tpXSA9IHByZXZBcmcuY2xvbmUoKTtcbiAgICAgICAgICAgICAgdGhpcy5fbWFwcGVkVGV4dHVyZVN3aXRjaGVkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZBcmcuZGVsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtlcm5lbFZhbHVlLnByZXZBcmcgPSBhcmcuY2xvbmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkFjdGl2YXRlKHByZXZpb3VzS2VybmVsKSB7XG4gICAgdGhpcy5fdGV4dHVyZVN3aXRjaGVkID0gdHJ1ZTtcbiAgICB0aGlzLnRleHR1cmUgPSBwcmV2aW91c0tlcm5lbC50ZXh0dXJlO1xuICAgIGlmICh0aGlzLm1hcHBlZFRleHR1cmVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFwcGVkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fbWFwcGVkVGV4dHVyZVN3aXRjaGVkW2ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXMgPSBwcmV2aW91c0tlcm5lbC5tYXBwZWRUZXh0dXJlcztcbiAgICB9XG4gIH1cblxuICBpbml0Q2FudmFzKCkge31cbn1cblxuY29uc3QgdHlwZU1hcCA9IHtcbiAgaW50OiAnSW50ZWdlcicsXG4gIGZsb2F0OiAnTnVtYmVyJyxcbiAgdmVjMjogJ0FycmF5KDIpJyxcbiAgdmVjMzogJ0FycmF5KDMpJyxcbiAgdmVjNDogJ0FycmF5KDQpJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTEtlcm5lbFxufTtcbn0se1wiLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi9rZXJuZWxcIjozNixcIi4vdGV4dHVyZS9hcnJheS0yLWZsb2F0XCI6MTYsXCIuL3RleHR1cmUvYXJyYXktMi1mbG9hdC0yZFwiOjE0LFwiLi90ZXh0dXJlL2FycmF5LTItZmxvYXQtM2RcIjoxNSxcIi4vdGV4dHVyZS9hcnJheS0zLWZsb2F0XCI6MTksXCIuL3RleHR1cmUvYXJyYXktMy1mbG9hdC0yZFwiOjE3LFwiLi90ZXh0dXJlL2FycmF5LTMtZmxvYXQtM2RcIjoxOCxcIi4vdGV4dHVyZS9hcnJheS00LWZsb2F0XCI6MjIsXCIuL3RleHR1cmUvYXJyYXktNC1mbG9hdC0yZFwiOjIwLFwiLi90ZXh0dXJlL2FycmF5LTQtZmxvYXQtM2RcIjoyMSxcIi4vdGV4dHVyZS9mbG9hdFwiOjI1LFwiLi90ZXh0dXJlL2Zsb2F0LTJkXCI6MjMsXCIuL3RleHR1cmUvZmxvYXQtM2RcIjoyNCxcIi4vdGV4dHVyZS9ncmFwaGljYWxcIjoyNixcIi4vdGV4dHVyZS9tZW1vcnktb3B0aW1pemVkXCI6MzAsXCIuL3RleHR1cmUvbWVtb3J5LW9wdGltaXplZC0yZFwiOjI4LFwiLi90ZXh0dXJlL21lbW9yeS1vcHRpbWl6ZWQtM2RcIjoyOSxcIi4vdGV4dHVyZS91bnNpZ25lZFwiOjMzLFwiLi90ZXh0dXJlL3Vuc2lnbmVkLTJkXCI6MzEsXCIuL3RleHR1cmUvdW5zaWduZWQtM2RcIjozMn1dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUFycmF5MkZsb2F0MkQgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoMiknO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0MkRBcnJheTIodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXkyRmxvYXQyRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTJGbG9hdDNEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDIpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDNEQXJyYXkyKHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSwgdGhpcy5vdXRwdXRbMl0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTJGbG9hdDNEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUFycmF5MkZsb2F0IGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDIpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdEFycmF5Mih0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTJGbG9hdFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTNGbG9hdDJEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDMpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDJEQXJyYXkzKHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUFycmF5M0Zsb2F0MkRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlQXJyYXkzRmxvYXQzRCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgzKSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QzREFycmF5Myh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0sIHRoaXMub3V0cHV0WzJdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXkzRmxvYXQzRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTNGbG9hdCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgzKSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RBcnJheTModGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTNGbG9hdFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTRGbG9hdDJEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDQpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDJEQXJyYXk0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUFycmF5NEZsb2F0MkRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlQXJyYXk0RmxvYXQzRCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSg0KSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QzREFycmF5NCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0sIHRoaXMub3V0cHV0WzJdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXk0RmxvYXQzRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTRGbG9hdCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSg0KSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RBcnJheTQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTRGbG9hdFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVGbG9hdDJEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDEpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDJERmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlRmxvYXQyRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVGbG9hdDNEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDEpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDNERmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdLCB0aGlzLm91dHB1dFsyXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUZsb2F0M0Rcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUZsb2F0IGV4dGVuZHMgR0xUZXh0dXJlIHtcbiAgZ2V0IHRleHR1cmVUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuRkxPQVQ7XG4gIH1cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgxKSc7XG4gIH1cbiAgcmVuZGVyUmF3T3V0cHV0KCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKCkpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCxcbiAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICB0aGlzLnRleHR1cmUsXG4gICAgICAwXG4gICAgKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KHNpemVbMF0gKiBzaXplWzFdICogNCk7XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCBzaXplWzBdLCBzaXplWzFdLCBnbC5SR0JBLCBnbC5GTE9BVCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlbmRlclZhbHVlcygpIHtcbiAgICBpZiAodGhpcy5fZGVsZXRlZCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyUmF3T3V0cHV0KCk7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RGbG9hdCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUZsb2F0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaW5kZXhcIjoyN31dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgR0xUZXh0dXJlVW5zaWduZWQgfSA9IHJlcXVpcmUoJy4vdW5zaWduZWQnKTtcblxuY2xhc3MgR0xUZXh0dXJlR3JhcGhpY2FsIGV4dGVuZHMgR0xUZXh0dXJlVW5zaWduZWQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDQpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclZhbHVlcygpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVHcmFwaGljYWxcbn07XG59LHtcIi4vdW5zaWduZWRcIjozM31dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdGV4dHVyZScpO1xuXG5jbGFzcyBHTFRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcbiAgZ2V0IHRleHR1cmVUeXBlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJ0ZXh0dXJlVHlwZVwiIG5vdCBpbXBsZW1lbnRlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuICB9XG5cbiAgYmVmb3JlTXV0YXRlKCkge1xuICAgIGlmICh0aGlzLnRleHR1cmUuX3JlZnMgPiAxKSB7XG4gICAgICB0aGlzLm5ld1RleHR1cmUoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjbG9uZVRleHR1cmUoKSB7XG4gICAgdGhpcy50ZXh0dXJlLl9yZWZzLS07XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCwgc2l6ZSwgdGV4dHVyZSwga2VybmVsIH0gPSB0aGlzO1xuICAgIGlmIChrZXJuZWwuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUud2FybignY2xvbmluZyBpbnRlcm5hbCB0ZXh0dXJlJyk7XG4gICAgfVxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcigpKTtcbiAgICBzZWxlY3RUZXh0dXJlKGdsLCB0ZXh0dXJlKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgIGNvbnN0IHRhcmdldCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBzZWxlY3RUZXh0dXJlKGdsLCB0YXJnZXQpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5pbnRlcm5hbEZvcm1hdCwgc2l6ZVswXSwgc2l6ZVsxXSwgMCwgdGhpcy50ZXh0dXJlRm9ybWF0LCB0aGlzLnRleHR1cmVUeXBlLCBudWxsKTtcbiAgICBnbC5jb3B5VGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCAwLCAwLCBzaXplWzBdLCBzaXplWzFdKTtcbiAgICB0YXJnZXQuX3JlZnMgPSAxO1xuICAgIHRoaXMudGV4dHVyZSA9IHRhcmdldDtcbiAgfVxuXG4gIG5ld1RleHR1cmUoKSB7XG4gICAgdGhpcy50ZXh0dXJlLl9yZWZzLS07XG4gICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBjb25zdCBrZXJuZWwgPSB0aGlzLmtlcm5lbDtcbiAgICBpZiAoa2VybmVsLmRlYnVnKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ25ldyBpbnRlcm5hbCB0ZXh0dXJlJyk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBzZWxlY3RUZXh0dXJlKGdsLCB0YXJnZXQpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5pbnRlcm5hbEZvcm1hdCwgc2l6ZVswXSwgc2l6ZVsxXSwgMCwgdGhpcy50ZXh0dXJlRm9ybWF0LCB0aGlzLnRleHR1cmVUeXBlLCBudWxsKTtcbiAgICB0YXJnZXQuX3JlZnMgPSAxO1xuICAgIHRoaXMudGV4dHVyZSA9IHRhcmdldDtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLnRleHR1cmUuX3JlZnMpIHtcbiAgICAgIHRoaXMudGV4dHVyZS5fcmVmcy0tO1xuICAgICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBzZWxlY3RUZXh0dXJlKGdsLCB0YXJnZXQpO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHRhcmdldC5fcmVmcyA9IDE7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuaW50ZXJuYWxGb3JtYXQsIHNpemVbMF0sIHNpemVbMV0sIDAsIHRoaXMudGV4dHVyZUZvcm1hdCwgdGhpcy50ZXh0dXJlVHlwZSwgbnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wsIHRleHR1cmUgfSA9IHRoaXM7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKCkpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIHNlbGVjdFRleHR1cmUoZ2wsIHRleHR1cmUpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG4gIH1cblxuICBkZWxldGUoKSB7XG4gICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHJldHVybjtcbiAgICB0aGlzLl9kZWxldGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy50ZXh0dXJlLl9yZWZzKSB7XG4gICAgICB0aGlzLnRleHR1cmUuX3JlZnMtLTtcbiAgICAgIGlmICh0aGlzLnRleHR1cmUuX3JlZnMpIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0LmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcbiAgICBpZiAodGhpcy50ZXh0dXJlLl9yZWZzID09PSAwICYmIHRoaXMuX2ZyYW1lYnVmZmVyKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5fZnJhbWVidWZmZXIpO1xuICAgICAgdGhpcy5fZnJhbWVidWZmZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZyYW1lYnVmZmVyKCkge1xuICAgIGlmICghdGhpcy5fZnJhbWVidWZmZXIpIHtcbiAgICAgIHRoaXMuX2ZyYW1lYnVmZmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgfVxuICAgIHRoaXMuX2ZyYW1lYnVmZmVyLndpZHRoID0gdGhpcy5zaXplWzBdO1xuICAgIHRoaXMuX2ZyYW1lYnVmZmVyLmhlaWdodCA9IHRoaXMuc2l6ZVsxXTtcbiAgICByZXR1cm4gdGhpcy5fZnJhbWVidWZmZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VsZWN0VGV4dHVyZShnbCwgdGV4dHVyZSkge1xuICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxNSk7XG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgR0xUZXh0dXJlIH07XG59LHtcIi4uLy4uLy4uL3RleHR1cmVcIjoxMTN9XSwyODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQyRCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0TWVtb3J5T3B0aW1pemVkMkRGbG9hdCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQyRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQzRCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0TWVtb3J5T3B0aW1pemVkM0RGbG9hdCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0sIHRoaXMub3V0cHV0WzJdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkM0Rcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RNZW1vcnlPcHRpbWl6ZWRGbG9hdCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVVbnNpZ25lZCB9ID0gcmVxdWlyZSgnLi91bnNpZ25lZCcpO1xuXG5jbGFzcyBHTFRleHR1cmVVbnNpZ25lZDJEIGV4dGVuZHMgR0xUZXh0dXJlVW5zaWduZWQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnTnVtYmVyVGV4dHVyZSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QyRFBhY2tlZEZsb2F0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZVVuc2lnbmVkMkRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi91bnNpZ25lZFwiOjMzfV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlVW5zaWduZWQgfSA9IHJlcXVpcmUoJy4vdW5zaWduZWQnKTtcblxuY2xhc3MgR0xUZXh0dXJlVW5zaWduZWQzRCBleHRlbmRzIEdMVGV4dHVyZVVuc2lnbmVkIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ051bWJlclRleHR1cmUnO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0M0RQYWNrZWRGbG9hdCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0sIHRoaXMub3V0cHV0WzJdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlVW5zaWduZWQzRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL3Vuc2lnbmVkXCI6MzN9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuY2xhc3MgR0xUZXh0dXJlVW5zaWduZWQgZXh0ZW5kcyBHTFRleHR1cmUge1xuICBnZXQgdGV4dHVyZVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5VTlNJR05FRF9CWVRFO1xuICB9XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdOdW1iZXJUZXh0dXJlJztcbiAgfVxuICByZW5kZXJSYXdPdXRwdXQoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICBnbC5GUkFNRUJVRkZFUixcbiAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgIHRoaXMudGV4dHVyZSxcbiAgICAgIDBcbiAgICApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuc2l6ZVswXSAqIHRoaXMuc2l6ZVsxXSAqIDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgdGhpcy5zaXplWzBdLCB0aGlzLnNpemVbMV0sIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZW5kZXJWYWx1ZXMoKSB7XG4gICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMucmVuZGVyUmF3T3V0cHV0KCkuYnVmZmVyKTtcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdFBhY2tlZEZsb2F0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlVW5zaWduZWRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9pbmRleFwiOjI3fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgZ2V0Q29udGV4dCA9IHJlcXVpcmUoJ2dsJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsIH0gPSByZXF1aXJlKCcuLi93ZWItZ2wva2VybmVsJyk7XG5jb25zdCB7IGdsS2VybmVsU3RyaW5nIH0gPSByZXF1aXJlKCcuLi9nbC9rZXJuZWwtc3RyaW5nJyk7XG5cbmxldCBpc1N1cHBvcnRlZCA9IG51bGw7XG5sZXQgdGVzdENhbnZhcyA9IG51bGw7XG5sZXQgdGVzdENvbnRleHQgPSBudWxsO1xubGV0IHRlc3RFeHRlbnNpb25zID0gbnVsbDtcbmxldCBmZWF0dXJlcyA9IG51bGw7XG5cbmNsYXNzIEhlYWRsZXNzR0xLZXJuZWwgZXh0ZW5kcyBXZWJHTEtlcm5lbCB7XG4gIHN0YXRpYyBnZXQgaXNTdXBwb3J0ZWQoKSB7XG4gICAgaWYgKGlzU3VwcG9ydGVkICE9PSBudWxsKSByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gICAgdGhpcy5zZXR1cEZlYXR1cmVDaGVja3MoKTtcbiAgICBpc1N1cHBvcnRlZCA9IHRlc3RDb250ZXh0ICE9PSBudWxsO1xuICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHN0YXRpYyBzZXR1cEZlYXR1cmVDaGVja3MoKSB7XG4gICAgdGVzdENhbnZhcyA9IG51bGw7XG4gICAgdGVzdEV4dGVuc2lvbnMgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgZ2V0Q29udGV4dCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuICAgIHRyeSB7IFxuICAgICAgdGVzdENvbnRleHQgPSBnZXRDb250ZXh0KDIsIDIsIHtcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmICghdGVzdENvbnRleHQgfHwgIXRlc3RDb250ZXh0LmdldEV4dGVuc2lvbikgcmV0dXJuO1xuICAgICAgdGVzdEV4dGVuc2lvbnMgPSB7XG4gICAgICAgIFNUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXI6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignU1RBQ0tHTF9yZXNpemVfZHJhd2luZ2J1ZmZlcicpLFxuICAgICAgICBTVEFDS0dMX2Rlc3Ryb3lfY29udGV4dDogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdTVEFDS0dMX2Rlc3Ryb3lfY29udGV4dCcpLFxuICAgICAgICBPRVNfdGV4dHVyZV9mbG9hdDogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpLFxuICAgICAgICBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXI6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyksXG4gICAgICAgIE9FU19lbGVtZW50X2luZGV4X3VpbnQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpLFxuICAgICAgICBXRUJHTF9kcmF3X2J1ZmZlcnM6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignV0VCR0xfZHJhd19idWZmZXJzJyksXG4gICAgICAgIFdFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdDogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKSxcbiAgICAgIH07XG4gICAgICBmZWF0dXJlcyA9IHRoaXMuZ2V0RmVhdHVyZXMoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGlzQ29udGV4dE1hdGNoKGNvbnRleHQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0UGFyYW1ldGVyKGNvbnRleHQuUkVOREVSRVIpID09PSAnQU5HTEUnO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0SXNUZXh0dXJlRmxvYXQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGVzdEV4dGVuc2lvbnMuT0VTX3RleHR1cmVfZmxvYXQpO1xuICB9XG5cbiAgc3RhdGljIGdldElzRHJhd0J1ZmZlcnMoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGVzdEV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRDaGFubmVsQ291bnQoKSB7XG4gICAgcmV0dXJuIHRlc3RFeHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycyA/XG4gICAgICB0ZXN0Q29udGV4dC5nZXRQYXJhbWV0ZXIodGVzdEV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzLk1BWF9EUkFXX0JVRkZFUlNfV0VCR0wpIDpcbiAgICAgIDE7XG4gIH1cblxuICBzdGF0aWMgZ2V0TWF4VGV4dHVyZVNpemUoKSB7XG4gICAgcmV0dXJuIHRlc3RDb250ZXh0LmdldFBhcmFtZXRlcih0ZXN0Q29udGV4dC5NQVhfVEVYVFVSRV9TSVpFKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVzdENhbnZhcygpIHtcbiAgICByZXR1cm4gdGVzdENhbnZhcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVzdENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRlc3RDb250ZXh0O1xuICB9XG5cbiAgc3RhdGljIGdldCBmZWF0dXJlcygpIHtcbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH1cblxuICBpbml0Q2FudmFzKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGluaXRDb250ZXh0KCkge1xuICAgIHJldHVybiBnZXRDb250ZXh0KDIsIDIsIHtcbiAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgaW5pdEV4dGVuc2lvbnMoKSB7XG4gICAgdGhpcy5leHRlbnNpb25zID0ge1xuICAgICAgU1RBQ0tHTF9yZXNpemVfZHJhd2luZ2J1ZmZlcjogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignU1RBQ0tHTF9yZXNpemVfZHJhd2luZ2J1ZmZlcicpLFxuICAgICAgU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQ6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ1NUQUNLR0xfZGVzdHJveV9jb250ZXh0JyksXG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSxcbiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcjogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyksXG4gICAgICBPRVNfZWxlbWVudF9pbmRleF91aW50OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JyksXG4gICAgICBXRUJHTF9kcmF3X2J1ZmZlcnM6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpLFxuICAgIH07XG4gIH1cblxuICBidWlsZCgpIHtcbiAgICBzdXBlci5idWlsZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICghdGhpcy5mYWxsYmFja1JlcXVlc3RlZCkge1xuICAgICAgdGhpcy5leHRlbnNpb25zLlNUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXIucmVzaXplKHRoaXMubWF4VGV4U2l6ZVswXSwgdGhpcy5tYXhUZXhTaXplWzFdKTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95RXh0ZW5zaW9ucygpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMuU1RBQ0tHTF9yZXNpemVfZHJhd2luZ2J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLlNUQUNLR0xfZGVzdHJveV9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmV4dGVuc2lvbnMuT0VTX3RleHR1cmVfZmxvYXQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5PRVNfZWxlbWVudF9pbmRleF91aW50ID0gbnVsbDtcbiAgICB0aGlzLmV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBkZXN0cm95Q29udGV4dChjb250ZXh0KSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gY29udGV4dC5nZXRFeHRlbnNpb24oJ1NUQUNLR0xfZGVzdHJveV9jb250ZXh0Jyk7XG4gICAgaWYgKGV4dGVuc2lvbiAmJiBleHRlbnNpb24uZGVzdHJveSkge1xuICAgICAgZXh0ZW5zaW9uLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBzZXR1cENvbnRleHRTdHJpbmcgPSBgY29uc3QgZ2wgPSBjb250ZXh0IHx8IHJlcXVpcmUoJ2dsJykoMSwgMSk7XFxuYDtcbiAgICBjb25zdCBkZXN0cm95Q29udGV4dFN0cmluZyA9IGAgICAgaWYgKCFjb250ZXh0KSB7IGdsLmdldEV4dGVuc2lvbignU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQnKS5kZXN0cm95KCk7IH1cXG5gO1xuICAgIHJldHVybiBnbEtlcm5lbFN0cmluZyh0aGlzLmNvbnN0cnVjdG9yLCBhcmd1bWVudHMsIHRoaXMsIHNldHVwQ29udGV4dFN0cmluZywgZGVzdHJveUNvbnRleHRTdHJpbmcpO1xuICB9XG5cbiAgc2V0T3V0cHV0KG91dHB1dCkge1xuICAgIHN1cGVyLnNldE91dHB1dChvdXRwdXQpO1xuICAgIGlmICh0aGlzLmdyYXBoaWNhbCAmJiB0aGlzLmV4dGVuc2lvbnMuU1RBQ0tHTF9yZXNpemVfZHJhd2luZ2J1ZmZlcikge1xuICAgICAgdGhpcy5leHRlbnNpb25zLlNUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXIucmVzaXplKHRoaXMubWF4VGV4U2l6ZVswXSwgdGhpcy5tYXhUZXhTaXplWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEhlYWRsZXNzR0xLZXJuZWxcbn07XG59LHtcIi4uL2dsL2tlcm5lbC1zdHJpbmdcIjoxMixcIi4uL3dlYi1nbC9rZXJuZWxcIjo3MCxcImdsXCI6Mn1dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNsYXNzIEtlcm5lbFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGtlcm5lbCxcbiAgICAgIGNvbnRleHQsXG4gICAgICBjaGVja0NvbnRleHQsXG4gICAgICBvblJlcXVlc3RDb250ZXh0SGFuZGxlLFxuICAgICAgb25VcGRhdGVWYWx1ZU1pc21hdGNoLFxuICAgICAgb3JpZ2luLFxuICAgICAgc3RyaWN0SW50ZWdlcnMsXG4gICAgICB0eXBlLFxuICAgICAgdGFjdGljLFxuICAgIH0gPSBzZXR0aW5ncztcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbmFtZSBub3Qgc2V0Jyk7XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIG5vdCBzZXQnKTtcbiAgICB9XG4gICAgaWYgKCFvcmlnaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3JpZ2luIG5vdCBzZXQnKTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbiAhPT0gJ3VzZXInICYmIG9yaWdpbiAhPT0gJ2NvbnN0YW50cycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgb3JpZ2luIG11c3QgYmUgXCJ1c2VyXCIgb3IgXCJjb25zdGFudHNcIiB2YWx1ZSBpcyBcIiR7IG9yaWdpbiB9XCJgKTtcbiAgICB9XG4gICAgaWYgKCFvblJlcXVlc3RDb250ZXh0SGFuZGxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29uUmVxdWVzdENvbnRleHRIYW5kbGUgaXMgbm90IHNldCcpO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgIHRoaXMudGFjdGljID0gdGFjdGljO1xuICAgIHRoaXMudmFyTmFtZSA9IG9yaWdpbiA9PT0gJ2NvbnN0YW50cycgPyBgY29uc3RhbnRzLiR7bmFtZX1gIDogbmFtZTtcbiAgICB0aGlzLmtlcm5lbCA9IGtlcm5lbDtcbiAgICB0aGlzLnN0cmljdEludGVnZXJzID0gc3RyaWN0SW50ZWdlcnM7XG4gICAgdGhpcy50eXBlID0gdmFsdWUudHlwZSB8fCB0eXBlO1xuICAgIHRoaXMuc2l6ZSA9IHZhbHVlLnNpemUgfHwgbnVsbDtcbiAgICB0aGlzLmluZGV4ID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuY2hlY2tDb250ZXh0ID0gY2hlY2tDb250ZXh0ICE9PSBudWxsICYmIGNoZWNrQ29udGV4dCAhPT0gdW5kZWZpbmVkID8gY2hlY2tDb250ZXh0IDogdHJ1ZTtcbiAgICB0aGlzLmNvbnRleHRIYW5kbGUgPSBudWxsO1xuICAgIHRoaXMub25SZXF1ZXN0Q29udGV4dEhhbmRsZSA9IG9uUmVxdWVzdENvbnRleHRIYW5kbGU7XG4gICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2ggPSBvblVwZGF0ZVZhbHVlTWlzbWF0Y2g7XG4gICAgdGhpcy5mb3JjZVVwbG9hZEVhY2hSdW4gPSBudWxsO1xuICB9XG5cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9yaWdpbn1fJHtuYW1lfWA7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImdldFNvdXJjZVwiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJ1cGRhdGVWYWx1ZVwiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtlcm5lbFZhbHVlXG59O1xufSx7fV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbmNvbnN0IHsgSW5wdXQgfSA9IHJlcXVpcmUoJy4uL2lucHV0Jyk7XG5cbmNsYXNzIEtlcm5lbCB7XG4gIHN0YXRpYyBnZXQgaXNTdXBwb3J0ZWQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImlzU3VwcG9ydGVkXCIgbm90IGltcGxlbWVudGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgaXNDb250ZXh0TWF0Y2goY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJpc0NvbnRleHRNYXRjaFwiIG5vdCBpbXBsZW1lbnRlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgc3RhdGljIGdldEZlYXR1cmVzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJnZXRGZWF0dXJlc1wiIG5vdCBpbXBsZW1lbnRlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgc3RhdGljIGRlc3Ryb3lDb250ZXh0KGNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZGVzdHJveUNvbnRleHRcIiBjYWxsZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBuYXRpdmVGdW5jdGlvbkFyZ3VtZW50cygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwibmF0aXZlRnVuY3Rpb25Bcmd1bWVudHNcIiBjYWxsZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBuYXRpdmVGdW5jdGlvblJldHVyblR5cGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIm5hdGl2ZUZ1bmN0aW9uUmV0dXJuVHlwZVwiIGNhbGxlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgc3RhdGljIGNvbWJpbmVLZXJuZWxzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJjb21iaW5lS2VybmVsc1wiIGNhbGxlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioc291cmNlLCBzZXR0aW5ncykge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIG5vdCBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlscy5pc0Z1bmN0aW9uU3RyaW5nKHNvdXJjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2Ugbm90IGEgZnVuY3Rpb24gc3RyaW5nJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXNlTGVnYWN5RW5jb2RlciA9IGZhbHNlO1xuICAgIHRoaXMuZmFsbGJhY2tSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9uUmVxdWVzdEZhbGxiYWNrID0gbnVsbDtcblxuICAgIHRoaXMuYXJndW1lbnROYW1lcyA9IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gdXRpbHMuZ2V0QXJndW1lbnROYW1lc0Zyb21TdHJpbmcoc291cmNlKSA6IG51bGw7XG4gICAgdGhpcy5hcmd1bWVudFR5cGVzID0gbnVsbDtcbiAgICB0aGlzLmFyZ3VtZW50U2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuYXJndW1lbnRCaXRSYXRpb3MgPSBudWxsO1xuICAgIHRoaXMua2VybmVsQXJndW1lbnRzID0gbnVsbDtcbiAgICB0aGlzLmtlcm5lbENvbnN0YW50cyA9IG51bGw7XG4gICAgdGhpcy5mb3JjZVVwbG9hZEtlcm5lbENvbnN0YW50cyA9IG51bGw7XG5cblxuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuXG4gICAgdGhpcy5vdXRwdXQgPSBudWxsO1xuXG4gICAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5ncmFwaGljYWwgPSBmYWxzZTtcblxuICAgIHRoaXMubG9vcE1heEl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgdGhpcy5jb25zdGFudHMgPSBudWxsO1xuXG4gICAgdGhpcy5jb25zdGFudFR5cGVzID0gbnVsbDtcblxuICAgIHRoaXMuY29uc3RhbnRCaXRSYXRpb3MgPSBudWxsO1xuXG4gICAgdGhpcy5keW5hbWljQXJndW1lbnRzID0gZmFsc2U7XG5cbiAgICB0aGlzLmR5bmFtaWNPdXRwdXQgPSBmYWxzZTtcblxuICAgIHRoaXMuY2FudmFzID0gbnVsbDtcblxuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG5cbiAgICB0aGlzLmNoZWNrQ29udGV4dCA9IG51bGw7XG5cbiAgICB0aGlzLmdwdSA9IG51bGw7XG5cbiAgICB0aGlzLmZ1bmN0aW9ucyA9IG51bGw7XG5cbiAgICB0aGlzLm5hdGl2ZUZ1bmN0aW9ucyA9IG51bGw7XG5cbiAgICB0aGlzLmluamVjdGVkTmF0aXZlID0gbnVsbDtcblxuICAgIHRoaXMuc3ViS2VybmVscyA9IG51bGw7XG5cbiAgICB0aGlzLnZhbGlkYXRlID0gdHJ1ZTtcblxuICAgIHRoaXMuaW1tdXRhYmxlID0gZmFsc2U7XG5cbiAgICB0aGlzLnBpcGVsaW5lID0gZmFsc2U7XG5cbiAgICB0aGlzLnByZWNpc2lvbiA9IG51bGw7XG5cbiAgICB0aGlzLnRhY3RpYyA9IG51bGw7XG5cbiAgICB0aGlzLnBsdWdpbnMgPSBudWxsO1xuXG4gICAgdGhpcy5yZXR1cm5UeXBlID0gbnVsbDtcbiAgICB0aGlzLmxlYWRpbmdSZXR1cm5TdGF0ZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkgPSBudWxsO1xuICAgIHRoaXMuc3RyaWN0SW50ZWdlcnMgPSBmYWxzZTtcbiAgICB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gbnVsbDtcbiAgICB0aGlzLm9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlID0gbnVsbDtcbiAgICB0aGlzLnJlbW92ZUlzdGFuYnVsQ292ZXJhZ2UgPSBmYWxzZTtcbiAgICB0aGlzLmJ1aWx0ID0gZmFsc2U7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBudWxsO1xuICB9XG5cbiAgbWVyZ2VTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIGZvciAobGV0IHAgaW4gc2V0dGluZ3MpIHtcbiAgICAgIGlmICghc2V0dGluZ3MuaGFzT3duUHJvcGVydHkocCkgfHwgIXRoaXMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICAgICAgc3dpdGNoIChwKSB7XG4gICAgICAgIGNhc2UgJ291dHB1dCc6XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNldHRpbmdzLm91dHB1dCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0KHNldHRpbmdzLm91dHB1dCk7IFxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmdW5jdGlvbnMnOlxuICAgICAgICAgIHRoaXMuZnVuY3Rpb25zID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5mdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRnVuY3Rpb24oc2V0dGluZ3MuZnVuY3Rpb25zW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgJ2dyYXBoaWNhbCc6XG4gICAgICAgICAgaWYgKHNldHRpbmdzW3BdICYmICFzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgncHJlY2lzaW9uJykpIHtcbiAgICAgICAgICAgIHRoaXMucHJlY2lzaW9uID0gJ3Vuc2lnbmVkJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpc1twXSA9IHNldHRpbmdzW3BdO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlICdyZW1vdmVJc3RhbmJ1bENvdmVyYWdlJzpcbiAgICAgICAgICBpZiAoc2V0dGluZ3NbcF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXNbcF0gPSBzZXR0aW5nc1twXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgJ25hdGl2ZUZ1bmN0aW9ucyc6XG4gICAgICAgICAgaWYgKCFzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMubmF0aXZlRnVuY3Rpb25zID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnNbaV07XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIHNvdXJjZSB9ID0gcztcbiAgICAgICAgICAgIHRoaXMuYWRkTmF0aXZlRnVuY3Rpb24obmFtZSwgc291cmNlLCBzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzW3BdID0gc2V0dGluZ3NbcF07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNhbnZhcykgdGhpcy5jYW52YXMgPSB0aGlzLmluaXRDYW52YXMoKTtcbiAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhpcy5jb250ZXh0ID0gdGhpcy5pbml0Q29udGV4dCgpO1xuICAgIGlmICghdGhpcy5wbHVnaW5zKSB0aGlzLnBsdWdpbnMgPSB0aGlzLmluaXRQbHVnaW5zKHNldHRpbmdzKTtcbiAgfVxuICBidWlsZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiYnVpbGRcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgcnVuKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJydW5cIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApXG4gIH1cblxuICBpbml0Q2FudmFzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJpbml0Q2FudmFzXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIGluaXRDb250ZXh0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJpbml0Q29udGV4dFwiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBpbml0UGx1Z2lucyhzZXR0aW5ncykge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJpbml0UGx1Z2luc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBhZGRGdW5jdGlvbihzb3VyY2UsIHNldHRpbmdzID0ge30pIHtcbiAgICBpZiAoc291cmNlLm5hbWUgJiYgc291cmNlLnNvdXJjZSAmJiBzb3VyY2UuYXJndW1lbnRUeXBlcyAmJiAncmV0dXJuVHlwZScgaW4gc291cmNlKSB7XG4gICAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICgnc2V0dGluZ3MnIGluIHNvdXJjZSAmJiAnc291cmNlJyBpbiBzb3VyY2UpIHtcbiAgICAgIHRoaXMuZnVuY3Rpb25zLnB1c2godGhpcy5mdW5jdGlvblRvSUdQVUZ1bmN0aW9uKHNvdXJjZS5zb3VyY2UsIHNvdXJjZS5zZXR0aW5ncykpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5mdW5jdGlvbnMucHVzaCh0aGlzLmZ1bmN0aW9uVG9JR1BVRnVuY3Rpb24oc291cmNlLCBzZXR0aW5ncykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGZ1bmN0aW9uIG5vdCBwcm9wZXJseSBkZWZpbmVkYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYWRkTmF0aXZlRnVuY3Rpb24obmFtZSwgc291cmNlLCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcmd1bWVudFR5cGVzLCBhcmd1bWVudE5hbWVzIH0gPSBzZXR0aW5ncy5hcmd1bWVudFR5cGVzID9cbiAgICAgIHNwbGl0QXJndW1lbnRUeXBlcyhzZXR0aW5ncy5hcmd1bWVudFR5cGVzKSA6XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLm5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKHNvdXJjZSkgfHwge307XG4gICAgdGhpcy5uYXRpdmVGdW5jdGlvbnMucHVzaCh7XG4gICAgICBuYW1lLFxuICAgICAgc291cmNlLFxuICAgICAgc2V0dGluZ3MsXG4gICAgICBhcmd1bWVudFR5cGVzLFxuICAgICAgYXJndW1lbnROYW1lcyxcbiAgICAgIHJldHVyblR5cGU6IHNldHRpbmdzLnJldHVyblR5cGUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYXRpdmVGdW5jdGlvblJldHVyblR5cGUoc291cmNlKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0dXBBcmd1bWVudHMoYXJncykge1xuICAgIHRoaXMua2VybmVsQXJndW1lbnRzID0gW107XG4gICAgaWYgKCF0aGlzLmFyZ3VtZW50VHlwZXMpIHtcbiAgICAgIGlmICghdGhpcy5hcmd1bWVudFR5cGVzKSB7XG4gICAgICAgIHRoaXMuYXJndW1lbnRUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBhcmdUeXBlID0gdXRpbHMuZ2V0VmFyaWFibGVUeXBlKGFyZ3NbaV0sIHRoaXMuc3RyaWN0SW50ZWdlcnMpO1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBhcmdUeXBlID09PSAnSW50ZWdlcicgPyAnTnVtYmVyJyA6IGFyZ1R5cGU7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudFR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgdGhpcy5rZXJuZWxBcmd1bWVudHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5rZXJuZWxBcmd1bWVudHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5hcmd1bWVudFR5cGVzW2ldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYXJndW1lbnRTaXplcyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gICAgdGhpcy5hcmd1bWVudEJpdFJhdGlvcyA9IG5ldyBJbnQzMkFycmF5KGFyZ3MubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXJnID0gYXJnc1tpXTtcbiAgICAgIHRoaXMuYXJndW1lbnRTaXplc1tpXSA9IGFyZy5jb25zdHJ1Y3RvciA9PT0gSW5wdXQgPyBhcmcuc2l6ZSA6IG51bGw7XG4gICAgICB0aGlzLmFyZ3VtZW50Qml0UmF0aW9zW2ldID0gdGhpcy5nZXRCaXRSYXRpbyhhcmcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFyZ3VtZW50TmFtZXMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcmd1bWVudHMgYXJlIG1pc3MtYWxpZ25lZGApO1xuICAgIH1cbiAgfVxuXG4gIHNldHVwQ29uc3RhbnRzKCkge1xuICAgIHRoaXMua2VybmVsQ29uc3RhbnRzID0gW107XG4gICAgbGV0IG5lZWRzQ29uc3RhbnRUeXBlcyA9IHRoaXMuY29uc3RhbnRUeXBlcyA9PT0gbnVsbDtcbiAgICBpZiAobmVlZHNDb25zdGFudFR5cGVzKSB7XG4gICAgICB0aGlzLmNvbnN0YW50VHlwZXMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5jb25zdGFudEJpdFJhdGlvcyA9IHt9O1xuICAgIGlmICh0aGlzLmNvbnN0YW50cykge1xuICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLmNvbnN0YW50cykge1xuICAgICAgICBpZiAobmVlZHNDb25zdGFudFR5cGVzKSB7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZSh0aGlzLmNvbnN0YW50c1tuYW1lXSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICAgICAgdGhpcy5jb25zdGFudFR5cGVzW25hbWVdID0gdHlwZTtcbiAgICAgICAgICB0aGlzLmtlcm5lbENvbnN0YW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5rZXJuZWxDb25zdGFudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5jb25zdGFudFR5cGVzW25hbWVdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25zdGFudEJpdFJhdGlvc1tuYW1lXSA9IHRoaXMuZ2V0Qml0UmF0aW8odGhpcy5jb25zdGFudHNbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldE9wdGltaXplRmxvYXRNZW1vcnkoZmxhZykge1xuICAgIHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0b0tlcm5lbE91dHB1dChvdXRwdXQpIHtcbiAgICBpZiAob3V0cHV0Lmhhc093blByb3BlcnR5KCd4JykpIHtcbiAgICAgIGlmIChvdXRwdXQuaGFzT3duUHJvcGVydHkoJ3knKSkge1xuICAgICAgICBpZiAob3V0cHV0Lmhhc093blByb3BlcnR5KCd6JykpIHtcbiAgICAgICAgICByZXR1cm4gW291dHB1dC54LCBvdXRwdXQueSwgb3V0cHV0LnpdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbb3V0cHV0LngsIG91dHB1dC55XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtvdXRwdXQueF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICB9XG5cbiAgc2V0T3V0cHV0KG91dHB1dCkge1xuICAgIHRoaXMub3V0cHV0ID0gdGhpcy50b0tlcm5lbE91dHB1dChvdXRwdXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0RGVidWcoZmxhZykge1xuICAgIHRoaXMuZGVidWcgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0R3JhcGhpY2FsKGZsYWcpIHtcbiAgICB0aGlzLmdyYXBoaWNhbCA9IGZsYWc7XG4gICAgdGhpcy5wcmVjaXNpb24gPSAndW5zaWduZWQnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0TG9vcE1heEl0ZXJhdGlvbnMobWF4KSB7XG4gICAgdGhpcy5sb29wTWF4SXRlcmF0aW9ucyA9IG1heDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldENvbnN0YW50cyhjb25zdGFudHMpIHtcbiAgICB0aGlzLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldENvbnN0YW50VHlwZXMoY29uc3RhbnRUeXBlcykge1xuICAgIHRoaXMuY29uc3RhbnRUeXBlcyA9IGNvbnN0YW50VHlwZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRGdW5jdGlvbnMoZnVuY3Rpb25zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYWRkRnVuY3Rpb24oZnVuY3Rpb25zW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXROYXRpdmVGdW5jdGlvbnMobmF0aXZlRnVuY3Rpb25zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYXRpdmVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gbmF0aXZlRnVuY3Rpb25zW2ldO1xuICAgICAgY29uc3QgeyBuYW1lLCBzb3VyY2UgfSA9IHNldHRpbmdzO1xuICAgICAgdGhpcy5hZGROYXRpdmVGdW5jdGlvbihuYW1lLCBzb3VyY2UsIHNldHRpbmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRJbmplY3RlZE5hdGl2ZShpbmplY3RlZE5hdGl2ZSkge1xuICAgIHRoaXMuaW5qZWN0ZWROYXRpdmUgPSBpbmplY3RlZE5hdGl2ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFBpcGVsaW5lKGZsYWcpIHtcbiAgICB0aGlzLnBpcGVsaW5lID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFByZWNpc2lvbihmbGFnKSB7XG4gICAgdGhpcy5wcmVjaXNpb24gPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0RGltZW5zaW9ucyhmbGFnKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ21ldGhvZCcsICdzZXREaW1lbnNpb25zJywgJ3NldE91dHB1dCcpO1xuICAgIHRoaXMub3V0cHV0ID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldE91dHB1dFRvVGV4dHVyZShmbGFnKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ21ldGhvZCcsICdzZXRPdXRwdXRUb1RleHR1cmUnLCAnc2V0UGlwZWxpbmUnKTtcbiAgICB0aGlzLnBpcGVsaW5lID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEltbXV0YWJsZShmbGFnKSB7XG4gICAgdGhpcy5pbW11dGFibGUgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0Q2FudmFzKGNhbnZhcykge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0U3RyaWN0SW50ZWdlcnMoZmxhZykge1xuICAgIHRoaXMuc3RyaWN0SW50ZWdlcnMgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0RHluYW1pY091dHB1dChmbGFnKSB7XG4gICAgdGhpcy5keW5hbWljT3V0cHV0ID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEhhcmRjb2RlQ29uc3RhbnRzKGZsYWcpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnbWV0aG9kJywgJ3NldEhhcmRjb2RlQ29uc3RhbnRzJyk7XG4gICAgdGhpcy5zZXREeW5hbWljT3V0cHV0KGZsYWcpO1xuICAgIHRoaXMuc2V0RHluYW1pY0FyZ3VtZW50cyhmbGFnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldER5bmFtaWNBcmd1bWVudHMoZmxhZykge1xuICAgIHRoaXMuZHluYW1pY0FyZ3VtZW50cyA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRVc2VMZWdhY3lFbmNvZGVyKGZsYWcpIHtcbiAgICB0aGlzLnVzZUxlZ2FjeUVuY29kZXIgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0V2FyblZhclVzYWdlKGZsYWcpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnbWV0aG9kJywgJ3NldFdhcm5WYXJVc2FnZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0Q2FudmFzKCkge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdtZXRob2QnLCAnZ2V0Q2FudmFzJyk7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICB9XG5cbiAgZ2V0V2ViR2woKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ21ldGhvZCcsICdnZXRXZWJHbCcpO1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQ7XG4gIH1cblxuICBzZXRDb250ZXh0KGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0QXJndW1lbnRUeXBlcyhhcmd1bWVudFR5cGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRUeXBlcykpIHtcbiAgICAgIHRoaXMuYXJndW1lbnRUeXBlcyA9IGFyZ3VtZW50VHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXJndW1lbnRUeXBlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwIGluIGFyZ3VtZW50VHlwZXMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudFR5cGVzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgYXJndW1lbnRJbmRleCA9IHRoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKHApO1xuICAgICAgICBpZiAoYXJndW1lbnRJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGZpbmQgYXJndW1lbnQgJHsgcCB9YCk7XG4gICAgICAgIHRoaXMuYXJndW1lbnRUeXBlc1thcmd1bWVudEluZGV4XSA9IGFyZ3VtZW50VHlwZXNbcF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0VGFjdGljKHRhY3RpYykge1xuICAgIHRoaXMudGFjdGljID0gdGFjdGljO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVxdWVzdEZhbGxiYWNrKGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMub25SZXF1ZXN0RmFsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXCJvblJlcXVlc3RGYWxsYmFja1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gICAgfVxuICAgIHRoaXMuZmFsbGJhY2tSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLm9uUmVxdWVzdEZhbGxiYWNrKGFyZ3MpO1xuICB9XG5cbiAgdmFsaWRhdGVTZXR0aW5ncygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwidmFsaWRhdGVTZXR0aW5nc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBhZGRTdWJLZXJuZWwoc3ViS2VybmVsKSB7XG4gICAgaWYgKHRoaXMuc3ViS2VybmVscyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdWJLZXJuZWxzID0gW107XG4gICAgfVxuICAgIGlmICghc3ViS2VybmVsLnNvdXJjZSkgdGhyb3cgbmV3IEVycm9yKCdzdWJLZXJuZWwgbWlzc2luZyBcInNvdXJjZVwiIHByb3BlcnR5Jyk7XG4gICAgaWYgKCFzdWJLZXJuZWwucHJvcGVydHkgJiYgaXNOYU4oc3ViS2VybmVsLnByb3BlcnR5KSkgdGhyb3cgbmV3IEVycm9yKCdzdWJLZXJuZWwgbWlzc2luZyBcInByb3BlcnR5XCIgcHJvcGVydHknKTtcbiAgICBpZiAoIXN1Yktlcm5lbC5uYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ3N1Yktlcm5lbCBtaXNzaW5nIFwibmFtZVwiIHByb3BlcnR5Jyk7XG4gICAgdGhpcy5zdWJLZXJuZWxzLnB1c2goc3ViS2VybmVsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlc3Ryb3kocmVtb3ZlQ2FudmFzUmVmZXJlbmNlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJkZXN0cm95XCIgY2FsbGVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBnZXRCaXRSYXRpbyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIHJldHVybiA0O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJpdFJhdGlvKHZhbHVlWzBdKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBJbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qml0UmF0aW8odmFsdWUudmFsdWUpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIFVpbnQ4Q2xhbXBlZEFycmF5OlxuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBjYXNlIEZsb2F0MzJBcnJheTpcbiAgICAgIGNhc2UgSW50MzJBcnJheTpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgfVxuXG4gIGdldFBpeGVscyhmbGlwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImdldFBpeGVsc1wiIGNhbGxlZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgY2hlY2tPdXRwdXQoKSB7XG4gICAgaWYgKCF0aGlzLm91dHB1dCB8fCAhdXRpbHMuaXNBcnJheSh0aGlzLm91dHB1dCkpIHRocm93IG5ldyBFcnJvcigna2VybmVsLm91dHB1dCBub3QgYW4gYXJyYXknKTtcbiAgICBpZiAodGhpcy5vdXRwdXQubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IEVycm9yKCdrZXJuZWwub3V0cHV0IGlzIGVtcHR5LCBuZWVkcyBhdCBsZWFzdCAxIHZhbHVlJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlzTmFOKHRoaXMub3V0cHV0W2ldKSB8fCB0aGlzLm91dHB1dFtpXSA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfS5vdXRwdXRbJHsgaSB9XSBpbmNvcnJlY3RseSBkZWZpbmVkIGFzIFxcYCR7IHRoaXMub3V0cHV0W2ldIH1cXGAsIG5lZWRzIHRvIGJlIG51bWVyaWMsIGFuZCBncmVhdGVyIHRoYW4gMGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByZXBlbmRTdHJpbmcodmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwicHJlcGVuZFN0cmluZ1wiIGNhbGxlZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgaGFzUHJlcGVuZFN0cmluZyh2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJoYXNQcmVwZW5kU3RyaW5nXCIgY2FsbGVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICAgIHBpcGVsaW5lOiB0aGlzLnBpcGVsaW5lLFxuICAgICAgICBhcmd1bWVudE5hbWVzOiB0aGlzLmFyZ3VtZW50TmFtZXMsXG4gICAgICAgIGFyZ3VtZW50c1R5cGVzOiB0aGlzLmFyZ3VtZW50VHlwZXMsXG4gICAgICAgIGNvbnN0YW50czogdGhpcy5jb25zdGFudHMsXG4gICAgICAgIHBsdWdpbk5hbWVzOiB0aGlzLnBsdWdpbnMgPyB0aGlzLnBsdWdpbnMubWFwKHBsdWdpbiA9PiBwbHVnaW4ubmFtZSkgOiBudWxsLFxuICAgICAgICByZXR1cm5UeXBlOiB0aGlzLnJldHVyblR5cGUsXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGJ1aWxkU2lnbmF0dXJlKGFyZ3MpIHtcbiAgICBjb25zdCBDb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBDb25zdHJ1Y3Rvci5nZXRTaWduYXR1cmUodGhpcywgQ29uc3RydWN0b3IuZ2V0QXJndW1lbnRUeXBlcyh0aGlzLCBhcmdzKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0QXJndW1lbnRUeXBlcyhrZXJuZWwsIGFyZ3MpIHtcbiAgICBjb25zdCBhcmd1bWVudFR5cGVzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgICBjb25zdCB0eXBlID0ga2VybmVsLmFyZ3VtZW50VHlwZXNbaV07XG4gICAgICBpZiAoYXJnLnR5cGUpIHtcbiAgICAgICAgYXJndW1lbnRUeXBlc1tpXSA9IGFyZy50eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcbiAgICAgICAgICAgIGFyZ3VtZW50VHlwZXNbaV0gPSB1dGlscy5nZXRWYXJpYWJsZVR5cGUoYXJnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhcmd1bWVudFR5cGVzW2ldID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJndW1lbnRUeXBlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXRTaWduYXR1cmUoa2VybmVsLCBhcmd1bWVudFR5cGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImdldFNpZ25hdHVyZVwiIG5vdCBpbXBsZW1lbnRlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgZnVuY3Rpb25Ub0lHUFVGdW5jdGlvbihzb3VyY2UsIHNldHRpbmdzID0ge30pIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHNvdXJjZSAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2Ugbm90IGEgc3RyaW5nIG9yIGZ1bmN0aW9uJyk7XG4gICAgY29uc3Qgc291cmNlU3RyaW5nID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBzb3VyY2UgOiBzb3VyY2UudG9TdHJpbmcoKTtcbiAgICBsZXQgYXJndW1lbnRUeXBlcyA9IFtdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2V0dGluZ3MuYXJndW1lbnRUeXBlcykpIHtcbiAgICAgIGFyZ3VtZW50VHlwZXMgPSBzZXR0aW5ncy5hcmd1bWVudFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNldHRpbmdzLmFyZ3VtZW50VHlwZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBhcmd1bWVudFR5cGVzID0gdXRpbHMuZ2V0QXJndW1lbnROYW1lc0Zyb21TdHJpbmcoc291cmNlU3RyaW5nKVxuICAgICAgICAubWFwKG5hbWUgPT4gc2V0dGluZ3MuYXJndW1lbnRUeXBlc1tuYW1lXSkgfHwgW107XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3VtZW50VHlwZXMgPSBzZXR0aW5ncy5hcmd1bWVudFR5cGVzIHx8IFtdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB1dGlscy5nZXRGdW5jdGlvbk5hbWVGcm9tU3RyaW5nKHNvdXJjZVN0cmluZykgfHwgbnVsbCxcbiAgICAgIHNvdXJjZTogc291cmNlU3RyaW5nLFxuICAgICAgYXJndW1lbnRUeXBlcyxcbiAgICAgIHJldHVyblR5cGU6IHNldHRpbmdzLnJldHVyblR5cGUgfHwgbnVsbCxcbiAgICB9O1xuICB9XG5cbiAgb25BY3RpdmF0ZShwcmV2aW91c0tlcm5lbCkge31cbn1cblxuZnVuY3Rpb24gc3BsaXRBcmd1bWVudFR5cGVzKGFyZ3VtZW50VHlwZXNPYmplY3QpIHtcbiAgY29uc3QgYXJndW1lbnROYW1lcyA9IE9iamVjdC5rZXlzKGFyZ3VtZW50VHlwZXNPYmplY3QpO1xuICBjb25zdCBhcmd1bWVudFR5cGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZ3VtZW50TmFtZSA9IGFyZ3VtZW50TmFtZXNbaV07XG4gICAgYXJndW1lbnRUeXBlcy5wdXNoKGFyZ3VtZW50VHlwZXNPYmplY3RbYXJndW1lbnROYW1lXSk7XG4gIH1cbiAgcmV0dXJuIHsgYXJndW1lbnRUeXBlcywgYXJndW1lbnROYW1lcyB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgS2VybmVsXG59O1xufSx7XCIuLi9pbnB1dFwiOjExMCxcIi4uL3V0aWxzXCI6MTE0fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBgX19IRUFERVJfXztcbl9fRkxPQVRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX0lOVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fU0FNUExFUl8yRF9UQUNUSUNfREVDTEFSQVRJT05fXztcblxuY29uc3QgaW50IExPT1BfTUFYID0gX19MT09QX01BWF9fO1xuXG5fX1BMVUdJTlNfXztcbl9fQ09OU1RBTlRTX187XG5cbnZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG5cbmZsb2F0IGFjb3NoKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCAtIDEuMCkpO1xufVxuXG5mbG9hdCBzaW5oKGZsb2F0IHgpIHtcbiAgcmV0dXJuIChwb3coJHtNYXRoLkV9LCB4KSAtIHBvdygke01hdGguRX0sIC14KSkgLyAyLjA7XG59XG5cbmZsb2F0IGFzaW5oKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCArIDEuMCkpO1xufVxuXG5mbG9hdCBhdGFuMihmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgaWYgKHYxID09IDAuMCB8fCB2MiA9PSAwLjApIHJldHVybiAwLjA7XG4gIHJldHVybiBhdGFuKHYxIC8gdjIpO1xufVxuXG5mbG9hdCBhdGFuaChmbG9hdCB4KSB7XG4gIHggPSAoeCArIDEuMCkgLyAoeCAtIDEuMCk7XG4gIGlmICh4IDwgMC4wKSB7XG4gICAgcmV0dXJuIDAuNSAqIGxvZygteCk7XG4gIH1cbiAgcmV0dXJuIDAuNSAqIGxvZyh4KTtcbn1cblxuZmxvYXQgY2JydChmbG9hdCB4KSB7XG4gIGlmICh4ID49IDAuMCkge1xuICAgIHJldHVybiBwb3coeCwgMS4wIC8gMy4wKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLXBvdyh4LCAxLjAgLyAzLjApO1xuICB9XG59XG5cbmZsb2F0IGNvc2goZmxvYXQgeCkge1xuICByZXR1cm4gKHBvdygke01hdGguRX0sIHgpICsgcG93KCR7TWF0aC5FfSwgLXgpKSAvIDIuMDsgXG59XG5cbmZsb2F0IGV4cG0xKGZsb2F0IHgpIHtcbiAgcmV0dXJuIHBvdygke01hdGguRX0sIHgpIC0gMS4wOyBcbn1cblxuZmxvYXQgZnJvdW5kKGhpZ2hwIGZsb2F0IHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZsb2F0IGltdWwoZmxvYXQgdjEsIGZsb2F0IHYyKSB7XG4gIHJldHVybiBmbG9hdChpbnQodjEpICogaW50KHYyKSk7XG59XG5cbmZsb2F0IGxvZzEwKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZzIoeCkgKiAoMS4wIC8gbG9nMigxMC4wKSk7XG59XG5cbmZsb2F0IGxvZzFwKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZygxLjAgKyB4KTtcbn1cblxuZmxvYXQgX3BvdyhmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgaWYgKHYyID09IDAuMCkgcmV0dXJuIDEuMDtcbiAgcmV0dXJuIHBvdyh2MSwgdjIpO1xufVxuXG5mbG9hdCB0YW5oKGZsb2F0IHgpIHtcbiAgZmxvYXQgZSA9IGV4cCgyLjAgKiB4KTtcbiAgcmV0dXJuIChlIC0gMS4wKSAvIChlICsgMS4wKTtcbn1cblxuZmxvYXQgdHJ1bmMoZmxvYXQgeCkge1xuICBpZiAoeCA+PSAwLjApIHtcbiAgICByZXR1cm4gZmxvb3IoeCk7IFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjZWlsKHgpO1xuICB9XG59XG5cbnZlYzQgX3JvdW5kKHZlYzQgeCkge1xuICByZXR1cm4gZmxvb3IoeCArIDAuNSk7XG59XG5cbmZsb2F0IF9yb3VuZChmbG9hdCB4KSB7XG4gIHJldHVybiBmbG9vcih4ICsgMC41KTtcbn1cblxuY29uc3QgaW50IEJJVF9DT1VOVCA9IDMyO1xuaW50IG1vZGkoaW50IHgsIGludCB5KSB7XG4gIHJldHVybiB4IC0geSAqICh4IC8geSk7XG59XG5cbmludCBiaXR3aXNlT3IoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIFxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKChtb2RpKGEsIDIpID09IDEpIHx8IChtb2RpKGIsIDIpID09IDEpKSB7XG4gICAgICByZXN1bHQgKz0gbjtcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIGIgPSBiIC8gMjtcbiAgICBuID0gbiAqIDI7XG4gICAgaWYoIShhID4gMCB8fCBiID4gMCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VYT1IoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIFxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKChtb2RpKGEsIDIpID09IDEpICE9IChtb2RpKGIsIDIpID09IDEpKSB7XG4gICAgICByZXN1bHQgKz0gbjtcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIGIgPSBiIC8gMjtcbiAgICBuID0gbiAqIDI7XG4gICAgaWYoIShhID4gMCB8fCBiID4gMCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VBbmQoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoKG1vZGkoYSwgMikgPT0gMSkgJiYgKG1vZGkoYiwgMikgPT0gMSkpIHtcbiAgICAgIHJlc3VsdCArPSBuO1xuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgYiA9IGIgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgICBpZighKGEgPiAwICYmIGIgPiAwKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZU5vdChpbnQgYSkge1xuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IG4gPSAxO1xuICBcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtb2RpKGEsIDIpID09IDApIHtcbiAgICAgIHJlc3VsdCArPSBuOyAgICBcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VaZXJvRmlsbExlZnRTaGlmdChpbnQgbiwgaW50IHNoaWZ0KSB7XG4gIGludCBtYXhCeXRlcyA9IEJJVF9DT1VOVDtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtYXhCeXRlcyA+PSBuKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbWF4Qnl0ZXMgKj0gMjtcbiAgfVxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gc2hpZnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuICo9IDI7XG4gIH1cblxuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IGJ5dGVWYWwgPSAxO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gbWF4Qnl0ZXMpIGJyZWFrO1xuICAgIGlmIChtb2RpKG4sIDIpID4gMCkgeyByZXN1bHQgKz0gYnl0ZVZhbDsgfVxuICAgIG4gPSBpbnQobiAvIDIpO1xuICAgIGJ5dGVWYWwgKj0gMjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5pbnQgYml0d2lzZVNpZ25lZFJpZ2h0U2hpZnQoaW50IG51bSwgaW50IHNoaWZ0cykge1xuICByZXR1cm4gaW50KGZsb29yKGZsb2F0KG51bSkgLyBwb3coMi4wLCBmbG9hdChzaGlmdHMpKSkpO1xufVxuXG5pbnQgYml0d2lzZVplcm9GaWxsUmlnaHRTaGlmdChpbnQgbiwgaW50IHNoaWZ0KSB7XG4gIGludCBtYXhCeXRlcyA9IEJJVF9DT1VOVDtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtYXhCeXRlcyA+PSBuKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbWF4Qnl0ZXMgKj0gMjtcbiAgfVxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gc2hpZnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuIC89IDI7XG4gIH1cbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBieXRlVmFsID0gMTtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChpID49IG1heEJ5dGVzKSBicmVhaztcbiAgICBpZiAobW9kaShuLCAyKSA+IDApIHsgcmVzdWx0ICs9IGJ5dGVWYWw7IH1cbiAgICBuID0gaW50KG4gLyAyKTtcbiAgICBieXRlVmFsICo9IDI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmVjMiBpbnRlZ2VyTW9kKHZlYzIgeCwgZmxvYXQgeSkge1xuICB2ZWMyIHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XG4gIHJldHVybiByZXMgKiBzdGVwKDEuMCAtIGZsb29yKHkpLCAtcmVzKTtcbn1cblxudmVjMyBpbnRlZ2VyTW9kKHZlYzMgeCwgZmxvYXQgeSkge1xuICB2ZWMzIHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XG4gIHJldHVybiByZXMgKiBzdGVwKDEuMCAtIGZsb29yKHkpLCAtcmVzKTtcbn1cblxudmVjNCBpbnRlZ2VyTW9kKHZlYzQgeCwgdmVjNCB5KSB7XG4gIHZlYzQgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG5mbG9hdCBpbnRlZ2VyTW9kKGZsb2F0IHgsIGZsb2F0IHkpIHtcbiAgZmxvYXQgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIChyZXMgPiBmbG9vcih5KSAtIDEuMCA/IDAuMCA6IDEuMCk7XG59XG5cbmludCBpbnRlZ2VyTW9kKGludCB4LCBpbnQgeSkge1xuICByZXR1cm4geCAtICh5ICogaW50KHggLyB5KSk7XG59XG5cbl9fRElWSURFX1dJVEhfSU5URUdFUl9DSEVDS19fO1xuXG4vLyBIZXJlIGJlIGRyYWdvbnMhXG4vLyBETyBOT1QgT1BUSU1JWkUgVEhJUyBDT0RFXG4vLyBZT1UgV0lMTCBCUkVBSyBTT01FVEhJTkcgT04gU09NRUJPRFlcXCdTIE1BQ0hJTkVcbi8vIExFQVZFIElUIEFTIElUIElTLCBMRVNUIFlPVSBXQVNURSBZT1VSIE9XTiBUSU1FXG5jb25zdCB2ZWMyIE1BR0lDX1ZFQyA9IHZlYzIoMS4wLCAtMjU2LjApO1xuY29uc3QgdmVjNCBTQ0FMRV9GQUNUT1IgPSB2ZWM0KDEuMCwgMjU2LjAsIDY1NTM2LjAsIDAuMCk7XG5jb25zdCB2ZWM0IFNDQUxFX0ZBQ1RPUl9JTlYgPSB2ZWM0KDEuMCwgMC4wMDM5MDYyNSwgMC4wMDAwMTUyNTg3ODkwNjI1LCAwLjApOyAvLyAxLCAxLzI1NiwgMS82NTUzNlxuZmxvYXQgZGVjb2RlMzIodmVjNCB0ZXhlbCkge1xuICBfX0RFQ09ERTMyX0VORElBTk5FU1NfXztcbiAgdGV4ZWwgKj0gMjU1LjA7XG4gIHZlYzIgZ3RlMTI4O1xuICBndGUxMjgueCA9IHRleGVsLmIgPj0gMTI4LjAgPyAxLjAgOiAwLjA7XG4gIGd0ZTEyOC55ID0gdGV4ZWwuYSA+PSAxMjguMCA/IDEuMCA6IDAuMDtcbiAgZmxvYXQgZXhwb25lbnQgPSAyLjAgKiB0ZXhlbC5hIC0gMTI3LjAgKyBkb3QoZ3RlMTI4LCBNQUdJQ19WRUMpO1xuICBmbG9hdCByZXMgPSBleHAyKF9yb3VuZChleHBvbmVudCkpO1xuICB0ZXhlbC5iID0gdGV4ZWwuYiAtIDEyOC4wICogZ3RlMTI4Lng7XG4gIHJlcyA9IGRvdCh0ZXhlbCwgU0NBTEVfRkFDVE9SKSAqIGV4cDIoX3JvdW5kKGV4cG9uZW50LTIzLjApKSArIHJlcztcbiAgcmVzICo9IGd0ZTEyOC55ICogLTIuMCArIDEuMDtcbiAgcmV0dXJuIHJlcztcbn1cblxuZmxvYXQgZGVjb2RlMTYodmVjNCB0ZXhlbCwgaW50IGluZGV4KSB7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgMik7XG4gIGlmIChjaGFubmVsID09IDApIHJldHVybiB0ZXhlbC5yICogMjU1LjAgKyB0ZXhlbC5nICogNjUyODAuMDtcbiAgaWYgKGNoYW5uZWwgPT0gMSkgcmV0dXJuIHRleGVsLmIgKiAyNTUuMCArIHRleGVsLmEgKiA2NTI4MC4wO1xuICByZXR1cm4gMC4wO1xufVxuXG5mbG9hdCBkZWNvZGU4KHZlYzQgdGV4ZWwsIGludCBpbmRleCkge1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDQpO1xuICBpZiAoY2hhbm5lbCA9PSAwKSByZXR1cm4gdGV4ZWwuciAqIDI1NS4wO1xuICBpZiAoY2hhbm5lbCA9PSAxKSByZXR1cm4gdGV4ZWwuZyAqIDI1NS4wO1xuICBpZiAoY2hhbm5lbCA9PSAyKSByZXR1cm4gdGV4ZWwuYiAqIDI1NS4wO1xuICBpZiAoY2hhbm5lbCA9PSAzKSByZXR1cm4gdGV4ZWwuYSAqIDI1NS4wO1xuICByZXR1cm4gMC4wO1xufVxuXG52ZWM0IGxlZ2FjeUVuY29kZTMyKGZsb2F0IGYpIHtcbiAgZmxvYXQgRiA9IGFicyhmKTtcbiAgZmxvYXQgc2lnbiA9IGYgPCAwLjAgPyAxLjAgOiAwLjA7XG4gIGZsb2F0IGV4cG9uZW50ID0gZmxvb3IobG9nMihGKSk7XG4gIGZsb2F0IG1hbnRpc3NhID0gKGV4cDIoLWV4cG9uZW50KSAqIEYpO1xuICAvLyBleHBvbmVudCArPSBmbG9vcihsb2cyKG1hbnRpc3NhKSk7XG4gIHZlYzQgdGV4ZWwgPSB2ZWM0KEYgKiBleHAyKDIzLjAtZXhwb25lbnQpKSAqIFNDQUxFX0ZBQ1RPUl9JTlY7XG4gIHRleGVsLnJnID0gaW50ZWdlck1vZCh0ZXhlbC5yZywgMjU2LjApO1xuICB0ZXhlbC5iID0gaW50ZWdlck1vZCh0ZXhlbC5iLCAxMjguMCk7XG4gIHRleGVsLmEgPSBleHBvbmVudCowLjUgKyA2My41O1xuICB0ZXhlbC5iYSArPSB2ZWMyKGludGVnZXJNb2QoZXhwb25lbnQrMTI3LjAsIDIuMCksIHNpZ24pICogMTI4LjA7XG4gIHRleGVsID0gZmxvb3IodGV4ZWwpO1xuICB0ZXhlbCAqPSAwLjAwMzkyMTU2OTsgLy8gMS8yNTVcbiAgX19FTkNPREUzMl9FTkRJQU5ORVNTX187XG4gIHJldHVybiB0ZXhlbDtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dwdWpzL2dwdS5qcy93aWtpL0VuY29kZXItZGV0YWlsc1xudmVjNCBlbmNvZGUzMihmbG9hdCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gMC4wKSByZXR1cm4gdmVjNCgwLCAwLCAwLCAwKTtcblxuICBmbG9hdCBleHBvbmVudDtcbiAgZmxvYXQgbWFudGlzc2E7XG4gIHZlYzQgIHJlc3VsdDtcbiAgZmxvYXQgc2duO1xuXG4gIHNnbiA9IHN0ZXAoMC4wLCAtdmFsdWUpO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSk7XG5cbiAgZXhwb25lbnQgPSBmbG9vcihsb2cyKHZhbHVlKSk7XG5cbiAgbWFudGlzc2EgPSB2YWx1ZSpwb3coMi4wLCAtZXhwb25lbnQpLTEuMDtcbiAgZXhwb25lbnQgPSBleHBvbmVudCsxMjcuMDtcbiAgcmVzdWx0ICAgPSB2ZWM0KDAsMCwwLDApO1xuXG4gIHJlc3VsdC5hID0gZmxvb3IoZXhwb25lbnQvMi4wKTtcbiAgZXhwb25lbnQgPSBleHBvbmVudCAtIHJlc3VsdC5hKjIuMDtcbiAgcmVzdWx0LmEgPSByZXN1bHQuYSArIDEyOC4wKnNnbjtcblxuICByZXN1bHQuYiA9IGZsb29yKG1hbnRpc3NhICogMTI4LjApO1xuICBtYW50aXNzYSA9IG1hbnRpc3NhIC0gcmVzdWx0LmIgLyAxMjguMDtcbiAgcmVzdWx0LmIgPSByZXN1bHQuYiArIGV4cG9uZW50KjEyOC4wO1xuXG4gIHJlc3VsdC5nID0gZmxvb3IobWFudGlzc2EqMzI3NjguMCk7XG4gIG1hbnRpc3NhID0gbWFudGlzc2EgLSByZXN1bHQuZy8zMjc2OC4wO1xuXG4gIHJlc3VsdC5yID0gZmxvb3IobWFudGlzc2EqODM4ODYwOC4wKTtcbiAgcmV0dXJuIHJlc3VsdC8yNTUuMDtcbn1cbi8vIERyYWdvbnMgZW5kIGhlcmVcblxuaW50IGluZGV4O1xuaXZlYzMgdGhyZWFkSWQ7XG5cbml2ZWMzIGluZGV4VG8zRChpbnQgaWR4LCBpdmVjMyB0ZXhEaW0pIHtcbiAgaW50IHogPSBpbnQoaWR4IC8gKHRleERpbS54ICogdGV4RGltLnkpKTtcbiAgaWR4IC09IHogKiBpbnQodGV4RGltLnggKiB0ZXhEaW0ueSk7XG4gIGludCB5ID0gaW50KGlkeCAvIHRleERpbS54KTtcbiAgaW50IHggPSBpbnQoaW50ZWdlck1vZChpZHgsIHRleERpbS54KSk7XG4gIHJldHVybiBpdmVjMyh4LCB5LCB6KTtcbn1cblxuZmxvYXQgZ2V0MzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodGV4LCBzdCAvIHZlYzIodGV4U2l6ZSkpO1xuICByZXR1cm4gZGVjb2RlMzIodGV4ZWwpO1xufVxuXG5mbG9hdCBnZXQxNihzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgdyA9IHRleFNpemUueCAqIDI7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodGV4LCBzdCAvIHZlYzIodGV4U2l6ZS54ICogMiwgdGV4U2l6ZS55KSk7XG4gIHJldHVybiBkZWNvZGUxNih0ZXhlbCwgaW5kZXgpO1xufVxuXG5mbG9hdCBnZXQ4KHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCB3ID0gdGV4U2l6ZS54ICogNDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplLnggKiA0LCB0ZXhTaXplLnkpKTtcbiAgcmV0dXJuIGRlY29kZTgodGV4ZWwsIGluZGV4KTtcbn1cblxuZmxvYXQgZ2V0TWVtb3J5T3B0aW1pemVkMzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKGluZGV4LCA0KTtcbiAgaW5kZXggPSBpbmRleCAvIDQ7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbiAgaWYgKGNoYW5uZWwgPT0gMCkgcmV0dXJuIHRleGVsLnI7XG4gIGlmIChjaGFubmVsID09IDEpIHJldHVybiB0ZXhlbC5nO1xuICBpZiAoY2hhbm5lbCA9PSAyKSByZXR1cm4gdGV4ZWwuYjtcbiAgaWYgKGNoYW5uZWwgPT0gMykgcmV0dXJuIHRleGVsLmE7XG4gIHJldHVybiAwLjA7XG59XG5cbnZlYzQgZ2V0SW1hZ2UyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgcmV0dXJuIHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG59XG5cbmZsb2F0IGdldEZsb2F0RnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgdmVjNCByZXN1bHQgPSBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbiAgcmV0dXJuIHJlc3VsdFswXTtcbn1cblxudmVjMiBnZXRWZWMyRnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgdmVjNCByZXN1bHQgPSBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbiAgcmV0dXJuIHZlYzIocmVzdWx0WzBdLCByZXN1bHRbMV0pO1xufVxuXG52ZWMyIGdldE1lbW9yeU9wdGltaXplZFZlYzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyAodGV4RGltLnggKiAoeSArICh0ZXhEaW0ueSAqIHopKSk7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgMik7XG4gIGluZGV4ID0gaW5kZXggLyAyO1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIGlmIChjaGFubmVsID09IDApIHJldHVybiB2ZWMyKHRleGVsLnIsIHRleGVsLmcpO1xuICBpZiAoY2hhbm5lbCA9PSAxKSByZXR1cm4gdmVjMih0ZXhlbC5iLCB0ZXhlbC5hKTtcbiAgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xufVxuXG52ZWMzIGdldFZlYzNGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gdmVjMyhyZXN1bHRbMF0sIHJlc3VsdFsxXSwgcmVzdWx0WzJdKTtcbn1cblxudmVjMyBnZXRNZW1vcnlPcHRpbWl6ZWRWZWMzKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgZmllbGRJbmRleCA9IDMgKiAoeCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopKTtcbiAgaW50IHZlY3RvckluZGV4ID0gZmllbGRJbmRleCAvIDQ7XG4gIGludCB2ZWN0b3JPZmZzZXQgPSBmaWVsZEluZGV4IC0gdmVjdG9ySW5kZXggKiA0O1xuICBpbnQgcmVhZFkgPSB2ZWN0b3JJbmRleCAvIHRleFNpemUueDtcbiAgaW50IHJlYWRYID0gdmVjdG9ySW5kZXggLSByZWFkWSAqIHRleFNpemUueDtcbiAgdmVjNCB0ZXgxID0gdGV4dHVyZTJEKHRleCwgKHZlYzIocmVhZFgsIHJlYWRZKSArIDAuNSkgLyB2ZWMyKHRleFNpemUpKTtcbiAgXG4gIGlmICh2ZWN0b3JPZmZzZXQgPT0gMCkge1xuICAgIHJldHVybiB0ZXgxLnh5ejtcbiAgfSBlbHNlIGlmICh2ZWN0b3JPZmZzZXQgPT0gMSkge1xuICAgIHJldHVybiB0ZXgxLnl6dztcbiAgfSBlbHNlIHtcbiAgICByZWFkWCsrO1xuICAgIGlmIChyZWFkWCA+PSB0ZXhTaXplLngpIHtcbiAgICAgIHJlYWRYID0gMDtcbiAgICAgIHJlYWRZKys7XG4gICAgfVxuICAgIHZlYzQgdGV4MiA9IHRleHR1cmUyRCh0ZXgsIHZlYzIocmVhZFgsIHJlYWRZKSAvIHZlYzIodGV4U2l6ZSkpO1xuICAgIGlmICh2ZWN0b3JPZmZzZXQgPT0gMikge1xuICAgICAgcmV0dXJuIHZlYzModGV4MS56LCB0ZXgxLncsIHRleDIueCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2ZWMzKHRleDEudywgdGV4Mi54LCB0ZXgyLnkpO1xuICAgIH1cbiAgfVxufVxuXG52ZWM0IGdldFZlYzRGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICByZXR1cm4gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgeiwgeSwgeCk7XG59XG5cbnZlYzQgZ2V0TWVtb3J5T3B0aW1pemVkVmVjNChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDIpO1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIHJldHVybiB2ZWM0KHRleGVsLnIsIHRleGVsLmcsIHRleGVsLmIsIHRleGVsLmEpO1xufVxuXG52ZWM0IGFjdHVhbENvbG9yO1xudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiLCBmbG9hdCBhKSB7XG4gIGFjdHVhbENvbG9yID0gdmVjNChyLGcsYixhKTtcbn1cblxudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiKSB7XG4gIGNvbG9yKHIsZyxiLDEuMCk7XG59XG5cbnZvaWQgY29sb3Ioc2FtcGxlcjJEIGltYWdlKSB7XG4gIGFjdHVhbENvbG9yID0gdGV4dHVyZTJEKGltYWdlLCB2VGV4Q29vcmQpO1xufVxuXG5mbG9hdCBtb2R1bG8oZmxvYXQgbnVtYmVyLCBmbG9hdCBkaXZpc29yKSB7XG4gIGlmIChudW1iZXIgPCAwLjApIHtcbiAgICBudW1iZXIgPSBhYnMobnVtYmVyKTtcbiAgICBpZiAoZGl2aXNvciA8IDAuMCkge1xuICAgICAgZGl2aXNvciA9IGFicyhkaXZpc29yKTtcbiAgICB9XG4gICAgcmV0dXJuIC1tb2QobnVtYmVyLCBkaXZpc29yKTtcbiAgfVxuICBpZiAoZGl2aXNvciA8IDAuMCkge1xuICAgIGRpdmlzb3IgPSBhYnMoZGl2aXNvcik7XG4gIH1cbiAgcmV0dXJuIG1vZChudW1iZXIsIGRpdmlzb3IpO1xufVxuXG5fX0lOSkVDVEVEX05BVElWRV9fO1xuX19NQUlOX0NPTlNUQU5UU19fO1xuX19NQUlOX0FSR1VNRU5UU19fO1xuX19LRVJORUxfXztcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgaW5kZXggPSBpbnQodlRleENvb3JkLnMgKiBmbG9hdCh1VGV4U2l6ZS54KSkgKyBpbnQodlRleENvb3JkLnQgKiBmbG9hdCh1VGV4U2l6ZS55KSkgKiB1VGV4U2l6ZS54O1xuICBfX01BSU5fUkVTVUxUX187XG59YDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZyYWdtZW50U2hhZGVyXG59O1xufSx7fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuLi9mdW5jdGlvbi1ub2RlJyk7XG5cbmNsYXNzIFdlYkdMRnVuY3Rpb25Ob2RlIGV4dGVuZHMgRnVuY3Rpb25Ob2RlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHNvdXJjZSwgc2V0dGluZ3MpO1xuICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3knKSkge1xuICAgICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IHNldHRpbmdzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5O1xuICAgIH1cbiAgfVxuXG4gIGFzdENvbmRpdGlvbmFsRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIGlmIChhc3QudHlwZSAhPT0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ05vdCBhIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgIH1cbiAgICBjb25zdCBjb25zZXF1ZW50VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QuY29uc2VxdWVudCk7XG4gICAgY29uc3QgYWx0ZXJuYXRlVHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QuYWx0ZXJuYXRlKTtcbiAgICBpZiAoY29uc2VxdWVudFR5cGUgPT09IG51bGwgJiYgYWx0ZXJuYXRlVHlwZSA9PT0gbnVsbCkge1xuICAgICAgcmV0QXJyLnB1c2goJ2lmICgnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QudGVzdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcpIHsnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc7Jyk7XG4gICAgICByZXRBcnIucHVzaCgnfSBlbHNlIHsnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYWx0ZXJuYXRlLCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJzsnKTtcbiAgICAgIHJldEFyci5wdXNoKCd9Jyk7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QudGVzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnPycpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnOicpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYWx0ZXJuYXRlLCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEZ1bmN0aW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKHRoaXMuaXNSb290S2VybmVsKSB7XG4gICAgICByZXRBcnIucHVzaCgndm9pZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICBjb25zdCBsYXN0UmV0dXJuID0gdGhpcy5maW5kTGFzdFJldHVybigpO1xuICAgICAgICBpZiAobGFzdFJldHVybikge1xuICAgICAgICAgIHRoaXMucmV0dXJuVHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QuYm9keSk7XG4gICAgICAgICAgaWYgKHRoaXMucmV0dXJuVHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuICAgICAgICAgICAgdGhpcy5yZXR1cm5UeXBlID0gJ051bWJlcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgcmV0dXJuVHlwZSB9ID0gdGhpcztcbiAgICAgIGlmICghcmV0dXJuVHlwZSkge1xuICAgICAgICByZXRBcnIucHVzaCgndm9pZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVNYXBbcmV0dXJuVHlwZV07XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlICR7cmV0dXJuVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXRBcnIucHVzaCh0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyAnKTtcbiAgICByZXRBcnIucHVzaCh0aGlzLm5hbWUpO1xuICAgIHJldEFyci5wdXNoKCcoJyk7XG5cbiAgICBpZiAoIXRoaXMuaXNSb290S2VybmVsKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBhcmd1bWVudE5hbWUgPSB0aGlzLmFyZ3VtZW50TmFtZXNbaV07XG5cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJywgJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFyZ3VtZW50VHlwZSA9IHRoaXMuYXJndW1lbnRUeXBlc1t0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihhcmd1bWVudE5hbWUpXTtcbiAgICAgICAgaWYgKCFhcmd1bWVudFR5cGUpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmtub3duIGFyZ3VtZW50ICR7YXJndW1lbnROYW1lfSB0eXBlYCwgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRUeXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudFR5cGVzW2ldID0gYXJndW1lbnRUeXBlID0gJ051bWJlcic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVNYXBbYXJndW1lbnRUeXBlXTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdXRpbHMuc2FuaXRpemVOYW1lKGFyZ3VtZW50TmFtZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc2FtcGxlcjJEJyB8fCB0eXBlID09PSAnc2FtcGxlcjJEQXJyYXknKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goYCR7dHlwZX0gdXNlcl8ke25hbWV9LGl2ZWMyIHVzZXJfJHtuYW1lfVNpemUsaXZlYzMgdXNlcl8ke25hbWV9RGltYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goYCR7dHlwZX0gdXNlcl8ke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXRBcnIucHVzaCgnKSB7XFxuJyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5ib2R5LmJvZHkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYm9keS5ib2R5W2ldLCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJ1xcbicpO1xuICAgIH1cblxuICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdFJldHVyblN0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIGlmICghYXN0LmFyZ3VtZW50KSB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIHJldHVybiBzdGF0ZW1lbnQnLCBhc3QpO1xuICAgIHRoaXMucHVzaFN0YXRlKCdza2lwLWxpdGVyYWwtY29ycmVjdGlvbicpO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LmFyZ3VtZW50KTtcbiAgICB0aGlzLnBvcFN0YXRlKCdza2lwLWxpdGVyYWwtY29ycmVjdGlvbicpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICBpZiAoIXRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicgfHwgdHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHRoaXMucmV0dXJuVHlwZSA9ICdOdW1iZXInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXR1cm5UeXBlID0gdHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnZmxvYXQoJyk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFzdC5hcmd1bWVudCwgcmVzdWx0KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VHlwZShhc3QpID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQoJ2Zsb2F0KCcpO1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvSW50ZWdlcihhc3QuYXJndW1lbnQsIHJlc3VsdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5hcmd1bWVudCwgcmVzdWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnSW5wdXQnOlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYHVuaGFuZGxlZCByZXR1cm4gdHlwZSAke3RoaXMucmV0dXJuVHlwZX1gLCBhc3QpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUm9vdEtlcm5lbCkge1xuICAgICAgcmV0QXJyLnB1c2goYGtlcm5lbFJlc3VsdCA9ICR7IHJlc3VsdC5qb2luKCcnKSB9O2ApO1xuICAgICAgcmV0QXJyLnB1c2goJ3JldHVybjsnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdWJLZXJuZWwpIHtcbiAgICAgIHJldEFyci5wdXNoKGBzdWJLZXJuZWxSZXN1bHRfJHsgdGhpcy5uYW1lIH0gPSAkeyByZXN1bHQuam9pbignJykgfTtgKTtcbiAgICAgIHJldEFyci5wdXNoKGByZXR1cm4gc3ViS2VybmVsUmVzdWx0XyR7IHRoaXMubmFtZSB9O2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaChgcmV0dXJuICR7IHJlc3VsdC5qb2luKCcnKSB9O2ApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0TGl0ZXJhbChhc3QsIHJldEFycikge1xuICAgIGlmIChpc05hTihhc3QudmFsdWUpKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KFxuICAgICAgICAnTm9uLW51bWVyaWMgbGl0ZXJhbCBub3Qgc3VwcG9ydGVkIDogJyArIGFzdC52YWx1ZSxcbiAgICAgICAgYXN0XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IHRoaXMuYXN0S2V5KGFzdCk7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoYXN0LnZhbHVlKSkge1xuICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykgfHwgdGhpcy5pc1N0YXRlKCdidWlsZGluZy1pbnRlZ2VyJykpIHtcbiAgICAgICAgdGhpcy5saXRlcmFsVHlwZXNba2V5XSA9ICdJbnRlZ2VyJztcbiAgICAgICAgcmV0QXJyLnB1c2goYCR7YXN0LnZhbHVlfWApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKSB8fCB0aGlzLmlzU3RhdGUoJ2J1aWxkaW5nLWZsb2F0JykpIHtcbiAgICAgICAgdGhpcy5saXRlcmFsVHlwZXNba2V5XSA9ICdOdW1iZXInO1xuICAgICAgICByZXRBcnIucHVzaChgJHthc3QudmFsdWV9LjBgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGl0ZXJhbFR5cGVzW2tleV0gPSAnTnVtYmVyJztcbiAgICAgICAgcmV0QXJyLnB1c2goYCR7YXN0LnZhbHVlfS4wYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpIHx8IHRoaXMuaXNTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpKSB7XG4gICAgICB0aGlzLmxpdGVyYWxUeXBlc1trZXldID0gJ0ludGVnZXInO1xuICAgICAgcmV0QXJyLnB1c2goTWF0aC5yb3VuZChhc3QudmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saXRlcmFsVHlwZXNba2V5XSA9ICdOdW1iZXInO1xuICAgICAgcmV0QXJyLnB1c2goYCR7YXN0LnZhbHVlfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0QmluYXJ5RXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIGlmICh0aGlzLmNoZWNrQW5kVXBjb252ZXJ0T3BlcmF0b3IoYXN0LCByZXRBcnIpKSB7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ICYmIGFzdC5vcGVyYXRvciA9PT0gJy8nKSB7XG4gICAgICByZXRBcnIucHVzaCgnZGl2V2l0aEludENoZWNrKCcpO1xuICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICBzd2l0Y2ggKHRoaXMuZ2V0VHlwZShhc3QubGVmdCkpIHtcbiAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goJywgJyk7XG4gICAgICBzd2l0Y2ggKHRoaXMuZ2V0VHlwZShhc3QucmlnaHQpKSB7XG4gICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgIHRoaXMuY2FzdFZhbHVlVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9XG5cbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIGNvbnN0IGxlZnRUeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5sZWZ0KSB8fCAnTnVtYmVyJztcbiAgICBjb25zdCByaWdodFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LnJpZ2h0KSB8fCAnTnVtYmVyJztcbiAgICBpZiAoIWxlZnRUeXBlIHx8ICFyaWdodFR5cGUpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBiaW5hcnkgZXhwcmVzc2lvbmAsIGFzdCk7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGxlZnRUeXBlICsgJyAmICcgKyByaWdodFR5cGU7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ0ludGVnZXIgJiBJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdOdW1iZXIgJiBGbG9hdCc6XG4gICAgICBjYXNlICdGbG9hdCAmIE51bWJlcic6XG4gICAgICBjYXNlICdGbG9hdCAmIEZsb2F0JzpcbiAgICAgIGNhc2UgJ051bWJlciAmIE51bWJlcic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlciAmIExpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykgfHwgdGhpcy5pc1N0YXRlKCdidWlsZGluZy1pbnRlZ2VyJykpIHtcbiAgICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdJbnRlZ2VyICYgRmxvYXQnOlxuICAgICAgY2FzZSAnSW50ZWdlciAmIE51bWJlcic6XG4gICAgICAgIGlmIChhc3Qub3BlcmF0b3IgPT09ICc+JyB8fCBhc3Qub3BlcmF0b3IgPT09ICc8JyAmJiBhc3QucmlnaHQudHlwZSA9PT0gJ0xpdGVyYWwnKSB7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFzdC5yaWdodC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcbiAgICAgICAgaWYgKGFzdC5yaWdodC50eXBlID09PSAnTGl0ZXJhbCcpIHtcbiAgICAgICAgICBjb25zdCBsaXRlcmFsUmVzdWx0ID0gW107XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgbGl0ZXJhbFJlc3VsdCk7XG4gICAgICAgICAgY29uc3QgbGl0ZXJhbFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LnJpZ2h0KTtcbiAgICAgICAgICBpZiAobGl0ZXJhbFR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgICAgcmV0QXJyLnB1c2gobGl0ZXJhbFJlc3VsdC5qb2luKCcnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBiaW5hcnkgZXhwcmVzc2lvbiB3aXRoIGxpdGVyYWxgLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnaW50KCcpO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0ludGVnZXIgJiBMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTnVtYmVyICYgSW50ZWdlcic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdGbG9hdCAmIExpdGVyYWxJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ051bWJlciAmIExpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXIgJiBGbG9hdCc6XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlciAmIE51bWJlcic6XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpKSB7XG4gICAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvSW50ZWdlcihhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKTtcbiAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICAgIHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKTtcbiAgICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXIgJiBJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdCb29sZWFuICYgQm9vbGVhbic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1ib29sZWFuJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1ib29sZWFuJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdGbG9hdCAmIEludGVnZXInOlxuICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMuY2FzdFZhbHVlVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgYmluYXJ5IGV4cHJlc3Npb24gYmV0d2VlbiAke2tleX1gLCBhc3QpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKScpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNoZWNrQW5kVXBjb252ZXJ0T3BlcmF0b3IoYXN0LCByZXRBcnIpIHtcbiAgICBjb25zdCBiaXR3aXNlUmVzdWx0ID0gdGhpcy5jaGVja0FuZFVwY29udmVydEJpdHdpc2VPcGVyYXRvcnMoYXN0LCByZXRBcnIpO1xuICAgIGlmIChiaXR3aXNlUmVzdWx0KSB7XG4gICAgICByZXR1cm4gYml0d2lzZVJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgdXBjb252ZXJ0YWJsZU9wZXJhdG9ycyA9IHtcbiAgICAgICclJzogdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA/ICdpbnRlZ2VyQ29ycmVjdGlvbk1vZHVsbycgOiAnbW9kdWxvJyxcbiAgICAgICcqKic6ICdwb3cnLFxuICAgIH07XG4gICAgY29uc3QgZm91bmRPcGVyYXRvciA9IHVwY29udmVydGFibGVPcGVyYXRvcnNbYXN0Lm9wZXJhdG9yXTtcbiAgICBpZiAoIWZvdW5kT3BlcmF0b3IpIHJldHVybiBudWxsO1xuICAgIHJldEFyci5wdXNoKGZvdW5kT3BlcmF0b3IpO1xuICAgIHJldEFyci5wdXNoKCcoJyk7XG4gICAgc3dpdGNoICh0aGlzLmdldFR5cGUoYXN0LmxlZnQpKSB7XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnLCcpO1xuICAgIHN3aXRjaCAodGhpcy5nZXRUeXBlKGFzdC5yaWdodCkpIHtcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvRmxvYXQoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNoZWNrQW5kVXBjb252ZXJ0Qml0d2lzZU9wZXJhdG9ycyhhc3QsIHJldEFycikge1xuICAgIGNvbnN0IHVwY29udmVydGFibGVPcGVyYXRvcnMgPSB7XG4gICAgICAnJic6ICdiaXR3aXNlQW5kJyxcbiAgICAgICd8JzogJ2JpdHdpc2VPcicsXG4gICAgICAnXic6ICdiaXR3aXNlWE9SJyxcbiAgICAgICc8PCc6ICdiaXR3aXNlWmVyb0ZpbGxMZWZ0U2hpZnQnLFxuICAgICAgJz4+JzogJ2JpdHdpc2VTaWduZWRSaWdodFNoaWZ0JyxcbiAgICAgICc+Pj4nOiAnYml0d2lzZVplcm9GaWxsUmlnaHRTaGlmdCcsXG4gICAgfTtcbiAgICBjb25zdCBmb3VuZE9wZXJhdG9yID0gdXBjb252ZXJ0YWJsZU9wZXJhdG9yc1thc3Qub3BlcmF0b3JdO1xuICAgIGlmICghZm91bmRPcGVyYXRvcikgcmV0dXJuIG51bGw7XG4gICAgcmV0QXJyLnB1c2goZm91bmRPcGVyYXRvcik7XG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICBjb25zdCBsZWZ0VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QubGVmdCk7XG4gICAgc3dpdGNoIChsZWZ0VHlwZSkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0ludGVnZXIoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJywnKTtcbiAgICBjb25zdCByaWdodFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LnJpZ2h0KTtcbiAgICBzd2l0Y2ggKHJpZ2h0VHlwZSkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0ludGVnZXIoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgY2hlY2tBbmRVcGNvbnZlcnRCaXR3aXNlVW5hcnkoYXN0LCByZXRBcnIpIHtcbiAgICBjb25zdCB1cGNvbnZlcnRhYmxlT3BlcmF0b3JzID0ge1xuICAgICAgJ34nOiAnYml0d2lzZU5vdCcsXG4gICAgfTtcbiAgICBjb25zdCBmb3VuZE9wZXJhdG9yID0gdXBjb252ZXJ0YWJsZU9wZXJhdG9yc1thc3Qub3BlcmF0b3JdO1xuICAgIGlmICghZm91bmRPcGVyYXRvcikgcmV0dXJuIG51bGw7XG4gICAgcmV0QXJyLnB1c2goZm91bmRPcGVyYXRvcik7XG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICBzd2l0Y2ggKHRoaXMuZ2V0VHlwZShhc3QuYXJndW1lbnQpKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvSW50ZWdlcihhc3QuYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5hcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXRBcnIpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjYXN0TGl0ZXJhbFRvSW50ZWdlcihhc3QsIHJldEFycikge1xuICAgIHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LCByZXRBcnIpO1xuICAgIHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LCByZXRBcnIpIHtcbiAgICB0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QsIHJldEFycik7XG4gICAgdGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjYXN0VmFsdWVUb0ludGVnZXIoYXN0LCByZXRBcnIpIHtcbiAgICB0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG4gICAgcmV0QXJyLnB1c2goJ2ludCgnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgdGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNhc3RWYWx1ZVRvRmxvYXQoYXN0LCByZXRBcnIpIHtcbiAgICB0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuICAgIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgdGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RJZGVudGlmaWVyRXhwcmVzc2lvbihpZHROb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoaWR0Tm9kZS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0lkZW50aWZpZXJFeHByZXNzaW9uIC0gbm90IGFuIElkZW50aWZpZXInLCBpZHROb2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGlkdE5vZGUpO1xuXG4gICAgY29uc3QgbmFtZSA9IHV0aWxzLnNhbml0aXplTmFtZShpZHROb2RlLm5hbWUpO1xuICAgIGlmIChpZHROb2RlLm5hbWUgPT09ICdJbmZpbml0eScpIHtcbiAgICAgIHJldEFyci5wdXNoKCczLjQwMjgyMzQ2NmUrMzgnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdCb29sZWFuJykge1xuICAgICAgaWYgKHRoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKG5hbWUpID4gLTEpIHtcbiAgICAgICAgcmV0QXJyLnB1c2goYGJvb2wodXNlcl8ke25hbWV9KWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHtuYW1lfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaChgdXNlcl8ke25hbWV9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEZvclN0YXRlbWVudChmb3JOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoZm9yTm9kZS50eXBlICE9PSAnRm9yU3RhdGVtZW50Jykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnSW52YWxpZCBmb3Igc3RhdGVtZW50JywgZm9yTm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdEFyciA9IFtdO1xuICAgIGNvbnN0IHRlc3RBcnIgPSBbXTtcbiAgICBjb25zdCB1cGRhdGVBcnIgPSBbXTtcbiAgICBjb25zdCBib2R5QXJyID0gW107XG4gICAgbGV0IGlzU2FmZSA9IG51bGw7XG5cbiAgICBpZiAoZm9yTm9kZS5pbml0KSB7XG4gICAgICBjb25zdCB7IGRlY2xhcmF0aW9ucyB9ID0gZm9yTm9kZS5pbml0O1xuICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUuaW5pdCwgaW5pdEFycik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGVjbGFyYXRpb25zW2ldLmluaXQgJiYgZGVjbGFyYXRpb25zW2ldLmluaXQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG4gICAgICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZvck5vZGUudGVzdCkge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUudGVzdCwgdGVzdEFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmb3JOb2RlLnVwZGF0ZSkge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUudXBkYXRlLCB1cGRhdGVBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc1NhZmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZm9yTm9kZS5ib2R5KSB7XG4gICAgICB0aGlzLnB1c2hTdGF0ZSgnbG9vcC1ib2R5Jyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS5ib2R5LCBib2R5QXJyKTtcbiAgICAgIHRoaXMucG9wU3RhdGUoJ2xvb3AtYm9keScpO1xuICAgIH1cblxuICAgIGlmIChpc1NhZmUgPT09IG51bGwpIHtcbiAgICAgIGlzU2FmZSA9IHRoaXMuaXNTYWZlKGZvck5vZGUuaW5pdCkgJiYgdGhpcy5pc1NhZmUoZm9yTm9kZS50ZXN0KTtcbiAgICB9XG5cbiAgICBpZiAoaXNTYWZlKSB7XG4gICAgICBjb25zdCBpbml0U3RyaW5nID0gaW5pdEFyci5qb2luKCcnKTtcbiAgICAgIGNvbnN0IGluaXROZWVkc1NlbWlDb2xvbiA9IGluaXRTdHJpbmdbaW5pdFN0cmluZy5sZW5ndGggLSAxXSAhPT0gJzsnO1xuICAgICAgcmV0QXJyLnB1c2goYGZvciAoJHtpbml0U3RyaW5nfSR7aW5pdE5lZWRzU2VtaUNvbG9uID8gJzsnIDogJyd9JHt0ZXN0QXJyLmpvaW4oJycpfTske3VwZGF0ZUFyci5qb2luKCcnKX0pe1xcbmApO1xuICAgICAgcmV0QXJyLnB1c2goYm9keUFyci5qb2luKCcnKSk7XG4gICAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpVmFyaWFibGVOYW1lID0gdGhpcy5nZXRJbnRlcm5hbFZhcmlhYmxlTmFtZSgnc2FmZUknKTtcbiAgICAgIGlmIChpbml0QXJyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0QXJyLnB1c2goaW5pdEFyci5qb2luKCcnKSwgJ1xcbicpO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goYGZvciAoaW50ICR7aVZhcmlhYmxlTmFtZX09MDske2lWYXJpYWJsZU5hbWV9PExPT1BfTUFYOyR7aVZhcmlhYmxlTmFtZX0rKyl7XFxuYCk7XG4gICAgICBpZiAodGVzdEFyci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldEFyci5wdXNoKGBpZiAoISR7dGVzdEFyci5qb2luKCcnKX0pIGJyZWFrO1xcbmApO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goYm9keUFyci5qb2luKCcnKSk7XG4gICAgICByZXRBcnIucHVzaChgXFxuJHt1cGRhdGVBcnIuam9pbignJyl9O2ApO1xuICAgICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdFdoaWxlU3RhdGVtZW50KHdoaWxlTm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKHdoaWxlTm9kZS50eXBlICE9PSAnV2hpbGVTdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIHdoaWxlIHN0YXRlbWVudCcsIHdoaWxlTm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaVZhcmlhYmxlTmFtZSA9IHRoaXMuZ2V0SW50ZXJuYWxWYXJpYWJsZU5hbWUoJ3NhZmVJJyk7XG4gICAgcmV0QXJyLnB1c2goYGZvciAoaW50ICR7aVZhcmlhYmxlTmFtZX09MDske2lWYXJpYWJsZU5hbWV9PExPT1BfTUFYOyR7aVZhcmlhYmxlTmFtZX0rKyl7XFxuYCk7XG4gICAgcmV0QXJyLnB1c2goJ2lmICghJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKHdoaWxlTm9kZS50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpIGJyZWFrO1xcbicpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyh3aGlsZU5vZGUuYm9keSwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdERvV2hpbGVTdGF0ZW1lbnQoZG9XaGlsZU5vZGUsIHJldEFycikge1xuICAgIGlmIChkb1doaWxlTm9kZS50eXBlICE9PSAnRG9XaGlsZVN0YXRlbWVudCcpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0ludmFsaWQgd2hpbGUgc3RhdGVtZW50JywgZG9XaGlsZU5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGlWYXJpYWJsZU5hbWUgPSB0aGlzLmdldEludGVybmFsVmFyaWFibGVOYW1lKCdzYWZlSScpO1xuICAgIHJldEFyci5wdXNoKGBmb3IgKGludCAke2lWYXJpYWJsZU5hbWV9PTA7JHtpVmFyaWFibGVOYW1lfTxMT09QX01BWDske2lWYXJpYWJsZU5hbWV9Kyspe1xcbmApO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhkb1doaWxlTm9kZS5ib2R5LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCdpZiAoIScpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhkb1doaWxlTm9kZS50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpIGJyZWFrO1xcbicpO1xuICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cblxuICBhc3RBc3NpZ25tZW50RXhwcmVzc2lvbihhc3NOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoYXNzTm9kZS5vcGVyYXRvciA9PT0gJyU9Jykge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc9Jyk7XG4gICAgICByZXRBcnIucHVzaCgnbW9kKCcpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcsJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5yaWdodCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgfSBlbHNlIGlmIChhc3NOb2RlLm9wZXJhdG9yID09PSAnKio9Jykge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc9Jyk7XG4gICAgICByZXRBcnIucHVzaCgncG93KCcpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcsJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5yaWdodCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlZnRUeXBlID0gdGhpcy5nZXRUeXBlKGFzc05vZGUubGVmdCk7XG4gICAgICBjb25zdCByaWdodFR5cGUgPSB0aGlzLmdldFR5cGUoYXNzTm9kZS5yaWdodCk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5sZWZ0LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goYXNzTm9kZS5vcGVyYXRvcik7XG4gICAgICBpZiAobGVmdFR5cGUgIT09ICdJbnRlZ2VyJyAmJiByaWdodFR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICByZXRBcnIucHVzaCgnZmxvYXQoJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUucmlnaHQsIHJldEFycik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cbiAgfVxuXG4gIGFzdEJsb2NrU3RhdGVtZW50KGJOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAodGhpcy5pc1N0YXRlKCdsb29wLWJvZHknKSkge1xuICAgICAgdGhpcy5wdXNoU3RhdGUoJ2Jsb2NrLWJvZHknKTsgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJOb2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGJOb2RlLmJvZHlbaV0sIHJldEFycik7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcFN0YXRlKCdibG9jay1ib2R5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKCd7XFxuJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJOb2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGJOb2RlLmJvZHlbaV0sIHJldEFycik7XG4gICAgICB9XG4gICAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0VmFyaWFibGVEZWNsYXJhdGlvbih2YXJEZWNOb2RlLCByZXRBcnIpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSB2YXJEZWNOb2RlLmRlY2xhcmF0aW9ucztcbiAgICBpZiAoIWRlY2xhcmF0aW9ucyB8fCAhZGVjbGFyYXRpb25zWzBdIHx8ICFkZWNsYXJhdGlvbnNbMF0uaW5pdCkge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgdmFyRGVjTm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBsYXN0VHlwZSA9IG51bGw7XG4gICAgY29uc3QgZGVjbGFyYXRpb25TZXRzID0gW107XG4gICAgbGV0IGRlY2xhcmF0aW9uU2V0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNsYXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb25zW2ldO1xuICAgICAgY29uc3QgaW5pdCA9IGRlY2xhcmF0aW9uLmluaXQ7XG4gICAgICBjb25zdCBpbmZvID0gdGhpcy5nZXREZWNsYXJhdGlvbihkZWNsYXJhdGlvbi5pZCk7XG4gICAgICBjb25zdCBhY3R1YWxUeXBlID0gdGhpcy5nZXRUeXBlKGRlY2xhcmF0aW9uLmluaXQpO1xuICAgICAgbGV0IHR5cGUgPSBhY3R1YWxUeXBlO1xuICAgICAgaWYgKHR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicpIHtcbiAgICAgICAgaWYgKGluZm8uc3VnZ2VzdGVkVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgdHlwZSA9ICdJbnRlZ2VyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlID0gJ051bWJlcic7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hcmt1cFR5cGUgPSB0eXBlTWFwW3R5cGVdO1xuICAgICAgaWYgKCFtYXJrdXBUeXBlKSB7XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYE1hcmt1cCB0eXBlICR7IG1hcmt1cFR5cGUgfSBub3QgaGFuZGxlZGAsIHZhckRlY05vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVjbGFyYXRpb25SZXN1bHQgPSBbXTtcbiAgICAgIGlmIChhY3R1YWxUeXBlID09PSAnSW50ZWdlcicgJiYgdHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIGluZm8udmFsdWVUeXBlID0gJ051bWJlcic7XG4gICAgICAgIGlmIChpID09PSAwIHx8IGxhc3RUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaCgnZmxvYXQgJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gbGFzdFR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBkZWNsYXJhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RUeXBlID0gdHlwZTtcbiAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaChgdXNlcl8ke3V0aWxzLnNhbml0aXplTmFtZShkZWNsYXJhdGlvbi5pZC5uYW1lKX09YCk7XG4gICAgICAgIGRlY2xhcmF0aW9uUmVzdWx0LnB1c2goJ2Zsb2F0KCcpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoaW5pdCwgZGVjbGFyYXRpb25SZXN1bHQpO1xuICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvLnZhbHVlVHlwZSA9IHR5cGU7XG4gICAgICAgIGlmIChpID09PSAwIHx8IGxhc3RUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaChgJHttYXJrdXBUeXBlfSBgKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSBsYXN0VHlwZSkge1xuICAgICAgICAgIGRlY2xhcmF0aW9uU2V0cy5wdXNoKGRlY2xhcmF0aW9uU2V0LmpvaW4oJywnKSk7XG4gICAgICAgICAgZGVjbGFyYXRpb25TZXQgPSBbXTtcbiAgICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKGAke21hcmt1cFR5cGV9IGApO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RUeXBlID0gdHlwZTtcbiAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaChgdXNlcl8ke3V0aWxzLnNhbml0aXplTmFtZShkZWNsYXJhdGlvbi5pZC5uYW1lKX09YCk7XG4gICAgICAgIGlmIChhY3R1YWxUeXBlID09PSAnTnVtYmVyJyAmJiB0eXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICBpZiAoaW5pdC5sZWZ0ICYmIGluaXQubGVmdC50eXBlID09PSAnTGl0ZXJhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhpbml0LCBkZWNsYXJhdGlvblJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uUmVzdWx0LnB1c2goJ2ludCgnKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhpbml0LCBkZWNsYXJhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFjdHVhbFR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicgJiYgdHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihpbml0LCBkZWNsYXJhdGlvblJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGluaXQsIGRlY2xhcmF0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVjbGFyYXRpb25TZXQucHVzaChkZWNsYXJhdGlvblJlc3VsdC5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgaWYgKGRlY2xhcmF0aW9uU2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGRlY2xhcmF0aW9uU2V0cy5wdXNoKGRlY2xhcmF0aW9uU2V0LmpvaW4oJywnKSk7XG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2goZGVjbGFyYXRpb25TZXRzLmpvaW4oJzsnKSk7XG5cbiAgICByZXRBcnIucHVzaChyZXN1bHQuam9pbignJykpO1xuICAgIHJldEFyci5wdXNoKCc7Jyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdElmU3RhdGVtZW50KGlmTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJ2lmICgnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLnRlc3QsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICBpZiAoaWZOb2RlLmNvbnNlcXVlbnQudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaCgnIHtcXG4nKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCdcXG59XFxuJyk7XG4gICAgfVxuXG4gICAgaWYgKGlmTm9kZS5hbHRlcm5hdGUpIHtcbiAgICAgIHJldEFyci5wdXNoKCdlbHNlICcpO1xuICAgICAgaWYgKGlmTm9kZS5hbHRlcm5hdGUudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50JyB8fCBpZk5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09ICdJZlN0YXRlbWVudCcpIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXRBcnIucHVzaCgnIHtcXG4nKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCdcXG59XFxuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RTd2l0Y2hTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICBpZiAoYXN0LnR5cGUgIT09ICdTd2l0Y2hTdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIHN3aXRjaCBzdGF0ZW1lbnQnLCBhc3QpO1xuICAgIH1cbiAgICBjb25zdCB7IGRpc2NyaW1pbmFudCwgY2FzZXMgfSA9IGFzdDtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGRpc2NyaW1pbmFudCk7XG4gICAgY29uc3QgdmFyTmFtZSA9IGBzd2l0Y2hEaXNjcmltaW5hbnQke3RoaXMuYXN0S2V5KGFzdCwgJ18nKX1gO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGZsb2F0ICR7dmFyTmFtZX0gPSBgKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGRpc2NyaW1pbmFudCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJztcXG4nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGludCAke3Zhck5hbWV9ID0gYCk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhkaXNjcmltaW5hbnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCc7XFxuJyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoY2FzZXMubGVuZ3RoID09PSAxICYmICFjYXNlc1swXS50ZXN0KSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoY2FzZXNbMF0uY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfVxuXG4gICAgbGV0IGZhbGxpbmdUaHJvdWdoID0gZmFsc2U7XG4gICAgbGV0IGRlZmF1bHRSZXN1bHQgPSBbXTtcbiAgICBsZXQgbW92aW5nRGVmYXVsdFRvRW5kID0gZmFsc2U7XG4gICAgbGV0IHBhc3RGaXJzdElmID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFjYXNlc1tpXS50ZXN0KSB7XG4gICAgICAgIGlmIChjYXNlcy5sZW5ndGggPiBpICsgMSkge1xuICAgICAgICAgIG1vdmluZ0RlZmF1bHRUb0VuZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGNhc2VzW2ldLmNvbnNlcXVlbnQsIGRlZmF1bHRSZXN1bHQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldEFyci5wdXNoKCcgZWxzZSB7XFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpID09PSAwIHx8ICFwYXN0Rmlyc3RJZikge1xuICAgICAgICAgIHBhc3RGaXJzdElmID0gdHJ1ZTtcbiAgICAgICAgICByZXRBcnIucHVzaChgaWYgKCR7dmFyTmFtZX0gPT0gYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZhbGxpbmdUaHJvdWdoKSB7XG4gICAgICAgICAgICByZXRBcnIucHVzaChgJHt2YXJOYW1lfSA9PSBgKTtcbiAgICAgICAgICAgIGZhbGxpbmdUaHJvdWdoID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGAgZWxzZSBpZiAoJHt2YXJOYW1lfSA9PSBgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgIGNvbnN0IHRlc3RUeXBlID0gdGhpcy5nZXRUeXBlKGNhc2VzW2ldLnRlc3QpO1xuICAgICAgICAgIHN3aXRjaCAodGVzdFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgICAgIHRoaXMuY2FzdFZhbHVlVG9JbnRlZ2VyKGNhc2VzW2ldLnRlc3QsIHJldEFycik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGNhc2VzW2ldLnRlc3QsIHJldEFycik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnRmxvYXQnKSB7XG4gICAgICAgICAgY29uc3QgdGVzdFR5cGUgPSB0aGlzLmdldFR5cGUoY2FzZXNbaV0udGVzdCk7XG4gICAgICAgICAgc3dpdGNoICh0ZXN0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChjYXNlc1tpXS50ZXN0LCByZXRBcnIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvRmxvYXQoY2FzZXNbaV0udGVzdCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5oYW5sZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYXNlc1tpXS5jb25zZXF1ZW50IHx8IGNhc2VzW2ldLmNvbnNlcXVlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZmFsbGluZ1Rocm91Z2ggPSB0cnVlO1xuICAgICAgICAgIHJldEFyci5wdXNoKCcgfHwgJyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0QXJyLnB1c2goYCkge1xcbmApO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3RHZW5lcmljKGNhc2VzW2ldLmNvbnNlcXVlbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnXFxufScpO1xuICAgIH1cbiAgICBpZiAobW92aW5nRGVmYXVsdFRvRW5kKSB7XG4gICAgICByZXRBcnIucHVzaCgnIGVsc2UgeycpO1xuICAgICAgcmV0QXJyLnB1c2goZGVmYXVsdFJlc3VsdC5qb2luKCcnKSk7XG4gICAgICByZXRBcnIucHVzaCgnfScpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0VGhpc0V4cHJlc3Npb24odE5vZGUsIHJldEFycikge1xuICAgIHJldEFyci5wdXNoKCd0aGlzJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdE1lbWJlckV4cHJlc3Npb24obU5vZGUsIHJldEFycikge1xuICAgIGNvbnN0IHtcbiAgICAgIHByb3BlcnR5LFxuICAgICAgbmFtZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIG9yaWdpbixcbiAgICAgIHR5cGUsXG4gICAgICB4UHJvcGVydHksXG4gICAgICB5UHJvcGVydHksXG4gICAgICB6UHJvcGVydHlcbiAgICB9ID0gdGhpcy5nZXRNZW1iZXJFeHByZXNzaW9uRGV0YWlscyhtTm9kZSk7XG4gICAgc3dpdGNoIChzaWduYXR1cmUpIHtcbiAgICAgIGNhc2UgJ3ZhbHVlLnRocmVhZC52YWx1ZSc6XG4gICAgICBjYXNlICd0aGlzLnRocmVhZC52YWx1ZSc6XG4gICAgICAgIGlmIChuYW1lICE9PSAneCcgJiYgbmFtZSAhPT0gJ3knICYmIG5hbWUgIT09ICd6Jykge1xuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbiwgZXhwZWN0ZWQgYHRoaXMudGhyZWFkLnhgLCBgdGhpcy50aHJlYWQueWAsIG9yIGB0aGlzLnRocmVhZC56YCcsIG1Ob2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXRBcnIucHVzaChgdGhyZWFkSWQuJHtuYW1lfWApO1xuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgY2FzZSAndGhpcy5vdXRwdXQudmFsdWUnOlxuICAgICAgICBpZiAodGhpcy5keW5hbWljT3V0cHV0KSB7XG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ2Zsb2F0KHVPdXRwdXREaW0ueCknKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCgndU91dHB1dERpbS54Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ2Zsb2F0KHVPdXRwdXREaW0ueSknKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCgndU91dHB1dERpbS55Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ2Zsb2F0KHVPdXRwdXREaW0ueiknKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCgndU91dHB1dERpbS56Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBtTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMub3V0cHV0WzBdLCAnLjAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKSkge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMub3V0cHV0WzFdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm91dHB1dFsxXSwgJy4wJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykpIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm91dHB1dFsyXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMl0sICcuMCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBtTm9kZSk7XG4gICAgICBjYXNlICd2YWx1ZVtdJzpcbiAgICAgIGNhc2UgJ3ZhbHVlW11bXSc6XG4gICAgICBjYXNlICd2YWx1ZVtdW11bXSc6XG4gICAgICBjYXNlICd2YWx1ZVtdW11bXVtdJzpcbiAgICAgIGNhc2UgJ3ZhbHVlLnZhbHVlJzpcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gJ01hdGgnKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goTWF0aFtuYW1lXSk7XG4gICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGVhbk5hbWUgPSB1dGlscy5zYW5pdGl6ZU5hbWUobmFtZSk7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IGNsZWFuTmFtZSB9LnJgKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8keyBjbGVhbk5hbWUgfS5nYCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHsgY2xlYW5OYW1lIH0uYmApO1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IGNsZWFuTmFtZSB9LmFgKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZSc6XG4gICAgICAgIGlmICh0eXBlb2YgeFByb3BlcnR5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgICAgICByZXRBcnIucHVzaChgY29uc3RhbnRzXyR7IHV0aWxzLnNhbml0aXplTmFtZShuYW1lKSB9YCk7XG4gICAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW10nOlxuICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW10nOlxuICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXSc6XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdW10nOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmbigpW10nOlxuICAgICAgICAgIHRoaXMuYXN0Q2FsbEV4cHJlc3Npb24obU5vZGUub2JqZWN0LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAocHJvcGVydHkpKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIGNhc2UgJ1tdW10nOlxuICAgICAgICAgIHRoaXMuYXN0QXJyYXlFeHByZXNzaW9uKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHByb3BlcnR5KSk7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICBjYXNlICd2YWx1ZS52YWx1ZVtdJzpcbiAgICAgICAgY2FzZSAndmFsdWUudmFsdWVbXVtdJzpcbiAgICAgICAgICBpZiAodGhpcy5yZW1vdmVJc3RhbmJ1bENvdmVyYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuICAgIH1cblxuICAgIGlmIChtTm9kZS5jb21wdXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgICAgICByZXRBcnIucHVzaChgJHtvcmlnaW59XyR7dXRpbHMuc2FuaXRpemVOYW1lKG5hbWUpfWApO1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWFya3VwTmFtZSA9IGAke29yaWdpbn1fJHt1dGlscy5zYW5pdGl6ZU5hbWUobmFtZSl9YDtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICByZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cCh4UHJvcGVydHkpKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRJbWFnZTNEKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldEZsb2F0RnJvbVNhbXBsZXIyRCgkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5MUQoMiknOlxuICAgICAgY2FzZSAnQXJyYXkyRCgyKSc6XG4gICAgICBjYXNlICdBcnJheTNEKDIpJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldE1lbW9yeU9wdGltaXplZFZlYzIoJHsgbWFya3VwTmFtZSB9LCAkeyBtYXJrdXBOYW1lIH1TaXplLCAkeyBtYXJrdXBOYW1lIH1EaW0sIGApO1xuICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoMiknOlxuICAgICAgICByZXRBcnIucHVzaChgZ2V0VmVjMkZyb21TYW1wbGVyMkQoJHsgbWFya3VwTmFtZSB9LCAkeyBtYXJrdXBOYW1lIH1TaXplLCAkeyBtYXJrdXBOYW1lIH1EaW0sIGApO1xuICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheTFEKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5MkQoMyknOlxuICAgICAgY2FzZSAnQXJyYXkzRCgzKSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRNZW1vcnlPcHRpbWl6ZWRWZWMzKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldFZlYzNGcm9tU2FtcGxlcjJEKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXkxRCg0KSc6XG4gICAgICBjYXNlICdBcnJheTJEKDQpJzpcbiAgICAgIGNhc2UgJ0FycmF5M0QoNCknOlxuICAgICAgICByZXRBcnIucHVzaChgZ2V0TWVtb3J5T3B0aW1pemVkVmVjNCgkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG4gICAgICBjYXNlICdIVE1MQ2FudmFzJzpcbiAgICAgIGNhc2UgJ0hUTUxJbWFnZSc6XG4gICAgICBjYXNlICdIVE1MVmlkZW8nOlxuICAgICAgICByZXRBcnIucHVzaChgZ2V0VmVjNEZyb21TYW1wbGVyMkQoJHsgbWFya3VwTmFtZSB9LCAkeyBtYXJrdXBOYW1lIH1TaXplLCAkeyBtYXJrdXBOYW1lIH1EaW0sIGApO1xuICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdOdW1iZXJUZXh0dXJlJzpcbiAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIGNhc2UgJ0FycmF5MkQnOlxuICAgICAgY2FzZSAnQXJyYXkzRCc6XG4gICAgICBjYXNlICdBcnJheTREJzpcbiAgICAgIGNhc2UgJ0lucHV0JzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgICAgIHJldEFyci5wdXNoKGBnZXRNZW1vcnlPcHRpbWl6ZWQzMigke21hcmt1cE5hbWV9LCAke21hcmt1cE5hbWV9U2l6ZSwgJHttYXJrdXBOYW1lfURpbSwgYCk7XG4gICAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBiaXRSYXRpbyA9IChvcmlnaW4gPT09ICd1c2VyJyA/XG4gICAgICAgICAgICB0aGlzLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyh0aGlzLm5hbWUsIG5hbWUpIDpcbiAgICAgICAgICAgIHRoaXMuY29uc3RhbnRCaXRSYXRpb3NbbmFtZV1cbiAgICAgICAgICApO1xuICAgICAgICAgIHN3aXRjaCAoYml0UmF0aW8pIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcmV0QXJyLnB1c2goYGdldDgoJHttYXJrdXBOYW1lfSwgJHttYXJrdXBOYW1lfVNpemUsICR7bWFya3VwTmFtZX1EaW0sIGApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcmV0QXJyLnB1c2goYGdldDE2KCR7bWFya3VwTmFtZX0sICR7bWFya3VwTmFtZX1TaXplLCAke21hcmt1cE5hbWV9RGltLCBgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKGBnZXQzMigke21hcmt1cE5hbWV9LCAke21hcmt1cE5hbWV9U2l6ZSwgJHttYXJrdXBOYW1lfURpbSwgYCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgYml0IHJhdGlvIG9mICR7Yml0UmF0aW99YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldE1lbW9yeU9wdGltaXplZDMyKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgbWVtYmVyIGV4cHJlc3Npb24gXCIkeyB0eXBlIH1cImApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0Q2FsbEV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICBpZiAoIWFzdC5jYWxsZWUpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1Vua25vd24gQ2FsbEV4cHJlc3Npb24nLCBhc3QpO1xuICAgIH1cblxuICAgIGxldCBmdW5jdGlvbk5hbWUgPSBudWxsO1xuICAgIGNvbnN0IGlzTWF0aEZ1bmN0aW9uID0gdGhpcy5pc0FzdE1hdGhGdW5jdGlvbihhc3QpO1xuXG4gICAgaWYgKGlzTWF0aEZ1bmN0aW9uIHx8IChhc3QuY2FsbGVlLm9iamVjdCAmJiBhc3QuY2FsbGVlLm9iamVjdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSkge1xuICAgICAgZnVuY3Rpb25OYW1lID0gYXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QuY2FsbGVlLnR5cGUgPT09ICdTZXF1ZW5jZUV4cHJlc3Npb24nICYmIGFzdC5jYWxsZWUuZXhwcmVzc2lvbnNbMF0udHlwZSA9PT0gJ0xpdGVyYWwnICYmICFpc05hTihhc3QuY2FsbGVlLmV4cHJlc3Npb25zWzBdLnJhdykpIHtcbiAgICAgIGZ1bmN0aW9uTmFtZSA9IGFzdC5jYWxsZWUuZXhwcmVzc2lvbnNbMV0ucHJvcGVydHkubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVuY3Rpb25OYW1lID0gYXN0LmNhbGxlZS5uYW1lO1xuICAgIH1cblxuICAgIGlmICghZnVuY3Rpb25OYW1lKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgZnVuY3Rpb24sIGNvdWxkbid0IGZpbmQgbmFtZWAsIGFzdCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgIGNhc2UgJ3Bvdyc6XG4gICAgICAgIGZ1bmN0aW9uTmFtZSA9ICdfcG93JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyb3VuZCc6XG4gICAgICAgIGZ1bmN0aW9uTmFtZSA9ICdfcm91bmQnO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jYWxsZWRGdW5jdGlvbnMuaW5kZXhPZihmdW5jdGlvbk5hbWUpIDwgMCkge1xuICAgICAgdGhpcy5jYWxsZWRGdW5jdGlvbnMucHVzaChmdW5jdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIGlmIChmdW5jdGlvbk5hbWUgPT09ICdyYW5kb20nICYmIHRoaXMucGx1Z2lucyAmJiB0aGlzLnBsdWdpbnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy5wbHVnaW5zW2ldO1xuICAgICAgICBpZiAocGx1Z2luLmZ1bmN0aW9uTWF0Y2ggPT09ICdNYXRoLnJhbmRvbSgpJyAmJiBwbHVnaW4uZnVuY3Rpb25SZXBsYWNlKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2gocGx1Z2luLmZ1bmN0aW9uUmVwbGFjZSk7XG4gICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9uRnVuY3Rpb25DYWxsKSB7XG4gICAgICB0aGlzLm9uRnVuY3Rpb25DYWxsKHRoaXMubmFtZSwgZnVuY3Rpb25OYW1lLCBhc3QuYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXRBcnIucHVzaChmdW5jdGlvbk5hbWUpO1xuXG4gICAgcmV0QXJyLnB1c2goJygnKTtcblxuICAgIGlmIChpc01hdGhGdW5jdGlvbikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QuYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50ID0gYXN0LmFyZ3VtZW50c1tpXTtcbiAgICAgICAgY29uc3QgYXJndW1lbnRUeXBlID0gdGhpcy5nZXRUeXBlKGFyZ3VtZW50KTtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJywgJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50VHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldFR5cGVzID0gdGhpcy5sb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMoZnVuY3Rpb25OYW1lKSB8fCBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LmFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBhcmd1bWVudCA9IGFzdC5hcmd1bWVudHNbaV07XG4gICAgICAgIGxldCB0YXJnZXRUeXBlID0gdGFyZ2V0VHlwZXNbaV07XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHJldEFyci5wdXNoKCcsICcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50VHlwZSA9IHRoaXMuZ2V0VHlwZShhcmd1bWVudCk7XG4gICAgICAgIGlmICghdGFyZ2V0VHlwZSkge1xuICAgICAgICAgIHRoaXMudHJpZ2dlckltcGx5QXJndW1lbnRUeXBlKGZ1bmN0aW9uTmFtZSwgaSwgYXJndW1lbnRUeXBlLCB0aGlzKTtcbiAgICAgICAgICB0YXJnZXRUeXBlID0gYXJndW1lbnRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRUeXBlKSB7XG4gICAgICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICAgIGlmICh0YXJnZXRUeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ2ludCgnKTtcbiAgICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VHlwZSA9PT0gJ051bWJlcicgfHwgdGFyZ2V0VHlwZSA9PT0gJ0Zsb2F0Jykge1xuICAgICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRUeXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgaWYgKHRhcmdldFR5cGUgPT09ICdOdW1iZXInIHx8IHRhcmdldFR5cGUgPT09ICdGbG9hdCcpIHtcbiAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ2Zsb2F0KCcpO1xuICAgICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRUeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICAgIGlmICh0YXJnZXRUeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFR5cGUgPT09ICdOdW1iZXInIHx8IHRhcmdldFR5cGUgPT09ICdGbG9hdCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRUeXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgICAgIGlmICh0YXJnZXRUeXBlID09PSBhcmd1bWVudFR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50LnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7dXRpbHMuc2FuaXRpemVOYW1lKGFyZ3VtZW50Lm5hbWUpfWApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50LnR5cGUgPT09ICdBcnJheUV4cHJlc3Npb24nIHx8IGFyZ3VtZW50LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyB8fCBhcmd1bWVudC50eXBlID09PSAnQ2FsbEV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBhcmd1bWVudCB0eXBlICR7IGFyZ3VtZW50LnR5cGUgfWAsIGFzdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdIVE1MQ2FudmFzJzpcbiAgICAgICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgICAgIGNhc2UgJ0hUTUxJbWFnZUFycmF5JzpcbiAgICAgICAgICBjYXNlICdIVE1MVmlkZW8nOlxuICAgICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDIpJzpcbiAgICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMyknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG4gICAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgIGNhc2UgJ0lucHV0JzpcbiAgICAgICAgICAgIGlmICh0YXJnZXRUeXBlID09PSBhcmd1bWVudFR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50LnR5cGUgIT09ICdJZGVudGlmaWVyJykgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIGFyZ3VtZW50IHR5cGUgJHsgYXJndW1lbnQudHlwZSB9YCwgYXN0KTtcbiAgICAgICAgICAgICAgdGhpcy50cmlnZ2VySW1wbHlBcmd1bWVudEJpdFJhdGlvKHRoaXMubmFtZSwgYXJndW1lbnQubmFtZSwgZnVuY3Rpb25OYW1lLCBpKTtcbiAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IHV0aWxzLnNhbml0aXplTmFtZShhcmd1bWVudC5uYW1lKTtcbiAgICAgICAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHtuYW1lfSx1c2VyXyR7bmFtZX1TaXplLHVzZXJfJHtuYW1lfURpbWApO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBhcmd1bWVudCBjb21iaW5hdGlvbiBvZiAkeyBhcmd1bWVudFR5cGUgfSBhbmQgJHsgdGFyZ2V0VHlwZSB9IGZvciBhcmd1bWVudCBuYW1lZCBcIiR7IGFyZ3VtZW50Lm5hbWUgfVwiYCwgYXN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyknKTtcblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RBcnJheUV4cHJlc3Npb24oYXJyTm9kZSwgcmV0QXJyKSB7XG4gICAgY29uc3QgYXJyTGVuID0gYXJyTm9kZS5lbGVtZW50cy5sZW5ndGg7XG5cbiAgICByZXRBcnIucHVzaCgndmVjJyArIGFyckxlbiArICcoJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJMZW47ICsraSkge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHJldEFyci5wdXNoKCcsICcpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3ViTm9kZSA9IGFyck5vZGUuZWxlbWVudHNbaV07XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoc3ViTm9kZSwgcmV0QXJyKVxuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKScpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIG1lbWJlckV4cHJlc3Npb25YWVooeCwgeSwgeiwgcmV0QXJyKSB7XG4gICAgaWYgKHopIHtcbiAgICAgIHJldEFyci5wdXNoKHRoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHopLCAnLCAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goJzAsICcpO1xuICAgIH1cbiAgICBpZiAoeSkge1xuICAgICAgcmV0QXJyLnB1c2godGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAoeSksICcsICcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaCgnMCwgJyk7XG4gICAgfVxuICAgIHJldEFyci5wdXNoKHRoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHgpKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgbWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHByb3BlcnR5KSB7XG4gICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBub3Qgc2V0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUocHJvcGVydHkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0ludGVnZXIocHJvcGVydHksIHJlc3VsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKHByb3BlcnR5LCByZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhwcm9wZXJ0eSwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgfVxufVxuXG5jb25zdCB0eXBlTWFwID0ge1xuICAnQXJyYXknOiAnc2FtcGxlcjJEJyxcbiAgJ0FycmF5KDIpJzogJ3ZlYzInLFxuICAnQXJyYXkoMyknOiAndmVjMycsXG4gICdBcnJheSg0KSc6ICd2ZWM0JyxcbiAgJ0FycmF5MkQnOiAnc2FtcGxlcjJEJyxcbiAgJ0FycmF5M0QnOiAnc2FtcGxlcjJEJyxcbiAgJ0Jvb2xlYW4nOiAnYm9vbCcsXG4gICdGbG9hdCc6ICdmbG9hdCcsXG4gICdJbnB1dCc6ICdzYW1wbGVyMkQnLFxuICAnSW50ZWdlcic6ICdpbnQnLFxuICAnTnVtYmVyJzogJ2Zsb2F0JyxcbiAgJ0xpdGVyYWxJbnRlZ2VyJzogJ2Zsb2F0JyxcbiAgJ051bWJlclRleHR1cmUnOiAnc2FtcGxlcjJEJyxcbiAgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOiAnc2FtcGxlcjJEJyxcbiAgJ0FycmF5VGV4dHVyZSgxKSc6ICdzYW1wbGVyMkQnLFxuICAnQXJyYXlUZXh0dXJlKDIpJzogJ3NhbXBsZXIyRCcsXG4gICdBcnJheVRleHR1cmUoMyknOiAnc2FtcGxlcjJEJyxcbiAgJ0FycmF5VGV4dHVyZSg0KSc6ICdzYW1wbGVyMkQnLFxuICAnSFRNTFZpZGVvJzogJ3NhbXBsZXIyRCcsXG4gICdIVE1MQ2FudmFzJzogJ3NhbXBsZXIyRCcsXG4gICdIVE1MSW1hZ2UnOiAnc2FtcGxlcjJEJyxcbiAgJ0hUTUxJbWFnZUFycmF5JzogJ3NhbXBsZXIyREFycmF5Jyxcbn07XG5cbmNvbnN0IG9wZXJhdG9yTWFwID0ge1xuICAnPT09JzogJz09JyxcbiAgJyE9PSc6ICchPSdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEZ1bmN0aW9uTm9kZVxufTtcbn0se1wiLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi9mdW5jdGlvbi1ub2RlXCI6MTB9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVCb29sZWFuIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9ib29sZWFuJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVGbG9hdCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZmxvYXQnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUludGVnZXIgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2ludGVnZXInKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2UnKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlSFRNTFZpZGVvIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9odG1sLXZpZGVvJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtdmlkZW8nKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dCcpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUlucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1pbnB1dCcpO1xuXG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1pbnB1dCcpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtaW5wdXQnKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZScpO1xuXG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9udW1iZXItdGV4dHVyZScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtbnVtYmVyLXRleHR1cmUnKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheScpO1xuXG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MWQtaScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTFkLWknKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWknKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkyZC1pJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzZC1pJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5M2QtaScpO1xuXG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTIgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTInKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MyB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXk0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXk0Jyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3Vuc2lnbmVkLWFycmF5Jyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1hcnJheScpO1xuXG5jb25zdCBrZXJuZWxWYWx1ZU1hcHMgPSB7XG4gIHVuc2lnbmVkOiB7XG4gICAgZHluYW1pYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbixcbiAgICAgICdJbnRlZ2VyJzogV2ViR0xLZXJuZWxWYWx1ZUludGVnZXIsXG4gICAgICAnRmxvYXQnOiBXZWJHTEtlcm5lbFZhbHVlRmxvYXQsXG4gICAgICAnQXJyYXknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXksXG4gICAgICAnQXJyYXkoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheSgzKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5KDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDQpJzogZmFsc2UsXG4gICAgICAnSW5wdXQnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXQsXG4gICAgICAnTnVtYmVyVGV4dHVyZSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMSknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgzKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoNCknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSxcbiAgICAgICdIVE1MQ2FudmFzJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBmYWxzZSxcbiAgICAgICdIVE1MVmlkZW8nOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlbyxcbiAgICB9LFxuICAgIHN0YXRpYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbixcbiAgICAgICdGbG9hdCc6IFdlYkdMS2VybmVsVmFsdWVGbG9hdCxcbiAgICAgICdJbnRlZ2VyJzogV2ViR0xLZXJuZWxWYWx1ZUludGVnZXIsXG4gICAgICAnQXJyYXknOiBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRBcnJheSxcbiAgICAgICdBcnJheSgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5KDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkoNCknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDIpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCgzKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoNCknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDIpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCgzKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoNCknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDIpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCgzKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoNCknOiBmYWxzZSxcbiAgICAgICdJbnB1dCc6IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMSknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMiknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoNCknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gICAgICAnSFRNTENhbnZhcyc6IFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlJzogV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IGZhbHNlLFxuICAgICAgJ0hUTUxWaWRlbyc6IFdlYkdMS2VybmVsVmFsdWVIVE1MVmlkZW8sXG4gICAgfVxuICB9LFxuICBzaW5nbGU6IHtcbiAgICBkeW5hbWljOiB7XG4gICAgICAnQm9vbGVhbic6IFdlYkdMS2VybmVsVmFsdWVCb29sZWFuLFxuICAgICAgJ0ludGVnZXInOiBXZWJHTEtlcm5lbFZhbHVlSW50ZWdlcixcbiAgICAgICdGbG9hdCc6IFdlYkdMS2VybmVsVmFsdWVGbG9hdCxcbiAgICAgICdBcnJheSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXksXG4gICAgICAnQXJyYXkoMiknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyLFxuICAgICAgJ0FycmF5KDMpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MyxcbiAgICAgICdBcnJheSg0KSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTQsXG4gICAgICAnQXJyYXkxRCgyKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxREksXG4gICAgICAnQXJyYXkxRCgzKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxREksXG4gICAgICAnQXJyYXkxRCg0KSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxREksXG4gICAgICAnQXJyYXkyRCgyKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREksXG4gICAgICAnQXJyYXkyRCgzKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREksXG4gICAgICAnQXJyYXkyRCg0KSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREksXG4gICAgICAnQXJyYXkzRCgyKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREksXG4gICAgICAnQXJyYXkzRCgzKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREksXG4gICAgICAnQXJyYXkzRCg0KSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREksXG4gICAgICAnSW5wdXQnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUlucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDEpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgyKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDQpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gICAgICAnSFRNTENhbnZhcyc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZUFycmF5JzogZmFsc2UsXG4gICAgICAnSFRNTFZpZGVvJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8sXG4gICAgfSxcbiAgICBzdGF0aWM6IHtcbiAgICAgICdCb29sZWFuJzogV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnRmxvYXQnOiBXZWJHTEtlcm5lbFZhbHVlRmxvYXQsXG4gICAgICAnSW50ZWdlcic6IFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0FycmF5JzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MixcbiAgICAgICdBcnJheSgzKSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTMsXG4gICAgICAnQXJyYXkoNCknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXk0LFxuICAgICAgJ0FycmF5MUQoMiknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREksXG4gICAgICAnQXJyYXkxRCgzKSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTFEKDQpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MkQoMiknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREksXG4gICAgICAnQXJyYXkyRCgzKSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTJEKDQpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5M0QoMiknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREksXG4gICAgICAnQXJyYXkzRCgzKSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSxcbiAgICAgICdBcnJheTNEKDQpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJLFxuICAgICAgJ0lucHV0JzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUlucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMSknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMiknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoNCknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gICAgICAnSFRNTENhbnZhcyc6IFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlJzogV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IGZhbHNlLFxuICAgICAgJ0hUTUxWaWRlbyc6IFdlYkdMS2VybmVsVmFsdWVIVE1MVmlkZW8sXG4gICAgfVxuICB9LFxufTtcblxuZnVuY3Rpb24gbG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIGR5bmFtaWMsIHByZWNpc2lvbiwgdmFsdWUpIHtcbiAgaWYgKCF0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoIWR5bmFtaWMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2R5bmFtaWMgbWlzc2luZycpO1xuICB9XG4gIGlmICghcHJlY2lzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcmVjaXNpb24gbWlzc2luZycpO1xuICB9XG4gIGlmICh2YWx1ZS50eXBlKSB7XG4gICAgdHlwZSA9IHZhbHVlLnR5cGU7XG4gIH1cbiAgY29uc3QgdHlwZXMgPSBrZXJuZWxWYWx1ZU1hcHNbcHJlY2lzaW9uXVtkeW5hbWljXTtcbiAgaWYgKHR5cGVzW3R5cGVdID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVzW3R5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgS2VybmVsVmFsdWUgZm9yICR7IHR5cGUgfWApO1xuICB9XG4gIHJldHVybiB0eXBlc1t0eXBlXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvb2t1cEtlcm5lbFZhbHVlVHlwZSxcbiAga2VybmVsVmFsdWVNYXBzLFxufTtcbn0se1wiLi9rZXJuZWwtdmFsdWUvYm9vbGVhblwiOjQxLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlXCI6NDIsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtdmlkZW9cIjo0MyxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZVwiOjQ0LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1udW1iZXItdGV4dHVyZVwiOjQ1LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXlcIjo0NixcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MWQtaVwiOjQ3LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkyZC1pXCI6NDgsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTNkLWlcIjo0OSxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWlucHV0XCI6NTAsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWFycmF5XCI6NTEsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWlucHV0XCI6NTIsXCIuL2tlcm5lbC12YWx1ZS9mbG9hdFwiOjUzLFwiLi9rZXJuZWwtdmFsdWUvaHRtbC1pbWFnZVwiOjU0LFwiLi9rZXJuZWwtdmFsdWUvaHRtbC12aWRlb1wiOjU1LFwiLi9rZXJuZWwtdmFsdWUvaW50ZWdlclwiOjU3LFwiLi9rZXJuZWwtdmFsdWUvbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZVwiOjU4LFwiLi9rZXJuZWwtdmFsdWUvbnVtYmVyLXRleHR1cmVcIjo1OSxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheVwiOjYwLFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MWQtaVwiOjYxLFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MlwiOjYyLFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MmQtaVwiOjYzLFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M1wiOjY0LFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M2QtaVwiOjY1LFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5NFwiOjY2LFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWlucHV0XCI6NjcsXCIuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1hcnJheVwiOjY4LFwiLi9rZXJuZWwtdmFsdWUvdW5zaWduZWQtaW5wdXRcIjo2OX1dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuY29uc3QgeyBJbnB1dCB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vaW5wdXQnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWUge1xuICBjaGVja1NpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghdGhpcy5rZXJuZWwudmFsaWRhdGUpIHJldHVybjtcbiAgICBjb25zdCB7IG1heFRleHR1cmVTaXplIH0gPSB0aGlzLmtlcm5lbC5jb25zdHJ1Y3Rvci5mZWF0dXJlcztcbiAgICBpZiAod2lkdGggPiBtYXhUZXh0dXJlU2l6ZSB8fCBoZWlnaHQgPiBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgaWYgKHdpZHRoID4gaGVpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgdGV4dHVyZSB3aWR0aCBvZiAke3dpZHRofSBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemUgb2YgJHttYXhUZXh0dXJlU2l6ZX0gZm9yIHlvdXIgR1BVYCk7XG4gICAgICB9IGVsc2UgaWYgKHdpZHRoIDwgaGVpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgdGV4dHVyZSBoZWlnaHQgb2YgJHtoZWlnaHR9IGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZSBvZiAke21heFRleHR1cmVTaXplfSBmb3IgeW91ciBHUFVgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgdGV4dHVyZSBoZWlnaHQgYW5kIHdpZHRoIG9mICR7aGVpZ2h0fSBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemUgb2YgJHttYXhUZXh0dXJlU2l6ZX0gZm9yIHlvdXIgR1BVYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0dXAoKSB7XG4gICAgdGhpcy5yZXF1ZXN0VGV4dHVyZSgpO1xuICAgIHRoaXMuc2V0dXBUZXh0dXJlKCk7XG4gICAgdGhpcy5kZWZpbmVUZXh0dXJlKCk7XG4gIH1cblxuICByZXF1ZXN0VGV4dHVyZSgpIHtcbiAgICB0aGlzLnRleHR1cmUgPSB0aGlzLm9uUmVxdWVzdFRleHR1cmUoKTtcbiAgfVxuXG4gIGRlZmluZVRleHR1cmUoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICB9XG5cbiAgc2V0dXBUZXh0dXJlKCkge1xuICAgIHRoaXMuY29udGV4dEhhbmRsZSA9IHRoaXMub25SZXF1ZXN0Q29udGV4dEhhbmRsZSgpO1xuICAgIHRoaXMuaW5kZXggPSB0aGlzLm9uUmVxdWVzdEluZGV4KCk7XG4gICAgdGhpcy5kaW1lbnNpb25zSWQgPSB0aGlzLmlkICsgJ0RpbSc7XG4gICAgdGhpcy5zaXplSWQgPSB0aGlzLmlkICsgJ1NpemUnO1xuICB9XG5cbiAgZ2V0Qml0UmF0aW8odmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJpdFJhdGlvKHZhbHVlWzBdKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBJbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qml0UmF0aW8odmFsdWUudmFsdWUpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIFVpbnQ4Q2xhbXBlZEFycmF5OlxuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBjYXNlIEZsb2F0MzJBcnJheTpcbiAgICAgIGNhc2UgSW50MzJBcnJheTpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucHJldkFyZykge1xuICAgICAgdGhpcy5wcmV2QXJnLmRlbGV0ZSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRleHQuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbEFycmF5XG59O1xufSx7XCIuLi8uLi8uLi9pbnB1dFwiOjExMCxcIi4vaW5kZXhcIjo1Nn1dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW4gZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZ2V0U291cmNlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgcmV0dXJuIGBjb25zdCBib29sICR7dGhpcy5pZH0gPSAke3ZhbHVlfTtcXG5gO1xuICAgIH1cbiAgICByZXR1cm4gYHVuaWZvcm0gYm9vbCAke3RoaXMuaWR9O1xcbmA7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX07XFxuYDtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhblxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2luZGV4XCI6NTZ9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2h0bWwtaW1hZ2UnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB2YWx1ZTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBbd2lkdGgsIGhlaWdodCwgMV07XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2Vcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9odG1sLWltYWdlXCI6NTR9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2R5bmFtaWMtaHRtbC1pbWFnZScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlbyBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlb1xufTtcbn0se1wiLi9keW5hbWljLWh0bWwtaW1hZ2VcIjo0Mn1dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW5wdXRUZXh0dXJlKSB7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gaW5wdXRUZXh0dXJlLmRpbWVuc2lvbnM7XG4gICAgdGhpcy5jaGVja1NpemUoaW5wdXRUZXh0dXJlLnNpemVbMF0sIGlucHV0VGV4dHVyZS5zaXplWzFdKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gaW5wdXRUZXh0dXJlLnNpemU7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZShpbnB1dFRleHR1cmUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmVcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlXCI6NTh9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9udW1iZXItdGV4dHVyZScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IHZhbHVlLmRpbWVuc2lvbnM7XG4gICAgdGhpcy5jaGVja1NpemUodmFsdWUuc2l6ZVswXSwgdmFsdWUuc2l6ZVsxXSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHZhbHVlLnNpemU7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL251bWJlci10ZXh0dXJlXCI6NTl9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkgfSA9IHJlcXVpcmUoJy4vc2luZ2xlLWFycmF5Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9zaW5nbGUtYXJyYXlcIjo2MH1dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSB9ID0gcmVxdWlyZSgnLi9zaW5nbGUtYXJyYXkxZC1pJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxREkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL3NpbmdsZS1hcnJheTFkLWlcIjo2MX1dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSB9ID0gcmVxdWlyZSgnLi9zaW5nbGUtYXJyYXkyZC1pJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL3NpbmdsZS1hcnJheTJkLWlcIjo2M31dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSB9ID0gcmVxdWlyZSgnLi9zaW5nbGUtYXJyYXkzZC1pJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTNESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL3NpbmdsZS1hcnJheTNkLWlcIjo2NX1dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dCB9ID0gcmVxdWlyZSgnLi9zaW5nbGUtaW5wdXQnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dCB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGxldCBbdywgaCwgZF0gPSB2YWx1ZS5zaXplO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBJbnQzMkFycmF5KFt3IHx8IDEsIGggfHwgMSwgZCB8fCAxXSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiB0aGlzLmJpdFJhdGlvO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUlucHV0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vc2luZ2xlLWlucHV0XCI6Njd9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRBcnJheSB9ID0gcmVxdWlyZSgnLi91bnNpZ25lZC1hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRBcnJheSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IHV0aWxzLmdldERpbWVuc2lvbnModmFsdWUsIHRydWUpO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRQYWNrZWRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqICg0IC8gdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgY29uc3QgVHlwZSA9IHRoaXMuZ2V0VHJhbnNmZXJBcnJheVR5cGUodmFsdWUpO1xuICAgIHRoaXMucHJlVXBsb2FkVmFsdWUgPSBuZXcgVHlwZSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5wcmVVcGxvYWRWYWx1ZS5idWZmZXIpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi91bnNpZ25lZC1hcnJheVwiOjY4fV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXQgfSA9IHJlcXVpcmUoJy4vdW5zaWduZWQtaW5wdXQnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXQge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBsZXQgW3csIGgsIGRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdyB8fCAxLCBoIHx8IDEsIGQgfHwgMV0pO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRQYWNrZWRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqICg0IC8gdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgY29uc3QgVHlwZSA9IHRoaXMuZ2V0VHJhbnNmZXJBcnJheVR5cGUodmFsdWUudmFsdWUpO1xuICAgIHRoaXMucHJlVXBsb2FkVmFsdWUgPSBuZXcgVHlwZSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5wcmVVcGxvYWRWYWx1ZS5idWZmZXIpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi91bnNpZ25lZC1pbnB1dFwiOjY5fV0sNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRmxvYXQgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cbiAgZ2V0U291cmNlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBgY29uc3QgZmxvYXQgJHt0aGlzLmlkfSA9ICR7dmFsdWV9LjA7XFxuYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgY29uc3QgZmxvYXQgJHt0aGlzLmlkfSA9ICR7dmFsdWV9O1xcbmA7XG4gICAgfVxuICAgIHJldHVybiBgdW5pZm9ybSBmbG9hdCAke3RoaXMuaWR9O1xcbmA7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybjtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWYodGhpcy5pZCwgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUZsb2F0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaW5kZXhcIjo1Nn1dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdmFsdWU7XG4gICAgdGhpcy5jaGVja1NpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gW3dpZHRoLCBoZWlnaHQsIDFdO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSBbd2lkdGgsIGhlaWdodF07XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW5wdXRJbWFnZSkge1xuICAgIGlmIChpbnB1dEltYWdlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaChpbnB1dEltYWdlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudXBsb2FkVmFsdWUgPSBpbnB1dEltYWdlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2Vcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2h0bWwtaW1hZ2UnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUhUTUxWaWRlbyBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2Uge31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVIVE1MVmlkZW9cbn07XG59LHtcIi4vaHRtbC1pbWFnZVwiOjU0fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4uLy4uL2tlcm5lbC12YWx1ZScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlIGV4dGVuZHMgS2VybmVsVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuZGltZW5zaW9uc0lkID0gbnVsbDtcbiAgICB0aGlzLnNpemVJZCA9IG51bGw7XG4gICAgdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgIHRoaXMub25SZXF1ZXN0VGV4dHVyZSA9IHNldHRpbmdzLm9uUmVxdWVzdFRleHR1cmU7XG4gICAgdGhpcy5vblJlcXVlc3RJbmRleCA9IHNldHRpbmdzLm9uUmVxdWVzdEluZGV4O1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSBudWxsO1xuICAgIHRoaXMuYml0UmF0aW8gPSBudWxsO1xuICAgIHRoaXMucHJldkFyZyA9IG51bGw7XG4gIH1cblxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3JpZ2lufV8ke3V0aWxzLnNhbml0aXplTmFtZSh0aGlzLm5hbWUpfWA7XG4gIH1cblxuICBzZXR1cCgpIHt9XG5cbiAgZ2V0VHJhbnNmZXJBcnJheVR5cGUodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRyYW5zZmVyQXJyYXlUeXBlKHZhbHVlWzBdKTtcbiAgICB9XG4gICAgc3dpdGNoICh2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBBcnJheTpcbiAgICAgIGNhc2UgSW50MzJBcnJheTpcbiAgICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuICAgICAgY2FzZSBVaW50OENsYW1wZWRBcnJheTpcbiAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICBjYXNlIFVpbnQzMkFycmF5OlxuICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICBjYXNlIEZsb2F0NjRBcnJheTpcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oJ1VuZmFtaWxpYXIgY29uc3RydWN0b3IgdHlwZS4gIFdpbGwgZ28gYWhlYWQgYW5kIHVzZSwgYnV0IGxpa2xleSB0aGlzIG1heSByZXN1bHQgaW4gYSB0cmFuc2ZlciBvZiB6ZXJvcycpO1xuICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZ2V0U3RyaW5nVmFsdWVIYW5kbGVyXCIgbm90IGltcGxlbWVudGVkIG9uICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMua2VybmVsLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4dHVyZVNpemUgfHwgdW5kZWZpbmVkLCB0aGlzLnRhY3RpYyB8fCB1bmRlZmluZWQpO1xuICB9XG5cbiAgZGVzdHJveSgpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL2tlcm5lbC12YWx1ZVwiOjM1fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlSW50ZWdlciBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX07XFxuYDtcbiAgfVxuICBnZXRTb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSB7XG4gICAgICByZXR1cm4gYGNvbnN0IGludCAke3RoaXMuaWR9ID0gJHsgcGFyc2VJbnQodmFsdWUpIH07XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGB1bmlmb3JtIGludCAke3RoaXMuaWR9O1xcbmA7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybjtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUludGVnZXJcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9pbmRleFwiOjU2fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jb25zdCBzYW1lRXJyb3IgPSBgU291cmNlIGFuZCBkZXN0aW5hdGlvbiB0ZXh0dXJlcyBhcmUgdGhlIHNhbWUuICBVc2UgaW1tdXRhYmxlID0gdHJ1ZSBhbmQgbWFudWFsbHkgY2xlYW51cCBrZXJuZWwgb3V0cHV0IHRleHR1cmUgbWVtb3J5IHdpdGggdGV4dHVyZS5kZWxldGUoKWA7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB2YWx1ZS5kaW1lbnNpb25zO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB2YWx1ZS5zaXplO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZS50ZXh0dXJlO1xuICAgIHRoaXMuZm9yY2VVcGxvYWRFYWNoUnVuID0gdHJ1ZTtcbiAgfVxuXG4gIHNldHVwKCkge1xuICAgIHRoaXMuc2V0dXBUZXh0dXJlKCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX0udGV4dHVyZTtcXG5gO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKGlucHV0VGV4dHVyZSkge1xuICAgIGlmIChpbnB1dFRleHR1cmUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKGlucHV0VGV4dHVyZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmNoZWNrQ29udGV4dCAmJiBpbnB1dFRleHR1cmUuY29udGV4dCAhPT0gdGhpcy5jb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlICR7dGhpcy5uYW1lfSAoJHt0aGlzLnR5cGV9KSBtdXN0IGJlIGZyb20gc2FtZSBjb250ZXh0YCk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBrZXJuZWwsIGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGlmIChrZXJuZWwucGlwZWxpbmUpIHtcbiAgICAgIGlmIChrZXJuZWwuaW1tdXRhYmxlKSB7XG4gICAgICAgIGtlcm5lbC51cGRhdGVUZXh0dXJlQXJndW1lbnRSZWZzKHRoaXMsIGlucHV0VGV4dHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2VybmVsLnRleHR1cmUudGV4dHVyZSA9PT0gaW5wdXRUZXh0dXJlLnRleHR1cmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2FtZUVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXJuZWwubWFwcGVkVGV4dHVyZXMpIHtcbiAgICAgICAgICBjb25zdCB7IG1hcHBlZFRleHR1cmVzIH0gPSBrZXJuZWw7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBwZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1hcHBlZFRleHR1cmVzW2ldLnRleHR1cmUgPT09IGlucHV0VGV4dHVyZS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzYW1lRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnVwbG9hZFZhbHVlID0gaW5wdXRUZXh0dXJlLnRleHR1cmUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gIHNhbWVFcnJvclxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDB9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5jb25zdCB7IHNhbWVFcnJvciB9ID0gcmVxdWlyZSgnLi9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB7IHNpemU6IHRleHR1cmVTaXplLCBkaW1lbnNpb25zIH0gPSB2YWx1ZTtcbiAgICB0aGlzLmJpdFJhdGlvID0gdGhpcy5nZXRCaXRSYXRpbyh2YWx1ZSk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdGV4dHVyZVNpemU7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlLnRleHR1cmU7XG4gICAgdGhpcy5mb3JjZVVwbG9hZEVhY2hSdW4gPSB0cnVlO1xuICB9XG5cbiAgc2V0dXAoKSB7XG4gICAgdGhpcy5zZXR1cFRleHR1cmUoKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfS50ZXh0dXJlO1xcbmA7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW5wdXRUZXh0dXJlKSB7XG4gICAgaWYgKGlucHV0VGV4dHVyZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2goaW5wdXRUZXh0dXJlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hlY2tDb250ZXh0ICYmIGlucHV0VGV4dHVyZS5jb250ZXh0ICE9PSB0aGlzLmNvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgJHt0aGlzLm5hbWV9ICgke3RoaXMudHlwZX0pIG11c3QgYmUgZnJvbSBzYW1lIGNvbnRleHRgKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGtlcm5lbCwgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgaWYgKGtlcm5lbC5waXBlbGluZSkge1xuICAgICAgaWYgKGtlcm5lbC5pbW11dGFibGUpIHtcbiAgICAgICAga2VybmVsLnVwZGF0ZVRleHR1cmVBcmd1bWVudFJlZnModGhpcywgaW5wdXRUZXh0dXJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXJuZWwudGV4dHVyZS50ZXh0dXJlID09PSBpbnB1dFRleHR1cmUudGV4dHVyZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzYW1lRXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGtlcm5lbC5tYXBwZWRUZXh0dXJlcykge1xuICAgICAgICAgIGNvbnN0IHsgbWFwcGVkVGV4dHVyZXMgfSA9IGtlcm5lbDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcHBlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWFwcGVkVGV4dHVyZXNbaV0udGV4dHVyZSA9PT0gaW5wdXRUZXh0dXJlLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNhbWVFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudXBsb2FkVmFsdWUgPSBpbnB1dFRleHR1cmUudGV4dHVyZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDAsXCIuL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmVcIjo1OH1dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5iaXRSYXRpbyA9IDQ7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiB0aGlzLmJpdFJhdGlvO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSBuZXcgRmxvYXQzMkFycmF5KCR7dGhpcy51cGxvYWRBcnJheUxlbmd0aH0pYCxcbiAgICAgIGBmbGF0dGVuVG8oJHt0aGlzLnZhck5hbWV9LCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW5Ubyh2YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MH1dLDYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJIGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5iaXRSYXRpbyA9IDQ7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gIH1cblxuICBzZXRTaGFwZSh2YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlRGltZW5zaW9ucyA9IHV0aWxzLmdldERpbWVuc2lvbnModmFsdWUsIHRydWUpO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHZhbHVlRGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IEludDMyQXJyYXkoW3ZhbHVlRGltZW5zaW9uc1sxXSwgMSwgMV0pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyBGbG9hdDMyQXJyYXkoJHt0aGlzLnVwbG9hZEFycmF5TGVuZ3RofSlgLFxuICAgICAgYGZsYXR0ZW5Ubygke3RoaXMudmFyTmFtZX0sIHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlbjJkQXJyYXlUbyh2YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MH1dLDYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MiBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBnZXRTb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSB7XG4gICAgICByZXR1cm4gYGNvbnN0IHZlYzIgJHt0aGlzLmlkfSA9IHZlYzIoJHt2YWx1ZVswXX0sJHt2YWx1ZVsxXX0pO1xcbmA7XG4gICAgfVxuICAgIHJldHVybiBgdW5pZm9ybSB2ZWMyICR7dGhpcy5pZH07XFxuYDtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX07XFxuYDtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yZnYodGhpcy5pZCwgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MlxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2luZGV4XCI6NTZ9XSw2MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuYml0UmF0aW8gPSA0O1xuICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICB9XG5cbiAgc2V0U2hhcGUodmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZURpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh2YWx1ZURpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBJbnQzMkFycmF5KFt2YWx1ZURpbWVuc2lvbnNbMV0sIHZhbHVlRGltZW5zaW9uc1syXSwgMV0pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyBGbG9hdDMyQXJyYXkoJHt0aGlzLnVwbG9hZEFycmF5TGVuZ3RofSlgLFxuICAgICAgYGZsYXR0ZW5Ubygke3RoaXMudmFyTmFtZX0sIHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlbjNkQXJyYXlUbyh2YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MH1dLDY0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MyBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBnZXRTb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSB7XG4gICAgICByZXR1cm4gYGNvbnN0IHZlYzMgJHt0aGlzLmlkfSA9IHZlYzMoJHt2YWx1ZVswXX0sJHt2YWx1ZVsxXX0sJHt2YWx1ZVsyXX0pO1xcbmA7XG4gICAgfVxuICAgIHJldHVybiBgdW5pZm9ybSB2ZWMzICR7dGhpcy5pZH07XFxuYDtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX07XFxuYDtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zZnYodGhpcy5pZCwgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M1xufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2luZGV4XCI6NTZ9XSw2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuYml0UmF0aW8gPSA0O1xuICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICB9XG5cbiAgc2V0U2hhcGUodmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZURpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh2YWx1ZURpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBJbnQzMkFycmF5KFt2YWx1ZURpbWVuc2lvbnNbMV0sIHZhbHVlRGltZW5zaW9uc1syXSwgdmFsdWVEaW1lbnNpb25zWzNdXSk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3IEZsb2F0MzJBcnJheSgke3RoaXMudXBsb2FkQXJyYXlMZW5ndGh9KWAsXG4gICAgICBgZmxhdHRlblRvKCR7dGhpcy52YXJOYW1lfSwgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9KWAsXG4gICAgXSk7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuNGRBcnJheVRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXk0IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGdldFNvdXJjZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHtcbiAgICAgIHJldHVybiBgY29uc3QgdmVjNCAke3RoaXMuaWR9ID0gdmVjNCgke3ZhbHVlWzBdfSwke3ZhbHVlWzFdfSwke3ZhbHVlWzJdfSwke3ZhbHVlWzNdfSk7XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGB1bmlmb3JtIHZlYzQgJHt0aGlzLmlkfTtcXG5gO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybiAnJztcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfTtcXG5gO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm47XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTRmdih0aGlzLmlkLCB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXk0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaW5kZXhcIjo1Nn1dLDY3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUlucHV0IGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5iaXRSYXRpbyA9IDQ7XG4gICAgbGV0IFt3LCBoLCBkXSA9IHZhbHVlLnNpemU7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IEludDMyQXJyYXkoW3cgfHwgMSwgaCB8fCAxLCBkIHx8IDFdKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyBGbG9hdDMyQXJyYXkoJHt0aGlzLnVwbG9hZEFycmF5TGVuZ3RofSlgLFxuICAgICAgYGZsYXR0ZW5Ubygke3RoaXMudmFyTmFtZX0udmFsdWUsIHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKGlucHV0KSB7XG4gICAgaWYgKGlucHV0LmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaChpbnB1dC5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKGlucHV0LnZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlSW5wdXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuYml0UmF0aW8gPSB0aGlzLmdldEJpdFJhdGlvKHZhbHVlKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkUGFja2VkVGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiAoNCAvIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMuVHJhbnNlckFycmF5VHlwZSA9IHRoaXMuZ2V0VHJhbnNmZXJBcnJheVR5cGUodmFsdWUpO1xuICAgIHRoaXMucHJlVXBsb2FkVmFsdWUgPSBuZXcgdGhpcy5UcmFuc2VyQXJyYXlUeXBlKHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgVWludDhBcnJheSh0aGlzLnByZVVwbG9hZFZhbHVlLmJ1ZmZlcik7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYGNvbnN0IHByZVVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyAke3RoaXMuVHJhbnNlckFycmF5VHlwZS5uYW1lfSgke3RoaXMudXBsb2FkQXJyYXlMZW5ndGh9KWAsXG4gICAgICBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3IFVpbnQ4QXJyYXkocHJlVXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9LmJ1ZmZlcilgLFxuICAgICAgYGZsYXR0ZW5Ubygke3RoaXMudmFyTmFtZX0sIHByZVVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKHZhbHVlLCB0aGlzLnByZVVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MH1dLDY5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXQgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmJpdFJhdGlvID0gdGhpcy5nZXRCaXRSYXRpbyh2YWx1ZSk7XG4gICAgY29uc3QgW3csIGgsIGRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdyB8fCAxLCBoIHx8IDEsIGQgfHwgMV0pO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRQYWNrZWRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqICg0IC8gdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy5UcmFuc2VyQXJyYXlUeXBlID0gdGhpcy5nZXRUcmFuc2ZlckFycmF5VHlwZSh2YWx1ZS52YWx1ZSk7XG4gICAgdGhpcy5wcmVVcGxvYWRWYWx1ZSA9IG5ldyB0aGlzLlRyYW5zZXJBcnJheVR5cGUodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBVaW50OEFycmF5KHRoaXMucHJlVXBsb2FkVmFsdWUuYnVmZmVyKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgcHJlVXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3ICR7dGhpcy5UcmFuc2VyQXJyYXlUeXBlLm5hbWV9KCR7dGhpcy51cGxvYWRBcnJheUxlbmd0aH0pYCxcbiAgICAgIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSBuZXcgVWludDhBcnJheShwcmVVcGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0uYnVmZmVyKWAsXG4gICAgICBgZmxhdHRlblRvKCR7dGhpcy52YXJOYW1lfS52YWx1ZSwgcHJlVXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9KWAsXG4gICAgXSk7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuVG8oaW5wdXQudmFsdWUsIHRoaXMucHJlVXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBHTEtlcm5lbCB9ID0gcmVxdWlyZSgnLi4vZ2wva2VybmVsJyk7XG5jb25zdCB7IEZ1bmN0aW9uQnVpbGRlciB9ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tYnVpbGRlcicpO1xuY29uc3QgeyBXZWJHTEZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi1ub2RlJyk7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgbXJ1ZCA9IHJlcXVpcmUoJy4uLy4uL3BsdWdpbnMvbWF0aC1yYW5kb20tdW5pZm9ybWx5LWRpc3RyaWJ1dGVkJyk7XG5jb25zdCB7IGZyYWdtZW50U2hhZGVyIH0gPSByZXF1aXJlKCcuL2ZyYWdtZW50LXNoYWRlcicpO1xuY29uc3QgeyB2ZXJ0ZXhTaGFkZXIgfSA9IHJlcXVpcmUoJy4vdmVydGV4LXNoYWRlcicpO1xuY29uc3QgeyBnbEtlcm5lbFN0cmluZyB9ID0gcmVxdWlyZSgnLi4vZ2wva2VybmVsLXN0cmluZycpO1xuY29uc3QgeyBsb29rdXBLZXJuZWxWYWx1ZVR5cGUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlLW1hcHMnKTtcblxubGV0IGlzU3VwcG9ydGVkID0gbnVsbDtcbmxldCB0ZXN0Q2FudmFzID0gbnVsbDtcbmxldCB0ZXN0Q29udGV4dCA9IG51bGw7XG5sZXQgdGVzdEV4dGVuc2lvbnMgPSBudWxsO1xubGV0IGZlYXR1cmVzID0gbnVsbDtcblxuY29uc3QgcGx1Z2lucyA9IFttcnVkXTtcbmNvbnN0IGNhbnZhc2VzID0gW107XG5jb25zdCBtYXhUZXhTaXplcyA9IHt9O1xuXG5cbmNsYXNzIFdlYkdMS2VybmVsIGV4dGVuZHMgR0xLZXJuZWwge1xuICBzdGF0aWMgZ2V0IGlzU3VwcG9ydGVkKCkge1xuICAgIGlmIChpc1N1cHBvcnRlZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgIH1cbiAgICB0aGlzLnNldHVwRmVhdHVyZUNoZWNrcygpO1xuICAgIGlzU3VwcG9ydGVkID0gdGhpcy5pc0NvbnRleHRNYXRjaCh0ZXN0Q29udGV4dCk7XG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICB9XG5cbiAgc3RhdGljIHNldHVwRmVhdHVyZUNoZWNrcygpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGVzdENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRlc3RDYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuICAgIH1cbiAgICBpZiAoIXRlc3RDYW52YXMpIHJldHVybjtcbiAgICB0ZXN0Q29udGV4dCA9IHRlc3RDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fCB0ZXN0Q2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpO1xuICAgIGlmICghdGVzdENvbnRleHQgfHwgIXRlc3RDb250ZXh0LmdldEV4dGVuc2lvbikgcmV0dXJuO1xuICAgIHRlc3RFeHRlbnNpb25zID0ge1xuICAgICAgT0VTX3RleHR1cmVfZmxvYXQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSxcbiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcjogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSxcbiAgICAgIE9FU19lbGVtZW50X2luZGV4X3VpbnQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpLFxuICAgICAgV0VCR0xfZHJhd19idWZmZXJzOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpLFxuICAgIH07XG4gICAgZmVhdHVyZXMgPSB0aGlzLmdldEZlYXR1cmVzKCk7XG4gIH1cblxuICBzdGF0aWMgaXNDb250ZXh0TWF0Y2goY29udGV4dCkge1xuICAgIGlmICh0eXBlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGNvbnRleHQgaW5zdGFuY2VvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc1RleHR1cmVGbG9hdCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0ZXN0RXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0SXNEcmF3QnVmZmVycygpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0ZXN0RXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMpO1xuICB9XG5cbiAgc3RhdGljIGdldENoYW5uZWxDb3VudCgpIHtcbiAgICByZXR1cm4gdGVzdEV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzID9cbiAgICAgIHRlc3RDb250ZXh0LmdldFBhcmFtZXRlcih0ZXN0RXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMuTUFYX0RSQVdfQlVGRkVSU19XRUJHTCkgOlxuICAgICAgMTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRNYXhUZXh0dXJlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGVzdENvbnRleHQuZ2V0UGFyYW1ldGVyKHRlc3RDb250ZXh0Lk1BWF9URVhUVVJFX1NJWkUpO1xuICB9XG5cbiAgc3RhdGljIGxvb2t1cEtlcm5lbFZhbHVlVHlwZSh0eXBlLCBkeW5hbWljLCBwcmVjaXNpb24sIHZhbHVlKSB7XG4gICAgcmV0dXJuIGxvb2t1cEtlcm5lbFZhbHVlVHlwZSh0eXBlLCBkeW5hbWljLCBwcmVjaXNpb24sIHZhbHVlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVzdENhbnZhcygpIHtcbiAgICByZXR1cm4gdGVzdENhbnZhcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVzdENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRlc3RDb250ZXh0O1xuICB9XG5cbiAgc3RhdGljIGdldCBmZWF0dXJlcygpIHtcbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGZyYWdtZW50U2hhZGVyKCkge1xuICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdmVydGV4U2hhZGVyKCkge1xuICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc291cmNlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICB0aGlzLnBpcGVsaW5lID0gc2V0dGluZ3MucGlwZWxpbmU7XG4gICAgdGhpcy5lbmRpYW5uZXNzID0gdXRpbHMuc3lzdGVtRW5kaWFubmVzcygpO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuICAgIHRoaXMuYXJndW1lbnRUZXh0dXJlQ291bnQgPSAwO1xuICAgIHRoaXMuY29uc3RhbnRUZXh0dXJlQ291bnQgPSAwO1xuICAgIHRoaXMuZnJhZ1NoYWRlciA9IG51bGw7XG4gICAgdGhpcy52ZXJ0U2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLmRyYXdCdWZmZXJzTWFwID0gbnVsbDtcblxuICAgIHRoaXMubWF4VGV4U2l6ZSA9IG51bGw7XG4gICAgdGhpcy5vblJlcXVlc3RTd2l0Y2hLZXJuZWwgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlSXN0YW5idWxDb3ZlcmFnZSA9IHRydWU7XG5cbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMubWFwcGVkVGV4dHVyZXMgPSBudWxsO1xuICAgIHRoaXMubWVyZ2VTZXR0aW5ncyhzb3VyY2Uuc2V0dGluZ3MgfHwgc2V0dGluZ3MpO1xuXG4gICAgdGhpcy50aHJlYWREaW0gPSBudWxsO1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSBudWxsO1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcblxuICAgIHRoaXMudGV4dHVyZUNhY2hlID0gW107XG4gICAgdGhpcy5wcm9ncmFtVW5pZm9ybUxvY2F0aW9uQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm0xZkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtMWlDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTJmQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm0yZnZDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTJpdkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtM2Z2Q2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm0zaXZDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTRmdkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtNGl2Q2FjaGUgPSB7fTtcbiAgfVxuXG4gIGluaXRDYW52YXMoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLndpZHRoID0gMjtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSAyO1xuICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygwLCAwKTtcbiAgICB9XG4gIH1cblxuICBpbml0Q29udGV4dCgpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgIGRlcHRoOiBmYWxzZSxcbiAgICAgIGFudGlhbGlhczogZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIHNldHRpbmdzKSB8fCB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBzZXR0aW5ncyk7XG4gIH1cblxuICBpbml0UGx1Z2lucyhzZXR0aW5ncykge1xuICAgIGNvbnN0IHBsdWdpbnNUb1VzZSA9IFtdO1xuICAgIGNvbnN0IHsgc291cmNlIH0gPSB0aGlzO1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICAgIGlmIChzb3VyY2UubWF0Y2gocGx1Z2luLmZ1bmN0aW9uTWF0Y2gpKSB7XG4gICAgICAgICAgcGx1Z2luc1RvVXNlLnB1c2gocGx1Z2luKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChzZXR0aW5ncy5wbHVnaW5OYW1lcykgeyBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgICAgICBjb25zdCB1c2VQbHVnaW4gPSBzZXR0aW5ncy5wbHVnaW5OYW1lcy5zb21lKHBsdWdpbk5hbWUgPT4gcGx1Z2luTmFtZSA9PT0gcGx1Z2luLm5hbWUpO1xuICAgICAgICAgIGlmICh1c2VQbHVnaW4pIHtcbiAgICAgICAgICAgIHBsdWdpbnNUb1VzZS5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwbHVnaW5zVG9Vc2U7XG4gIH1cblxuICBpbml0RXh0ZW5zaW9ucygpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7XG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSxcbiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcjogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyksXG4gICAgICBPRVNfZWxlbWVudF9pbmRleF91aW50OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JyksXG4gICAgICBXRUJHTF9kcmF3X2J1ZmZlcnM6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpLFxuICAgICAgV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKSxcbiAgICB9O1xuICB9XG5cbiAgdmFsaWRhdGVTZXR0aW5ncyhhcmdzKSB7XG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlKSB7XG4gICAgICB0aGlzLnRleFNpemUgPSB1dGlscy5nZXRLZXJuZWxUZXh0dXJlU2l6ZSh7XG4gICAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgICAgcHJlY2lzaW9uOiB0aGlzLnByZWNpc2lvbixcbiAgICAgIH0sIHRoaXMub3V0cHV0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IGZlYXR1cmVzIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSA9PT0gdHJ1ZSAmJiAhZmVhdHVyZXMuaXNUZXh0dXJlRmxvYXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmxvYXQgdGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJyAmJiAhZmVhdHVyZXMuaXNGbG9hdFJlYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2luZ2xlIHByZWNpc2lvbiBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5ncmFwaGljYWwgJiYgdGhpcy5wcmVjaXNpb24gPT09IG51bGwgJiYgZmVhdHVyZXMuaXNUZXh0dXJlRmxvYXQpIHtcbiAgICAgIHRoaXMucHJlY2lzaW9uID0gZmVhdHVyZXMuaXNGbG9hdFJlYWQgPyAnc2luZ2xlJyA6ICd1bnNpZ25lZCc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3ViS2VybmVscyAmJiB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoID4gMCAmJiAhdGhpcy5leHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgaW5zdGFudGlhdGUgZHJhdyBidWZmZXJzIGV4dGVuc2lvbicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID09PSBudWxsKSB7XG4gICAgICB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gIWZlYXR1cmVzLmlzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ICYmIGZlYXR1cmVzLmlzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUpIHtcbiAgICAgIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrT3V0cHV0KCk7XG5cbiAgICBpZiAoIXRoaXMub3V0cHV0IHx8IHRoaXMub3V0cHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0byBvdXRwdXQgb25seSBzdXBwb3J0ZWQgZm9yIGtlcm5lbHMgd2l0aCBvbmx5IG9uZSBpbnB1dCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhcmdUeXBlID0gdXRpbHMuZ2V0VmFyaWFibGVUeXBlKGFyZ3NbMF0sIHRoaXMuc3RyaWN0SW50ZWdlcnMpO1xuICAgICAgc3dpdGNoIChhcmdUeXBlKSB7XG4gICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICB0aGlzLm91dHB1dCA9IHV0aWxzLmdldERpbWVuc2lvbnMoYXJnVHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ051bWJlclRleHR1cmUnOlxuICAgICAgICBjYXNlICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDIpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcbiAgICAgICAgICB0aGlzLm91dHB1dCA9IGFyZ3NbMF0ub3V0cHV0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0byBvdXRwdXQgbm90IHN1cHBvcnRlZCBmb3IgaW5wdXQgdHlwZTogJyArIGFyZ1R5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgaWYgKHRoaXMub3V0cHV0Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dHB1dCBtdXN0IGhhdmUgMiBkaW1lbnNpb25zIG9uIGdyYXBoaWNhbCBtb2RlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3ByZWNpc2lvbicpIHtcbiAgICAgICAgdGhpcy5wcmVjaXNpb24gPSAndW5zaWduZWQnO1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Nhbm5vdCB1c2UgZ3JhcGhpY2FsIG1vZGUgYW5kIHNpbmdsZSBwcmVjaXNpb24gYXQgdGhlIHNhbWUgdGltZScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRleFNpemUgPSB1dGlscy5jbG9uZSh0aGlzLm91dHB1dCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gbnVsbCAmJiBmZWF0dXJlcy5pc1RleHR1cmVGbG9hdCkge1xuICAgICAgdGhpcy5wcmVjaXNpb24gPSAnc2luZ2xlJztcbiAgICB9XG5cbiAgICB0aGlzLnRleFNpemUgPSB1dGlscy5nZXRLZXJuZWxUZXh0dXJlU2l6ZSh7XG4gICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICBwcmVjaXNpb246IHRoaXMucHJlY2lzaW9uLFxuICAgIH0sIHRoaXMub3V0cHV0KTtcblxuICAgIHRoaXMuY2hlY2tUZXh0dXJlU2l6ZSgpO1xuICB9XG5cbiAgdXBkYXRlTWF4VGV4U2l6ZSgpIHtcbiAgICBjb25zdCB7IHRleFNpemUsIGNhbnZhcyB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5tYXhUZXhTaXplID09PSBudWxsKSB7XG4gICAgICBsZXQgY2FudmFzSW5kZXggPSBjYW52YXNlcy5pbmRleE9mKGNhbnZhcyk7XG4gICAgICBpZiAoY2FudmFzSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGNhbnZhc0luZGV4ID0gY2FudmFzZXMubGVuZ3RoO1xuICAgICAgICBjYW52YXNlcy5wdXNoKGNhbnZhcyk7XG4gICAgICAgIG1heFRleFNpemVzW2NhbnZhc0luZGV4XSA9IFt0ZXhTaXplWzBdLCB0ZXhTaXplWzFdXTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWF4VGV4U2l6ZSA9IG1heFRleFNpemVzW2NhbnZhc0luZGV4XTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4VGV4U2l6ZVswXSA8IHRleFNpemVbMF0pIHtcbiAgICAgIHRoaXMubWF4VGV4U2l6ZVswXSA9IHRleFNpemVbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLm1heFRleFNpemVbMV0gPCB0ZXhTaXplWzFdKSB7XG4gICAgICB0aGlzLm1heFRleFNpemVbMV0gPSB0ZXhTaXplWzFdO1xuICAgIH1cbiAgfVxuXG4gIHNldHVwQXJndW1lbnRzKGFyZ3MpIHtcbiAgICB0aGlzLmtlcm5lbEFyZ3VtZW50cyA9IFtdO1xuICAgIHRoaXMuYXJndW1lbnRUZXh0dXJlQ291bnQgPSAwO1xuICAgIGNvbnN0IG5lZWRzQXJndW1lbnRUeXBlcyA9IHRoaXMuYXJndW1lbnRUeXBlcyA9PT0gbnVsbDtcbiAgICBpZiAobmVlZHNBcmd1bWVudFR5cGVzKSB7XG4gICAgICB0aGlzLmFyZ3VtZW50VHlwZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5hcmd1bWVudFNpemVzID0gW107XG4gICAgdGhpcy5hcmd1bWVudEJpdFJhdGlvcyA9IFtdO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgdGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgZW5vdWdoIGFyZ3VtZW50cyBmb3Iga2VybmVsJyk7XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA+IHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndG9vIG1hbnkgYXJndW1lbnRzIGZvciBrZXJuZWwnKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGxldCB0ZXh0dXJlSW5kZXhlcyA9IDA7XG5cbiAgICBjb25zdCBvblJlcXVlc3RUZXh0dXJlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZSgpO1xuICAgIH07XG4gICAgY29uc3Qgb25SZXF1ZXN0SW5kZXggPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGV4dHVyZUluZGV4ZXMrKztcbiAgICB9O1xuICAgIGNvbnN0IG9uVXBkYXRlVmFsdWVNaXNtYXRjaCA9IChjb25zdHJ1Y3RvcikgPT4ge1xuICAgICAgdGhpcy5zd2l0Y2hLZXJuZWxzKHtcbiAgICAgICAgdHlwZTogJ2FyZ3VtZW50TWlzbWF0Y2gnLFxuICAgICAgICBuZWVkZWQ6IGNvbnN0cnVjdG9yXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUmVxdWVzdENvbnRleHRIYW5kbGUgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50VGV4dHVyZUNvdW50ICsgdGhpcy5hcmd1bWVudFRleHR1cmVDb3VudCsrO1xuICAgIH07XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJncy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXJnc1tpbmRleF07XG4gICAgICBjb25zdCBuYW1lID0gdGhpcy5hcmd1bWVudE5hbWVzW2luZGV4XTtcbiAgICAgIGxldCB0eXBlO1xuICAgICAgaWYgKG5lZWRzQXJndW1lbnRUeXBlcykge1xuICAgICAgICB0eXBlID0gdXRpbHMuZ2V0VmFyaWFibGVUeXBlKHZhbHVlLCB0aGlzLnN0cmljdEludGVnZXJzKTtcbiAgICAgICAgdGhpcy5hcmd1bWVudFR5cGVzLnB1c2godHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gdGhpcy5hcmd1bWVudFR5cGVzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IEtlcm5lbFZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5sb29rdXBLZXJuZWxWYWx1ZVR5cGUodHlwZSwgdGhpcy5keW5hbWljQXJndW1lbnRzID8gJ2R5bmFtaWMnIDogJ3N0YXRpYycsIHRoaXMucHJlY2lzaW9uLCBhcmdzW2luZGV4XSk7XG4gICAgICBpZiAoS2VybmVsVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEZhbGxiYWNrKGFyZ3MpO1xuICAgICAgfVxuICAgICAgY29uc3Qga2VybmVsQXJndW1lbnQgPSBuZXcgS2VybmVsVmFsdWUodmFsdWUsIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGFjdGljOiB0aGlzLnRhY3RpYyxcbiAgICAgICAgb3JpZ2luOiAndXNlcicsXG4gICAgICAgIGNvbnRleHQ6IGdsLFxuICAgICAgICBjaGVja0NvbnRleHQ6IHRoaXMuY2hlY2tDb250ZXh0LFxuICAgICAgICBrZXJuZWw6IHRoaXMsXG4gICAgICAgIHN0cmljdEludGVnZXJzOiB0aGlzLnN0cmljdEludGVnZXJzLFxuICAgICAgICBvblJlcXVlc3RUZXh0dXJlLFxuICAgICAgICBvblJlcXVlc3RJbmRleCxcbiAgICAgICAgb25VcGRhdGVWYWx1ZU1pc21hdGNoLFxuICAgICAgICBvblJlcXVlc3RDb250ZXh0SGFuZGxlLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmtlcm5lbEFyZ3VtZW50cy5wdXNoKGtlcm5lbEFyZ3VtZW50KTtcbiAgICAgIGtlcm5lbEFyZ3VtZW50LnNldHVwKCk7XG4gICAgICB0aGlzLmFyZ3VtZW50U2l6ZXMucHVzaChrZXJuZWxBcmd1bWVudC50ZXh0dXJlU2l6ZSk7XG4gICAgICB0aGlzLmFyZ3VtZW50Qml0UmF0aW9zW2luZGV4XSA9IGtlcm5lbEFyZ3VtZW50LmJpdFJhdGlvO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVRleHR1cmUoKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuY29udGV4dC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGUucHVzaCh0ZXh0dXJlKTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuXG4gIHNldHVwQ29uc3RhbnRzKGFyZ3MpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHRoaXMua2VybmVsQ29uc3RhbnRzID0gW107XG4gICAgdGhpcy5mb3JjZVVwbG9hZEtlcm5lbENvbnN0YW50cyA9IFtdO1xuICAgIGxldCBuZWVkc0NvbnN0YW50VHlwZXMgPSB0aGlzLmNvbnN0YW50VHlwZXMgPT09IG51bGw7XG4gICAgaWYgKG5lZWRzQ29uc3RhbnRUeXBlcykge1xuICAgICAgdGhpcy5jb25zdGFudFR5cGVzID0ge307XG4gICAgfVxuICAgIHRoaXMuY29uc3RhbnRCaXRSYXRpb3MgPSB7fTtcbiAgICBsZXQgdGV4dHVyZUluZGV4ZXMgPSAwO1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLmNvbnN0YW50cykge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmNvbnN0YW50c1tuYW1lXTtcbiAgICAgIGxldCB0eXBlO1xuICAgICAgaWYgKG5lZWRzQ29uc3RhbnRUeXBlcykge1xuICAgICAgICB0eXBlID0gdXRpbHMuZ2V0VmFyaWFibGVUeXBlKHZhbHVlLCB0aGlzLnN0cmljdEludGVnZXJzKTtcbiAgICAgICAgdGhpcy5jb25zdGFudFR5cGVzW25hbWVdID0gdHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSB0aGlzLmNvbnN0YW50VHlwZXNbbmFtZV07XG4gICAgICB9XG4gICAgICBjb25zdCBLZXJuZWxWYWx1ZSA9IHRoaXMuY29uc3RydWN0b3IubG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsICdzdGF0aWMnLCB0aGlzLnByZWNpc2lvbiwgdmFsdWUpO1xuICAgICAgaWYgKEtlcm5lbFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RGYWxsYmFjayhhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtlcm5lbFZhbHVlID0gbmV3IEtlcm5lbFZhbHVlKHZhbHVlLCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRhY3RpYzogdGhpcy50YWN0aWMsXG4gICAgICAgIG9yaWdpbjogJ2NvbnN0YW50cycsXG4gICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgY2hlY2tDb250ZXh0OiB0aGlzLmNoZWNrQ29udGV4dCxcbiAgICAgICAga2VybmVsOiB0aGlzLFxuICAgICAgICBzdHJpY3RJbnRlZ2VyczogdGhpcy5zdHJpY3RJbnRlZ2VycyxcbiAgICAgICAgb25SZXF1ZXN0VGV4dHVyZTogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25SZXF1ZXN0SW5kZXg6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGV4dHVyZUluZGV4ZXMrKztcbiAgICAgICAgfSxcbiAgICAgICAgb25SZXF1ZXN0Q29udGV4dEhhbmRsZTogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRUZXh0dXJlQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbnN0YW50Qml0UmF0aW9zW25hbWVdID0ga2VybmVsVmFsdWUuYml0UmF0aW87XG4gICAgICB0aGlzLmtlcm5lbENvbnN0YW50cy5wdXNoKGtlcm5lbFZhbHVlKTtcbiAgICAgIGtlcm5lbFZhbHVlLnNldHVwKCk7XG4gICAgICBpZiAoa2VybmVsVmFsdWUuZm9yY2VVcGxvYWRFYWNoUnVuKSB7XG4gICAgICAgIHRoaXMuZm9yY2VVcGxvYWRLZXJuZWxDb25zdGFudHMucHVzaChrZXJuZWxWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYnVpbGQoKSB7XG4gICAgaWYgKHRoaXMuYnVpbHQpIHJldHVybjtcbiAgICB0aGlzLmluaXRFeHRlbnNpb25zKCk7XG4gICAgdGhpcy52YWxpZGF0ZVNldHRpbmdzKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5zZXR1cENvbnN0YW50cyhhcmd1bWVudHMpO1xuICAgIGlmICh0aGlzLmZhbGxiYWNrUmVxdWVzdGVkKSByZXR1cm47XG4gICAgdGhpcy5zZXR1cEFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgIGlmICh0aGlzLmZhbGxiYWNrUmVxdWVzdGVkKSByZXR1cm47XG4gICAgdGhpcy51cGRhdGVNYXhUZXhTaXplKCk7XG4gICAgdGhpcy50cmFuc2xhdGVTb3VyY2UoKTtcbiAgICBjb25zdCBmYWlsdXJlUmVzdWx0ID0gdGhpcy5waWNrUmVuZGVyU3RyYXRlZ3koYXJndW1lbnRzKTtcbiAgICBpZiAoZmFpbHVyZVJlc3VsdCkge1xuICAgICAgcmV0dXJuIGZhaWx1cmVSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHsgdGV4U2l6ZSwgY29udGV4dDogZ2wsIGNhbnZhcyB9ID0gdGhpcztcbiAgICBnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgICBpZiAodGhpcy5waXBlbGluZSAmJiB0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMubWF4VGV4U2l6ZVswXSwgdGhpcy5tYXhUZXhTaXplWzFdKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMubWF4VGV4U2l6ZVswXTtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLm1heFRleFNpemVbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMubWF4VGV4U2l6ZVswXSwgdGhpcy5tYXhUZXhTaXplWzFdKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMubWF4VGV4U2l6ZVswXTtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLm1heFRleFNpemVbMV07XG4gICAgfVxuICAgIGNvbnN0IHRocmVhZERpbSA9IHRoaXMudGhyZWFkRGltID0gQXJyYXkuZnJvbSh0aGlzLm91dHB1dCk7XG4gICAgd2hpbGUgKHRocmVhZERpbS5sZW5ndGggPCAzKSB7XG4gICAgICB0aHJlYWREaW0ucHVzaCgxKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21waWxlZFZlcnRleFNoYWRlciA9IHRoaXMuZ2V0VmVydGV4U2hhZGVyKGFyZ3VtZW50cyk7XG4gICAgY29uc3QgdmVydFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UodmVydFNoYWRlciwgY29tcGlsZWRWZXJ0ZXhTaGFkZXIpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIodmVydFNoYWRlcik7XG4gICAgdGhpcy52ZXJ0U2hhZGVyID0gdmVydFNoYWRlcjtcblxuICAgIGNvbnN0IGNvbXBpbGVkRnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdldEZyYWdtZW50U2hhZGVyKGFyZ3VtZW50cyk7XG4gICAgY29uc3QgZnJhZ1NoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZShmcmFnU2hhZGVyLCBjb21waWxlZEZyYWdtZW50U2hhZGVyKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdTaGFkZXIpO1xuICAgIHRoaXMuZnJhZ1NoYWRlciA9IGZyYWdTaGFkZXI7XG5cbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coJ0dMU0wgU2hhZGVyIE91dHB1dDonKTtcbiAgICAgIGNvbnNvbGUubG9nKGNvbXBpbGVkRnJhZ21lbnRTaGFkZXIpO1xuICAgIH1cblxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjb21waWxpbmcgdmVydGV4IHNoYWRlcjogJyArIGdsLmdldFNoYWRlckluZm9Mb2codmVydFNoYWRlcikpO1xuICAgIH1cbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnU2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY29tcGlsaW5nIGZyYWdtZW50IHNoYWRlcjogJyArIGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ1NoYWRlcikpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLnByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRTaGFkZXIpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnU2hhZGVyKTtcbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICB0aGlzLmZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICB0aGlzLmZyYW1lYnVmZmVyLndpZHRoID0gdGV4U2l6ZVswXTtcbiAgICB0aGlzLmZyYW1lYnVmZmVyLmhlaWdodCA9IHRleFNpemVbMV07XG5cbiAgICBjb25zdCB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAtMSxcbiAgICAgIDEsIC0xLCAtMSwgMSxcbiAgICAgIDEsIDFcbiAgICBdKTtcbiAgICBjb25zdCB0ZXhDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgIDAsIDAsXG4gICAgICAxLCAwLFxuICAgICAgMCwgMSxcbiAgICAgIDEsIDFcbiAgICBdKTtcblxuICAgIGNvbnN0IHRleENvb3JkT2Zmc2V0ID0gdmVydGljZXMuYnl0ZUxlbmd0aDtcblxuICAgIGxldCBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgYnVmZmVyID0gdGhpcy5idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLmJ5dGVMZW5ndGggKyB0ZXhDb29yZHMuYnl0ZUxlbmd0aCwgZ2wuU1RBVElDX0RSQVcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICB9XG5cbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdmVydGljZXMpO1xuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0ZXhDb29yZE9mZnNldCwgdGV4Q29vcmRzKTtcblxuICAgIGNvbnN0IGFQb3NMb2MgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sICdhUG9zJyk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYVBvc0xvYyk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhUG9zTG9jLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGNvbnN0IGFUZXhDb29yZExvYyA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ2FUZXhDb29yZCcpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFUZXhDb29yZExvYyk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhVGV4Q29vcmRMb2MsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgdGV4Q29vcmRPZmZzZXQpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG5cbiAgICBsZXQgaSA9IDA7XG4gICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIGZvciAobGV0IHAgaW4gdGhpcy5jb25zdGFudHMpIHtcbiAgICAgIHRoaXMua2VybmVsQ29uc3RhbnRzW2krK10udXBkYXRlVmFsdWUodGhpcy5jb25zdGFudHNbcF0pO1xuICAgIH1cblxuICAgIHRoaXMuX3NldHVwT3V0cHV0VGV4dHVyZSgpO1xuICAgIGlmIChcbiAgICAgIHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCAmJlxuICAgICAgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aCA+IDBcbiAgICApIHtcbiAgICAgIHRoaXMuX21hcHBlZFRleHR1cmVTd2l0Y2hlZCA9IHt9O1xuICAgICAgdGhpcy5fc2V0dXBTdWJPdXRwdXRUZXh0dXJlcygpO1xuICAgIH1cbiAgICB0aGlzLmJ1aWxkU2lnbmF0dXJlKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5idWlsdCA9IHRydWU7XG4gIH1cblxuICB0cmFuc2xhdGVTb3VyY2UoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25CdWlsZGVyID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgV2ViR0xGdW5jdGlvbk5vZGUsIHtcbiAgICAgIGZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5OiB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5XG4gICAgfSk7XG4gICAgdGhpcy50cmFuc2xhdGVkU291cmNlID0gZnVuY3Rpb25CdWlsZGVyLmdldFByb3RvdHlwZVN0cmluZygna2VybmVsJyk7XG4gICAgdGhpcy5zZXR1cFJldHVyblR5cGVzKGZ1bmN0aW9uQnVpbGRlcik7XG4gIH1cblxuICBzZXR1cFJldHVyblR5cGVzKGZ1bmN0aW9uQnVpbGRlcikge1xuICAgIGlmICghdGhpcy5ncmFwaGljYWwgJiYgIXRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgdGhpcy5yZXR1cm5UeXBlID0gZnVuY3Rpb25CdWlsZGVyLmdldEtlcm5lbFJlc3VsdFR5cGUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdWJLZXJuZWxzICYmIHRoaXMuc3ViS2VybmVscy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzdWJLZXJuZWwgPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICAgIGlmICghc3ViS2VybmVsLnJldHVyblR5cGUpIHtcbiAgICAgICAgICBzdWJLZXJuZWwucmV0dXJuVHlwZSA9IGZ1bmN0aW9uQnVpbGRlci5nZXRTdWJLZXJuZWxSZXN1bHRUeXBlKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcnVuKCkge1xuICAgIGNvbnN0IHsga2VybmVsQXJndW1lbnRzLCB0ZXhTaXplLCBmb3JjZVVwbG9hZEtlcm5lbENvbnN0YW50cywgY29udGV4dDogZ2wgfSA9IHRoaXM7XG5cbiAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgZ2wuc2Npc3NvcigwLCAwLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdKTtcbiAgICBpZiAodGhpcy5keW5hbWljT3V0cHV0KSB7XG4gICAgICB0aGlzLnNldFVuaWZvcm0zaXYoJ3VPdXRwdXREaW0nLCBuZXcgSW50MzJBcnJheSh0aGlzLnRocmVhZERpbSkpO1xuICAgICAgdGhpcy5zZXRVbmlmb3JtMml2KCd1VGV4U2l6ZScsIHRleFNpemUpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VW5pZm9ybTJmKCdyYXRpbycsIHRleFNpemVbMF0gLyB0aGlzLm1heFRleFNpemVbMF0sIHRleFNpemVbMV0gLyB0aGlzLm1heFRleFNpemVbMV0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JjZVVwbG9hZEtlcm5lbENvbnN0YW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29uc3RhbnQgPSBmb3JjZVVwbG9hZEtlcm5lbENvbnN0YW50c1tpXTtcbiAgICAgIGNvbnN0YW50LnVwZGF0ZVZhbHVlKHRoaXMuY29uc3RhbnRzW2NvbnN0YW50Lm5hbWVdKTtcbiAgICAgIGlmICh0aGlzLnN3aXRjaGluZ0tlcm5lbHMpIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxBcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtlcm5lbEFyZ3VtZW50c1tpXS51cGRhdGVWYWx1ZShhcmd1bWVudHNbaV0pO1xuICAgICAgaWYgKHRoaXMuc3dpdGNoaW5nS2VybmVscykgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBsdWdpbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tpXTtcbiAgICAgICAgaWYgKHBsdWdpbi5vbkJlZm9yZVJ1bikge1xuICAgICAgICAgIHBsdWdpbi5vbkJlZm9yZVJ1bih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgaWYgKHRoaXMucGlwZWxpbmUpIHtcbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICBpZiAodGhpcy5pbW11dGFibGUpIHtcbiAgICAgICAgICB0aGlzLl9yZXBsYWNlT3V0cHV0VGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbW11dGFibGUgPyB0aGlzLnRleHR1cmUuY2xvbmUoKSA6IHRoaXMudGV4dHVyZTtcbiAgICAgIH1cbiAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIGlmICh0aGlzLmltbXV0YWJsZSkge1xuICAgICAgdGhpcy5fcmVwbGFjZU91dHB1dFRleHR1cmUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdWJLZXJuZWxzICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5pbW11dGFibGUpIHtcbiAgICAgICAgdGhpcy5fcmVwbGFjZVN1Yk91dHB1dFRleHR1cmVzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdCdWZmZXJzKCk7XG4gICAgfVxuXG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gIH1cblxuICBkcmF3QnVmZmVycygpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzLmRyYXdCdWZmZXJzV0VCR0wodGhpcy5kcmF3QnVmZmVyc01hcCk7XG4gIH1cblxuICBnZXRJbnRlcm5hbEZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LlJHQkE7XG4gIH1cbiAgZ2V0VGV4dHVyZUZvcm1hdCgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAodGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpKSB7XG4gICAgICBjYXNlIGdsLlJHQkE6XG4gICAgICAgIHJldHVybiBnbC5SR0JBO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGludGVybmFsIGZvcm1hdCcpO1xuICAgIH1cbiAgfVxuXG4gIF9yZXBsYWNlT3V0cHV0VGV4dHVyZSgpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlLmJlZm9yZU11dGF0ZSgpIHx8IHRoaXMuX3RleHR1cmVTd2l0Y2hlZCkge1xuICAgICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZS50ZXh0dXJlLCAwKTtcbiAgICAgIHRoaXMuX3RleHR1cmVTd2l0Y2hlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIF9zZXR1cE91dHB1dFRleHR1cmUoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3QgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZTtcbiAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZS50ZXh0dXJlLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50VGV4dHVyZUNvdW50ICsgdGhpcy5hcmd1bWVudFRleHR1cmVDb3VudCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldEludGVybmFsRm9ybWF0KCk7XG4gICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGZvcm1hdCwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgfVxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgdGhpcy50ZXh0dXJlID0gbmV3IHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yKHtcbiAgICAgIHRleHR1cmUsXG4gICAgICBzaXplOiB0ZXhTaXplLFxuICAgICAgZGltZW5zaW9uczogdGhpcy50aHJlYWREaW0sXG4gICAgICBvdXRwdXQ6IHRoaXMub3V0cHV0LFxuICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgaW50ZXJuYWxGb3JtYXQ6IHRoaXMuZ2V0SW50ZXJuYWxGb3JtYXQoKSxcbiAgICAgIHRleHR1cmVGb3JtYXQ6IHRoaXMuZ2V0VGV4dHVyZUZvcm1hdCgpLFxuICAgICAga2VybmVsOiB0aGlzLFxuICAgIH0pO1xuICB9XG5cbiAgX3JlcGxhY2VTdWJPdXRwdXRUZXh0dXJlcygpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFwcGVkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG1hcHBlZFRleHR1cmUgPSB0aGlzLm1hcHBlZFRleHR1cmVzW2ldO1xuICAgICAgaWYgKG1hcHBlZFRleHR1cmUuYmVmb3JlTXV0YXRlKCkgfHwgdGhpcy5fbWFwcGVkVGV4dHVyZVN3aXRjaGVkW2ldKSB7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkgKyAxLCBnbC5URVhUVVJFXzJELCBtYXBwZWRUZXh0dXJlLnRleHR1cmUsIDApO1xuICAgICAgICB0aGlzLl9tYXBwZWRUZXh0dXJlU3dpdGNoZWRbaV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfc2V0dXBTdWJPdXRwdXRUZXh0dXJlcygpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICBpZiAodGhpcy5tYXBwZWRUZXh0dXJlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEsIGdsLlRFWFRVUkVfMkQsIHRoaXMubWFwcGVkVGV4dHVyZXNbaV0udGV4dHVyZSwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleFNpemUgPSB0aGlzLnRleFNpemU7XG4gICAgdGhpcy5kcmF3QnVmZmVyc01hcCA9IFtnbC5DT0xPUl9BVFRBQ0hNRU5UMF07XG4gICAgdGhpcy5tYXBwZWRUZXh0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICB0aGlzLmRyYXdCdWZmZXJzTWFwLnB1c2goZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSk7XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudFRleHR1cmVDb3VudCArIHRoaXMuYXJndW1lbnRUZXh0dXJlQ291bnQgKyBpKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgICAgfVxuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuXG4gICAgICB0aGlzLm1hcHBlZFRleHR1cmVzLnB1c2gobmV3IHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yKHtcbiAgICAgICAgdGV4dHVyZSxcbiAgICAgICAgc2l6ZTogdGV4U2l6ZSxcbiAgICAgICAgZGltZW5zaW9uczogdGhpcy50aHJlYWREaW0sXG4gICAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgaW50ZXJuYWxGb3JtYXQ6IHRoaXMuZ2V0SW50ZXJuYWxGb3JtYXQoKSxcbiAgICAgICAgdGV4dHVyZUZvcm1hdDogdGhpcy5nZXRUZXh0dXJlRm9ybWF0KCksXG4gICAgICAgIGtlcm5lbDogdGhpcyxcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICBzZXRVbmlmb3JtMWYobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtMWZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm0xZkNhY2hlW25hbWVdO1xuICAgICAgaWYgKHZhbHVlID09PSBjYWNoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybTFmQ2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTFmKGxvYywgdmFsdWUpO1xuICB9XG5cbiAgc2V0VW5pZm9ybTFpKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybTFpQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtMWlDYWNoZVtuYW1lXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gY2FjaGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm0xaUNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgY29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgdGhpcy5jb250ZXh0LnVuaWZvcm0xaShsb2MsIHZhbHVlKTtcbiAgfVxuXG4gIHNldFVuaWZvcm0yZihuYW1lLCB2YWx1ZTEsIHZhbHVlMikge1xuICAgIGlmICh0aGlzLnVuaWZvcm0yZkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTJmQ2FjaGVbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlMSA9PT0gY2FjaGVbMF0gJiZcbiAgICAgICAgdmFsdWUyID09PSBjYWNoZVsxXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtMmZDYWNoZVtuYW1lXSA9IFt2YWx1ZTEsIHZhbHVlMl07XG4gICAgY29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgdGhpcy5jb250ZXh0LnVuaWZvcm0yZihsb2MsIHZhbHVlMSwgdmFsdWUyKTtcbiAgfVxuXG4gIHNldFVuaWZvcm0yZnYobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtMmZ2Q2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtMmZ2Q2FjaGVbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlWzBdID09PSBjYWNoZVswXSAmJlxuICAgICAgICB2YWx1ZVsxXSA9PT0gY2FjaGVbMV1cbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybTJmdkNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgY29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgdGhpcy5jb250ZXh0LnVuaWZvcm0yZnYobG9jLCB2YWx1ZSk7XG4gIH1cblxuICBzZXRVbmlmb3JtMml2KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybTJpdkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTJpdkNhY2hlW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZVswXSA9PT0gY2FjaGVbMF0gJiZcbiAgICAgICAgdmFsdWVbMV0gPT09IGNhY2hlWzFdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm0yaXZDYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIHRoaXMuY29udGV4dC51bmlmb3JtMml2KGxvYywgdmFsdWUpO1xuICB9XG5cbiAgc2V0VW5pZm9ybTNmdihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm0zZnZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm0zZnZDYWNoZVtuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWVbMF0gPT09IGNhY2hlWzBdICYmXG4gICAgICAgIHZhbHVlWzFdID09PSBjYWNoZVsxXSAmJlxuICAgICAgICB2YWx1ZVsyXSA9PT0gY2FjaGVbMl1cbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybTNmdkNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgY29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgdGhpcy5jb250ZXh0LnVuaWZvcm0zZnYobG9jLCB2YWx1ZSk7XG4gIH1cblxuICBzZXRVbmlmb3JtM2l2KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybTNpdkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTNpdkNhY2hlW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZVswXSA9PT0gY2FjaGVbMF0gJiZcbiAgICAgICAgdmFsdWVbMV0gPT09IGNhY2hlWzFdICYmXG4gICAgICAgIHZhbHVlWzJdID09PSBjYWNoZVsyXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtM2l2Q2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTNpdihsb2MsIHZhbHVlKTtcbiAgfVxuXG4gIHNldFVuaWZvcm00ZnYobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtNGZ2Q2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtNGZ2Q2FjaGVbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlWzBdID09PSBjYWNoZVswXSAmJlxuICAgICAgICB2YWx1ZVsxXSA9PT0gY2FjaGVbMV0gJiZcbiAgICAgICAgdmFsdWVbMl0gPT09IGNhY2hlWzJdICYmXG4gICAgICAgIHZhbHVlWzNdID09PSBjYWNoZVszXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtNGZ2Q2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTRmdihsb2MsIHZhbHVlKTtcbiAgfVxuXG4gIHNldFVuaWZvcm00aXYobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtNGl2Q2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtNGl2Q2FjaGVbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlWzBdID09PSBjYWNoZVswXSAmJlxuICAgICAgICB2YWx1ZVsxXSA9PT0gY2FjaGVbMV0gJiZcbiAgICAgICAgdmFsdWVbMl0gPT09IGNhY2hlWzJdICYmXG4gICAgICAgIHZhbHVlWzNdID09PSBjYWNoZVszXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtNGl2Q2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTRpdihsb2MsIHZhbHVlKTtcbiAgfVxuXG4gIGdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKSB7XG4gICAgaWYgKHRoaXMucHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9ncmFtVW5pZm9ybUxvY2F0aW9uQ2FjaGVbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2dyYW1Vbmlmb3JtTG9jYXRpb25DYWNoZVtuYW1lXSA9IHRoaXMuY29udGV4dC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKTtcbiAgfVxuXG4gIF9nZXRGcmFnU2hhZGVyQXJ0aWZhY3RNYXAoYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICBIRUFERVI6IHRoaXMuX2dldEhlYWRlclN0cmluZygpLFxuICAgICAgTE9PUF9NQVg6IHRoaXMuX2dldExvb3BNYXhTdHJpbmcoKSxcbiAgICAgIFBMVUdJTlM6IHRoaXMuX2dldFBsdWdpbnNTdHJpbmcoKSxcbiAgICAgIENPTlNUQU5UUzogdGhpcy5fZ2V0Q29uc3RhbnRzU3RyaW5nKCksXG4gICAgICBERUNPREUzMl9FTkRJQU5ORVNTOiB0aGlzLl9nZXREZWNvZGUzMkVuZGlhbm5lc3NTdHJpbmcoKSxcbiAgICAgIEVOQ09ERTMyX0VORElBTk5FU1M6IHRoaXMuX2dldEVuY29kZTMyRW5kaWFubmVzc1N0cmluZygpLFxuICAgICAgRElWSURFX1dJVEhfSU5URUdFUl9DSEVDSzogdGhpcy5fZ2V0RGl2aWRlV2l0aEludGVnZXJDaGVja1N0cmluZygpLFxuICAgICAgSU5KRUNURURfTkFUSVZFOiB0aGlzLl9nZXRJbmplY3RlZE5hdGl2ZSgpLFxuICAgICAgTUFJTl9DT05TVEFOVFM6IHRoaXMuX2dldE1haW5Db25zdGFudHNTdHJpbmcoKSxcbiAgICAgIE1BSU5fQVJHVU1FTlRTOiB0aGlzLl9nZXRNYWluQXJndW1lbnRzU3RyaW5nKGFyZ3MpLFxuICAgICAgS0VSTkVMOiB0aGlzLmdldEtlcm5lbFN0cmluZygpLFxuICAgICAgTUFJTl9SRVNVTFQ6IHRoaXMuZ2V0TWFpblJlc3VsdFN0cmluZygpLFxuICAgICAgRkxPQVRfVEFDVElDX0RFQ0xBUkFUSU9OOiB0aGlzLmdldEZsb2F0VGFjdGljRGVjbGFyYXRpb24oKSxcbiAgICAgIElOVF9UQUNUSUNfREVDTEFSQVRJT046IHRoaXMuZ2V0SW50VGFjdGljRGVjbGFyYXRpb24oKSxcbiAgICAgIFNBTVBMRVJfMkRfVEFDVElDX0RFQ0xBUkFUSU9OOiB0aGlzLmdldFNhbXBsZXIyRFRhY3RpY0RlY2xhcmF0aW9uKCksXG4gICAgICBTQU1QTEVSXzJEX0FSUkFZX1RBQ1RJQ19ERUNMQVJBVElPTjogdGhpcy5nZXRTYW1wbGVyMkRBcnJheVRhY3RpY0RlY2xhcmF0aW9uKCksXG4gICAgfTtcbiAgfVxuXG4gIF9nZXRWZXJ0U2hhZGVyQXJ0aWZhY3RNYXAoYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICBGTE9BVF9UQUNUSUNfREVDTEFSQVRJT046IHRoaXMuZ2V0RmxvYXRUYWN0aWNEZWNsYXJhdGlvbigpLFxuICAgICAgSU5UX1RBQ1RJQ19ERUNMQVJBVElPTjogdGhpcy5nZXRJbnRUYWN0aWNEZWNsYXJhdGlvbigpLFxuICAgICAgU0FNUExFUl8yRF9UQUNUSUNfREVDTEFSQVRJT046IHRoaXMuZ2V0U2FtcGxlcjJEVGFjdGljRGVjbGFyYXRpb24oKSxcbiAgICAgIFNBTVBMRVJfMkRfQVJSQVlfVEFDVElDX0RFQ0xBUkFUSU9OOiB0aGlzLmdldFNhbXBsZXIyREFycmF5VGFjdGljRGVjbGFyYXRpb24oKSxcbiAgICB9O1xuICB9XG5cbiAgX2dldEhlYWRlclN0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5zdWJLZXJuZWxzICE9PSBudWxsID9cbiAgICAgICcjZXh0ZW5zaW9uIEdMX0VYVF9kcmF3X2J1ZmZlcnMgOiByZXF1aXJlXFxuJyA6XG4gICAgICAnJ1xuICAgICk7XG4gIH1cblxuICBfZ2V0TG9vcE1heFN0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb29wTWF4SXRlcmF0aW9ucyA/XG4gICAgICBgICR7cGFyc2VJbnQodGhpcy5sb29wTWF4SXRlcmF0aW9ucyl9O1xcbmAgOlxuICAgICAgJyAxMDAwO1xcbidcbiAgICApO1xuICB9XG5cbiAgX2dldFBsdWdpbnNTdHJpbmcoKSB7XG4gICAgaWYgKCF0aGlzLnBsdWdpbnMpIHJldHVybiAnXFxuJztcbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zLm1hcChwbHVnaW4gPT4gcGx1Z2luLnNvdXJjZSAmJiB0aGlzLnNvdXJjZS5tYXRjaChwbHVnaW4uZnVuY3Rpb25NYXRjaCkgPyBwbHVnaW4uc291cmNlIDogJycpLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgX2dldENvbnN0YW50c1N0cmluZygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCB7IHRocmVhZERpbSwgdGV4U2l6ZSB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5keW5hbWljT3V0cHV0KSB7XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgJ3VuaWZvcm0gaXZlYzMgdU91dHB1dERpbScsXG4gICAgICAgICd1bmlmb3JtIGl2ZWMyIHVUZXhTaXplJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgIGBpdmVjMyB1T3V0cHV0RGltID0gaXZlYzMoJHt0aHJlYWREaW1bMF19LCAke3RocmVhZERpbVsxXX0sICR7dGhyZWFkRGltWzJdfSlgLFxuICAgICAgICBgaXZlYzIgdVRleFNpemUgPSBpdmVjMigke3RleFNpemVbMF19LCAke3RleFNpemVbMV19KWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHJlc3VsdCk7XG4gIH1cblxuICBfZ2V0VGV4dHVyZUNvb3JkaW5hdGUoKSB7XG4gICAgY29uc3Qgc3ViS2VybmVscyA9IHRoaXMuc3ViS2VybmVscztcbiAgICBpZiAoc3ViS2VybmVscyA9PT0gbnVsbCB8fCBzdWJLZXJuZWxzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ291dCB2ZWMyIHZUZXhDb29yZDtcXG4nO1xuICAgIH1cbiAgfVxuXG4gIF9nZXREZWNvZGUzMkVuZGlhbm5lc3NTdHJpbmcoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZW5kaWFubmVzcyA9PT0gJ0xFJyA/XG4gICAgICAnJyA6XG4gICAgICAnICB0ZXhlbC5yZ2JhID0gdGV4ZWwuYWJncjtcXG4nXG4gICAgKTtcbiAgfVxuXG4gIF9nZXRFbmNvZGUzMkVuZGlhbm5lc3NTdHJpbmcoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZW5kaWFubmVzcyA9PT0gJ0xFJyA/XG4gICAgICAnJyA6XG4gICAgICAnICB0ZXhlbC5yZ2JhID0gdGV4ZWwuYWJncjtcXG4nXG4gICAgKTtcbiAgfVxuXG4gIF9nZXREaXZpZGVXaXRoSW50ZWdlckNoZWNrU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID9cbiAgICAgIGBmbG9hdCBkaXZXaXRoSW50Q2hlY2soZmxvYXQgeCwgZmxvYXQgeSkge1xuICBpZiAoZmxvb3IoeCkgPT0geCAmJiBmbG9vcih5KSA9PSB5ICYmIGludGVnZXJNb2QoeCwgeSkgPT0gMC4wKSB7XG4gICAgcmV0dXJuIGZsb2F0KGludCh4KSAvIGludCh5KSk7XG4gIH1cbiAgcmV0dXJuIHggLyB5O1xufVxuXG5mbG9hdCBpbnRlZ2VyQ29ycmVjdGlvbk1vZHVsbyhmbG9hdCBudW1iZXIsIGZsb2F0IGRpdmlzb3IpIHtcbiAgaWYgKG51bWJlciA8IDAuMCkge1xuICAgIG51bWJlciA9IGFicyhudW1iZXIpO1xuICAgIGlmIChkaXZpc29yIDwgMC4wKSB7XG4gICAgICBkaXZpc29yID0gYWJzKGRpdmlzb3IpO1xuICAgIH1cbiAgICByZXR1cm4gLShudW1iZXIgLSAoZGl2aXNvciAqIGZsb29yKGRpdldpdGhJbnRDaGVjayhudW1iZXIsIGRpdmlzb3IpKSkpO1xuICB9XG4gIGlmIChkaXZpc29yIDwgMC4wKSB7XG4gICAgZGl2aXNvciA9IGFicyhkaXZpc29yKTtcbiAgfVxuICByZXR1cm4gbnVtYmVyIC0gKGRpdmlzb3IgKiBmbG9vcihkaXZXaXRoSW50Q2hlY2sobnVtYmVyLCBkaXZpc29yKSkpO1xufWAgOlxuICAgICAgJyc7XG4gIH1cblxuICBfZ2V0TWFpbkFyZ3VtZW50c1N0cmluZyhhcmdzKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHsgYXJndW1lbnROYW1lcyB9ID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmtlcm5lbEFyZ3VtZW50c1tpXS5nZXRTb3VyY2UoYXJnc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cy5qb2luKCcnKTtcbiAgfVxuXG4gIF9nZXRJbmplY3RlZE5hdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmplY3RlZE5hdGl2ZSB8fCAnJztcbiAgfVxuXG4gIF9nZXRNYWluQ29uc3RhbnRzU3RyaW5nKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHsgY29uc3RhbnRzIH0gPSB0aGlzO1xuICAgIGlmIChjb25zdGFudHMpIHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgY29udGludWU7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMua2VybmVsQ29uc3RhbnRzW2krK10uZ2V0U291cmNlKHRoaXMuY29uc3RhbnRzW25hbWVdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gIH1cblxuICBnZXRLZXJuZWxSZXN1bHREZWNsYXJhdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICByZXR1cm4gJ3ZlYzIga2VybmVsUmVzdWx0JztcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgcmV0dXJuICd2ZWMzIGtlcm5lbFJlc3VsdCc7XG4gICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgIHJldHVybiAndmVjNCBrZXJuZWxSZXN1bHQnO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICByZXR1cm4gJ2Zsb2F0IGtlcm5lbFJlc3VsdCc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcbiAgICAgICAgICByZXR1cm4gJ2Zsb2F0IGtlcm5lbFJlc3VsdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgb3V0cHV0IHR5cGUgXCIkeyB0aGlzLnJldHVyblR5cGUgfVwiYCk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0S2VybmVsU3RyaW5nKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFt0aGlzLmdldEtlcm5lbFJlc3VsdERlY2xhcmF0aW9uKCldO1xuICAgIGNvbnN0IHsgc3ViS2VybmVscyB9ID0gdGhpcztcbiAgICBpZiAoc3ViS2VybmVscyAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHN1Yktlcm5lbHNbaV07XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgc3ViS2VybmVsLnJldHVyblR5cGUgPT09ICdJbnRlZ2VyJyA/XG4gICAgICAgICAgICAgIGBpbnQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH0gPSAwYCA6XG4gICAgICAgICAgICAgIGBmbG9hdCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IDAuMGBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYHZlYzIgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbHNbaV0ubmFtZSB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBgdmVjMyBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsc1tpXS5uYW1lIH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIGB2ZWM0IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWxzW2ldLm5hbWUgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHJlc3VsdCkgKyB0aGlzLnRyYW5zbGF0ZWRTb3VyY2U7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0R3JhcGhpY2FsKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBnbF9GcmFnQ29sb3IgPSBhY3R1YWxDb2xvcicsXG4gICAgXSk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0UGFja2VkUGl4ZWxzKCkge1xuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxQYWNrZWRQaXhlbHMoKSArXG4gICAgICAgICAgdGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsUGFja2VkUGl4ZWxzKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhY2tlZCBvdXRwdXQgb25seSB1c2FibGUgd2l0aCBOdW1iZXJzLCBcIiR7dGhpcy5yZXR1cm5UeXBlfVwiIHNwZWNpZmllZGApO1xuICAgIH1cbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxQYWNrZWRQaXhlbHMoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgIGAgIGdsX0ZyYWdEYXRhWzBdID0gJHt0aGlzLnVzZUxlZ2FjeUVuY29kZXIgPyAnbGVnYWN5RW5jb2RlMzInIDogJ2VuY29kZTMyJ30oa2VybmVsUmVzdWx0KWBcbiAgICBdKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxQYWNrZWRQaXhlbHMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgaWYgKHN1Yktlcm5lbC5yZXR1cm5UeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dID0gJHt0aGlzLnVzZUxlZ2FjeUVuY29kZXIgPyAnbGVnYWN5RW5jb2RlMzInIDogJ2VuY29kZTMyJ30oZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9KSlgXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV0gPSAke3RoaXMudXNlTGVnYWN5RW5jb2RlciA/ICdsZWdhY3lFbmNvZGUzMicgOiAnZW5jb2RlMzInfShzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX0pYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdE1lbW9yeU9wdGltaXplZEZsb2F0cygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXG4gICAgICAnICBpbmRleCAqPSA0JyxcbiAgICBdO1xuXG4gICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgY29uc3QgY2hhbm5lbHMgPSBbJ3InLCAnZycsICdiJywgJ2EnXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFubmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSBjaGFubmVsc1tpXTtcbiAgICAgICAgICB0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxNZW1vcnlPcHRpbWl6ZWRGbG9hdHMocmVzdWx0LCBjaGFubmVsKTtcbiAgICAgICAgICB0aGlzLmdldE1haW5SZXN1bHRTdWJLZXJuZWxNZW1vcnlPcHRpbWl6ZWRGbG9hdHMocmVzdWx0LCBjaGFubmVsKTtcbiAgICAgICAgICBpZiAoaSArIDEgPCBjaGFubmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcgIGluZGV4ICs9IDEnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9wdGltaXplZCBvdXRwdXQgb25seSB1c2FibGUgd2l0aCBOdW1iZXJzLCAke3RoaXMucmV0dXJuVHlwZX0gc3BlY2lmaWVkYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcocmVzdWx0KTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxNZW1vcnlPcHRpbWl6ZWRGbG9hdHMocmVzdWx0LCBjaGFubmVsKSB7XG4gICAgcmVzdWx0LnB1c2goXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgYCAgZ2xfRnJhZ0RhdGFbMF0uJHtjaGFubmVsfSA9IGtlcm5lbFJlc3VsdGAsXG4gICAgKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxNZW1vcnlPcHRpbWl6ZWRGbG9hdHMocmVzdWx0LCBjaGFubmVsKSB7XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIGlmIChzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XS4ke2NoYW5uZWx9ID0gZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9KWAsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV0uJHtjaGFubmVsfSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbE51bWJlclRleHR1cmUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBnbF9GcmFnRGF0YVswXVswXSA9IGtlcm5lbFJlc3VsdCcsXG4gICAgXTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxOdW1iZXJUZXh0dXJlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBzdWJLZXJuZWwgPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICBpZiAoc3ViS2VybmVsLnJldHVyblR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMF0gPSBmbG9hdChzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX0pYCxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkyVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdWzBdID0ga2VybmVsUmVzdWx0WzBdJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdWzFdID0ga2VybmVsUmVzdWx0WzFdJyxcbiAgICBdO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5MlRleHR1cmUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMF1gLFxuICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMV1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTNUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZ2xfRnJhZ0RhdGFbMF1bMF0gPSBrZXJuZWxSZXN1bHRbMF0nLFxuICAgICAgJyAgZ2xfRnJhZ0RhdGFbMF1bMV0gPSBrZXJuZWxSZXN1bHRbMV0nLFxuICAgICAgJyAgZ2xfRnJhZ0RhdGFbMF1bMl0gPSBrZXJuZWxSZXN1bHRbMl0nLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXkzVGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVswXWAsXG4gICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVsxXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsxXWAsXG4gICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVsyXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsyXWAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5NFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBnbF9GcmFnRGF0YVswXSA9IGtlcm5lbFJlc3VsdCcsXG4gICAgXTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgICAgIGlmIChzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dID0gZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9KWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzBdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzBdYCxcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVsxXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsxXWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVswXWAsXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMV1gLFxuICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzJdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzJdYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzBdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzBdYCxcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVsxXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsxXWAsXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMl0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMl1gLFxuICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzNdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzNdYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXBsYWNlQXJ0aWZhY3RzKHNyYywgbWFwKSB7XG4gICAgcmV0dXJuIHNyYy5yZXBsYWNlKC9bIF0qX18oW0EtWl0rWzAtOV0qKFtfXT9bQS1aXSpbMC05XT8pKilfXztcXG4vZywgKG1hdGNoLCBhcnRpZmFjdCkgPT4ge1xuICAgICAgaWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShhcnRpZmFjdCkpIHtcbiAgICAgICAgcmV0dXJuIG1hcFthcnRpZmFjdF07XG4gICAgICB9XG4gICAgICB0aHJvdyBgdW5oYW5kbGVkIGFydGlmYWN0ICR7YXJ0aWZhY3R9YDtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEZyYWdtZW50U2hhZGVyKGFyZ3MpIHtcbiAgICBpZiAodGhpcy5jb21waWxlZEZyYWdtZW50U2hhZGVyICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEZyYWdtZW50U2hhZGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21waWxlZEZyYWdtZW50U2hhZGVyID0gdGhpcy5yZXBsYWNlQXJ0aWZhY3RzKHRoaXMuY29uc3RydWN0b3IuZnJhZ21lbnRTaGFkZXIsIHRoaXMuX2dldEZyYWdTaGFkZXJBcnRpZmFjdE1hcChhcmdzKSk7XG4gIH1cblxuICBnZXRWZXJ0ZXhTaGFkZXIoYXJncykge1xuICAgIGlmICh0aGlzLmNvbXBpbGVkVmVydGV4U2hhZGVyICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZFZlcnRleFNoYWRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZWRWZXJ0ZXhTaGFkZXIgPSB0aGlzLnJlcGxhY2VBcnRpZmFjdHModGhpcy5jb25zdHJ1Y3Rvci52ZXJ0ZXhTaGFkZXIsIHRoaXMuX2dldFZlcnRTaGFkZXJBcnRpZmFjdE1hcChhcmdzKSk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBzZXR1cENvbnRleHRTdHJpbmcgPSB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGBjb25zdCBnbCA9IGNvbnRleHRgLFxuICAgIF0pO1xuICAgIHJldHVybiBnbEtlcm5lbFN0cmluZyh0aGlzLmNvbnN0cnVjdG9yLCBhcmd1bWVudHMsIHRoaXMsIHNldHVwQ29udGV4dFN0cmluZyk7XG4gIH1cblxuICBkZXN0cm95KHJlbW92ZUNhbnZhc1JlZmVyZW5jZXMpIHtcbiAgICBpZiAoIXRoaXMuY29udGV4dCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgdGhpcy5jb250ZXh0LmRlbGV0ZUJ1ZmZlcih0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYW1lYnVmZmVyKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLnZlcnRTaGFkZXIpIHtcbiAgICAgIHRoaXMuY29udGV4dC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0U2hhZGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJhZ1NoYWRlcikge1xuICAgICAgdGhpcy5jb250ZXh0LmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdTaGFkZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9ncmFtKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICB0aGlzLnRleHR1cmUuZGVsZXRlKCk7XG4gICAgICBjb25zdCB0ZXh0dXJlQ2FjaGVJbmRleCA9IHRoaXMudGV4dHVyZUNhY2hlLmluZGV4T2YodGhpcy50ZXh0dXJlLnRleHR1cmUpO1xuICAgICAgaWYgKHRleHR1cmVDYWNoZUluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlQ2FjaGUuc3BsaWNlKHRleHR1cmVDYWNoZUluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcHBlZFRleHR1cmVzICYmIHRoaXMubWFwcGVkVGV4dHVyZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFwcGVkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbWFwcGVkVGV4dHVyZSA9IHRoaXMubWFwcGVkVGV4dHVyZXNbaV07XG4gICAgICAgIG1hcHBlZFRleHR1cmUuZGVsZXRlKCk7XG4gICAgICAgIGNvbnN0IHRleHR1cmVDYWNoZUluZGV4ID0gdGhpcy50ZXh0dXJlQ2FjaGUuaW5kZXhPZihtYXBwZWRUZXh0dXJlLnRleHR1cmUpO1xuICAgICAgICBpZiAodGV4dHVyZUNhY2hlSW5kZXggPiAtMSkge1xuICAgICAgICAgIHRoaXMudGV4dHVyZUNhY2hlLnNwbGljZSh0ZXh0dXJlQ2FjaGVJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXMgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5rZXJuZWxBcmd1bWVudHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5rZXJuZWxBcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5rZXJuZWxBcmd1bWVudHNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5rZXJuZWxDb25zdGFudHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5rZXJuZWxDb25zdGFudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5rZXJuZWxDb25zdGFudHNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAodGhpcy50ZXh0dXJlQ2FjaGUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMudGV4dHVyZUNhY2hlLnBvcCgpO1xuICAgICAgdGhpcy5jb250ZXh0LmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgfVxuICAgIGlmIChyZW1vdmVDYW52YXNSZWZlcmVuY2VzKSB7XG4gICAgICBjb25zdCBpZHggPSBjYW52YXNlcy5pbmRleE9mKHRoaXMuY2FudmFzKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICBjYW52YXNlc1tpZHhdID0gbnVsbDtcbiAgICAgICAgbWF4VGV4U2l6ZXNbaWR4XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveUV4dGVuc2lvbnMoKTtcbiAgICBkZWxldGUgdGhpcy5jb250ZXh0O1xuICAgIGRlbGV0ZSB0aGlzLmNhbnZhcztcbiAgICBpZiAoIXRoaXMuZ3B1KSByZXR1cm47XG4gICAgY29uc3QgaSA9IHRoaXMuZ3B1Lmtlcm5lbHMuaW5kZXhPZih0aGlzKTtcbiAgICBpZiAoaSA9PT0gLTEpIHJldHVybjtcbiAgICB0aGlzLmdwdS5rZXJuZWxzLnNwbGljZShpLCAxKTtcbiAgfVxuXG4gIGRlc3Ryb3lFeHRlbnNpb25zKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdCA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLk9FU19lbGVtZW50X2luZGV4X3VpbnQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGRlc3Ryb3lDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBjb250ZXh0LmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG4gICAgaWYgKGV4dGVuc2lvbikge1xuICAgICAgZXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGpzb24gPSBzdXBlci50b0pTT04oKTtcbiAgICBqc29uLmZ1bmN0aW9uTm9kZXMgPSBGdW5jdGlvbkJ1aWxkZXIuZnJvbUtlcm5lbCh0aGlzLCBXZWJHTEZ1bmN0aW9uTm9kZSkudG9KU09OKCk7XG4gICAganNvbi5zZXR0aW5ncy50aHJlYWREaW0gPSB0aGlzLnRocmVhZERpbTtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxcbn07XG59LHtcIi4uLy4uL3BsdWdpbnMvbWF0aC1yYW5kb20tdW5pZm9ybWx5LWRpc3RyaWJ1dGVkXCI6MTEyLFwiLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi9mdW5jdGlvbi1idWlsZGVyXCI6OSxcIi4uL2dsL2tlcm5lbFwiOjEzLFwiLi4vZ2wva2VybmVsLXN0cmluZ1wiOjEyLFwiLi9mcmFnbWVudC1zaGFkZXJcIjozNyxcIi4vZnVuY3Rpb24tbm9kZVwiOjM4LFwiLi9rZXJuZWwtdmFsdWUtbWFwc1wiOjM5LFwiLi92ZXJ0ZXgtc2hhZGVyXCI6NzF9XSw3MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB2ZXJ0ZXhTaGFkZXIgPSBgX19GTE9BVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fSU5UX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuX19TQU1QTEVSXzJEX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuXG5hdHRyaWJ1dGUgdmVjMiBhUG9zO1xuYXR0cmlidXRlIHZlYzIgYVRleENvb3JkO1xuXG52YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xudW5pZm9ybSB2ZWMyIHJhdGlvO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnbF9Qb3NpdGlvbiA9IHZlYzQoKGFQb3MgKyB2ZWMyKDEpKSAqIHJhdGlvICsgdmVjMigtMSksIDAsIDEpO1xuICB2VGV4Q29vcmQgPSBhVGV4Q29vcmQ7XG59YDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZlcnRleFNoYWRlclxufTtcbn0se31dLDcyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IGZyYWdtZW50U2hhZGVyID0gYCN2ZXJzaW9uIDMwMCBlc1xuX19IRUFERVJfXztcbl9fRkxPQVRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX0lOVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fU0FNUExFUl8yRF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fU0FNUExFUl8yRF9BUlJBWV9UQUNUSUNfREVDTEFSQVRJT05fXztcblxuY29uc3QgaW50IExPT1BfTUFYID0gX19MT09QX01BWF9fO1xuXG5fX1BMVUdJTlNfXztcbl9fQ09OU1RBTlRTX187XG5cbmluIHZlYzIgdlRleENvb3JkO1xuXG5mbG9hdCBhdGFuMihmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgaWYgKHYxID09IDAuMCB8fCB2MiA9PSAwLjApIHJldHVybiAwLjA7XG4gIHJldHVybiBhdGFuKHYxIC8gdjIpO1xufVxuXG5mbG9hdCBjYnJ0KGZsb2F0IHgpIHtcbiAgaWYgKHggPj0gMC4wKSB7XG4gICAgcmV0dXJuIHBvdyh4LCAxLjAgLyAzLjApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAtcG93KHgsIDEuMCAvIDMuMCk7XG4gIH1cbn1cblxuZmxvYXQgZXhwbTEoZmxvYXQgeCkge1xuICByZXR1cm4gcG93KCR7TWF0aC5FfSwgeCkgLSAxLjA7IFxufVxuXG5mbG9hdCBmcm91bmQoaGlnaHAgZmxvYXQgeCkge1xuICByZXR1cm4geDtcbn1cblxuZmxvYXQgaW11bChmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgcmV0dXJuIGZsb2F0KGludCh2MSkgKiBpbnQodjIpKTtcbn1cblxuZmxvYXQgbG9nMTAoZmxvYXQgeCkge1xuICByZXR1cm4gbG9nMih4KSAqICgxLjAgLyBsb2cyKDEwLjApKTtcbn1cblxuZmxvYXQgbG9nMXAoZmxvYXQgeCkge1xuICByZXR1cm4gbG9nKDEuMCArIHgpO1xufVxuXG5mbG9hdCBfcG93KGZsb2F0IHYxLCBmbG9hdCB2Mikge1xuICBpZiAodjIgPT0gMC4wKSByZXR1cm4gMS4wO1xuICByZXR1cm4gcG93KHYxLCB2Mik7XG59XG5cbmZsb2F0IF9yb3VuZChmbG9hdCB4KSB7XG4gIHJldHVybiBmbG9vcih4ICsgMC41KTtcbn1cblxuXG5jb25zdCBpbnQgQklUX0NPVU5UID0gMzI7XG5pbnQgbW9kaShpbnQgeCwgaW50IHkpIHtcbiAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcbn1cblxuaW50IGJpdHdpc2VPcihpbnQgYSwgaW50IGIpIHtcbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBuID0gMTtcbiAgXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoKG1vZGkoYSwgMikgPT0gMSkgfHwgKG1vZGkoYiwgMikgPT0gMSkpIHtcbiAgICAgIHJlc3VsdCArPSBuO1xuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgYiA9IGIgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgICBpZighKGEgPiAwIHx8IGIgPiAwKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZVhPUihpbnQgYSwgaW50IGIpIHtcbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBuID0gMTtcbiAgXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoKG1vZGkoYSwgMikgPT0gMSkgIT0gKG1vZGkoYiwgMikgPT0gMSkpIHtcbiAgICAgIHJlc3VsdCArPSBuO1xuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgYiA9IGIgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgICBpZighKGEgPiAwIHx8IGIgPiAwKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZUFuZChpbnQgYSwgaW50IGIpIHtcbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBuID0gMTtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmICgobW9kaShhLCAyKSA9PSAxKSAmJiAobW9kaShiLCAyKSA9PSAxKSkge1xuICAgICAgcmVzdWx0ICs9IG47XG4gICAgfVxuICAgIGEgPSBhIC8gMjtcbiAgICBiID0gYiAvIDI7XG4gICAgbiA9IG4gKiAyO1xuICAgIGlmKCEoYSA+IDAgJiYgYiA+IDApKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmludCBiaXR3aXNlTm90KGludCBhKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIFxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKG1vZGkoYSwgMikgPT0gMCkge1xuICAgICAgcmVzdWx0ICs9IG47ICAgIFxuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgbiA9IG4gKiAyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZVplcm9GaWxsTGVmdFNoaWZ0KGludCBuLCBpbnQgc2hpZnQpIHtcbiAgaW50IG1heEJ5dGVzID0gQklUX0NPVU5UO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKG1heEJ5dGVzID49IG4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXhCeXRlcyAqPSAyO1xuICB9XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoaSA+PSBzaGlmdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG4gKj0gMjtcbiAgfVxuXG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgYnl0ZVZhbCA9IDE7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoaSA+PSBtYXhCeXRlcykgYnJlYWs7XG4gICAgaWYgKG1vZGkobiwgMikgPiAwKSB7IHJlc3VsdCArPSBieXRlVmFsOyB9XG4gICAgbiA9IGludChuIC8gMik7XG4gICAgYnl0ZVZhbCAqPSAyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmludCBiaXR3aXNlU2lnbmVkUmlnaHRTaGlmdChpbnQgbnVtLCBpbnQgc2hpZnRzKSB7XG4gIHJldHVybiBpbnQoZmxvb3IoZmxvYXQobnVtKSAvIHBvdygyLjAsIGZsb2F0KHNoaWZ0cykpKSk7XG59XG5cbmludCBiaXR3aXNlWmVyb0ZpbGxSaWdodFNoaWZ0KGludCBuLCBpbnQgc2hpZnQpIHtcbiAgaW50IG1heEJ5dGVzID0gQklUX0NPVU5UO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKG1heEJ5dGVzID49IG4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXhCeXRlcyAqPSAyO1xuICB9XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoaSA+PSBzaGlmdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG4gLz0gMjtcbiAgfVxuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IGJ5dGVWYWwgPSAxO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gbWF4Qnl0ZXMpIGJyZWFrO1xuICAgIGlmIChtb2RpKG4sIDIpID4gMCkgeyByZXN1bHQgKz0gYnl0ZVZhbDsgfVxuICAgIG4gPSBpbnQobiAvIDIpO1xuICAgIGJ5dGVWYWwgKj0gMjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52ZWMyIGludGVnZXJNb2QodmVjMiB4LCBmbG9hdCB5KSB7XG4gIHZlYzIgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG52ZWMzIGludGVnZXJNb2QodmVjMyB4LCBmbG9hdCB5KSB7XG4gIHZlYzMgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG52ZWM0IGludGVnZXJNb2QodmVjNCB4LCB2ZWM0IHkpIHtcbiAgdmVjNCByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xuICByZXR1cm4gcmVzICogc3RlcCgxLjAgLSBmbG9vcih5KSwgLXJlcyk7XG59XG5cbmZsb2F0IGludGVnZXJNb2QoZmxvYXQgeCwgZmxvYXQgeSkge1xuICBmbG9hdCByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xuICByZXR1cm4gcmVzICogKHJlcyA+IGZsb29yKHkpIC0gMS4wID8gMC4wIDogMS4wKTtcbn1cblxuaW50IGludGVnZXJNb2QoaW50IHgsIGludCB5KSB7XG4gIHJldHVybiB4IC0gKHkgKiBpbnQoeC95KSk7XG59XG5cbl9fRElWSURFX1dJVEhfSU5URUdFUl9DSEVDS19fO1xuXG4vLyBIZXJlIGJlIGRyYWdvbnMhXG4vLyBETyBOT1QgT1BUSU1JWkUgVEhJUyBDT0RFXG4vLyBZT1UgV0lMTCBCUkVBSyBTT01FVEhJTkcgT04gU09NRUJPRFlcXCdTIE1BQ0hJTkVcbi8vIExFQVZFIElUIEFTIElUIElTLCBMRVNUIFlPVSBXQVNURSBZT1VSIE9XTiBUSU1FXG5jb25zdCB2ZWMyIE1BR0lDX1ZFQyA9IHZlYzIoMS4wLCAtMjU2LjApO1xuY29uc3QgdmVjNCBTQ0FMRV9GQUNUT1IgPSB2ZWM0KDEuMCwgMjU2LjAsIDY1NTM2LjAsIDAuMCk7XG5jb25zdCB2ZWM0IFNDQUxFX0ZBQ1RPUl9JTlYgPSB2ZWM0KDEuMCwgMC4wMDM5MDYyNSwgMC4wMDAwMTUyNTg3ODkwNjI1LCAwLjApOyAvLyAxLCAxLzI1NiwgMS82NTUzNlxuZmxvYXQgZGVjb2RlMzIodmVjNCB0ZXhlbCkge1xuICBfX0RFQ09ERTMyX0VORElBTk5FU1NfXztcbiAgdGV4ZWwgKj0gMjU1LjA7XG4gIHZlYzIgZ3RlMTI4O1xuICBndGUxMjgueCA9IHRleGVsLmIgPj0gMTI4LjAgPyAxLjAgOiAwLjA7XG4gIGd0ZTEyOC55ID0gdGV4ZWwuYSA+PSAxMjguMCA/IDEuMCA6IDAuMDtcbiAgZmxvYXQgZXhwb25lbnQgPSAyLjAgKiB0ZXhlbC5hIC0gMTI3LjAgKyBkb3QoZ3RlMTI4LCBNQUdJQ19WRUMpO1xuICBmbG9hdCByZXMgPSBleHAyKHJvdW5kKGV4cG9uZW50KSk7XG4gIHRleGVsLmIgPSB0ZXhlbC5iIC0gMTI4LjAgKiBndGUxMjgueDtcbiAgcmVzID0gZG90KHRleGVsLCBTQ0FMRV9GQUNUT1IpICogZXhwMihyb3VuZChleHBvbmVudC0yMy4wKSkgKyByZXM7XG4gIHJlcyAqPSBndGUxMjgueSAqIC0yLjAgKyAxLjA7XG4gIHJldHVybiByZXM7XG59XG5cbmZsb2F0IGRlY29kZTE2KHZlYzQgdGV4ZWwsIGludCBpbmRleCkge1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDIpO1xuICByZXR1cm4gdGV4ZWxbY2hhbm5lbCoyXSAqIDI1NS4wICsgdGV4ZWxbY2hhbm5lbCoyICsgMV0gKiA2NTI4MC4wO1xufVxuXG5mbG9hdCBkZWNvZGU4KHZlYzQgdGV4ZWwsIGludCBpbmRleCkge1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDQpO1xuICByZXR1cm4gdGV4ZWxbY2hhbm5lbF0gKiAyNTUuMDtcbn1cblxudmVjNCBsZWdhY3lFbmNvZGUzMihmbG9hdCBmKSB7XG4gIGZsb2F0IEYgPSBhYnMoZik7XG4gIGZsb2F0IHNpZ24gPSBmIDwgMC4wID8gMS4wIDogMC4wO1xuICBmbG9hdCBleHBvbmVudCA9IGZsb29yKGxvZzIoRikpO1xuICBmbG9hdCBtYW50aXNzYSA9IChleHAyKC1leHBvbmVudCkgKiBGKTtcbiAgLy8gZXhwb25lbnQgKz0gZmxvb3IobG9nMihtYW50aXNzYSkpO1xuICB2ZWM0IHRleGVsID0gdmVjNChGICogZXhwMigyMy4wLWV4cG9uZW50KSkgKiBTQ0FMRV9GQUNUT1JfSU5WO1xuICB0ZXhlbC5yZyA9IGludGVnZXJNb2QodGV4ZWwucmcsIDI1Ni4wKTtcbiAgdGV4ZWwuYiA9IGludGVnZXJNb2QodGV4ZWwuYiwgMTI4LjApO1xuICB0ZXhlbC5hID0gZXhwb25lbnQqMC41ICsgNjMuNTtcbiAgdGV4ZWwuYmEgKz0gdmVjMihpbnRlZ2VyTW9kKGV4cG9uZW50KzEyNy4wLCAyLjApLCBzaWduKSAqIDEyOC4wO1xuICB0ZXhlbCA9IGZsb29yKHRleGVsKTtcbiAgdGV4ZWwgKj0gMC4wMDM5MjE1Njk7IC8vIDEvMjU1XG4gIF9fRU5DT0RFMzJfRU5ESUFOTkVTU19fO1xuICByZXR1cm4gdGV4ZWw7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ncHVqcy9ncHUuanMvd2lraS9FbmNvZGVyLWRldGFpbHNcbnZlYzQgZW5jb2RlMzIoZmxvYXQgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IDAuMCkgcmV0dXJuIHZlYzQoMCwgMCwgMCwgMCk7XG5cbiAgZmxvYXQgZXhwb25lbnQ7XG4gIGZsb2F0IG1hbnRpc3NhO1xuICB2ZWM0ICByZXN1bHQ7XG4gIGZsb2F0IHNnbjtcblxuICBzZ24gPSBzdGVwKDAuMCwgLXZhbHVlKTtcbiAgdmFsdWUgPSBhYnModmFsdWUpO1xuXG4gIGV4cG9uZW50ID0gZmxvb3IobG9nMih2YWx1ZSkpO1xuXG4gIG1hbnRpc3NhID0gdmFsdWUqcG93KDIuMCwgLWV4cG9uZW50KS0xLjA7XG4gIGV4cG9uZW50ID0gZXhwb25lbnQrMTI3LjA7XG4gIHJlc3VsdCAgID0gdmVjNCgwLDAsMCwwKTtcblxuICByZXN1bHQuYSA9IGZsb29yKGV4cG9uZW50LzIuMCk7XG4gIGV4cG9uZW50ID0gZXhwb25lbnQgLSByZXN1bHQuYSoyLjA7XG4gIHJlc3VsdC5hID0gcmVzdWx0LmEgKyAxMjguMCpzZ247XG5cbiAgcmVzdWx0LmIgPSBmbG9vcihtYW50aXNzYSAqIDEyOC4wKTtcbiAgbWFudGlzc2EgPSBtYW50aXNzYSAtIHJlc3VsdC5iIC8gMTI4LjA7XG4gIHJlc3VsdC5iID0gcmVzdWx0LmIgKyBleHBvbmVudCoxMjguMDtcblxuICByZXN1bHQuZyA9IGZsb29yKG1hbnRpc3NhKjMyNzY4LjApO1xuICBtYW50aXNzYSA9IG1hbnRpc3NhIC0gcmVzdWx0LmcvMzI3NjguMDtcblxuICByZXN1bHQuciA9IGZsb29yKG1hbnRpc3NhKjgzODg2MDguMCk7XG4gIHJldHVybiByZXN1bHQvMjU1LjA7XG59XG4vLyBEcmFnb25zIGVuZCBoZXJlXG5cbmludCBpbmRleDtcbml2ZWMzIHRocmVhZElkO1xuXG5pdmVjMyBpbmRleFRvM0QoaW50IGlkeCwgaXZlYzMgdGV4RGltKSB7XG4gIGludCB6ID0gaW50KGlkeCAvICh0ZXhEaW0ueCAqIHRleERpbS55KSk7XG4gIGlkeCAtPSB6ICogaW50KHRleERpbS54ICogdGV4RGltLnkpO1xuICBpbnQgeSA9IGludChpZHggLyB0ZXhEaW0ueCk7XG4gIGludCB4ID0gaW50KGludGVnZXJNb2QoaWR4LCB0ZXhEaW0ueCkpO1xuICByZXR1cm4gaXZlYzMoeCwgeSwgeik7XG59XG5cbmZsb2F0IGdldDMyKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIHJldHVybiBkZWNvZGUzMih0ZXhlbCk7XG59XG5cbmZsb2F0IGdldDE2KHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgKHRleERpbS54ICogKHkgKyAodGV4RGltLnkgKiB6KSkpO1xuICBpbnQgdyA9IHRleFNpemUueCAqIDI7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUueCAqIDIsIHRleFNpemUueSkpO1xuICByZXR1cm4gZGVjb2RlMTYodGV4ZWwsIGluZGV4KTtcbn1cblxuZmxvYXQgZ2V0OChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArICh0ZXhEaW0ueCAqICh5ICsgKHRleERpbS55ICogeikpKTtcbiAgaW50IHcgPSB0ZXhTaXplLnggKiA0O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplLnggKiA0LCB0ZXhTaXplLnkpKTtcbiAgcmV0dXJuIGRlY29kZTgodGV4ZWwsIGluZGV4KTtcbn1cblxuZmxvYXQgZ2V0TWVtb3J5T3B0aW1pemVkMzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyAodGV4RGltLnggKiAoeSArICh0ZXhEaW0ueSAqIHopKSk7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgNCk7XG4gIGluZGV4ID0gaW5kZXggLyA0O1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgaW5kZXggPSBpbmRleCAvIDQ7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbiAgcmV0dXJuIHRleGVsW2NoYW5uZWxdO1xufVxuXG52ZWM0IGdldEltYWdlMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHJldHVybiB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbn1cblxudmVjNCBnZXRJbWFnZTNEKHNhbXBsZXIyREFycmF5IHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHJldHVybiB0ZXh0dXJlKHRleCwgdmVjMyhzdCAvIHZlYzIodGV4U2l6ZSksIHopKTtcbn1cblxuZmxvYXQgZ2V0RmxvYXRGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gcmVzdWx0WzBdO1xufVxuXG52ZWMyIGdldFZlYzJGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gdmVjMihyZXN1bHRbMF0sIHJlc3VsdFsxXSk7XG59XG5cbnZlYzIgZ2V0TWVtb3J5T3B0aW1pemVkVmVjMihzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDIpO1xuICBpbmRleCA9IGluZGV4IC8gMjtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbiAgaWYgKGNoYW5uZWwgPT0gMCkgcmV0dXJuIHZlYzIodGV4ZWwuciwgdGV4ZWwuZyk7XG4gIGlmIChjaGFubmVsID09IDEpIHJldHVybiB2ZWMyKHRleGVsLmIsIHRleGVsLmEpO1xuICByZXR1cm4gdmVjMigwLjAsIDAuMCk7XG59XG5cbnZlYzMgZ2V0VmVjM0Zyb21TYW1wbGVyMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIHZlYzQgcmVzdWx0ID0gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgeiwgeSwgeCk7XG4gIHJldHVybiB2ZWMzKHJlc3VsdFswXSwgcmVzdWx0WzFdLCByZXN1bHRbMl0pO1xufVxuXG52ZWMzIGdldE1lbW9yeU9wdGltaXplZFZlYzMoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBmaWVsZEluZGV4ID0gMyAqICh4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeikpO1xuICBpbnQgdmVjdG9ySW5kZXggPSBmaWVsZEluZGV4IC8gNDtcbiAgaW50IHZlY3Rvck9mZnNldCA9IGZpZWxkSW5kZXggLSB2ZWN0b3JJbmRleCAqIDQ7XG4gIGludCByZWFkWSA9IHZlY3RvckluZGV4IC8gdGV4U2l6ZS54O1xuICBpbnQgcmVhZFggPSB2ZWN0b3JJbmRleCAtIHJlYWRZICogdGV4U2l6ZS54O1xuICB2ZWM0IHRleDEgPSB0ZXh0dXJlKHRleCwgKHZlYzIocmVhZFgsIHJlYWRZKSArIDAuNSkgLyB2ZWMyKHRleFNpemUpKTtcblxuICBpZiAodmVjdG9yT2Zmc2V0ID09IDApIHtcbiAgICByZXR1cm4gdGV4MS54eXo7XG4gIH0gZWxzZSBpZiAodmVjdG9yT2Zmc2V0ID09IDEpIHtcbiAgICByZXR1cm4gdGV4MS55enc7XG4gIH0gZWxzZSB7XG4gICAgcmVhZFgrKztcbiAgICBpZiAocmVhZFggPj0gdGV4U2l6ZS54KSB7XG4gICAgICByZWFkWCA9IDA7XG4gICAgICByZWFkWSsrO1xuICAgIH1cbiAgICB2ZWM0IHRleDIgPSB0ZXh0dXJlKHRleCwgdmVjMihyZWFkWCwgcmVhZFkpIC8gdmVjMih0ZXhTaXplKSk7XG4gICAgaWYgKHZlY3Rvck9mZnNldCA9PSAyKSB7XG4gICAgICByZXR1cm4gdmVjMyh0ZXgxLnosIHRleDEudywgdGV4Mi54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZlYzModGV4MS53LCB0ZXgyLngsIHRleDIueSk7XG4gICAgfVxuICB9XG59XG5cbnZlYzQgZ2V0VmVjNEZyb21TYW1wbGVyMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIHJldHVybiBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbn1cblxudmVjNCBnZXRNZW1vcnlPcHRpbWl6ZWRWZWM0KHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgMik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIHJldHVybiB2ZWM0KHRleGVsLnIsIHRleGVsLmcsIHRleGVsLmIsIHRleGVsLmEpO1xufVxuXG52ZWM0IGFjdHVhbENvbG9yO1xudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiLCBmbG9hdCBhKSB7XG4gIGFjdHVhbENvbG9yID0gdmVjNChyLGcsYixhKTtcbn1cblxudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiKSB7XG4gIGNvbG9yKHIsZyxiLDEuMCk7XG59XG5cbmZsb2F0IG1vZHVsbyhmbG9hdCBudW1iZXIsIGZsb2F0IGRpdmlzb3IpIHtcbiAgaWYgKG51bWJlciA8IDAuMCkge1xuICAgIG51bWJlciA9IGFicyhudW1iZXIpO1xuICAgIGlmIChkaXZpc29yIDwgMC4wKSB7XG4gICAgICBkaXZpc29yID0gYWJzKGRpdmlzb3IpO1xuICAgIH1cbiAgICByZXR1cm4gLW1vZChudW1iZXIsIGRpdmlzb3IpO1xuICB9XG4gIGlmIChkaXZpc29yIDwgMC4wKSB7XG4gICAgZGl2aXNvciA9IGFicyhkaXZpc29yKTtcbiAgfVxuICByZXR1cm4gbW9kKG51bWJlciwgZGl2aXNvcik7XG59XG5cbl9fSU5KRUNURURfTkFUSVZFX187XG5fX01BSU5fQ09OU1RBTlRTX187XG5fX01BSU5fQVJHVU1FTlRTX187XG5fX0tFUk5FTF9fO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBpbmRleCA9IGludCh2VGV4Q29vcmQucyAqIGZsb2F0KHVUZXhTaXplLngpKSArIGludCh2VGV4Q29vcmQudCAqIGZsb2F0KHVUZXhTaXplLnkpKSAqIHVUZXhTaXplLng7XG4gIF9fTUFJTl9SRVNVTFRfXztcbn1gO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZnJhZ21lbnRTaGFkZXJcbn07XG59LHt9XSw3MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi4vd2ViLWdsL2Z1bmN0aW9uLW5vZGUnKTtcblxuY2xhc3MgV2ViR0wyRnVuY3Rpb25Ob2RlIGV4dGVuZHMgV2ViR0xGdW5jdGlvbk5vZGUge1xuXG4gIGFzdElkZW50aWZpZXJFeHByZXNzaW9uKGlkdE5vZGUsIHJldEFycikge1xuICAgIGlmIChpZHROb2RlLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcbiAgICAgICAgJ0lkZW50aWZpZXJFeHByZXNzaW9uIC0gbm90IGFuIElkZW50aWZpZXInLFxuICAgICAgICBpZHROb2RlXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoaWR0Tm9kZSk7XG5cbiAgICBjb25zdCBuYW1lID0gdXRpbHMuc2FuaXRpemVOYW1lKGlkdE5vZGUubmFtZSk7XG4gICAgaWYgKGlkdE5vZGUubmFtZSA9PT0gJ0luZmluaXR5Jykge1xuICAgICAgcmV0QXJyLnB1c2goJ2ludEJpdHNUb0Zsb2F0KDIxMzkwOTUwMzkpJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnQm9vbGVhbicpIHtcbiAgICAgIGlmICh0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgIHJldEFyci5wdXNoKGBib29sKHVzZXJfJHtuYW1lfSlgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7bmFtZX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHtuYW1lfWApO1xuICAgIH1cblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMkZ1bmN0aW9uTm9kZVxufTtcbn0se1wiLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi93ZWItZ2wvZnVuY3Rpb24tbm9kZVwiOjM4fV0sNzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW4gfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2Jvb2xlYW4nKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVGbG9hdCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZmxvYXQnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9pbnRlZ2VyJyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2h0bWwtaW1hZ2UnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2UnKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZUFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlLWFycmF5Jyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZUFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2UtYXJyYXknKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxWaWRlbyB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvaHRtbC12aWRlbycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8gfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtaHRtbC12aWRlbycpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dCcpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtaW5wdXQnKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3Vuc2lnbmVkLWlucHV0Jyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtaW5wdXQnKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlJyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9udW1iZXItdGV4dHVyZScpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLW51bWJlci10ZXh0dXJlJyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5Jyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWknKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MWQtaScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWknKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MmQtaScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWknKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5M2QtaScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkzIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXk0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXk0Jyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1hcnJheScpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWFycmF5Jyk7XG5cbmNvbnN0IGtlcm5lbFZhbHVlTWFwcyA9IHtcbiAgdW5zaWduZWQ6IHtcbiAgICBkeW5hbWljOiB7XG4gICAgICAnQm9vbGVhbic6IFdlYkdMMktlcm5lbFZhbHVlQm9vbGVhbixcbiAgICAgICdJbnRlZ2VyJzogV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0Zsb2F0JzogV2ViR0wyS2VybmVsVmFsdWVGbG9hdCxcbiAgICAgICdBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXksXG4gICAgICAnQXJyYXkoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheSgzKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5KDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDQpJzogZmFsc2UsXG4gICAgICAnSW5wdXQnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgxKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gICAgICAnSFRNTENhbnZhcyc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2UnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2VBcnJheSxcbiAgICAgICdIVE1MVmlkZW8nOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8sXG4gICAgfSxcbiAgICBzdGF0aWM6IHtcbiAgICAgICdCb29sZWFuJzogV2ViR0wyS2VybmVsVmFsdWVCb29sZWFuLFxuICAgICAgJ0Zsb2F0JzogV2ViR0wyS2VybmVsVmFsdWVGbG9hdCxcbiAgICAgICdJbnRlZ2VyJzogV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0FycmF5JzogV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogZmFsc2UsXG4gICAgICAnQXJyYXkoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheSg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCg0KSc6IGZhbHNlLFxuICAgICAgJ0lucHV0JzogV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZElucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDEpJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgyKSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDQpJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2UnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXksXG4gICAgICAnSFRNTFZpZGVvJzogV2ViR0wyS2VybmVsVmFsdWVIVE1MVmlkZW8sXG4gICAgfVxuICB9LFxuICBzaW5nbGU6IHtcbiAgICBkeW5hbWljOiB7XG4gICAgICAnQm9vbGVhbic6IFdlYkdMMktlcm5lbFZhbHVlQm9vbGVhbixcbiAgICAgICdJbnRlZ2VyJzogV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0Zsb2F0JzogV2ViR0wyS2VybmVsVmFsdWVGbG9hdCxcbiAgICAgICdBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTIsXG4gICAgICAnQXJyYXkoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MyxcbiAgICAgICdBcnJheSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXk0LFxuICAgICAgJ0FycmF5MUQoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTFEKDMpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxREksXG4gICAgICAnQXJyYXkxRCg0KSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MkQoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTJEKDMpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREksXG4gICAgICAnQXJyYXkyRCg0KSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5M0QoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTNESSxcbiAgICAgICdBcnJheTNEKDMpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREksXG4gICAgICAnQXJyYXkzRCg0KSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJLFxuICAgICAgJ0lucHV0JzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlSW5wdXQsXG4gICAgICAnTnVtYmVyVGV4dHVyZSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDEpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgzKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDQpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSxcbiAgICAgICdIVE1MQ2FudmFzJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZUFycmF5LFxuICAgICAgJ0hUTUxWaWRlbyc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlbyxcbiAgICB9LFxuICAgIHN0YXRpYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnRmxvYXQnOiBXZWJHTDJLZXJuZWxWYWx1ZUZsb2F0LFxuICAgICAgJ0ludGVnZXInOiBXZWJHTDJLZXJuZWxWYWx1ZUludGVnZXIsXG4gICAgICAnQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTIsXG4gICAgICAnQXJyYXkoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MyxcbiAgICAgICdBcnJheSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXk0LFxuICAgICAgJ0FycmF5MUQoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MkQoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5M0QoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJLFxuICAgICAgJ0lucHV0JzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgxKSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogV2ViR0wyS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2UnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXksXG4gICAgICAnSFRNTFZpZGVvJzogV2ViR0wyS2VybmVsVmFsdWVIVE1MVmlkZW8sXG4gICAgfVxuICB9LFxufTtcblxuZnVuY3Rpb24gbG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIGR5bmFtaWMsIHByZWNpc2lvbiwgdmFsdWUpIHtcbiAgaWYgKCF0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoIWR5bmFtaWMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2R5bmFtaWMgbWlzc2luZycpO1xuICB9XG4gIGlmICghcHJlY2lzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcmVjaXNpb24gbWlzc2luZycpO1xuICB9XG4gIGlmICh2YWx1ZS50eXBlKSB7XG4gICAgdHlwZSA9IHZhbHVlLnR5cGU7XG4gIH1cbiAgY29uc3QgdHlwZXMgPSBrZXJuZWxWYWx1ZU1hcHNbcHJlY2lzaW9uXVtkeW5hbWljXTtcbiAgaWYgKHR5cGVzW3R5cGVdID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVzW3R5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgS2VybmVsVmFsdWUgZm9yICR7IHR5cGUgfWApO1xuICB9XG4gIHJldHVybiB0eXBlc1t0eXBlXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtlcm5lbFZhbHVlTWFwcyxcbiAgbG9va3VwS2VybmVsVmFsdWVUeXBlXG59O1xufSx7XCIuL2tlcm5lbC12YWx1ZS9ib29sZWFuXCI6NzUsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2VcIjo3NyxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtaHRtbC1pbWFnZS1hcnJheVwiOjc2LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLXZpZGVvXCI6NzgsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLW1lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmVcIjo3OSxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtbnVtYmVyLXRleHR1cmVcIjo4MCxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5XCI6ODEsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTFkLWlcIjo4MixcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MmQtaVwiOjgzLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkzZC1pXCI6ODQsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1pbnB1dFwiOjg1LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1hcnJheVwiOjg2LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1pbnB1dFwiOjg3LFwiLi9rZXJuZWwtdmFsdWUvZmxvYXRcIjo4OCxcIi4va2VybmVsLXZhbHVlL2h0bWwtaW1hZ2VcIjo5MCxcIi4va2VybmVsLXZhbHVlL2h0bWwtaW1hZ2UtYXJyYXlcIjo4OSxcIi4va2VybmVsLXZhbHVlL2h0bWwtdmlkZW9cIjo5MSxcIi4va2VybmVsLXZhbHVlL2ludGVnZXJcIjo5MixcIi4va2VybmVsLXZhbHVlL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmVcIjo5MyxcIi4va2VybmVsLXZhbHVlL251bWJlci10ZXh0dXJlXCI6OTQsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXlcIjo5NSxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWlcIjo5NixcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJcIjo5NyxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWlcIjo5OCxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNcIjo5OSxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWlcIjoxMDAsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXk0XCI6MTAxLFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWlucHV0XCI6MTAyLFwiLi9rZXJuZWwtdmFsdWUvdW5zaWduZWQtYXJyYXlcIjoxMDMsXCIuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1pbnB1dFwiOjEwNH1dLDc1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW4gfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvYm9vbGVhbicpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW4gZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbiB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVCb29sZWFuXG59O1xufSx7XCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2Jvb2xlYW5cIjo0MX1dLDc2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXkgfSA9IHJlcXVpcmUoJy4vaHRtbC1pbWFnZS1hcnJheScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2VBcnJheSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkRBcnJheSAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbWFnZXMpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGltYWdlc1swXTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBbd2lkdGgsIGhlaWdodCwgaW1hZ2VzLmxlbmd0aF07XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKGltYWdlcyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZUFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaHRtbC1pbWFnZS1hcnJheVwiOjg5fV0sNzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlXCI6NDJ9XSw3ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UgfSA9IHJlcXVpcmUoJy4vZHluYW1pYy1odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlbyBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZHluYW1pYy1odG1sLWltYWdlXCI6Nzd9XSw3OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlXCI6NDR9XSw4MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1udW1iZXItdGV4dHVyZScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtbnVtYmVyLXRleHR1cmVcIjo0NX1dLDgxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheVwiOjk1fV0sODI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MWQtaScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MWQtaVwiOjk2fV0sODM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MmQtaScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MmQtaVwiOjk4fV0sODQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M2QtaScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTNESSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M2QtaVwiOjEwMH1dLDg1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlSW5wdXQgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dCcpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlSW5wdXQge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBsZXQgW3csIGgsIGRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdyB8fCAxLCBoIHx8IDEsIGQgfHwgMV0pO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlSW5wdXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWlucHV0XCI6MTAyfV0sODY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtYXJyYXknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRBcnJheSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWFycmF5XCI6NTF9XSw4NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXQgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1pbnB1dCcpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRJbnB1dFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtaW5wdXRcIjo1Mn1dLDg4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVGbG9hdCB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9mbG9hdCcpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUZsb2F0IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUZsb2F0IHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUZsb2F0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZmxvYXRcIjo1M31dLDg5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvYXJyYXknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2VBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuY2hlY2tTaXplKHZhbHVlWzBdLndpZHRoLCB2YWx1ZVswXS5oZWlnaHQpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IFt2YWx1ZVswXS53aWR0aCwgdmFsdWVbMF0uaGVpZ2h0LCB2YWx1ZS5sZW5ndGhdO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSBbdmFsdWVbMF0ud2lkdGgsIHZhbHVlWzBdLmhlaWdodF07XG4gIH1cbiAgZGVmaW5lVGV4dHVyZSgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJEX0FSUkFZLCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkRfQVJSQVksIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX07XFxuYDtcbiAgfVxuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkRBcnJheSAke3RoaXMuaWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbWFnZXMpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJEX0FSUkFZLCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuICAgIGdsLnRleEltYWdlM0QoXG4gICAgICBnbC5URVhUVVJFXzJEX0FSUkFZLFxuICAgICAgMCxcbiAgICAgIGdsLlJHQkEsXG4gICAgICBpbWFnZXNbMF0ud2lkdGgsXG4gICAgICBpbWFnZXNbMF0uaGVpZ2h0LFxuICAgICAgaW1hZ2VzLmxlbmd0aCxcbiAgICAgIDAsXG4gICAgICBnbC5SR0JBLFxuICAgICAgZ2wuVU5TSUdORURfQllURSxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB4T2Zmc2V0ID0gMDtcbiAgICAgIGNvbnN0IHlPZmZzZXQgPSAwO1xuICAgICAgY29uc3QgaW1hZ2VEZXB0aCA9IDE7XG4gICAgICBnbC50ZXhTdWJJbWFnZTNEKFxuICAgICAgICBnbC5URVhUVVJFXzJEX0FSUkFZLFxuICAgICAgICAwLFxuICAgICAgICB4T2Zmc2V0LFxuICAgICAgICB5T2Zmc2V0LFxuICAgICAgICBpLFxuICAgICAgICBpbWFnZXNbaV0ud2lkdGgsXG4gICAgICAgIGltYWdlc1tpXS5oZWlnaHQsXG4gICAgICAgIGltYWdlRGVwdGgsXG4gICAgICAgIGdsLlJHQkEsXG4gICAgICAgIGdsLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHRoaXMudXBsb2FkVmFsdWUgPSBpbWFnZXNbaV1cbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2VBcnJheVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2FycmF5XCI6NDB9XSw5MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2h0bWwtaW1hZ2UnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2Vcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlXCI6NTR9XSw5MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlSFRNTFZpZGVvIGV4dGVuZHMgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2Uge31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlSFRNTFZpZGVvXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaHRtbC1pbWFnZVwiOjkwfV0sOTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlSW50ZWdlciB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9pbnRlZ2VyJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlSW50ZWdlciBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyIHtcbiAgZ2V0U291cmNlKHZhbHVlKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgcmV0dXJuIGBjb25zdCAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGludCAke3RoaXMuaWR9ID0gJHsgcGFyc2VJbnQodmFsdWUpIH07XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaW50ICR7dGhpcy5pZH07XFxuYDtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUludGVnZXJcbn07XG59LHtcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvaW50ZWdlclwiOjU3fV0sOTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB7IGlkLCBzaXplSWQsIHRleHR1cmVTaXplLCBkaW1lbnNpb25zSWQsIGRpbWVuc2lvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7aWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7c2l6ZUlkfSA9IGl2ZWMyKCR7dGV4dHVyZVNpemVbMF19LCAke3RleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHtkaW1lbnNpb25zSWR9ID0gaXZlYzMoJHtkaW1lbnNpb25zWzBdfSwgJHtkaW1lbnNpb25zWzFdfSwgJHtkaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmVcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlXCI6NTh9XSw5NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9udW1iZXItdGV4dHVyZScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB7IGlkLCBzaXplSWQsIHRleHR1cmVTaXplLCBkaW1lbnNpb25zSWQsIGRpbWVuc2lvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHtpZH1gLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHtzaXplSWR9ID0gaXZlYzIoJHt0ZXh0dXJlU2l6ZVswXX0sICR7dGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke2RpbWVuc2lvbnNJZH0gPSBpdmVjMygke2RpbWVuc2lvbnNbMF19LCAke2RpbWVuc2lvbnNbMV19LCAke2RpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL251bWJlci10ZXh0dXJlXCI6NTl9XSw5NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuVG8odmFsdWUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEzMkYsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXlcIjo2MH1dLDk2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkxZC1pJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkge1xuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW5Ubyh2YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQTMyRiwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWlcIjo2MX1dLDk3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MiB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MiB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJcbn07XG59LHtcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MlwiOjYyfV0sOTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSB7XG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MmQtaVwiOjYzfV0sOTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTMnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTMgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzIHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M1xufTtcbn0se1wiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzXCI6NjR9XSwxMDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSB7XG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M2QtaVwiOjY1fV0sMTAxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5NCB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXk0Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXk0IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5NCB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTRcbn07XG59LHtcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5NFwiOjY2fV0sMTAyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dCB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtaW5wdXQnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dCB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKGlucHV0LnZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUlucHV0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWlucHV0XCI6Njd9XSwxMDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvdW5zaWduZWQtYXJyYXknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1hcnJheVwiOjY4fV0sMTA0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3Vuc2lnbmVkLWlucHV0Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZElucHV0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvdW5zaWduZWQtaW5wdXRcIjo2OX1dLDEwNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsIH0gPSByZXF1aXJlKCcuLi93ZWItZ2wva2VybmVsJyk7XG5jb25zdCB7IFdlYkdMMkZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi1ub2RlJyk7XG5jb25zdCB7IEZ1bmN0aW9uQnVpbGRlciB9ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tYnVpbGRlcicpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgZnJhZ21lbnRTaGFkZXIgfSA9IHJlcXVpcmUoJy4vZnJhZ21lbnQtc2hhZGVyJyk7XG5jb25zdCB7IHZlcnRleFNoYWRlciB9ID0gcmVxdWlyZSgnLi92ZXJ0ZXgtc2hhZGVyJyk7XG5jb25zdCB7IGxvb2t1cEtlcm5lbFZhbHVlVHlwZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUtbWFwcycpO1xuXG5sZXQgaXNTdXBwb3J0ZWQgPSBudWxsO1xubGV0IHRlc3RDYW52YXMgPSBudWxsO1xubGV0IHRlc3RDb250ZXh0ID0gbnVsbDtcbmxldCB0ZXN0RXh0ZW5zaW9ucyA9IG51bGw7XG5cbmxldCBmZWF0dXJlcyA9IG51bGw7XG5cbmNsYXNzIFdlYkdMMktlcm5lbCBleHRlbmRzIFdlYkdMS2VybmVsIHtcbiAgc3RhdGljIGdldCBpc1N1cHBvcnRlZCgpIHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgICB9XG4gICAgdGhpcy5zZXR1cEZlYXR1cmVDaGVja3MoKTtcbiAgICBpc1N1cHBvcnRlZCA9IHRoaXMuaXNDb250ZXh0TWF0Y2godGVzdENvbnRleHQpO1xuICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHN0YXRpYyBzZXR1cEZlYXR1cmVDaGVja3MoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRlc3RDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0ZXN0Q2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygwLCAwKTtcbiAgICB9XG4gICAgaWYgKCF0ZXN0Q2FudmFzKSByZXR1cm47XG4gICAgdGVzdENvbnRleHQgPSB0ZXN0Q2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicpO1xuICAgIGlmICghdGVzdENvbnRleHQgfHwgIXRlc3RDb250ZXh0LmdldEV4dGVuc2lvbikgcmV0dXJuO1xuICAgIHRlc3RFeHRlbnNpb25zID0ge1xuICAgICAgRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdDogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JyksXG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXI6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyksXG4gICAgfTtcbiAgICBmZWF0dXJlcyA9IHRoaXMuZ2V0RmVhdHVyZXMoKTtcbiAgfVxuXG4gIHN0YXRpYyBpc0NvbnRleHRNYXRjaChjb250ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGNvbnRleHQgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgZ2V0RmVhdHVyZXMoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLnRlc3RDb250ZXh0O1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgIGlzRmxvYXRSZWFkOiB0aGlzLmdldElzRmxvYXRSZWFkKCksXG4gICAgICBpc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlOiB0aGlzLmdldElzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUoKSxcbiAgICAgIGlzU3BlZWRUYWN0aWNTdXBwb3J0ZWQ6IHRoaXMuZ2V0SXNTcGVlZFRhY3RpY1N1cHBvcnRlZCgpLFxuICAgICAga2VybmVsTWFwOiB0cnVlLFxuICAgICAgaXNUZXh0dXJlRmxvYXQ6IHRydWUsXG4gICAgICBpc0RyYXdCdWZmZXJzOiB0cnVlLFxuICAgICAgY2hhbm5lbENvdW50OiB0aGlzLmdldENoYW5uZWxDb3VudCgpLFxuICAgICAgbWF4VGV4dHVyZVNpemU6IHRoaXMuZ2V0TWF4VGV4dHVyZVNpemUoKSxcbiAgICAgIGxvd0ludFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTE9XX0lOVCksXG4gICAgICBsb3dGbG9hdFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTE9XX0ZMT0FUKSxcbiAgICAgIG1lZGl1bUludFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0lOVCksXG4gICAgICBtZWRpdW1GbG9hdFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUKSxcbiAgICAgIGhpZ2hJbnRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfSU5UKSxcbiAgICAgIGhpZ2hGbG9hdFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCksXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0SXNUZXh0dXJlRmxvYXQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdGF0aWMgZ2V0Q2hhbm5lbENvdW50KCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dC5nZXRQYXJhbWV0ZXIodGVzdENvbnRleHQuTUFYX0RSQVdfQlVGRkVSUyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0TWF4VGV4dHVyZVNpemUoKSB7XG4gICAgcmV0dXJuIHRlc3RDb250ZXh0LmdldFBhcmFtZXRlcih0ZXN0Q29udGV4dC5NQVhfVEVYVFVSRV9TSVpFKTtcbiAgfVxuXG4gIHN0YXRpYyBsb29rdXBLZXJuZWxWYWx1ZVR5cGUodHlwZSwgZHluYW1pYywgcHJlY2lzaW9uLCB2YWx1ZSkge1xuICAgIHJldHVybiBsb29rdXBLZXJuZWxWYWx1ZVR5cGUodHlwZSwgZHluYW1pYywgcHJlY2lzaW9uLCB2YWx1ZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlc3RDYW52YXMoKSB7XG4gICAgcmV0dXJuIHRlc3RDYW52YXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlc3RDb250ZXh0KCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgc3RhdGljIGdldCBmcmFnbWVudFNoYWRlcigpIHtcbiAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gIH1cbiAgc3RhdGljIGdldCB2ZXJ0ZXhTaGFkZXIoKSB7XG4gICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgfVxuXG4gIGluaXRDb250ZXh0KCkge1xuICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgYWxwaGE6IGZhbHNlLFxuICAgICAgZGVwdGg6IGZhbHNlLFxuICAgICAgYW50aWFsaWFzOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIHNldHRpbmdzKTtcbiAgfVxuXG4gIGluaXRFeHRlbnNpb25zKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHtcbiAgICAgIEVYVF9jb2xvcl9idWZmZXJfZmxvYXQ6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKSxcbiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcjogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyksXG4gICAgfTtcbiAgfVxuXG4gIHZhbGlkYXRlU2V0dGluZ3MoYXJncykge1xuICAgIGlmICghdGhpcy52YWxpZGF0ZSkge1xuICAgICAgdGhpcy50ZXhTaXplID0gdXRpbHMuZ2V0S2VybmVsVGV4dHVyZVNpemUoe1xuICAgICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICAgIHByZWNpc2lvbjogdGhpcy5wcmVjaXNpb24sXG4gICAgICB9LCB0aGlzLm91dHB1dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBmZWF0dXJlcyB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnICYmICFmZWF0dXJlcy5pc0Zsb2F0UmVhZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbG9hdCB0ZXh0dXJlIG91dHB1dHMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmdyYXBoaWNhbCAmJiB0aGlzLnByZWNpc2lvbiA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5wcmVjaXNpb24gPSBmZWF0dXJlcy5pc0Zsb2F0UmVhZCA/ICdzaW5nbGUnIDogJ3Vuc2lnbmVkJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9ICFmZWF0dXJlcy5pc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSAmJiBmZWF0dXJlcy5pc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlKSB7XG4gICAgICB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja091dHB1dCgpO1xuXG4gICAgaWYgKCF0aGlzLm91dHB1dCB8fCB0aGlzLm91dHB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dG8gb3V0cHV0IG9ubHkgc3VwcG9ydGVkIGZvciBrZXJuZWxzIHdpdGggb25seSBvbmUgaW5wdXQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXJnVHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZShhcmdzWzBdLCB0aGlzLnN0cmljdEludGVnZXJzKTtcbiAgICAgIHN3aXRjaCAoYXJnVHlwZSkge1xuICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgdGhpcy5vdXRwdXQgPSB1dGlscy5nZXREaW1lbnNpb25zKGFyZ1R5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdOdW1iZXJUZXh0dXJlJzpcbiAgICAgICAgY2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG4gICAgICAgICAgdGhpcy5vdXRwdXQgPSBhcmdzWzBdLm91dHB1dDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dG8gb3V0cHV0IG5vdCBzdXBwb3J0ZWQgZm9yIGlucHV0IHR5cGU6ICcgKyBhcmdUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcbiAgICAgIGlmICh0aGlzLm91dHB1dC5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdXRwdXQgbXVzdCBoYXZlIDIgZGltZW5zaW9ucyBvbiBncmFwaGljYWwgbW9kZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IHVzZSBncmFwaGljYWwgbW9kZSBhbmQgc2luZ2xlIHByZWNpc2lvbiBhdCB0aGUgc2FtZSB0aW1lJyk7XG4gICAgICAgIHRoaXMucHJlY2lzaW9uID0gJ3Vuc2lnbmVkJztcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXhTaXplID0gdXRpbHMuY2xvbmUodGhpcy5vdXRwdXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZ3JhcGhpY2FsICYmIHRoaXMucHJlY2lzaW9uID09PSBudWxsICYmIGZlYXR1cmVzLmlzVGV4dHVyZUZsb2F0KSB7XG4gICAgICB0aGlzLnByZWNpc2lvbiA9ICdzaW5nbGUnO1xuICAgIH1cblxuICAgIHRoaXMudGV4U2l6ZSA9IHV0aWxzLmdldEtlcm5lbFRleHR1cmVTaXplKHtcbiAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgIHByZWNpc2lvbjogdGhpcy5wcmVjaXNpb24sXG4gICAgfSwgdGhpcy5vdXRwdXQpO1xuXG4gICAgdGhpcy5jaGVja1RleHR1cmVTaXplKCk7XG4gIH1cblxuICB0cmFuc2xhdGVTb3VyY2UoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25CdWlsZGVyID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgV2ViR0wyRnVuY3Rpb25Ob2RlLCB7XG4gICAgICBmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeTogdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeVxuICAgIH0pO1xuICAgIHRoaXMudHJhbnNsYXRlZFNvdXJjZSA9IGZ1bmN0aW9uQnVpbGRlci5nZXRQcm90b3R5cGVTdHJpbmcoJ2tlcm5lbCcpO1xuICAgIHRoaXMuc2V0dXBSZXR1cm5UeXBlcyhmdW5jdGlvbkJ1aWxkZXIpO1xuICB9XG5cbiAgZHJhd0J1ZmZlcnMoKSB7XG4gICAgdGhpcy5jb250ZXh0LmRyYXdCdWZmZXJzKHRoaXMuZHJhd0J1ZmZlcnNNYXApO1xuICB9XG5cbiAgZ2V0VGV4dHVyZUZvcm1hdCgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAodGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpKSB7XG4gICAgICBjYXNlIGdsLlIzMkY6XG4gICAgICAgIHJldHVybiBnbC5SRUQ7XG4gICAgICBjYXNlIGdsLlJHMzJGOlxuICAgICAgICByZXR1cm4gZ2wuUkc7XG4gICAgICBjYXNlIGdsLlJHQkEzMkY6XG4gICAgICAgIHJldHVybiBnbC5SR0JBO1xuICAgICAgY2FzZSBnbC5SR0JBOlxuICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbnRlcm5hbCBmb3JtYXQnKTtcbiAgICB9XG4gIH1cbiAgZ2V0SW50ZXJuYWxGb3JtYXQoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcblxuICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIGlmICh0aGlzLnBpcGVsaW5lKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBnbC5SR0JBMzJGO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdsLlIzMkY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgICAgICAgIHJldHVybiBnbC5SRzMyRjtcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5KDMpJzogXG4gICAgICAgICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgICAgICAgIHJldHVybiBnbC5SR0JBMzJGO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmhhbmRsZWQgcmV0dXJuIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdsLlJHQkEzMkY7XG4gICAgfVxuICAgIHJldHVybiBnbC5SR0JBO1xuICB9XG5cbiAgX3NldHVwT3V0cHV0VGV4dHVyZSgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZS50ZXh0dXJlLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGNvbnN0IHRleFNpemUgPSB0aGlzLnRleFNpemU7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRUZXh0dXJlQ291bnQgKyB0aGlzLmFyZ3VtZW50VGV4dHVyZUNvdW50KTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5SRVBFQVQpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLlJFUEVBVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldEludGVybmFsRm9ybWF0KCk7XG4gICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgZ2wudGV4U3RvcmFnZTJEKGdsLlRFWFRVUkVfMkQsIDEsIGZvcm1hdCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBmb3JtYXQsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgIH1cbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgIHRoaXMudGV4dHVyZSA9IG5ldyB0aGlzLlRleHR1cmVDb25zdHJ1Y3Rvcih7XG4gICAgICB0ZXh0dXJlLFxuICAgICAgc2l6ZTogdGV4U2l6ZSxcbiAgICAgIGRpbWVuc2lvbnM6IHRoaXMudGhyZWFkRGltLFxuICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgIGludGVybmFsRm9ybWF0OiB0aGlzLmdldEludGVybmFsRm9ybWF0KCksXG4gICAgICB0ZXh0dXJlRm9ybWF0OiB0aGlzLmdldFRleHR1cmVGb3JtYXQoKSxcbiAgICAgIGtlcm5lbDogdGhpcyxcbiAgICB9KTtcbiAgfVxuXG4gIF9zZXR1cFN1Yk91dHB1dFRleHR1cmVzKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuICAgIGlmICh0aGlzLm1hcHBlZFRleHR1cmVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5tYXBwZWRUZXh0dXJlc1tpXS50ZXh0dXJlLCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZTtcbiAgICB0aGlzLmRyYXdCdWZmZXJzTWFwID0gW2dsLkNPTE9SX0FUVEFDSE1FTlQwXTtcbiAgICB0aGlzLm1hcHBlZFRleHR1cmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIHRoaXMuZHJhd0J1ZmZlcnNNYXAucHVzaChnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkgKyAxKTtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50VGV4dHVyZUNvdW50ICsgdGhpcy5hcmd1bWVudFRleHR1cmVDb3VudCArIGkpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpO1xuICAgICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgICBnbC50ZXhTdG9yYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMSwgZm9ybWF0LCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICB9XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG5cbiAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXMucHVzaChuZXcgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3Ioe1xuICAgICAgICB0ZXh0dXJlLFxuICAgICAgICBzaXplOiB0ZXhTaXplLFxuICAgICAgICBkaW1lbnNpb25zOiB0aGlzLnRocmVhZERpbSxcbiAgICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICBpbnRlcm5hbEZvcm1hdDogdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpLFxuICAgICAgICB0ZXh0dXJlRm9ybWF0OiB0aGlzLmdldFRleHR1cmVGb3JtYXQoKSxcbiAgICAgICAga2VybmVsOiB0aGlzLFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRIZWFkZXJTdHJpbmcoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgX2dldFRleHR1cmVDb29yZGluYXRlKCkge1xuICAgIGNvbnN0IHN1Yktlcm5lbHMgPSB0aGlzLnN1Yktlcm5lbHM7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4U2l6ZSwgdGhpcy50YWN0aWMpO1xuICAgIGlmIChzdWJLZXJuZWxzID09PSBudWxsIHx8IHN1Yktlcm5lbHMubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuIGBpbiAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHZlYzIgdlRleENvb3JkO1xcbmA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgb3V0ICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gdmVjMiB2VGV4Q29vcmQ7XFxuYDtcbiAgICB9XG4gIH1cblxuICBfZ2V0TWFpbkFyZ3VtZW50c1N0cmluZyhhcmdzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgYXJndW1lbnROYW1lcyA9IHRoaXMuYXJndW1lbnROYW1lcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKHRoaXMua2VybmVsQXJndW1lbnRzW2ldLmdldFNvdXJjZShhcmdzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gIH1cblxuICBnZXRLZXJuZWxTdHJpbmcoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW3RoaXMuZ2V0S2VybmVsUmVzdWx0RGVjbGFyYXRpb24oKV07XG4gICAgY29uc3Qgc3ViS2VybmVscyA9IHRoaXMuc3ViS2VybmVscztcbiAgICBpZiAoc3ViS2VybmVscyAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICdsYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgdmVjNCBkYXRhMCdcbiAgICAgICk7XG4gICAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3ViS2VybmVsID0gc3ViS2VybmVsc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInID9cbiAgICAgICAgICAgICAgYGludCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IDBgIDpcbiAgICAgICAgICAgICAgYGZsb2F0IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gMC4wYCxcbiAgICAgICAgICAgICAgYGxheW91dChsb2NhdGlvbiA9ICR7IGkgKyAxIH0pIG91dCB2ZWM0IGRhdGEkeyBpICsgMSB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBgdmVjMiBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsc1tpXS5uYW1lIH1gLFxuICAgICAgICAgICAgICBgbGF5b3V0KGxvY2F0aW9uID0gJHsgaSArIDEgfSkgb3V0IHZlYzQgZGF0YSR7IGkgKyAxIH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIGB2ZWMzIHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWxzW2ldLm5hbWUgfWAsXG4gICAgICAgICAgICAgIGBsYXlvdXQobG9jYXRpb24gPSAkeyBpICsgMSB9KSBvdXQgdmVjNCBkYXRhJHsgaSArIDEgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYHZlYzQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbHNbaV0ubmFtZSB9YCxcbiAgICAgICAgICAgICAgYGxheW91dChsb2NhdGlvbiA9ICR7IGkgKyAxIH0pIG91dCB2ZWM0IGRhdGEkeyBpICsgMSB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAnb3V0IHZlYzQgZGF0YTAnXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHJlc3VsdCkgKyB0aGlzLnRyYW5zbGF0ZWRTb3VyY2U7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0R3JhcGhpY2FsKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBkYXRhMCA9IGFjdHVhbENvbG9yJyxcbiAgICBdKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRQYWNrZWRQaXhlbHMoKSB7XG4gICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEtlcm5lbFBhY2tlZFBpeGVscygpICtcbiAgICAgICAgICB0aGlzLmdldE1haW5SZXN1bHRTdWJLZXJuZWxQYWNrZWRQaXhlbHMoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFja2VkIG91dHB1dCBvbmx5IHVzYWJsZSB3aXRoIE51bWJlcnMsIFwiJHt0aGlzLnJldHVyblR5cGV9XCIgc3BlY2lmaWVkYCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbFBhY2tlZFBpeGVscygpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgYCAgZGF0YTAgPSAke3RoaXMudXNlTGVnYWN5RW5jb2RlciA/ICdsZWdhY3lFbmNvZGUzMicgOiAnZW5jb2RlMzInfShrZXJuZWxSZXN1bHQpYFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbFBhY2tlZFBpeGVscygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJLZXJuZWwgPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICBpZiAoc3ViS2VybmVsLnJldHVyblR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBkYXRhJHtpICsgMX0gPSAke3RoaXMudXNlTGVnYWN5RW5jb2RlciA/ICdsZWdhY3lFbmNvZGUzMicgOiAnZW5jb2RlMzInfShmbG9hdChzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX0pKWBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGRhdGEke2kgKyAxfSA9ICR7dGhpcy51c2VMZWdhY3lFbmNvZGVyID8gJ2xlZ2FjeUVuY29kZTMyJyA6ICdlbmNvZGUzMid9KHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfSlgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHJlc3VsdCk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCkge1xuICAgIHJlc3VsdC5wdXNoKFxuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgIGAgIGRhdGEwLiR7Y2hhbm5lbH0gPSBrZXJuZWxSZXN1bHRgLFxuICAgICk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCkge1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJLZXJuZWwgPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICBpZiAoc3ViS2VybmVsLnJldHVyblR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBkYXRhJHtpICsgMX0uJHtjaGFubmVsfSA9IGZsb2F0KHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfSlgLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZGF0YSR7aSArIDF9LiR7Y2hhbm5lbH0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxOdW1iZXJUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZGF0YTBbMF0gPSBrZXJuZWxSZXN1bHQnLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsTnVtYmVyVGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgaWYgKHN1Yktlcm5lbC5yZXR1cm5UeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZGF0YSR7aSArIDF9WzBdID0gZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9KWAsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBkYXRhJHtpICsgMX1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5MlRleHR1cmUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBkYXRhMFswXSA9IGtlcm5lbFJlc3VsdFswXScsXG4gICAgICAnICBkYXRhMFsxXSA9IGtlcm5lbFJlc3VsdFsxXScsXG4gICAgXTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTJUZXh0dXJlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBzdWJLZXJuZWwgPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgYCAgZGF0YSR7aSArIDF9WzBdID0gc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9WzBdYCxcbiAgICAgICAgYCAgZGF0YSR7aSArIDF9WzFdID0gc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9WzFdYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkzVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgICcgIGRhdGEwWzBdID0ga2VybmVsUmVzdWx0WzBdJyxcbiAgICAgICcgIGRhdGEwWzFdID0ga2VybmVsUmVzdWx0WzFdJyxcbiAgICAgICcgIGRhdGEwWzJdID0ga2VybmVsUmVzdWx0WzJdJyxcbiAgICBdO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5M1RleHR1cmUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICBgICBkYXRhJHtpICsgMX1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1bMF1gLFxuICAgICAgICBgICBkYXRhJHtpICsgMX1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1bMV1gLFxuICAgICAgICBgICBkYXRhJHtpICsgMX1bMl0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1bMl1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZGF0YTAgPSBrZXJuZWxSZXN1bHQnLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXk0VGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgIGAgIGRhdGEke2kgKyAxfSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfWAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZGVzdHJveUV4dGVuc2lvbnMoKSB7XG4gICAgdGhpcy5leHRlbnNpb25zLkVYVF9jb2xvcl9idWZmZXJfZmxvYXQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIgPSBudWxsO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGpzb24gPSBzdXBlci50b0pTT04oKTtcbiAgICBqc29uLmZ1bmN0aW9uTm9kZXMgPSBGdW5jdGlvbkJ1aWxkZXIuZnJvbUtlcm5lbCh0aGlzLCBXZWJHTDJGdW5jdGlvbk5vZGUpLnRvSlNPTigpO1xuICAgIGpzb24uc2V0dGluZ3MudGhyZWFkRGltID0gdGhpcy50aHJlYWREaW07XG4gICAgcmV0dXJuIGpzb247XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFxufTtcbn0se1wiLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi9mdW5jdGlvbi1idWlsZGVyXCI6OSxcIi4uL3dlYi1nbC9rZXJuZWxcIjo3MCxcIi4vZnJhZ21lbnQtc2hhZGVyXCI6NzIsXCIuL2Z1bmN0aW9uLW5vZGVcIjo3MyxcIi4va2VybmVsLXZhbHVlLW1hcHNcIjo3NCxcIi4vdmVydGV4LXNoYWRlclwiOjEwNn1dLDEwNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB2ZXJ0ZXhTaGFkZXIgPSBgI3ZlcnNpb24gMzAwIGVzXG5fX0ZMT0FUX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuX19JTlRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX1NBTVBMRVJfMkRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5cbmluIHZlYzIgYVBvcztcbmluIHZlYzIgYVRleENvb3JkO1xuXG5vdXQgdmVjMiB2VGV4Q29vcmQ7XG51bmlmb3JtIHZlYzIgcmF0aW87XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgoYVBvcyArIHZlYzIoMSkpICogcmF0aW8gKyB2ZWMyKC0xKSwgMCwgMSk7XG4gIHZUZXhDb29yZCA9IGFUZXhDb29yZDtcbn1gO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmVydGV4U2hhZGVyXG59O1xufSx7fV0sMTA3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IGxpYiA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcbmNvbnN0IEdQVSA9IGxpYi5HUFU7XG5mb3IgKGNvbnN0IHAgaW4gbGliKSB7XG4gIGlmICghbGliLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgaWYgKHAgPT09ICdHUFUnKSBjb250aW51ZTsgXG4gIEdQVVtwXSA9IGxpYltwXTtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGJpbmRUbyh3aW5kb3cpO1xufVxuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICBiaW5kVG8oc2VsZik7XG59XG5cbmZ1bmN0aW9uIGJpbmRUbyh0YXJnZXQpIHtcbiAgaWYgKHRhcmdldC5HUFUpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgJ0dQVScsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gR1BVO1xuICAgIH1cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGliO1xufSx7XCIuL2luZGV4XCI6MTA5fV0sMTA4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgZ3B1TW9jayB9ID0gcmVxdWlyZSgnZ3B1LW1vY2suanMnKTtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHsgS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQva2VybmVsJyk7XG5jb25zdCB7IENQVUtlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2NwdS9rZXJuZWwnKTtcbmNvbnN0IHsgSGVhZGxlc3NHTEtlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2hlYWRsZXNzLWdsL2tlcm5lbCcpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wyL2tlcm5lbCcpO1xuY29uc3QgeyBXZWJHTEtlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL3dlYi1nbC9rZXJuZWwnKTtcbmNvbnN0IHsga2VybmVsUnVuU2hvcnRjdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXJ1bi1zaG9ydGN1dCcpO1xuXG5cbmNvbnN0IGtlcm5lbE9yZGVyID0gW0hlYWRsZXNzR0xLZXJuZWwsIFdlYkdMMktlcm5lbCwgV2ViR0xLZXJuZWxdO1xuXG5jb25zdCBrZXJuZWxUeXBlcyA9IFsnZ3B1JywgJ2NwdSddO1xuXG5jb25zdCBpbnRlcm5hbEtlcm5lbHMgPSB7XG4gICdoZWFkbGVzc2dsJzogSGVhZGxlc3NHTEtlcm5lbCxcbiAgJ3dlYmdsMic6IFdlYkdMMktlcm5lbCxcbiAgJ3dlYmdsJzogV2ViR0xLZXJuZWwsXG59O1xuXG5sZXQgdmFsaWRhdGUgPSB0cnVlO1xuXG5jbGFzcyBHUFUge1xuICBzdGF0aWMgZGlzYWJsZVZhbGlkYXRpb24oKSB7XG4gICAgdmFsaWRhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBlbmFibGVWYWxpZGF0aW9uKCkge1xuICAgIHZhbGlkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgaXNHUFVTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGtlcm5lbE9yZGVyLnNvbWUoS2VybmVsID0+IEtlcm5lbC5pc1N1cHBvcnRlZCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzS2VybmVsTWFwU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBrZXJuZWxPcmRlci5zb21lKEtlcm5lbCA9PiBLZXJuZWwuaXNTdXBwb3J0ZWQgJiYgS2VybmVsLmZlYXR1cmVzLmtlcm5lbE1hcCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAodHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcpIHx8IHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgaXNXZWJHTFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gV2ViR0xLZXJuZWwuaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzV2ViR0wyU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBXZWJHTDJLZXJuZWwuaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzSGVhZGxlc3NHTFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gSGVhZGxlc3NHTEtlcm5lbC5pc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgaXNDYW52YXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzR1BVSFRNTEltYWdlQXJyYXlTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIFdlYkdMMktlcm5lbC5pc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgaXNTaW5nbGVQcmVjaXNpb25TdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGtlcm5lbE9yZGVyLnNvbWUoS2VybmVsID0+IEtlcm5lbC5pc1N1cHBvcnRlZCAmJiBLZXJuZWwuZmVhdHVyZXMuaXNGbG9hdFJlYWQgJiYgS2VybmVsLmZlYXR1cmVzLmlzVGV4dHVyZUZsb2F0KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICB0aGlzLmNhbnZhcyA9IHNldHRpbmdzLmNhbnZhcyB8fCBudWxsO1xuICAgIHRoaXMuY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHQgfHwgbnVsbDtcbiAgICB0aGlzLm1vZGUgPSBzZXR0aW5ncy5tb2RlO1xuICAgIHRoaXMuS2VybmVsID0gbnVsbDtcbiAgICB0aGlzLmtlcm5lbHMgPSBbXTtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICAgIHRoaXMubmF0aXZlRnVuY3Rpb25zID0gW107XG4gICAgdGhpcy5pbmplY3RlZE5hdGl2ZSA9IG51bGw7XG4gICAgdGhpcy5vbklzdGFuYnVsQ292ZXJhZ2VWYXJpYWJsZSA9IHNldHRpbmdzLm9uSXN0YW5idWxDb3ZlcmFnZVZhcmlhYmxlIHx8IG51bGw7XG4gICAgdGhpcy5yZW1vdmVJc3RhbmJ1bENvdmVyYWdlID0gc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ3JlbW92ZUlzdGFuYnVsQ292ZXJhZ2UnKSA/IHNldHRpbmdzLnJlbW92ZUlzdGFuYnVsQ292ZXJhZ2UgOiBudWxsO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdkZXYnKSByZXR1cm47XG4gICAgdGhpcy5jaG9vc2VLZXJuZWwoKTtcbiAgICBpZiAoc2V0dGluZ3MuZnVuY3Rpb25zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLmZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZEZ1bmN0aW9uKHNldHRpbmdzLmZ1bmN0aW9uc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLm5hdGl2ZUZ1bmN0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBwIGluIHNldHRpbmdzLm5hdGl2ZUZ1bmN0aW9ucykge1xuICAgICAgICBpZiAoIXNldHRpbmdzLm5hdGl2ZUZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IHMgPSBzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnNbcF07XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgc291cmNlIH0gPSBzO1xuICAgICAgICB0aGlzLmFkZE5hdGl2ZUZ1bmN0aW9uKG5hbWUsIHNvdXJjZSwgcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2hvb3NlS2VybmVsKCkge1xuICAgIGlmICh0aGlzLktlcm5lbCkgcmV0dXJuO1xuXG4gICAgbGV0IEtlcm5lbCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbE9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEV4dGVybmFsS2VybmVsID0ga2VybmVsT3JkZXJbaV07XG4gICAgICAgIGlmIChFeHRlcm5hbEtlcm5lbC5pc0NvbnRleHRNYXRjaCh0aGlzLmNvbnRleHQpKSB7XG4gICAgICAgICAgaWYgKCFFeHRlcm5hbEtlcm5lbC5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgdHlwZSAke0V4dGVybmFsS2VybmVsLm5hbWV9IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgS2VybmVsID0gRXh0ZXJuYWxLZXJuZWw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChLZXJuZWwgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIENvbnRleHQnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSkge1xuICAgICAgaWYgKHRoaXMubW9kZSBpbiBpbnRlcm5hbEtlcm5lbHMpIHtcbiAgICAgICAgaWYgKCF2YWxpZGF0ZSB8fCBpbnRlcm5hbEtlcm5lbHNbdGhpcy5tb2RlXS5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgIEtlcm5lbCA9IGludGVybmFsS2VybmVsc1t0aGlzLm1vZGVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2dwdScpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChrZXJuZWxPcmRlcltpXS5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgS2VybmVsID0ga2VybmVsT3JkZXJbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSAnY3B1Jykge1xuICAgICAgICBLZXJuZWwgPSBDUFVLZXJuZWw7XG4gICAgICB9XG4gICAgICBpZiAoIUtlcm5lbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgcmVxdWVzdGVkIG1vZGUgb2YgXCIke3RoaXMubW9kZX1cIiBhbmQgaXMgbm90IHN1cHBvcnRlZGApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbE9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChrZXJuZWxPcmRlcltpXS5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgIEtlcm5lbCA9IGtlcm5lbE9yZGVyW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIUtlcm5lbCkge1xuICAgICAgICBLZXJuZWwgPSBDUFVLZXJuZWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm1vZGUpIHtcbiAgICAgIHRoaXMubW9kZSA9IEtlcm5lbC5tb2RlO1xuICAgIH1cbiAgICB0aGlzLktlcm5lbCA9IEtlcm5lbDtcbiAgfVxuXG4gIGNyZWF0ZUtlcm5lbChzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc291cmNlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcgJiYgIXV0aWxzLmlzRnVuY3Rpb24oc291cmNlKSAmJiB0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgcGFyYW1ldGVyIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3Qga2VybmVscyA9IHRoaXMua2VybmVscztcbiAgICBpZiAodGhpcy5tb2RlID09PSAnZGV2Jykge1xuICAgICAgY29uc3QgZGV2S2VybmVsID0gZ3B1TW9jayhzb3VyY2UsIHVwZ3JhZGVEZXByZWNhdGVkQ3JlYXRlS2VybmVsU2V0dGluZ3Moc2V0dGluZ3MpKTtcbiAgICAgIGtlcm5lbHMucHVzaChkZXZLZXJuZWwpO1xuICAgICAgcmV0dXJuIGRldktlcm5lbDtcbiAgICB9XG5cbiAgICBzb3VyY2UgPSB0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nID8gc291cmNlLnRvU3RyaW5nKCkgOiBzb3VyY2U7XG4gICAgY29uc3Qgc3dpdGNoYWJsZUtlcm5lbHMgPSB7fTtcbiAgICBjb25zdCBzZXR0aW5nc0NvcHkgPSB1cGdyYWRlRGVwcmVjYXRlZENyZWF0ZUtlcm5lbFNldHRpbmdzKHNldHRpbmdzKSB8fCB7fTtcbiAgICBpZiAoc2V0dGluZ3MgJiYgdHlwZW9mIHNldHRpbmdzLmFyZ3VtZW50VHlwZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBzZXR0aW5nc0NvcHkuYXJndW1lbnRUeXBlcyA9IE9iamVjdC5rZXlzKHNldHRpbmdzLmFyZ3VtZW50VHlwZXMpLm1hcChhcmd1bWVudE5hbWUgPT4gc2V0dGluZ3MuYXJndW1lbnRUeXBlc1thcmd1bWVudE5hbWVdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblJlcXVlc3RGYWxsYmFjayhhcmdzKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhbGxpbmcgYmFjayB0byBDUFUnKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrS2VybmVsID0gbmV3IENQVUtlcm5lbChzb3VyY2UsIHtcbiAgICAgICAgYXJndW1lbnRUeXBlczoga2VybmVsUnVuLmFyZ3VtZW50VHlwZXMsXG4gICAgICAgIGNvbnN0YW50VHlwZXM6IGtlcm5lbFJ1bi5jb25zdGFudFR5cGVzLFxuICAgICAgICBncmFwaGljYWw6IGtlcm5lbFJ1bi5ncmFwaGljYWwsXG4gICAgICAgIGxvb3BNYXhJdGVyYXRpb25zOiBrZXJuZWxSdW4ubG9vcE1heEl0ZXJhdGlvbnMsXG4gICAgICAgIGNvbnN0YW50czoga2VybmVsUnVuLmNvbnN0YW50cyxcbiAgICAgICAgZHluYW1pY091dHB1dDoga2VybmVsUnVuLmR5bmFtaWNPdXRwdXQsXG4gICAgICAgIGR5bmFtaWNBcmd1bWVudDoga2VybmVsUnVuLmR5bmFtaWNBcmd1bWVudHMsXG4gICAgICAgIG91dHB1dDoga2VybmVsUnVuLm91dHB1dCxcbiAgICAgICAgcHJlY2lzaW9uOiBrZXJuZWxSdW4ucHJlY2lzaW9uLFxuICAgICAgICBwaXBlbGluZToga2VybmVsUnVuLnBpcGVsaW5lLFxuICAgICAgICBpbW11dGFibGU6IGtlcm5lbFJ1bi5pbW11dGFibGUsXG4gICAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IGtlcm5lbFJ1bi5vcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgICAgICBmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeToga2VybmVsUnVuLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5LFxuICAgICAgICBmdW5jdGlvbnM6IGtlcm5lbFJ1bi5mdW5jdGlvbnMsXG4gICAgICAgIG5hdGl2ZUZ1bmN0aW9uczoga2VybmVsUnVuLm5hdGl2ZUZ1bmN0aW9ucyxcbiAgICAgICAgaW5qZWN0ZWROYXRpdmU6IGtlcm5lbFJ1bi5pbmplY3RlZE5hdGl2ZSxcbiAgICAgICAgc3ViS2VybmVsczoga2VybmVsUnVuLnN1Yktlcm5lbHMsXG4gICAgICAgIHN0cmljdEludGVnZXJzOiBrZXJuZWxSdW4uc3RyaWN0SW50ZWdlcnMsXG4gICAgICAgIGRlYnVnOiBrZXJuZWxSdW4uZGVidWcsXG4gICAgICB9KTtcbiAgICAgIGZhbGxiYWNrS2VybmVsLmJ1aWxkLmFwcGx5KGZhbGxiYWNrS2VybmVsLCBhcmdzKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZhbGxiYWNrS2VybmVsLnJ1bi5hcHBseShmYWxsYmFja0tlcm5lbCwgYXJncyk7XG4gICAgICBrZXJuZWxSdW4ucmVwbGFjZUtlcm5lbChmYWxsYmFja0tlcm5lbCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUmVxdWVzdFN3aXRjaEtlcm5lbChyZWFzb25zLCBhcmdzLCBfa2VybmVsKSB7XG4gICAgICBpZiAoX2tlcm5lbC5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1N3aXRjaGluZyBrZXJuZWxzJyk7XG4gICAgICB9XG4gICAgICBsZXQgbmV3T3V0cHV0ID0gbnVsbDtcbiAgICAgIGlmIChfa2VybmVsLnNpZ25hdHVyZSAmJiAhc3dpdGNoYWJsZUtlcm5lbHNbX2tlcm5lbC5zaWduYXR1cmVdKSB7XG4gICAgICAgIHN3aXRjaGFibGVLZXJuZWxzW19rZXJuZWwuc2lnbmF0dXJlXSA9IF9rZXJuZWw7XG4gICAgICB9XG4gICAgICBpZiAoX2tlcm5lbC5keW5hbWljT3V0cHV0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSByZWFzb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgcmVhc29uID0gcmVhc29uc1tpXTtcbiAgICAgICAgICBpZiAocmVhc29uLnR5cGUgPT09ICdvdXRwdXRQcmVjaXNpb25NaXNtYXRjaCcpIHtcbiAgICAgICAgICAgIG5ld091dHB1dCA9IHJlYXNvbi5uZWVkZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IENvbnN0cnVjdG9yID0gX2tlcm5lbC5jb25zdHJ1Y3RvcjtcbiAgICAgIGNvbnN0IGFyZ3VtZW50VHlwZXMgPSBDb25zdHJ1Y3Rvci5nZXRBcmd1bWVudFR5cGVzKF9rZXJuZWwsIGFyZ3MpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gQ29uc3RydWN0b3IuZ2V0U2lnbmF0dXJlKF9rZXJuZWwsIGFyZ3VtZW50VHlwZXMpO1xuICAgICAgY29uc3QgZXhpc3RpbmdLZXJuZWwgPSBzd2l0Y2hhYmxlS2VybmVsc1tzaWduYXR1cmVdO1xuICAgICAgaWYgKGV4aXN0aW5nS2VybmVsKSB7XG4gICAgICAgIGV4aXN0aW5nS2VybmVsLm9uQWN0aXZhdGUoX2tlcm5lbCk7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0tlcm5lbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3S2VybmVsID0gc3dpdGNoYWJsZUtlcm5lbHNbc2lnbmF0dXJlXSA9IG5ldyBDb25zdHJ1Y3Rvcihzb3VyY2UsIHtcbiAgICAgICAgYXJndW1lbnRUeXBlcyxcbiAgICAgICAgY29uc3RhbnRUeXBlczogX2tlcm5lbC5jb25zdGFudFR5cGVzLFxuICAgICAgICBncmFwaGljYWw6IF9rZXJuZWwuZ3JhcGhpY2FsLFxuICAgICAgICBsb29wTWF4SXRlcmF0aW9uczogX2tlcm5lbC5sb29wTWF4SXRlcmF0aW9ucyxcbiAgICAgICAgY29uc3RhbnRzOiBfa2VybmVsLmNvbnN0YW50cyxcbiAgICAgICAgZHluYW1pY091dHB1dDogX2tlcm5lbC5keW5hbWljT3V0cHV0LFxuICAgICAgICBkeW5hbWljQXJndW1lbnQ6IF9rZXJuZWwuZHluYW1pY0FyZ3VtZW50cyxcbiAgICAgICAgY29udGV4dDogX2tlcm5lbC5jb250ZXh0LFxuICAgICAgICBjYW52YXM6IF9rZXJuZWwuY2FudmFzLFxuICAgICAgICBvdXRwdXQ6IG5ld091dHB1dCB8fCBfa2VybmVsLm91dHB1dCxcbiAgICAgICAgcHJlY2lzaW9uOiBfa2VybmVsLnByZWNpc2lvbixcbiAgICAgICAgcGlwZWxpbmU6IF9rZXJuZWwucGlwZWxpbmUsXG4gICAgICAgIGltbXV0YWJsZTogX2tlcm5lbC5pbW11dGFibGUsXG4gICAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IF9rZXJuZWwub3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgICAgZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3k6IF9rZXJuZWwuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3ksXG4gICAgICAgIGZ1bmN0aW9uczogX2tlcm5lbC5mdW5jdGlvbnMsXG4gICAgICAgIG5hdGl2ZUZ1bmN0aW9uczogX2tlcm5lbC5uYXRpdmVGdW5jdGlvbnMsXG4gICAgICAgIGluamVjdGVkTmF0aXZlOiBfa2VybmVsLmluamVjdGVkTmF0aXZlLFxuICAgICAgICBzdWJLZXJuZWxzOiBfa2VybmVsLnN1Yktlcm5lbHMsXG4gICAgICAgIHN0cmljdEludGVnZXJzOiBfa2VybmVsLnN0cmljdEludGVnZXJzLFxuICAgICAgICBkZWJ1ZzogX2tlcm5lbC5kZWJ1ZyxcbiAgICAgICAgZ3B1OiBfa2VybmVsLmdwdSxcbiAgICAgICAgdmFsaWRhdGUsXG4gICAgICAgIHJldHVyblR5cGU6IF9rZXJuZWwucmV0dXJuVHlwZSxcbiAgICAgICAgb25Jc3RhbmJ1bENvdmVyYWdlVmFyaWFibGU6IF9rZXJuZWwub25Jc3RhbmJ1bENvdmVyYWdlVmFyaWFibGUsXG4gICAgICAgIHJlbW92ZUlzdGFuYnVsQ292ZXJhZ2U6IF9rZXJuZWwucmVtb3ZlSXN0YW5idWxDb3ZlcmFnZSxcbiAgICAgICAgdGFjdGljOiBfa2VybmVsLnRhY3RpYyxcbiAgICAgICAgb25SZXF1ZXN0RmFsbGJhY2ssXG4gICAgICAgIG9uUmVxdWVzdFN3aXRjaEtlcm5lbCxcbiAgICAgICAgdGV4dHVyZTogX2tlcm5lbC50ZXh0dXJlLFxuICAgICAgICBtYXBwZWRUZXh0dXJlczogX2tlcm5lbC5tYXBwZWRUZXh0dXJlcyxcbiAgICAgICAgZHJhd0J1ZmZlcnNNYXA6IF9rZXJuZWwuZHJhd0J1ZmZlcnNNYXAsXG4gICAgICB9KTtcbiAgICAgIG5ld0tlcm5lbC5idWlsZC5hcHBseShuZXdLZXJuZWwsIGFyZ3MpO1xuICAgICAga2VybmVsUnVuLnJlcGxhY2VLZXJuZWwobmV3S2VybmVsKTtcbiAgICAgIGtlcm5lbHMucHVzaChuZXdLZXJuZWwpO1xuICAgICAgcmV0dXJuIG5ld0tlcm5lbDtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkU2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgIGNhbnZhczogdGhpcy5jYW52YXMsXG4gICAgICBmdW5jdGlvbnM6IHRoaXMuZnVuY3Rpb25zLFxuICAgICAgbmF0aXZlRnVuY3Rpb25zOiB0aGlzLm5hdGl2ZUZ1bmN0aW9ucyxcbiAgICAgIGluamVjdGVkTmF0aXZlOiB0aGlzLmluamVjdGVkTmF0aXZlLFxuICAgICAgb25Jc3RhbmJ1bENvdmVyYWdlVmFyaWFibGU6IHRoaXMub25Jc3RhbmJ1bENvdmVyYWdlVmFyaWFibGUsXG4gICAgICByZW1vdmVJc3RhbmJ1bENvdmVyYWdlOiB0aGlzLnJlbW92ZUlzdGFuYnVsQ292ZXJhZ2UsXG4gICAgICBncHU6IHRoaXMsXG4gICAgICB2YWxpZGF0ZSxcbiAgICAgIG9uUmVxdWVzdEZhbGxiYWNrLFxuICAgICAgb25SZXF1ZXN0U3dpdGNoS2VybmVsXG4gICAgfSwgc2V0dGluZ3NDb3B5KTtcblxuICAgIGNvbnN0IGtlcm5lbCA9IG5ldyB0aGlzLktlcm5lbChzb3VyY2UsIG1lcmdlZFNldHRpbmdzKTtcbiAgICBjb25zdCBrZXJuZWxSdW4gPSBrZXJuZWxSdW5TaG9ydGN1dChrZXJuZWwpO1xuXG4gICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMgPSBrZXJuZWwuY2FudmFzO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250ZXh0KSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBrZXJuZWwuY29udGV4dDtcbiAgICB9XG5cbiAgICBrZXJuZWxzLnB1c2goa2VybmVsKTtcblxuICAgIHJldHVybiBrZXJuZWxSdW47XG4gIH1cblxuICBjcmVhdGVLZXJuZWxNYXAoKSB7XG4gICAgbGV0IGZuO1xuICAgIGxldCBzZXR0aW5ncztcbiAgICBjb25zdCBhcmd1bWVudDJUeXBlID0gdHlwZW9mIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMl07XG4gICAgaWYgKGFyZ3VtZW50MlR5cGUgPT09ICdmdW5jdGlvbicgfHwgYXJndW1lbnQyVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZuID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAyXTtcbiAgICAgIHNldHRpbmdzID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4gPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vZGUgIT09ICdkZXYnKSB7XG4gICAgICBpZiAoIXRoaXMuS2VybmVsLmlzU3VwcG9ydGVkIHx8ICF0aGlzLktlcm5lbC5mZWF0dXJlcy5rZXJuZWxNYXApIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSAmJiBrZXJuZWxUeXBlcy5pbmRleE9mKHRoaXMubW9kZSkgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBrZXJuZWxNYXAgbm90IHN1cHBvcnRlZCBvbiAke3RoaXMuS2VybmVsLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZXR0aW5nc0NvcHkgPSB1cGdyYWRlRGVwcmVjYXRlZENyZWF0ZUtlcm5lbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICBpZiAoc2V0dGluZ3MgJiYgdHlwZW9mIHNldHRpbmdzLmFyZ3VtZW50VHlwZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBzZXR0aW5nc0NvcHkuYXJndW1lbnRUeXBlcyA9IE9iamVjdC5rZXlzKHNldHRpbmdzLmFyZ3VtZW50VHlwZXMpLm1hcChhcmd1bWVudE5hbWUgPT4gc2V0dGluZ3MuYXJndW1lbnRUeXBlc1thcmd1bWVudE5hbWVdKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICBzZXR0aW5nc0NvcHkuc3ViS2VybmVscyA9IFtdO1xuICAgICAgY29uc3QgZnVuY3Rpb25zID0gYXJndW1lbnRzWzBdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gZnVuY3Rpb25zW2ldLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB1dGlscy5nZXRGdW5jdGlvbk5hbWVGcm9tU3RyaW5nKHNvdXJjZSk7XG4gICAgICAgIHNldHRpbmdzQ29weS5zdWJLZXJuZWxzLnB1c2goe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHByb3BlcnR5OiBpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0dGluZ3NDb3B5LnN1Yktlcm5lbHMgPSBbXTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZvciAobGV0IHAgaW4gZnVuY3Rpb25zKSB7XG4gICAgICAgIGlmICghZnVuY3Rpb25zLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gZnVuY3Rpb25zW3BdLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB1dGlscy5nZXRGdW5jdGlvbk5hbWVGcm9tU3RyaW5nKHNvdXJjZSk7XG4gICAgICAgIHNldHRpbmdzQ29weS5zdWJLZXJuZWxzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IG5hbWUgfHwgcCxcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgcHJvcGVydHk6IHAsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVLZXJuZWwoZm4sIHNldHRpbmdzQ29weSk7XG4gIH1cblxuICBjb21iaW5lS2VybmVscygpIHtcbiAgICBjb25zdCBmaXJzdEtlcm5lbCA9IGFyZ3VtZW50c1swXTtcbiAgICBjb25zdCBjb21iaW5lZEtlcm5lbCA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGZpcnN0S2VybmVsLmtlcm5lbC5jb25zdHJ1Y3Rvci5tb2RlID09PSAnY3B1JykgcmV0dXJuIGNvbWJpbmVkS2VybmVsO1xuICAgIGNvbnN0IGNhbnZhcyA9IGFyZ3VtZW50c1swXS5jYW52YXM7XG4gICAgY29uc3QgY29udGV4dCA9IGFyZ3VtZW50c1swXS5jb250ZXh0O1xuICAgIGNvbnN0IG1heCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIGFyZ3VtZW50c1tpXVxuICAgICAgICAuc2V0Q2FudmFzKGNhbnZhcylcbiAgICAgICAgLnNldENvbnRleHQoY29udGV4dClcbiAgICAgICAgLnNldFBpcGVsaW5lKHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBjb21iaW5lZEtlcm5lbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRleHR1cmUudG9BcnJheSkge1xuICAgICAgICByZXR1cm4gdGV4dHVyZS50b0FycmF5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9O1xuICB9XG5cbiAgc2V0RnVuY3Rpb25zKGZ1bmN0aW9ucykge1xuICAgIHRoaXMuZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0TmF0aXZlRnVuY3Rpb25zKG5hdGl2ZUZ1bmN0aW9ucykge1xuICAgIHRoaXMubmF0aXZlRnVuY3Rpb25zID0gbmF0aXZlRnVuY3Rpb25zO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYWRkRnVuY3Rpb24oc291cmNlLCBzZXR0aW5ncykge1xuICAgIHRoaXMuZnVuY3Rpb25zLnB1c2goeyBzb3VyY2UsIHNldHRpbmdzIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYWRkTmF0aXZlRnVuY3Rpb24obmFtZSwgc291cmNlLCBzZXR0aW5ncykge1xuICAgIGlmICh0aGlzLmtlcm5lbHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCBcImFkZE5hdGl2ZUZ1bmN0aW9uXCIgYWZ0ZXIgXCJjcmVhdGVLZXJuZWxzXCIgaGFzIGJlZW4gY2FsbGVkLicpO1xuICAgIH1cbiAgICB0aGlzLm5hdGl2ZUZ1bmN0aW9ucy5wdXNoKE9iamVjdC5hc3NpZ24oeyBuYW1lLCBzb3VyY2UgfSwgc2V0dGluZ3MpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGluamVjdE5hdGl2ZShzb3VyY2UpIHtcbiAgICB0aGlzLmluamVjdGVkTmF0aXZlID0gc291cmNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmtlcm5lbHMpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmtlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMua2VybmVsc1tpXS5kZXN0cm95KHRydWUpOyBcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGZpcnN0S2VybmVsID0gdGhpcy5rZXJuZWxzWzBdO1xuICAgICAgICAgIGlmIChmaXJzdEtlcm5lbCkge1xuICAgICAgICAgICAgaWYgKGZpcnN0S2VybmVsLmtlcm5lbCkge1xuICAgICAgICAgICAgICBmaXJzdEtlcm5lbCA9IGZpcnN0S2VybmVsLmtlcm5lbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdEtlcm5lbC5jb25zdHJ1Y3Rvci5kZXN0cm95Q29udGV4dCkge1xuICAgICAgICAgICAgICBmaXJzdEtlcm5lbC5jb25zdHJ1Y3Rvci5kZXN0cm95Q29udGV4dCh0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCAwKTtcbiAgICB9KTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHVwZ3JhZGVEZXByZWNhdGVkQ3JlYXRlS2VybmVsU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgaWYgKCFzZXR0aW5ncykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCB1cGdyYWRlZFNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgc2V0dGluZ3MpO1xuXG4gIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnZmxvYXRPdXRwdXQnKSkge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdzZXR0aW5nJywgJ2Zsb2F0T3V0cHV0JywgJ3ByZWNpc2lvbicpO1xuICAgIHVwZ3JhZGVkU2V0dGluZ3MucHJlY2lzaW9uID0gc2V0dGluZ3MuZmxvYXRPdXRwdXQgPyAnc2luZ2xlJyA6ICd1bnNpZ25lZCc7XG4gIH1cbiAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdvdXRwdXRUb1RleHR1cmUnKSkge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdzZXR0aW5nJywgJ291dHB1dFRvVGV4dHVyZScsICdwaXBlbGluZScpO1xuICAgIHVwZ3JhZGVkU2V0dGluZ3MucGlwZWxpbmUgPSBCb29sZWFuKHNldHRpbmdzLm91dHB1dFRvVGV4dHVyZSk7XG4gIH1cbiAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdvdXRwdXRJbW11dGFibGUnKSkge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdzZXR0aW5nJywgJ291dHB1dEltbXV0YWJsZScsICdpbW11dGFibGUnKTtcbiAgICB1cGdyYWRlZFNldHRpbmdzLmltbXV0YWJsZSA9IEJvb2xlYW4oc2V0dGluZ3Mub3V0cHV0SW1tdXRhYmxlKTtcbiAgfVxuICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2Zsb2F0VGV4dHVyZXMnKSkge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdzZXR0aW5nJywgJ2Zsb2F0VGV4dHVyZXMnLCAnb3B0aW1pemVGbG9hdE1lbW9yeScpO1xuICAgIHVwZ3JhZGVkU2V0dGluZ3Mub3B0aW1pemVGbG9hdE1lbW9yeSA9IEJvb2xlYW4oc2V0dGluZ3MuZmxvYXRUZXh0dXJlcyk7XG4gIH1cbiAgcmV0dXJuIHVwZ3JhZGVkU2V0dGluZ3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHUFUsXG4gIGtlcm5lbE9yZGVyLFxuICBrZXJuZWxUeXBlc1xufTtcbn0se1wiLi9iYWNrZW5kL2NwdS9rZXJuZWxcIjo4LFwiLi9iYWNrZW5kL2hlYWRsZXNzLWdsL2tlcm5lbFwiOjM0LFwiLi9iYWNrZW5kL2tlcm5lbFwiOjM2LFwiLi9iYWNrZW5kL3dlYi1nbC9rZXJuZWxcIjo3MCxcIi4vYmFja2VuZC93ZWItZ2wyL2tlcm5lbFwiOjEwNSxcIi4va2VybmVsLXJ1bi1zaG9ydGN1dFwiOjExMSxcIi4vdXRpbHNcIjoxMTQsXCJncHUtbW9jay5qc1wiOjR9XSwxMDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBHUFUgfSA9IHJlcXVpcmUoJy4vZ3B1Jyk7XG5jb25zdCB7IGFsaWFzIH0gPSByZXF1aXJlKCcuL2FsaWFzJyk7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB7IElucHV0LCBpbnB1dCB9ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xuY29uc3QgeyBUZXh0dXJlIH0gPSByZXF1aXJlKCcuL3RleHR1cmUnKTtcbmNvbnN0IHsgRnVuY3Rpb25CdWlsZGVyIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvZnVuY3Rpb24tYnVpbGRlcicpO1xuY29uc3QgeyBGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9mdW5jdGlvbi1ub2RlJyk7XG5jb25zdCB7IENQVUZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2NwdS9mdW5jdGlvbi1ub2RlJyk7XG5jb25zdCB7IENQVUtlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2NwdS9rZXJuZWwnKTtcblxuY29uc3QgeyBIZWFkbGVzc0dMS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvaGVhZGxlc3MtZ2wva2VybmVsJyk7XG5cbmNvbnN0IHsgV2ViR0xGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wvZnVuY3Rpb24tbm9kZScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL3dlYi1nbC9rZXJuZWwnKTtcbmNvbnN0IHsga2VybmVsVmFsdWVNYXBzOiB3ZWJHTEtlcm5lbFZhbHVlTWFwcyB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL3dlYi1nbC9rZXJuZWwtdmFsdWUtbWFwcycpO1xuXG5jb25zdCB7IFdlYkdMMkZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL3dlYi1nbDIvZnVuY3Rpb24tbm9kZScpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wyL2tlcm5lbCcpO1xuY29uc3QgeyBrZXJuZWxWYWx1ZU1hcHM6IHdlYkdMMktlcm5lbFZhbHVlTWFwcyB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL3dlYi1nbDIva2VybmVsLXZhbHVlLW1hcHMnKTtcblxuY29uc3QgeyBHTEtlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2dsL2tlcm5lbCcpO1xuXG5jb25zdCB7IEtlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2tlcm5lbCcpO1xuXG5jb25zdCB7IEZ1bmN0aW9uVHJhY2VyIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvZnVuY3Rpb24tdHJhY2VyJyk7XG5cbmNvbnN0IG1hdGhSYW5kb20gPSByZXF1aXJlKCcuL3BsdWdpbnMvbWF0aC1yYW5kb20tdW5pZm9ybWx5LWRpc3RyaWJ1dGVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhbGlhcyxcbiAgQ1BVRnVuY3Rpb25Ob2RlLFxuICBDUFVLZXJuZWwsXG4gIEdQVSxcbiAgRnVuY3Rpb25CdWlsZGVyLFxuICBGdW5jdGlvbk5vZGUsXG4gIEhlYWRsZXNzR0xLZXJuZWwsXG4gIElucHV0LFxuICBpbnB1dCxcbiAgVGV4dHVyZSxcbiAgdXRpbHMsXG5cbiAgV2ViR0wyRnVuY3Rpb25Ob2RlLFxuICBXZWJHTDJLZXJuZWwsXG4gIHdlYkdMMktlcm5lbFZhbHVlTWFwcyxcblxuICBXZWJHTEZ1bmN0aW9uTm9kZSxcbiAgV2ViR0xLZXJuZWwsXG4gIHdlYkdMS2VybmVsVmFsdWVNYXBzLFxuXG4gIEdMS2VybmVsLFxuICBLZXJuZWwsXG4gIEZ1bmN0aW9uVHJhY2VyLFxuXG4gIHBsdWdpbnM6IHtcbiAgICBtYXRoUmFuZG9tXG4gIH1cbn07XG59LHtcIi4vYWxpYXNcIjo1LFwiLi9iYWNrZW5kL2NwdS9mdW5jdGlvbi1ub2RlXCI6NixcIi4vYmFja2VuZC9jcHUva2VybmVsXCI6OCxcIi4vYmFja2VuZC9mdW5jdGlvbi1idWlsZGVyXCI6OSxcIi4vYmFja2VuZC9mdW5jdGlvbi1ub2RlXCI6MTAsXCIuL2JhY2tlbmQvZnVuY3Rpb24tdHJhY2VyXCI6MTEsXCIuL2JhY2tlbmQvZ2wva2VybmVsXCI6MTMsXCIuL2JhY2tlbmQvaGVhZGxlc3MtZ2wva2VybmVsXCI6MzQsXCIuL2JhY2tlbmQva2VybmVsXCI6MzYsXCIuL2JhY2tlbmQvd2ViLWdsL2Z1bmN0aW9uLW5vZGVcIjozOCxcIi4vYmFja2VuZC93ZWItZ2wva2VybmVsXCI6NzAsXCIuL2JhY2tlbmQvd2ViLWdsL2tlcm5lbC12YWx1ZS1tYXBzXCI6MzksXCIuL2JhY2tlbmQvd2ViLWdsMi9mdW5jdGlvbi1ub2RlXCI6NzMsXCIuL2JhY2tlbmQvd2ViLWdsMi9rZXJuZWxcIjoxMDUsXCIuL2JhY2tlbmQvd2ViLWdsMi9rZXJuZWwtdmFsdWUtbWFwc1wiOjc0LFwiLi9ncHVcIjoxMDgsXCIuL2lucHV0XCI6MTEwLFwiLi9wbHVnaW5zL21hdGgtcmFuZG9tLXVuaWZvcm1seS1kaXN0cmlidXRlZFwiOjExMixcIi4vdGV4dHVyZVwiOjExMyxcIi4vdXRpbHNcIjoxMTR9XSwxMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY2xhc3MgSW5wdXQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2l6ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzaXplKSkge1xuICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaXplID0gbmV3IEludDMyQXJyYXkoMyk7XG4gICAgICBpZiAoc2l6ZS56KSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ldyBJbnQzMkFycmF5KFtzaXplLngsIHNpemUueSwgc2l6ZS56XSk7XG4gICAgICB9IGVsc2UgaWYgKHNpemUueSkge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXcgSW50MzJBcnJheShbc2l6ZS54LCBzaXplLnldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ldyBJbnQzMkFycmF5KFtzaXplLnhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBbdywgaCwgZF0gPSB0aGlzLnNpemU7XG4gICAgaWYgKGQpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCAhPT0gKHcgKiBoICogZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaXplICR7dGhpcy52YWx1ZS5sZW5ndGh9IGRvZXMgbm90IG1hdGNoICR7d30gKiAke2h9ICogJHtkfSA9ICR7KGggKiB3ICogZCl9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggIT09ICh3ICogaCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaXplICR7dGhpcy52YWx1ZS5sZW5ndGh9IGRvZXMgbm90IG1hdGNoICR7d30gKiAke2h9ID0gJHsoaCAqIHcpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggIT09IHcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaXplICR7dGhpcy52YWx1ZS5sZW5ndGh9IGRvZXMgbm90IG1hdGNoICR7d31gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIGNvbnN0IFt3LCBoLCBkXSA9IHRoaXMuc2l6ZTtcbiAgICBpZiAoZCkge1xuICAgICAgcmV0dXJuIHV0aWxzLmVyZWN0TWVtb3J5T3B0aW1pemVkM0RGbG9hdCh0aGlzLnZhbHVlLnN1YmFycmF5ID8gdGhpcy52YWx1ZSA6IG5ldyBGbG9hdDMyQXJyYXkodGhpcy52YWx1ZSksIHcsIGgsIGQpO1xuICAgIH0gZWxzZSBpZiAoaCkge1xuICAgICAgcmV0dXJuIHV0aWxzLmVyZWN0TWVtb3J5T3B0aW1pemVkMkRGbG9hdCh0aGlzLnZhbHVlLnN1YmFycmF5ID8gdGhpcy52YWx1ZSA6IG5ldyBGbG9hdDMyQXJyYXkodGhpcy52YWx1ZSksIHcsIGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5wdXQodmFsdWUsIHNpemUpIHtcbiAgcmV0dXJuIG5ldyBJbnB1dCh2YWx1ZSwgc2l6ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBJbnB1dCxcbiAgaW5wdXRcbn07XG59LHtcIi4vdXRpbHNcIjoxMTR9XSwxMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5mdW5jdGlvbiBrZXJuZWxSdW5TaG9ydGN1dChrZXJuZWwpIHtcbiAgbGV0IHJ1biA9IGZ1bmN0aW9uKCkge1xuICAgIGtlcm5lbC5idWlsZC5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gICAgcnVuID0gZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgcmVzdWx0ID0ga2VybmVsLnJ1bi5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoa2VybmVsLnN3aXRjaGluZ0tlcm5lbHMpIHtcbiAgICAgICAgY29uc3QgcmVhc29ucyA9IGtlcm5lbC5yZXNldFN3aXRjaGluZ0tlcm5lbHMoKTtcbiAgICAgICAgY29uc3QgbmV3S2VybmVsID0ga2VybmVsLm9uUmVxdWVzdFN3aXRjaEtlcm5lbChyZWFzb25zLCBhcmd1bWVudHMsIGtlcm5lbCk7XG4gICAgICAgIHNob3J0Y3V0Lmtlcm5lbCA9IGtlcm5lbCA9IG5ld0tlcm5lbDtcbiAgICAgICAgcmVzdWx0ID0gbmV3S2VybmVsLnJ1bi5hcHBseShuZXdLZXJuZWwsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAoa2VybmVsLnJlbmRlcktlcm5lbHMpIHtcbiAgICAgICAgcmV0dXJuIGtlcm5lbC5yZW5kZXJLZXJuZWxzKCk7XG4gICAgICB9IGVsc2UgaWYgKGtlcm5lbC5yZW5kZXJPdXRwdXQpIHtcbiAgICAgICAgcmV0dXJuIGtlcm5lbC5yZW5kZXJPdXRwdXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcnVuLmFwcGx5KGtlcm5lbCwgYXJndW1lbnRzKTtcbiAgfTtcbiAgY29uc3Qgc2hvcnRjdXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcnVuLmFwcGx5KGtlcm5lbCwgYXJndW1lbnRzKTtcbiAgfTtcbiAgc2hvcnRjdXQuZXhlYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjY2VwdChydW4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgc2hvcnRjdXQucmVwbGFjZUtlcm5lbCA9IGZ1bmN0aW9uKHJlcGxhY2VtZW50S2VybmVsKSB7XG4gICAga2VybmVsID0gcmVwbGFjZW1lbnRLZXJuZWw7XG4gICAgYmluZEtlcm5lbFRvU2hvcnRjdXQoa2VybmVsLCBzaG9ydGN1dCk7XG4gIH07XG5cbiAgYmluZEtlcm5lbFRvU2hvcnRjdXQoa2VybmVsLCBzaG9ydGN1dCk7XG4gIHJldHVybiBzaG9ydGN1dDtcbn1cblxuZnVuY3Rpb24gYmluZEtlcm5lbFRvU2hvcnRjdXQoa2VybmVsLCBzaG9ydGN1dCkge1xuICBpZiAoc2hvcnRjdXQua2VybmVsKSB7XG4gICAgc2hvcnRjdXQua2VybmVsID0ga2VybmVsO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcm9wZXJ0aWVzID0gdXRpbHMuYWxsUHJvcGVydGllc09mKGtlcm5lbCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICBpZiAocHJvcGVydHlbMF0gPT09ICdfJyAmJiBwcm9wZXJ0eVsxXSA9PT0gJ18nKSBjb250aW51ZTtcbiAgICBpZiAodHlwZW9mIGtlcm5lbFtwcm9wZXJ0eV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChwcm9wZXJ0eS5zdWJzdHJpbmcoMCwgMykgPT09ICdhZGQnIHx8IHByb3BlcnR5LnN1YnN0cmluZygwLCAzKSA9PT0gJ3NldCcpIHtcbiAgICAgICAgc2hvcnRjdXRbcHJvcGVydHldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2hvcnRjdXQua2VybmVsW3Byb3BlcnR5XS5hcHBseShzaG9ydGN1dC5rZXJuZWwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHNob3J0Y3V0O1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hvcnRjdXRbcHJvcGVydHldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHNob3J0Y3V0Lmtlcm5lbFtwcm9wZXJ0eV0uYXBwbHkoc2hvcnRjdXQua2VybmVsLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzaG9ydGN1dC5fX2RlZmluZUdldHRlcl9fKHByb3BlcnR5LCAoKSA9PiBzaG9ydGN1dC5rZXJuZWxbcHJvcGVydHldKTtcbiAgICAgIHNob3J0Y3V0Ll9fZGVmaW5lU2V0dGVyX18ocHJvcGVydHksICh2YWx1ZSkgPT4ge1xuICAgICAgICBzaG9ydGN1dC5rZXJuZWxbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc2hvcnRjdXQua2VybmVsID0ga2VybmVsO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtlcm5lbFJ1blNob3J0Y3V0XG59O1xufSx7XCIuL3V0aWxzXCI6MTE0fV0sMTEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHNvdXJjZSA9IGAvLyBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvNHQyU0RoXG4vL25vdGU6IHVuaWZvcm1seSBkaXN0cmlidXRlZCwgbm9ybWFsaXplZCByYW5kLCBbMCwxXVxuaGlnaHAgZmxvYXQgcmFuZG9tU2VlZFNoaWZ0ID0gMS4wO1xuaGlnaHAgZmxvYXQgc2xpZGUgPSAxLjA7XG51bmlmb3JtIGhpZ2hwIGZsb2F0IHJhbmRvbVNlZWQxO1xudW5pZm9ybSBoaWdocCBmbG9hdCByYW5kb21TZWVkMjtcblxuaGlnaHAgZmxvYXQgbnJhbmQoaGlnaHAgdmVjMiBuKSB7XG4gIGhpZ2hwIGZsb2F0IHJlc3VsdCA9IGZyYWN0KHNpbihkb3QoKG4ueHkgKyAxLjApICogdmVjMihyYW5kb21TZWVkMSAqIHNsaWRlLCByYW5kb21TZWVkMiAqIHJhbmRvbVNlZWRTaGlmdCksIHZlYzIoMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1Myk7XG4gIHJhbmRvbVNlZWRTaGlmdCA9IHJlc3VsdDtcbiAgaWYgKHJhbmRvbVNlZWRTaGlmdCA+IDAuNSkge1xuICAgIHNsaWRlICs9IDAuMDAwMDk7IFxuICB9IGVsc2Uge1xuICAgIHNsaWRlICs9IDAuMDAwOTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufWA7XG5cbmNvbnN0IG5hbWUgPSAnbWF0aC1yYW5kb20tdW5pZm9ybWx5LWRpc3RyaWJ1dGVkJztcblxuY29uc3QgZnVuY3Rpb25NYXRjaCA9IGBNYXRoLnJhbmRvbSgpYDtcblxuY29uc3QgZnVuY3Rpb25SZXBsYWNlID0gYG5yYW5kKHZUZXhDb29yZClgO1xuXG5jb25zdCBmdW5jdGlvblJldHVyblR5cGUgPSAnTnVtYmVyJztcbmNvbnN0IG9uQmVmb3JlUnVuID0gKGtlcm5lbCkgPT4ge1xuICBrZXJuZWwuc2V0VW5pZm9ybTFmKCdyYW5kb21TZWVkMScsIE1hdGgucmFuZG9tKCkpO1xuICBrZXJuZWwuc2V0VW5pZm9ybTFmKCdyYW5kb21TZWVkMicsIE1hdGgucmFuZG9tKCkpO1xufTtcblxuY29uc3QgcGx1Z2luID0ge1xuICBuYW1lLFxuICBvbkJlZm9yZVJ1bixcbiAgZnVuY3Rpb25NYXRjaCxcbiAgZnVuY3Rpb25SZXBsYWNlLFxuICBmdW5jdGlvblJldHVyblR5cGUsXG4gIHNvdXJjZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwbHVnaW47XG59LHt9XSwxMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY2xhc3MgVGV4dHVyZSB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGV4dHVyZSxcbiAgICAgIHNpemUsXG4gICAgICBkaW1lbnNpb25zLFxuICAgICAgb3V0cHV0LFxuICAgICAgY29udGV4dCxcbiAgICAgIHR5cGUgPSAnTnVtYmVyVGV4dHVyZScsXG4gICAgICBrZXJuZWwsXG4gICAgICBpbnRlcm5hbEZvcm1hdCxcbiAgICAgIHRleHR1cmVGb3JtYXRcbiAgICB9ID0gc2V0dGluZ3M7XG4gICAgaWYgKCFvdXRwdXQpIHRocm93IG5ldyBFcnJvcignc2V0dGluZ3MgcHJvcGVydHkgXCJvdXRwdXRcIiByZXF1aXJlZC4nKTtcbiAgICBpZiAoIWNvbnRleHQpIHRocm93IG5ldyBFcnJvcignc2V0dGluZ3MgcHJvcGVydHkgXCJjb250ZXh0XCIgcmVxdWlyZWQuJyk7XG4gICAgaWYgKCF0ZXh0dXJlKSB0aHJvdyBuZXcgRXJyb3IoJ3NldHRpbmdzIHByb3BlcnR5IFwidGV4dHVyZVwiIHJlcXVpcmVkLicpO1xuICAgIGlmICgha2VybmVsKSB0aHJvdyBuZXcgRXJyb3IoJ3NldHRpbmdzIHByb3BlcnR5IFwia2VybmVsXCIgcmVxdWlyZWQuJyk7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICBpZiAodGV4dHVyZS5fcmVmcykge1xuICAgICAgdGV4dHVyZS5fcmVmcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0dXJlLl9yZWZzID0gMTtcbiAgICB9XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuICAgIHRoaXMub3V0cHV0ID0gb3V0cHV0O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5rZXJuZWwgPSBrZXJuZWw7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLl9kZWxldGVkID0gZmFsc2U7XG4gICAgdGhpcy5pbnRlcm5hbEZvcm1hdCA9IGludGVybmFsRm9ybWF0O1xuICAgIHRoaXMudGV4dHVyZUZvcm1hdCA9IHRleHR1cmVGb3JtYXQ7XG4gIH1cblxuICB0b0FycmF5KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm90IGltcGxlbWVudGVkIG9uICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgaW1wbGVtZW50ZWQgb24gJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gIH1cblxuICBkZWxldGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgaW1wbGVtZW50ZWQgb24gJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBpbXBsZW1lbnRlZCBvbiAke3RoaXMuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVGV4dHVyZVxufTtcbn0se31dLDExNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCBhY29ybiA9IHJlcXVpcmUoJ2Fjb3JuJyk7XG5jb25zdCB7IElucHV0IH0gPSByZXF1aXJlKCcuL2lucHV0Jyk7XG5jb25zdCB7IFRleHR1cmUgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZScpO1xuXG5jb25zdCBGVU5DVElPTl9OQU1FID0gL2Z1bmN0aW9uIChbXihdKikvO1xuY29uc3QgU1RSSVBfQ09NTUVOVFMgPSAvKChcXC9cXC8uKiQpfChcXC9cXCpbXFxzXFxTXSo/XFwqXFwvKSkvbWc7XG5jb25zdCBBUkdVTUVOVF9OQU1FUyA9IC8oW15cXHMsXSspL2c7XG5cbmNvbnN0IHV0aWxzID0ge1xuICBzeXN0ZW1FbmRpYW5uZXNzKCkge1xuICAgIHJldHVybiBfc3lzdGVtRW5kaWFubmVzcztcbiAgfSxcbiAgZ2V0U3lzdGVtRW5kaWFubmVzcygpIHtcbiAgICBjb25zdCBiID0gbmV3IEFycmF5QnVmZmVyKDQpO1xuICAgIGNvbnN0IGEgPSBuZXcgVWludDMyQXJyYXkoYik7XG4gICAgY29uc3QgYyA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgIGFbMF0gPSAweGRlYWRiZWVmO1xuICAgIGlmIChjWzBdID09PSAweGVmKSByZXR1cm4gJ0xFJztcbiAgICBpZiAoY1swXSA9PT0gMHhkZSkgcmV0dXJuICdCRSc7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGVuZGlhbm5lc3MnKTtcbiAgfSxcblxuICBpc0Z1bmN0aW9uKGZ1bmNPYmopIHtcbiAgICByZXR1cm4gdHlwZW9mKGZ1bmNPYmopID09PSAnZnVuY3Rpb24nO1xuICB9LFxuXG4gIGlzRnVuY3Rpb25TdHJpbmcoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIChmblxuICAgICAgICAuc2xpY2UoMCwgJ2Z1bmN0aW9uJy5sZW5ndGgpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpID09PSAnZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIGdldEZ1bmN0aW9uTmFtZUZyb21TdHJpbmcoZnVuY1N0cikge1xuICAgIGNvbnN0IHJlc3VsdCA9IEZVTkNUSU9OX05BTUUuZXhlYyhmdW5jU3RyKTtcbiAgICBpZiAoIXJlc3VsdCB8fCByZXN1bHQubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcmVzdWx0WzFdLnRyaW0oKTtcbiAgfSxcblxuICBnZXRGdW5jdGlvbkJvZHlGcm9tU3RyaW5nKGZ1bmNTdHIpIHtcbiAgICByZXR1cm4gZnVuY1N0ci5zdWJzdHJpbmcoZnVuY1N0ci5pbmRleE9mKCd7JykgKyAxLCBmdW5jU3RyLmxhc3RJbmRleE9mKCd9JykpO1xuICB9LFxuXG4gIGdldEFyZ3VtZW50TmFtZXNGcm9tU3RyaW5nKGZuKSB7XG4gICAgY29uc3QgZm5TdHIgPSBmbi5yZXBsYWNlKFNUUklQX0NPTU1FTlRTLCAnJyk7XG4gICAgbGV0IHJlc3VsdCA9IGZuU3RyLnNsaWNlKGZuU3RyLmluZGV4T2YoJygnKSArIDEsIGZuU3RyLmluZGV4T2YoJyknKSkubWF0Y2goQVJHVU1FTlRfTkFNRVMpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIGNsb25lKG9iaikge1xuICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqLmhhc093blByb3BlcnR5KCdpc0FjdGl2ZUNsb25lJykpIHJldHVybiBvYmo7XG5cbiAgICBjb25zdCB0ZW1wID0gb2JqLmNvbnN0cnVjdG9yKCk7IFxuXG4gICAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgb2JqLmlzQWN0aXZlQ2xvbmUgPSBudWxsO1xuICAgICAgICB0ZW1wW2tleV0gPSB1dGlscy5jbG9uZShvYmpba2V5XSk7XG4gICAgICAgIGRlbGV0ZSBvYmouaXNBY3RpdmVDbG9uZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcDtcbiAgfSxcblxuICBpc0FycmF5KGFycmF5KSB7XG4gICAgcmV0dXJuICFpc05hTihhcnJheS5sZW5ndGgpO1xuICB9LFxuXG4gIGdldFZhcmlhYmxlVHlwZSh2YWx1ZSwgc3RyaWN0SW50ZWdlcnMpIHtcbiAgICBpZiAodXRpbHMuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwICYmIHZhbHVlWzBdLm5vZGVOYW1lID09PSAnSU1HJykge1xuICAgICAgICByZXR1cm4gJ0hUTUxJbWFnZUFycmF5JztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnQXJyYXknO1xuICAgIH1cblxuICAgIHN3aXRjaCAodmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgcmV0dXJuICdCb29sZWFuJztcbiAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgICBpZiAoc3RyaWN0SW50ZWdlcnMgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gJ0ludGVnZXInO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnRmxvYXQnO1xuICAgICAgY2FzZSBUZXh0dXJlOlxuICAgICAgICByZXR1cm4gdmFsdWUudHlwZTtcbiAgICAgIGNhc2UgSW5wdXQ6XG4gICAgICAgIHJldHVybiAnSW5wdXQnO1xuICAgIH1cbiAgICBzd2l0Y2ggKHZhbHVlLm5vZGVOYW1lKSB7XG4gICAgICBjYXNlICdJTUcnOlxuICAgICAgICByZXR1cm4gJ0hUTUxJbWFnZSc7XG4gICAgICBjYXNlICdDQU5WQVMnOlxuICAgICAgICByZXR1cm4gJ0hUTUxJbWFnZSc7XG4gICAgICBjYXNlICdWSURFTyc6XG4gICAgICAgIHJldHVybiAnSFRNTFZpZGVvJztcbiAgICB9XG4gICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCd0eXBlJykpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50eXBlO1xuICAgIH1cbiAgICByZXR1cm4gJ1Vua25vd24nO1xuICB9LFxuXG4gIGdldEtlcm5lbFRleHR1cmVTaXplKHNldHRpbmdzLCBkaW1lbnNpb25zKSB7XG4gICAgbGV0IFt3LCBoLCBkXSA9IGRpbWVuc2lvbnM7XG4gICAgbGV0IHRleGVsQ291bnQgPSAodyB8fCAxKSAqIChoIHx8IDEpICogKGQgfHwgMSk7XG5cbiAgICBpZiAoc2V0dGluZ3Mub3B0aW1pemVGbG9hdE1lbW9yeSAmJiBzZXR0aW5ncy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICB3ID0gdGV4ZWxDb3VudCA9IE1hdGguY2VpbCh0ZXhlbENvdW50IC8gNCk7XG4gICAgfVxuICAgIGlmIChoID4gMSAmJiB3ICogaCA9PT0gdGV4ZWxDb3VudCkge1xuICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KFt3LCBoXSk7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5jbG9zZXN0U3F1YXJlRGltZW5zaW9ucyh0ZXhlbENvdW50KTtcbiAgfSxcblxuICBjbG9zZXN0U3F1YXJlRGltZW5zaW9ucyhsZW5ndGgpIHtcbiAgICBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0KGxlbmd0aCk7XG4gICAgbGV0IGhpZ2ggPSBNYXRoLmNlaWwoc3FydCk7XG4gICAgbGV0IGxvdyA9IE1hdGguZmxvb3Ioc3FydCk7XG4gICAgd2hpbGUgKGhpZ2ggKiBsb3cgPCBsZW5ndGgpIHtcbiAgICAgIGhpZ2gtLTtcbiAgICAgIGxvdyA9IE1hdGguY2VpbChsZW5ndGggLyBoaWdoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KFtsb3csIE1hdGguY2VpbChsZW5ndGggLyBsb3cpXSk7XG4gIH0sXG5cbiAgZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZShkaW1lbnNpb25zLCBiaXRSYXRpbykge1xuICAgIGNvbnN0IHRvdGFsQXJlYSA9IHV0aWxzLnJvdW5kVG8oKGRpbWVuc2lvbnNbMF0gfHwgMSkgKiAoZGltZW5zaW9uc1sxXSB8fCAxKSAqIChkaW1lbnNpb25zWzJdIHx8IDEpICogKGRpbWVuc2lvbnNbM10gfHwgMSksIDQpO1xuICAgIGNvbnN0IHRleGVsQ291bnQgPSB0b3RhbEFyZWEgLyBiaXRSYXRpbztcbiAgICByZXR1cm4gdXRpbHMuY2xvc2VzdFNxdWFyZURpbWVuc2lvbnModGV4ZWxDb3VudCk7XG4gIH0sXG5cbiAgZ2V0TWVtb3J5T3B0aW1pemVkUGFja2VkVGV4dHVyZVNpemUoZGltZW5zaW9ucywgYml0UmF0aW8pIHtcbiAgICBjb25zdCBbdywgaCwgZF0gPSBkaW1lbnNpb25zO1xuICAgIGNvbnN0IHRvdGFsQXJlYSA9IHV0aWxzLnJvdW5kVG8oKHcgfHwgMSkgKiAoaCB8fCAxKSAqIChkIHx8IDEpLCA0KTtcbiAgICBjb25zdCB0ZXhlbENvdW50ID0gdG90YWxBcmVhIC8gKDQgLyBiaXRSYXRpbyk7XG4gICAgcmV0dXJuIHV0aWxzLmNsb3Nlc3RTcXVhcmVEaW1lbnNpb25zKHRleGVsQ291bnQpO1xuICB9LFxuXG4gIHJvdW5kVG8obiwgZCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKChuICsgZCAtIDEpIC8gZCkgKiBkO1xuICB9LFxuICBnZXREaW1lbnNpb25zKHgsIHBhZCkge1xuICAgIGxldCByZXQ7XG4gICAgaWYgKHV0aWxzLmlzQXJyYXkoeCkpIHtcbiAgICAgIGNvbnN0IGRpbSA9IFtdO1xuICAgICAgbGV0IHRlbXAgPSB4O1xuICAgICAgd2hpbGUgKHV0aWxzLmlzQXJyYXkodGVtcCkpIHtcbiAgICAgICAgZGltLnB1c2godGVtcC5sZW5ndGgpO1xuICAgICAgICB0ZW1wID0gdGVtcFswXTtcbiAgICAgIH1cbiAgICAgIHJldCA9IGRpbS5yZXZlcnNlKCk7XG4gICAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgcmV0ID0geC5vdXRwdXQ7XG4gICAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgSW5wdXQpIHtcbiAgICAgIHJldCA9IHguc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRpbWVuc2lvbnMgb2YgJHt4fWApO1xuICAgIH1cblxuICAgIGlmIChwYWQpIHtcbiAgICAgIHJldCA9IEFycmF5LmZyb20ocmV0KTtcbiAgICAgIHdoaWxlIChyZXQubGVuZ3RoIDwgMykge1xuICAgICAgICByZXQucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEludDMyQXJyYXkocmV0KTtcbiAgfSxcblxuICBmbGF0dGVuMmRBcnJheVRvKGFycmF5LCB0YXJnZXQpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGFycmF5Lmxlbmd0aDsgeSsrKSB7XG4gICAgICB0YXJnZXQuc2V0KGFycmF5W3ldLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGFycmF5W3ldLmxlbmd0aDtcbiAgICB9XG4gIH0sXG5cbiAgZmxhdHRlbjNkQXJyYXlUbyhhcnJheSwgdGFyZ2V0KSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBhcnJheS5sZW5ndGg7IHorKykge1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBhcnJheVt6XS5sZW5ndGg7IHkrKykge1xuICAgICAgICB0YXJnZXQuc2V0KGFycmF5W3pdW3ldLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gYXJyYXlbel1beV0ubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBmbGF0dGVuNGRBcnJheVRvKGFycmF5LCB0YXJnZXQpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IGFycmF5Lmxlbmd0aDsgbCsrKSB7XG4gICAgICBmb3IgKGxldCB6ID0gMDsgeiA8IGFycmF5W2xdLmxlbmd0aDsgeisrKSB7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgYXJyYXlbbF1bel0ubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICB0YXJnZXQuc2V0KGFycmF5W2xdW3pdW3ldLCBvZmZzZXQpO1xuICAgICAgICAgIG9mZnNldCArPSBhcnJheVtsXVt6XVt5XS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZmxhdHRlblRvKGFycmF5LCB0YXJnZXQpIHtcbiAgICBpZiAodXRpbHMuaXNBcnJheShhcnJheVswXSkpIHtcbiAgICAgIGlmICh1dGlscy5pc0FycmF5KGFycmF5WzBdWzBdKSkge1xuICAgICAgICBpZiAodXRpbHMuaXNBcnJheShhcnJheVswXVswXVswXSkpIHtcbiAgICAgICAgICB1dGlscy5mbGF0dGVuNGRBcnJheVRvKGFycmF5LCB0YXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0aWxzLmZsYXR0ZW4zZEFycmF5VG8oYXJyYXksIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWxzLmZsYXR0ZW4yZEFycmF5VG8oYXJyYXksIHRhcmdldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5zZXQoYXJyYXkpO1xuICAgIH1cbiAgfSxcblxuICBzcGxpdEFycmF5KGFycmF5LCBwYXJ0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gcGFydCkge1xuICAgICAgcmVzdWx0LnB1c2gobmV3IGFycmF5LmNvbnN0cnVjdG9yKGFycmF5LmJ1ZmZlciwgaSAqIDQgKyBhcnJheS5ieXRlT2Zmc2V0LCBwYXJ0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgZ2V0QXN0U3RyaW5nKHNvdXJjZSwgYXN0KSB7XG4gICAgY29uc3QgbGluZXMgPSBBcnJheS5pc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vZyk7XG4gICAgY29uc3Qgc3RhcnQgPSBhc3QubG9jLnN0YXJ0O1xuICAgIGNvbnN0IGVuZCA9IGFzdC5sb2MuZW5kO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmIChzdGFydC5saW5lID09PSBlbmQubGluZSkge1xuICAgICAgcmVzdWx0LnB1c2gobGluZXNbc3RhcnQubGluZSAtIDFdLnN1YnN0cmluZyhzdGFydC5jb2x1bW4sIGVuZC5jb2x1bW4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gobGluZXNbc3RhcnQubGluZSAtIDFdLnNsaWNlKHN0YXJ0LmNvbHVtbikpO1xuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0LmxpbmU7IGkgPCBlbmQubGluZTsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmVzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGxpbmVzW2VuZC5saW5lIC0gMV0uc2xpY2UoMCwgZW5kLmNvbHVtbikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJ1xcbicpO1xuICB9LFxuXG4gIGFsbFByb3BlcnRpZXNPZihvYmopIHtcbiAgICBjb25zdCBwcm9wcyA9IFtdO1xuXG4gICAgZG8ge1xuICAgICAgcHJvcHMucHVzaC5hcHBseShwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKSk7XG4gICAgfSB3aGlsZSAob2JqID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpO1xuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9LFxuXG4gIGxpbmVzVG9TdHJpbmcobGluZXMpIHtcbiAgICBpZiAobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJztcXG4nKSArICc7XFxuJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdcXG4nO1xuICAgIH1cbiAgfSxcbiAgd2FybkRlcHJlY2F0ZWQodHlwZSwgb2xkTmFtZSwgbmV3TmFtZSkge1xuICAgIGlmIChuZXdOYW1lKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFlvdSBhcmUgdXNpbmcgYSBkZXByZWNhdGVkICR7IHR5cGUgfSBcIiR7IG9sZE5hbWUgfVwiLiBJdCBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIFwiJHsgbmV3TmFtZSB9XCIuIEZpeGluZywgYnV0IHBsZWFzZSB1cGdyYWRlIGFzIGl0IHdpbGwgc29vbiBiZSByZW1vdmVkLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oYFlvdSBhcmUgdXNpbmcgYSBkZXByZWNhdGVkICR7IHR5cGUgfSBcIiR7IG9sZE5hbWUgfVwiLiBJdCBoYXMgYmVlbiByZW1vdmVkLiBGaXhpbmcsIGJ1dCBwbGVhc2UgdXBncmFkZSBhcyBpdCB3aWxsIHNvb24gYmUgcmVtb3ZlZC5gKTtcbiAgICB9XG4gIH0sXG4gIGZsaXBQaXhlbHM6IChwaXhlbHMsIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMiB8IDA7IFxuICAgIGNvbnN0IGJ5dGVzUGVyUm93ID0gd2lkdGggKiA0O1xuICAgIGNvbnN0IHRlbXAgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiA0KTtcbiAgICBjb25zdCByZXN1bHQgPSBwaXhlbHMuc2xpY2UoMCk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoYWxmSGVpZ2h0OyArK3kpIHtcbiAgICAgIGNvbnN0IHRvcE9mZnNldCA9IHkgKiBieXRlc1BlclJvdztcbiAgICAgIGNvbnN0IGJvdHRvbU9mZnNldCA9IChoZWlnaHQgLSB5IC0gMSkgKiBieXRlc1BlclJvdztcblxuICAgICAgdGVtcC5zZXQocmVzdWx0LnN1YmFycmF5KHRvcE9mZnNldCwgdG9wT2Zmc2V0ICsgYnl0ZXNQZXJSb3cpKTtcblxuICAgICAgcmVzdWx0LmNvcHlXaXRoaW4odG9wT2Zmc2V0LCBib3R0b21PZmZzZXQsIGJvdHRvbU9mZnNldCArIGJ5dGVzUGVyUm93KTtcblxuICAgICAgcmVzdWx0LnNldCh0ZW1wLCBib3R0b21PZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBlcmVjdFBhY2tlZEZsb2F0OiAoYXJyYXksIHdpZHRoKSA9PiB7XG4gICAgcmV0dXJuIGFycmF5LnN1YmFycmF5KDAsIHdpZHRoKTtcbiAgfSxcbiAgZXJlY3QyRFBhY2tlZEZsb2F0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHhTdGFydCA9IHkgKiB3aWR0aDtcbiAgICAgIGNvbnN0IHhFbmQgPSB4U3RhcnQgKyB3aWR0aDtcbiAgICAgIHlSZXN1bHRzW3ldID0gYXJyYXkuc3ViYXJyYXkoeFN0YXJ0LCB4RW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdDNEUGFja2VkRmxvYXQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpID0+IHtcbiAgICBjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBkZXB0aDsgeisrKSB7XG4gICAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBjb25zdCB4U3RhcnQgPSAoeiAqIGhlaWdodCAqIHdpZHRoKSArIHkgKiB3aWR0aDtcbiAgICAgICAgY29uc3QgeEVuZCA9IHhTdGFydCArIHdpZHRoO1xuICAgICAgICB5UmVzdWx0c1t5XSA9IGFycmF5LnN1YmFycmF5KHhTdGFydCwgeEVuZCk7XG4gICAgICB9XG4gICAgICB6UmVzdWx0c1t6XSA9IHlSZXN1bHRzO1xuICAgIH1cbiAgICByZXR1cm4gelJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0TWVtb3J5T3B0aW1pemVkRmxvYXQ6IChhcnJheSwgd2lkdGgpID0+IHtcbiAgICByZXR1cm4gYXJyYXkuc3ViYXJyYXkoMCwgd2lkdGgpO1xuICB9LFxuICBlcmVjdE1lbW9yeU9wdGltaXplZDJERmxvYXQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHdpZHRoO1xuICAgICAgeVJlc3VsdHNbeV0gPSBhcnJheS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHdpZHRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdE1lbW9yeU9wdGltaXplZDNERmxvYXQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpID0+IHtcbiAgICBjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBkZXB0aDsgeisrKSB7XG4gICAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoeiAqIGhlaWdodCAqIHdpZHRoKSArICh5ICogd2lkdGgpO1xuICAgICAgICB5UmVzdWx0c1t5XSA9IGFycmF5LnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgd2lkdGgpO1xuICAgICAgfVxuICAgICAgelJlc3VsdHNbel0gPSB5UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHpSZXN1bHRzO1xuICB9LFxuICBlcmVjdEZsb2F0OiAoYXJyYXksIHdpZHRoKSA9PiB7XG4gICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICB4UmVzdWx0c1t4XSA9IGFycmF5W2ldO1xuICAgICAgaSArPSA0O1xuICAgIH1cbiAgICByZXR1cm4geFJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0MkRGbG9hdDogKGFycmF5LCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoKTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICB4UmVzdWx0c1t4XSA9IGFycmF5W2ldO1xuICAgICAgICBpICs9IDQ7XG4gICAgICB9XG4gICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgIH1cbiAgICByZXR1cm4geVJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0M0RGbG9hdDogKGFycmF5LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCkgPT4ge1xuICAgIGNvbnN0IHpSZXN1bHRzID0gbmV3IEFycmF5KGRlcHRoKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBkZXB0aDsgeisrKSB7XG4gICAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBGbG9hdDMyQXJyYXkod2lkdGgpO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICB4UmVzdWx0c1t4XSA9IGFycmF5W2ldO1xuICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgICAgfVxuICAgICAgelJlc3VsdHNbel0gPSB5UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHpSZXN1bHRzO1xuICB9LFxuICBlcmVjdEFycmF5MjogKGFycmF5LCB3aWR0aCkgPT4ge1xuICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCwgeCArIDIpO1xuICAgIH1cbiAgICByZXR1cm4geFJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0MkRBcnJheTI6IChhcnJheSwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgY29uc3QgWFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIFhSZXN1bHRzTWF4O1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBYUmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgMik7XG4gICAgICB9XG4gICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgIH1cbiAgICByZXR1cm4geVJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0M0RBcnJheTI6IChhcnJheSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBkZXB0aDsgeisrKSB7XG4gICAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9ICh6ICogeFJlc3VsdHNNYXggKiBoZWlnaHQpICsgKHkgKiB4UmVzdWx0c01heCk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHggKyBvZmZzZXQsIHggKyBvZmZzZXQgKyAyKTtcbiAgICAgICAgfVxuICAgICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgICAgfVxuICAgICAgelJlc3VsdHNbel0gPSB5UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHpSZXN1bHRzO1xuICB9LFxuICBlcmVjdEFycmF5MzogKGFycmF5LCB3aWR0aCkgPT4ge1xuICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCwgeCArIDMpO1xuICAgIH1cbiAgICByZXR1cm4geFJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0MkRBcnJheTM6IChhcnJheSwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHhSZXN1bHRzTWF4ID0gd2lkdGggKiA0O1xuICAgIGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHhSZXN1bHRzTWF4O1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgMyk7XG4gICAgICB9XG4gICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgIH1cbiAgICByZXR1cm4geVJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0M0RBcnJheTM6IChhcnJheSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBkZXB0aDsgeisrKSB7XG4gICAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9ICh6ICogeFJlc3VsdHNNYXggKiBoZWlnaHQpICsgKHkgKiB4UmVzdWx0c01heCk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHggKyBvZmZzZXQsIHggKyBvZmZzZXQgKyAzKTtcbiAgICAgICAgfVxuICAgICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgICAgfVxuICAgICAgelJlc3VsdHNbel0gPSB5UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHpSZXN1bHRzO1xuICB9LFxuICBlcmVjdEFycmF5NDogKGFycmF5LCB3aWR0aCkgPT4ge1xuICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KGFycmF5KTtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCwgeCArIDQpO1xuICAgIH1cbiAgICByZXR1cm4geFJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0MkRBcnJheTQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHhSZXN1bHRzTWF4ID0gd2lkdGggKiA0O1xuICAgIGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHhSZXN1bHRzTWF4O1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgNCk7XG4gICAgICB9XG4gICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgIH1cbiAgICByZXR1cm4geVJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0M0RBcnJheTQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBkZXB0aDsgeisrKSB7XG4gICAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9ICh6ICogeFJlc3VsdHNNYXggKiBoZWlnaHQpICsgKHkgKiB4UmVzdWx0c01heCk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHggKyBvZmZzZXQsIHggKyBvZmZzZXQgKyA0KTtcbiAgICAgICAgfVxuICAgICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgICAgfVxuICAgICAgelJlc3VsdHNbel0gPSB5UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHpSZXN1bHRzO1xuICB9LFxuXG4gIGZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nOiAoc291cmNlLCBzZXR0aW5ncykgPT4ge1xuICAgIGNvbnN0IHsgZmluZERlcGVuZGVuY3ksIHRoaXNMb29rdXAsIGRvTm90RGVmaW5lIH0gPSBzZXR0aW5ncztcbiAgICBsZXQgZmxhdHRlbmVkID0gc2V0dGluZ3MuZmxhdHRlbmVkO1xuICAgIGlmICghZmxhdHRlbmVkKSB7XG4gICAgICBmbGF0dGVuZWQgPSBzZXR0aW5ncy5mbGF0dGVuZWQgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgYXN0ID0gYWNvcm4ucGFyc2Uoc291cmNlKTtcbiAgICBjb25zdCBmdW5jdGlvbkRlcGVuZGVuY2llcyA9IFtdO1xuICAgIGxldCBpbmRlbnQgPSAwO1xuXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhc3QpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChmbGF0dGVuKGFzdFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzLmpvaW4oJycpO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChhc3QudHlwZSkge1xuICAgICAgICBjYXNlICdQcm9ncmFtJzpcbiAgICAgICAgICByZXR1cm4gZmxhdHRlbihhc3QuYm9keSkgKyAoYXN0LmJvZHlbMF0udHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRpb24nID8gJzsnIDogJycpO1xuICAgICAgICBjYXNlICdGdW5jdGlvbkRlY2xhcmF0aW9uJzpcbiAgICAgICAgICByZXR1cm4gYGZ1bmN0aW9uICR7YXN0LmlkLm5hbWV9KCR7YXN0LnBhcmFtcy5tYXAoZmxhdHRlbikuam9pbignLCAnKX0pICR7IGZsYXR0ZW4oYXN0LmJvZHkpIH1gO1xuICAgICAgICBjYXNlICdCbG9ja1N0YXRlbWVudCc6IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICBpbmRlbnQgKz0gMjtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBmbGF0ID0gZmxhdHRlbihhc3QuYm9keVtpXSk7XG4gICAgICAgICAgICBpZiAoZmxhdCkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCgnICcucmVwZWF0KGluZGVudCkgKyBmbGF0LCAnO1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRlbnQgLT0gMjtcbiAgICAgICAgICByZXR1cm4gYHtcXG4ke3Jlc3VsdC5qb2luKCcnKX19YDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcbiAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSB1dGlscy5ub3JtYWxpemVEZWNsYXJhdGlvbnMoYXN0KVxuICAgICAgICAgICAgLm1hcChmbGF0dGVuKVxuICAgICAgICAgICAgLmZpbHRlcihyID0+IHIgIT09IG51bGwpO1xuICAgICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YXN0LmtpbmR9ICR7ZGVjbGFyYXRpb25zLmpvaW4oJywnKX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0b3InOlxuICAgICAgICAgICAgaWYgKGFzdC5pbml0Lm9iamVjdCAmJiBhc3QuaW5pdC5vYmplY3QudHlwZSA9PT0gJ1RoaXNFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICBjb25zdCBsb29rdXAgPSB0aGlzTG9va3VwKGFzdC5pbml0LnByb3BlcnR5Lm5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICBpZiAobG9va3VwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2FzdC5pZC5uYW1lfSA9ICR7ZmxhdHRlbihhc3QuaW5pdCl9YDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGAke2FzdC5pZC5uYW1lfSA9ICR7ZmxhdHRlbihhc3QuaW5pdCl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzoge1xuICAgICAgICAgICAgICBpZiAoYXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lID09PSAnc3ViYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2ZsYXR0ZW4oYXN0LmNhbGxlZS5vYmplY3QpfS4ke2ZsYXR0ZW4oYXN0LmNhbGxlZS5wcm9wZXJ0eSl9KCR7YXN0LmFyZ3VtZW50cy5tYXAodmFsdWUgPT4gZmxhdHRlbih2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGFzdC5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdnbCcgfHwgYXN0LmNhbGxlZS5vYmplY3QubmFtZSA9PT0gJ2NvbnRleHQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2ZsYXR0ZW4oYXN0LmNhbGxlZS5vYmplY3QpfS4ke2ZsYXR0ZW4oYXN0LmNhbGxlZS5wcm9wZXJ0eSl9KCR7YXN0LmFyZ3VtZW50cy5tYXAodmFsdWUgPT4gZmxhdHRlbih2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGFzdC5jYWxsZWUub2JqZWN0LnR5cGUgPT09ICdUaGlzRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkRlcGVuZGVuY2llcy5wdXNoKGZpbmREZXBlbmRlbmN5KCd0aGlzJywgYXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2FzdC5jYWxsZWUucHJvcGVydHkubmFtZX0oJHthc3QuYXJndW1lbnRzLm1hcCh2YWx1ZSA9PiBmbGF0dGVuKHZhbHVlKSkuam9pbignLCAnKX0pYDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhc3QuY2FsbGVlLm9iamVjdC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmRTb3VyY2UgPSBmaW5kRGVwZW5kZW5jeShhc3QuY2FsbGVlLm9iamVjdC5uYW1lLCBhc3QuY2FsbGVlLnByb3BlcnR5Lm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZFNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2FzdC5jYWxsZWUub2JqZWN0Lm5hbWV9LiR7YXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lfSgke2FzdC5hcmd1bWVudHMubWFwKHZhbHVlID0+IGZsYXR0ZW4odmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlcGVuZGVuY2llcy5wdXNoKGZvdW5kU291cmNlKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHthc3QuY2FsbGVlLnByb3BlcnR5Lm5hbWV9KCR7YXN0LmFyZ3VtZW50cy5tYXAodmFsdWUgPT4gZmxhdHRlbih2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFzdC5jYWxsZWUub2JqZWN0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5jYWxsZWUub2JqZWN0KX0uJHthc3QuY2FsbGVlLnByb3BlcnR5Lm5hbWV9KCR7YXN0LmFyZ3VtZW50cy5tYXAodmFsdWUgPT4gZmxhdHRlbih2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGFzdC5jYWxsZWUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnUmV0dXJuU3RhdGVtZW50JzpcbiAgICAgICAgICAgICAgcmV0dXJuIGByZXR1cm4gJHtmbGF0dGVuKGFzdC5hcmd1bWVudCl9YDtcbiAgICAgICAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICByZXR1cm4gYCgke2ZsYXR0ZW4oYXN0LmxlZnQpfSR7YXN0Lm9wZXJhdG9yfSR7ZmxhdHRlbihhc3QucmlnaHQpfSlgO1xuICAgICAgICAgICAgY2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgaWYgKGFzdC5wcmVmaXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7YXN0Lm9wZXJhdG9yfSAke2ZsYXR0ZW4oYXN0LmFyZ3VtZW50KX1gO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5hcmd1bWVudCl9ICR7YXN0Lm9wZXJhdG9yfWA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnRXhwcmVzc2lvblN0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2ZsYXR0ZW4oYXN0LmV4cHJlc3Npb24pfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ1NlcXVlbmNlRXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAoJHtmbGF0dGVuKGFzdC5leHByZXNzaW9ucyl9KWA7XG4gICAgICAgICAgICAgIGNhc2UgJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCgke2FzdC5wYXJhbXMubWFwKGZsYXR0ZW4pLmpvaW4oJywgJyl9KSA9PiAke2ZsYXR0ZW4oYXN0LmJvZHkpfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ0xpdGVyYWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhc3QucmF3O1xuICAgICAgICAgICAgICBjYXNlICdJZGVudGlmaWVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN0Lm5hbWU7XG4gICAgICAgICAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIGlmIChhc3Qub2JqZWN0LnR5cGUgPT09ICdUaGlzRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzTG9va3VwKGFzdC5wcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFzdC5jb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2ZsYXR0ZW4oYXN0Lm9iamVjdCl9WyR7ZmxhdHRlbihhc3QucHJvcGVydHkpfV1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbihhc3Qub2JqZWN0KSArICcuJyArIGZsYXR0ZW4oYXN0LnByb3BlcnR5KTtcbiAgICAgICAgICAgICAgY2FzZSAnVGhpc0V4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiAndGhpcyc7XG4gICAgICAgICAgICAgIGNhc2UgJ05ld0V4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBgbmV3ICR7ZmxhdHRlbihhc3QuY2FsbGVlKX0oJHthc3QuYXJndW1lbnRzLm1hcCh2YWx1ZSA9PiBmbGF0dGVuKHZhbHVlKSkuam9pbignLCAnKX0pYDtcbiAgICAgICAgICAgICAgY2FzZSAnRm9yU3RhdGVtZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYGZvciAoJHtmbGF0dGVuKGFzdC5pbml0KX07JHtmbGF0dGVuKGFzdC50ZXN0KX07JHtmbGF0dGVuKGFzdC51cGRhdGUpfSkgJHtmbGF0dGVuKGFzdC5ib2R5KX1gO1xuICAgICAgICAgICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2ZsYXR0ZW4oYXN0LmxlZnQpfSR7YXN0Lm9wZXJhdG9yfSR7ZmxhdHRlbihhc3QucmlnaHQpfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5hcmd1bWVudCl9JHthc3Qub3BlcmF0b3J9YDtcbiAgICAgICAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBgaWYgKCR7ZmxhdHRlbihhc3QudGVzdCl9KSAke2ZsYXR0ZW4oYXN0LmNvbnNlcXVlbnQpfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ1Rocm93U3RhdGVtZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYHRocm93ICR7ZmxhdHRlbihhc3QuYXJndW1lbnQpfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ09iamVjdFBhdHRlcm4nOlxuICAgICAgICAgICAgICAgIHJldHVybiBhc3QucHJvcGVydGllcy5tYXAoZmxhdHRlbikuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgY2FzZSAnQXJyYXlQYXR0ZXJuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN0LmVsZW1lbnRzLm1hcChmbGF0dGVuKS5qb2luKCcsICcpO1xuICAgICAgICAgICAgICBjYXNlICdEZWJ1Z2dlclN0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkZWJ1Z2dlcjsnO1xuICAgICAgICAgICAgICBjYXNlICdDb25kaXRpb25hbEV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC50ZXN0KX0/JHtmbGF0dGVuKGFzdC5jb25zZXF1ZW50KX06JHtmbGF0dGVuKGFzdC5hbHRlcm5hdGUpfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ1Byb3BlcnR5JzpcbiAgICAgICAgICAgICAgICBpZiAoYXN0LmtpbmQgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW4oYXN0LmtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgYXN0LnR5cGUgb2YgJHsgYXN0LnR5cGUgfWApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBmbGF0dGVuKGFzdCk7XG4gICAgaWYgKGZ1bmN0aW9uRGVwZW5kZW5jaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGZsYXR0ZW5lZEZ1bmN0aW9uRGVwZW5kZW5jaWVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9uRGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uRGVwZW5kZW5jeSA9IGZ1bmN0aW9uRGVwZW5kZW5jaWVzW2ldO1xuICAgICAgICBpZiAoIWZsYXR0ZW5lZFtmdW5jdGlvbkRlcGVuZGVuY3ldKSB7XG4gICAgICAgICAgZmxhdHRlbmVkW2Z1bmN0aW9uRGVwZW5kZW5jeV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZsYXR0ZW5lZEZ1bmN0aW9uRGVwZW5kZW5jaWVzLnB1c2godXRpbHMuZmxhdHRlbkZ1bmN0aW9uVG9TdHJpbmcoZnVuY3Rpb25EZXBlbmRlbmN5LCBzZXR0aW5ncykgKyAnXFxuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmxhdHRlbmVkRnVuY3Rpb25EZXBlbmRlbmNpZXMuam9pbignJykgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgbm9ybWFsaXplRGVjbGFyYXRpb25zOiAoYXN0KSA9PiB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnVmFyaWFibGVEZWNsYXJhdGlvbicpIHRocm93IG5ldyBFcnJvcignQXN0IGlzIG5vdCBvZiB0eXBlIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiJyk7XG4gICAgY29uc3Qgbm9ybWFsaXplZERlY2xhcmF0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGRlY2xhcmF0aW9uSW5kZXggPSAwOyBkZWNsYXJhdGlvbkluZGV4IDwgYXN0LmRlY2xhcmF0aW9ucy5sZW5ndGg7IGRlY2xhcmF0aW9uSW5kZXgrKykge1xuICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBhc3QuZGVjbGFyYXRpb25zW2RlY2xhcmF0aW9uSW5kZXhdO1xuICAgICAgaWYgKGRlY2xhcmF0aW9uLmlkICYmIGRlY2xhcmF0aW9uLmlkLnR5cGUgPT09ICdPYmplY3RQYXR0ZXJuJyAmJiBkZWNsYXJhdGlvbi5pZC5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gZGVjbGFyYXRpb24uaWQ7XG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5SW5kZXggPSAwOyBwcm9wZXJ0eUluZGV4IDwgcHJvcGVydGllcy5sZW5ndGg7IHByb3BlcnR5SW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gcHJvcGVydGllc1twcm9wZXJ0eUluZGV4XTtcbiAgICAgICAgICBpZiAocHJvcGVydHkudmFsdWUudHlwZSA9PT0gJ09iamVjdFBhdHRlcm4nICYmIHByb3BlcnR5LnZhbHVlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHN1YlByb3BlcnR5SW5kZXggPSAwOyBzdWJQcm9wZXJ0eUluZGV4IDwgcHJvcGVydHkudmFsdWUucHJvcGVydGllcy5sZW5ndGg7IHN1YlByb3BlcnR5SW5kZXgrKykge1xuICAgICAgICAgICAgICBjb25zdCBzdWJQcm9wZXJ0eSA9IHByb3BlcnR5LnZhbHVlLnByb3BlcnRpZXNbc3ViUHJvcGVydHlJbmRleF07XG4gICAgICAgICAgICAgIGlmIChzdWJQcm9wZXJ0eS50eXBlID09PSAnUHJvcGVydHknKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZERlY2xhcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdWJQcm9wZXJ0eS5rZXkubmFtZVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBkZWNsYXJhdGlvbi5pbml0LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eS5rZXkubmFtZVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHN1YlByb3BlcnR5LmtleS5uYW1lXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBzdGF0ZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eS52YWx1ZS50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWREZWNsYXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eS52YWx1ZSAmJiBwcm9wZXJ0eS52YWx1ZS5uYW1lID8gcHJvcGVydHkudmFsdWUubmFtZSA6IHByb3BlcnR5LmtleS5uYW1lXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBkZWNsYXJhdGlvbi5pbml0LFxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eS5rZXkubmFtZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgc3RhdGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGVjbGFyYXRpb24uaWQgJiYgZGVjbGFyYXRpb24uaWQudHlwZSA9PT0gJ0FycmF5UGF0dGVybicgJiYgZGVjbGFyYXRpb24uaWQuZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50cyB9ID0gZGVjbGFyYXRpb24uaWQ7XG4gICAgICAgIGZvciAobGV0IGVsZW1lbnRJbmRleCA9IDA7IGVsZW1lbnRJbmRleCA8IGVsZW1lbnRzLmxlbmd0aDsgZWxlbWVudEluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbZWxlbWVudEluZGV4XTtcbiAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWREZWNsYXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICBuYW1lOiBlbGVtZW50Lm5hbWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaW5pdDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IGRlY2xhcmF0aW9uLmluaXQsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdMaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBlbGVtZW50SW5kZXgsXG4gICAgICAgICAgICAgICAgICByYXc6IGVsZW1lbnRJbmRleC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IGVsZW1lbnQuc3RhcnQsXG4gICAgICAgICAgICAgICAgICBlbmQ6IGVsZW1lbnQuZW5kXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHN0YXRlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkRGVjbGFyYXRpb25zLnB1c2goZGVjbGFyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZERlY2xhcmF0aW9ucztcbiAgfSxcblxuICBzcGxpdEhUTUxJbWFnZVRvUkdCOiAoZ3B1LCBpbWFnZSkgPT4ge1xuICAgIGNvbnN0IHJLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gYVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHJldHVybiBwaXhlbC5yICogMjU1O1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHRdLFxuICAgICAgcHJlY2lzaW9uOiAndW5zaWduZWQnLFxuICAgICAgYXJndW1lbnRUeXBlczogeyBhOiAnSFRNTEltYWdlJyB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGdLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gYVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHJldHVybiBwaXhlbC5nICogMjU1O1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHRdLFxuICAgICAgcHJlY2lzaW9uOiAndW5zaWduZWQnLFxuICAgICAgYXJndW1lbnRUeXBlczogeyBhOiAnSFRNTEltYWdlJyB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGJLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gYVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHJldHVybiBwaXhlbC5iICogMjU1O1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHRdLFxuICAgICAgcHJlY2lzaW9uOiAndW5zaWduZWQnLFxuICAgICAgYXJndW1lbnRUeXBlczogeyBhOiAnSFRNTEltYWdlJyB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGFLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gYVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHJldHVybiBwaXhlbC5hICogMjU1O1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHRdLFxuICAgICAgcHJlY2lzaW9uOiAndW5zaWduZWQnLFxuICAgICAgYXJndW1lbnRUeXBlczogeyBhOiAnSFRNTEltYWdlJyB9LFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtcbiAgICAgIHJLZXJuZWwoaW1hZ2UpLFxuICAgICAgZ0tlcm5lbChpbWFnZSksXG4gICAgICBiS2VybmVsKGltYWdlKSxcbiAgICAgIGFLZXJuZWwoaW1hZ2UpLFxuICAgIF07XG4gICAgcmVzdWx0LnJLZXJuZWwgPSByS2VybmVsO1xuICAgIHJlc3VsdC5nS2VybmVsID0gZ0tlcm5lbDtcbiAgICByZXN1bHQuYktlcm5lbCA9IGJLZXJuZWw7XG4gICAgcmVzdWx0LmFLZXJuZWwgPSBhS2VybmVsO1xuICAgIHJlc3VsdC5ncHUgPSBncHU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBzcGxpdFJHQkFUb0NhbnZhc2VzOiAoZ3B1LCByZ2JhLCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdmlzdWFsS2VybmVsUiA9IGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24odikge1xuICAgICAgY29uc3QgcGl4ZWwgPSB2W3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgdGhpcy5jb2xvcihwaXhlbC5yIC8gMjU1LCAwLCAwLCAyNTUpO1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgZ3JhcGhpY2FsOiB0cnVlLFxuICAgICAgYXJndW1lbnRUeXBlczogeyB2OiAnQXJyYXkyRCg0KScgfVxuICAgIH0pO1xuICAgIHZpc3VhbEtlcm5lbFIocmdiYSk7XG5cbiAgICBjb25zdCB2aXN1YWxLZXJuZWxHID0gZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbih2KSB7XG4gICAgICBjb25zdCBwaXhlbCA9IHZbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICB0aGlzLmNvbG9yKDAsIHBpeGVsLmcgLyAyNTUsIDAsIDI1NSk7XG4gICAgfSwge1xuICAgICAgb3V0cHV0OiBbd2lkdGgsIGhlaWdodF0sXG4gICAgICBncmFwaGljYWw6IHRydWUsXG4gICAgICBhcmd1bWVudFR5cGVzOiB7IHY6ICdBcnJheTJEKDQpJyB9XG4gICAgfSk7XG4gICAgdmlzdWFsS2VybmVsRyhyZ2JhKTtcblxuICAgIGNvbnN0IHZpc3VhbEtlcm5lbEIgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKHYpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gdlt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHRoaXMuY29sb3IoMCwgMCwgcGl4ZWwuYiAvIDI1NSwgMjU1KTtcbiAgICB9LCB7XG4gICAgICBvdXRwdXQ6IFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgIGdyYXBoaWNhbDogdHJ1ZSxcbiAgICAgIGFyZ3VtZW50VHlwZXM6IHsgdjogJ0FycmF5MkQoNCknIH1cbiAgICB9KTtcbiAgICB2aXN1YWxLZXJuZWxCKHJnYmEpO1xuXG4gICAgY29uc3QgdmlzdWFsS2VybmVsQSA9IGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24odikge1xuICAgICAgY29uc3QgcGl4ZWwgPSB2W3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgdGhpcy5jb2xvcigyNTUsIDI1NSwgMjU1LCBwaXhlbC5hIC8gMjU1KTtcbiAgICB9LCB7XG4gICAgICBvdXRwdXQ6IFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgIGdyYXBoaWNhbDogdHJ1ZSxcbiAgICAgIGFyZ3VtZW50VHlwZXM6IHsgdjogJ0FycmF5MkQoNCknIH1cbiAgICB9KTtcbiAgICB2aXN1YWxLZXJuZWxBKHJnYmEpO1xuICAgIHJldHVybiBbXG4gICAgICB2aXN1YWxLZXJuZWxSLmNhbnZhcyxcbiAgICAgIHZpc3VhbEtlcm5lbEcuY2FudmFzLFxuICAgICAgdmlzdWFsS2VybmVsQi5jYW52YXMsXG4gICAgICB2aXN1YWxLZXJuZWxBLmNhbnZhcyxcbiAgICBdO1xuICB9LFxuXG4gIGdldE1pbmlmeVNhZmVOYW1lOiAoZm4pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXN0ID0gYWNvcm4ucGFyc2UoYGNvbnN0IHZhbHVlID0gJHtmbi50b1N0cmluZygpfWApO1xuICAgICAgY29uc3QgeyBpbml0IH0gPSBhc3QuYm9keVswXS5kZWNsYXJhdGlvbnNbMF07XG4gICAgICByZXR1cm4gaW5pdC5ib2R5Lm5hbWUgfHwgaW5pdC5ib2R5LmJvZHlbMF0uYXJndW1lbnQubmFtZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBmdW5jdGlvbiB0eXBlLiAgUGxlYXNlIHVzZSBgKCkgPT4geW91ckZ1bmN0aW9uVmFyaWFibGVIZXJlYCBvciBmdW5jdGlvbigpIHsgcmV0dXJuIHlvdXJGdW5jdGlvblZhcmlhYmxlSGVyZTsgfScpO1xuICAgIH1cbiAgfSxcbiAgc2FuaXRpemVOYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKGRvbGxhclNpZ24udGVzdChuYW1lKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkb2xsYXJTaWduLCAnU19TJyk7XG4gICAgfVxuICAgIGlmIChkb3VibGVVbmRlcnNjb3JlLnRlc3QobmFtZSkpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZG91YmxlVW5kZXJzY29yZSwgJ1VfVScpO1xuICAgIH0gZWxzZSBpZiAoc2luZ2xlVW5kZXJzY29yZS50ZXN0KG5hbWUpKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKHNpbmdsZVVuZGVyc2NvcmUsICd1X3UnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbn07XG5cbmNvbnN0IGRvbGxhclNpZ24gPSAvXFwkLztcbmNvbnN0IGRvdWJsZVVuZGVyc2NvcmUgPSAvX18vO1xuY29uc3Qgc2luZ2xlVW5kZXJzY29yZSA9IC9fLztcblxuY29uc3QgX3N5c3RlbUVuZGlhbm5lc3MgPSB1dGlscy5nZXRTeXN0ZW1FbmRpYW5uZXNzKCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB1dGlsc1xufTtcbn0se1wiLi9pbnB1dFwiOjExMCxcIi4vdGV4dHVyZVwiOjExMyxcImFjb3JuXCI6MX1dfSx7fSxbMTA3XSkoMTA3KVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gaXNBbnlBcnJheShvYmplY3QpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqZWN0KS5lbmRzV2l0aCgnQXJyYXldJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBbnlBcnJheTtcbiIsImltcG9ydCBpc0FycmF5IGZyb20gJ2lzLWFueS1hcnJheSc7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIG1heGltdW0gb2YgdGhlIGdpdmVuIHZhbHVlc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIG1heChpbnB1dCkge1xuICBpZiAoIWlzQXJyYXkoaW5wdXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5wdXQgbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG5cbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICB2YXIgbWF4VmFsdWUgPSBpbnB1dFswXTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlucHV0W2ldID4gbWF4VmFsdWUpIG1heFZhbHVlID0gaW5wdXRbaV07XG4gIH1cblxuICByZXR1cm4gbWF4VmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1heDtcbiIsImltcG9ydCBpc0FycmF5IGZyb20gJ2lzLWFueS1hcnJheSc7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gb2YgdGhlIGdpdmVuIHZhbHVlc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIG1pbihpbnB1dCkge1xuICBpZiAoIWlzQXJyYXkoaW5wdXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5wdXQgbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG5cbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICB2YXIgbWluVmFsdWUgPSBpbnB1dFswXTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlucHV0W2ldIDwgbWluVmFsdWUpIG1pblZhbHVlID0gaW5wdXRbaV07XG4gIH1cblxuICByZXR1cm4gbWluVmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1pbjtcbiIsImltcG9ydCBpc0FycmF5IGZyb20gJ2lzLWFueS1hcnJheSc7XG5pbXBvcnQgbWF4IGZyb20gJ21sLWFycmF5LW1heCc7XG5pbXBvcnQgbWluIGZyb20gJ21sLWFycmF5LW1pbic7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGlucHV0XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5vdXRwdXQ9W11dIHNwZWNpZnkgdGhlIG91dHB1dCBhcnJheSwgY2FuIGJlIHRoZSBpbnB1dCBhcnJheSBmb3IgaW4gcGxhY2UgbW9kaWZpY2F0aW9uXG4gKi9cblxuZnVuY3Rpb24gcmVzY2FsZShpbnB1dCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgaWYgKCFpc0FycmF5KGlucHV0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IG11c3QgYmUgYW4gYXJyYXknKTtcbiAgfSBlbHNlIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnB1dCBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgdmFyIG91dHB1dDtcblxuICBpZiAob3B0aW9ucy5vdXRwdXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghaXNBcnJheShvcHRpb25zLm91dHB1dCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ291dHB1dCBvcHRpb24gbXVzdCBiZSBhbiBhcnJheSBpZiBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICBvdXRwdXQgPSBvcHRpb25zLm91dHB1dDtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50TWluID0gbWluKGlucHV0KTtcbiAgdmFyIGN1cnJlbnRNYXggPSBtYXgoaW5wdXQpO1xuXG4gIGlmIChjdXJyZW50TWluID09PSBjdXJyZW50TWF4KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pbmltdW0gYW5kIG1heGltdW0gaW5wdXQgdmFsdWVzIGFyZSBlcXVhbC4gQ2Fubm90IHJlc2NhbGUgYSBjb25zdGFudCBhcnJheScpO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1pbiA9IG9wdGlvbnMubWluLFxuICAgICAgbWluVmFsdWUgPSBfb3B0aW9ucyRtaW4gPT09IHZvaWQgMCA/IG9wdGlvbnMuYXV0b01pbk1heCA/IGN1cnJlbnRNaW4gOiAwIDogX29wdGlvbnMkbWluLFxuICAgICAgX29wdGlvbnMkbWF4ID0gb3B0aW9ucy5tYXgsXG4gICAgICBtYXhWYWx1ZSA9IF9vcHRpb25zJG1heCA9PT0gdm9pZCAwID8gb3B0aW9ucy5hdXRvTWluTWF4ID8gY3VycmVudE1heCA6IDEgOiBfb3B0aW9ucyRtYXg7XG5cbiAgaWYgKG1pblZhbHVlID49IG1heFZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pbiBvcHRpb24gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4IG9wdGlvbicpO1xuICB9XG5cbiAgdmFyIGZhY3RvciA9IChtYXhWYWx1ZSAtIG1pblZhbHVlKSAvIChjdXJyZW50TWF4IC0gY3VycmVudE1pbik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFtpXSA9IChpbnB1dFtpXSAtIGN1cnJlbnRNaW4pICogZmFjdG9yICsgbWluVmFsdWU7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5leHBvcnQgZGVmYXVsdCByZXNjYWxlO1xuIiwiaW1wb3J0IE1hdHJpeCBmcm9tICcuL21hdHJpeCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3JyZWxhdGlvbih4TWF0cml4LCB5TWF0cml4ID0geE1hdHJpeCwgb3B0aW9ucyA9IHt9KSB7XG4gIHhNYXRyaXggPSBuZXcgTWF0cml4KHhNYXRyaXgpO1xuICBsZXQgeUlzU2FtZSA9IGZhbHNlO1xuICBpZiAoXG4gICAgdHlwZW9mIHlNYXRyaXggPT09ICdvYmplY3QnICYmXG4gICAgIU1hdHJpeC5pc01hdHJpeCh5TWF0cml4KSAmJlxuICAgICFBcnJheS5pc0FycmF5KHlNYXRyaXgpXG4gICkge1xuICAgIG9wdGlvbnMgPSB5TWF0cml4O1xuICAgIHlNYXRyaXggPSB4TWF0cml4O1xuICAgIHlJc1NhbWUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHlNYXRyaXggPSBuZXcgTWF0cml4KHlNYXRyaXgpO1xuICB9XG4gIGlmICh4TWF0cml4LnJvd3MgIT09IHlNYXRyaXgucm93cykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvdGggbWF0cmljZXMgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiByb3dzJyk7XG4gIH1cblxuICBjb25zdCB7IGNlbnRlciA9IHRydWUsIHNjYWxlID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgaWYgKGNlbnRlcikge1xuICAgIHhNYXRyaXguY2VudGVyKCdjb2x1bW4nKTtcbiAgICBpZiAoIXlJc1NhbWUpIHtcbiAgICAgIHlNYXRyaXguY2VudGVyKCdjb2x1bW4nKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNjYWxlKSB7XG4gICAgeE1hdHJpeC5zY2FsZSgnY29sdW1uJyk7XG4gICAgaWYgKCF5SXNTYW1lKSB7XG4gICAgICB5TWF0cml4LnNjYWxlKCdjb2x1bW4nKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzZHggPSB4TWF0cml4LnN0YW5kYXJkRGV2aWF0aW9uKCdjb2x1bW4nLCB7IHVuYmlhc2VkOiB0cnVlIH0pO1xuICBjb25zdCBzZHkgPSB5SXNTYW1lXG4gICAgPyBzZHhcbiAgICA6IHlNYXRyaXguc3RhbmRhcmREZXZpYXRpb24oJ2NvbHVtbicsIHsgdW5iaWFzZWQ6IHRydWUgfSk7XG5cbiAgY29uc3QgY29yciA9IHhNYXRyaXgudHJhbnNwb3NlKCkubW11bCh5TWF0cml4KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3JyLnJvd3M7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29yci5jb2x1bW5zOyBqKyspIHtcbiAgICAgIGNvcnIuc2V0KFxuICAgICAgICBpLFxuICAgICAgICBqLFxuICAgICAgICBjb3JyLmdldChpLCBqKSAqICgxIC8gKHNkeFtpXSAqIHNkeVtqXSkpICogKDEgLyAoeE1hdHJpeC5yb3dzIC0gMSkpLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvcnI7XG59XG4iLCJpbXBvcnQgTWF0cml4IGZyb20gJy4vbWF0cml4JztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvdmFyaWFuY2UoeE1hdHJpeCwgeU1hdHJpeCA9IHhNYXRyaXgsIG9wdGlvbnMgPSB7fSkge1xuICB4TWF0cml4ID0gbmV3IE1hdHJpeCh4TWF0cml4KTtcbiAgbGV0IHlJc1NhbWUgPSBmYWxzZTtcbiAgaWYgKFxuICAgIHR5cGVvZiB5TWF0cml4ID09PSAnb2JqZWN0JyAmJlxuICAgICFNYXRyaXguaXNNYXRyaXgoeU1hdHJpeCkgJiZcbiAgICAhQXJyYXkuaXNBcnJheSh5TWF0cml4KVxuICApIHtcbiAgICBvcHRpb25zID0geU1hdHJpeDtcbiAgICB5TWF0cml4ID0geE1hdHJpeDtcbiAgICB5SXNTYW1lID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB5TWF0cml4ID0gbmV3IE1hdHJpeCh5TWF0cml4KTtcbiAgfVxuICBpZiAoeE1hdHJpeC5yb3dzICE9PSB5TWF0cml4LnJvd3MpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb3RoIG1hdHJpY2VzIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygcm93cycpO1xuICB9XG4gIGNvbnN0IHsgY2VudGVyID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgaWYgKGNlbnRlcikge1xuICAgIHhNYXRyaXggPSB4TWF0cml4LmNlbnRlcignY29sdW1uJyk7XG4gICAgaWYgKCF5SXNTYW1lKSB7XG4gICAgICB5TWF0cml4ID0geU1hdHJpeC5jZW50ZXIoJ2NvbHVtbicpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb3YgPSB4TWF0cml4LnRyYW5zcG9zZSgpLm1tdWwoeU1hdHJpeCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY292LnJvd3M7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY292LmNvbHVtbnM7IGorKykge1xuICAgICAgY292LnNldChpLCBqLCBjb3YuZ2V0KGksIGopICogKDEgLyAoeE1hdHJpeC5yb3dzIC0gMSkpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdjtcbn1cbiIsImltcG9ydCBNYXRyaXggZnJvbSAnLi4vbWF0cml4JztcbmltcG9ydCBXcmFwcGVyTWF0cml4MkQgZnJvbSAnLi4vd3JhcC9XcmFwcGVyTWF0cml4MkQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaG9sZXNreURlY29tcG9zaXRpb24ge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHZhbHVlID0gV3JhcHBlck1hdHJpeDJELmNoZWNrTWF0cml4KHZhbHVlKTtcbiAgICBpZiAoIXZhbHVlLmlzU3ltbWV0cmljKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWF0cml4IGlzIG5vdCBzeW1tZXRyaWMnKTtcbiAgICB9XG5cbiAgICBsZXQgYSA9IHZhbHVlO1xuICAgIGxldCBkaW1lbnNpb24gPSBhLnJvd3M7XG4gICAgbGV0IGwgPSBuZXcgTWF0cml4KGRpbWVuc2lvbiwgZGltZW5zaW9uKTtcbiAgICBsZXQgcG9zaXRpdmVEZWZpbml0ZSA9IHRydWU7XG4gICAgbGV0IGksIGosIGs7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgZGltZW5zaW9uOyBqKyspIHtcbiAgICAgIGxldCBkID0gMDtcbiAgICAgIGZvciAoayA9IDA7IGsgPCBqOyBrKyspIHtcbiAgICAgICAgbGV0IHMgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgICAgICAgcyArPSBsLmdldChrLCBpKSAqIGwuZ2V0KGosIGkpO1xuICAgICAgICB9XG4gICAgICAgIHMgPSAoYS5nZXQoaiwgaykgLSBzKSAvIGwuZ2V0KGssIGspO1xuICAgICAgICBsLnNldChqLCBrLCBzKTtcbiAgICAgICAgZCA9IGQgKyBzICogcztcbiAgICAgIH1cblxuICAgICAgZCA9IGEuZ2V0KGosIGopIC0gZDtcblxuICAgICAgcG9zaXRpdmVEZWZpbml0ZSAmPSBkID4gMDtcbiAgICAgIGwuc2V0KGosIGosIE1hdGguc3FydChNYXRoLm1heChkLCAwKSkpO1xuICAgICAgZm9yIChrID0gaiArIDE7IGsgPCBkaW1lbnNpb247IGsrKykge1xuICAgICAgICBsLnNldChqLCBrLCAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLkwgPSBsO1xuICAgIHRoaXMucG9zaXRpdmVEZWZpbml0ZSA9IEJvb2xlYW4ocG9zaXRpdmVEZWZpbml0ZSk7XG4gIH1cblxuICBpc1Bvc2l0aXZlRGVmaW5pdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpdmVEZWZpbml0ZTtcbiAgfVxuXG4gIHNvbHZlKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgodmFsdWUpO1xuXG4gICAgbGV0IGwgPSB0aGlzLkw7XG4gICAgbGV0IGRpbWVuc2lvbiA9IGwucm93cztcblxuICAgIGlmICh2YWx1ZS5yb3dzICE9PSBkaW1lbnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWF0cml4IGRpbWVuc2lvbnMgZG8gbm90IG1hdGNoJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzUG9zaXRpdmVEZWZpbml0ZSgpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaXggaXMgbm90IHBvc2l0aXZlIGRlZmluaXRlJyk7XG4gICAgfVxuXG4gICAgbGV0IGNvdW50ID0gdmFsdWUuY29sdW1ucztcbiAgICBsZXQgQiA9IHZhbHVlLmNsb25lKCk7XG4gICAgbGV0IGksIGosIGs7XG5cbiAgICBmb3IgKGsgPSAwOyBrIDwgZGltZW5zaW9uOyBrKyspIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICBCLnNldChrLCBqLCBCLmdldChrLCBqKSAtIEIuZ2V0KGksIGopICogbC5nZXQoaywgaSkpO1xuICAgICAgICB9XG4gICAgICAgIEIuc2V0KGssIGosIEIuZ2V0KGssIGopIC8gbC5nZXQoaywgaykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoayA9IGRpbWVuc2lvbiAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICBmb3IgKGkgPSBrICsgMTsgaSA8IGRpbWVuc2lvbjsgaSsrKSB7XG4gICAgICAgICAgQi5zZXQoaywgaiwgQi5nZXQoaywgaikgLSBCLmdldChpLCBqKSAqIGwuZ2V0KGksIGspKTtcbiAgICAgICAgfVxuICAgICAgICBCLnNldChrLCBqLCBCLmdldChrLCBqKSAvIGwuZ2V0KGssIGspKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQjtcbiAgfVxuXG4gIGdldCBsb3dlclRyaWFuZ3VsYXJNYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuTDtcbiAgfVxufVxuIiwiaW1wb3J0IE1hdHJpeCBmcm9tICcuLi9tYXRyaXgnO1xuaW1wb3J0IFdyYXBwZXJNYXRyaXgyRCBmcm9tICcuLi93cmFwL1dyYXBwZXJNYXRyaXgyRCc7XG5cbmltcG9ydCB7IGh5cG90ZW51c2UgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFaWdlbnZhbHVlRGVjb21wb3NpdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1hdHJpeCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhc3N1bWVTeW1tZXRyaWMgPSBmYWxzZSB9ID0gb3B0aW9ucztcblxuICAgIG1hdHJpeCA9IFdyYXBwZXJNYXRyaXgyRC5jaGVja01hdHJpeChtYXRyaXgpO1xuICAgIGlmICghbWF0cml4LmlzU3F1YXJlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWF0cml4IGlzIG5vdCBhIHNxdWFyZSBtYXRyaXgnKTtcbiAgICB9XG5cbiAgICBsZXQgbiA9IG1hdHJpeC5jb2x1bW5zO1xuICAgIGxldCBWID0gbmV3IE1hdHJpeChuLCBuKTtcbiAgICBsZXQgZCA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG4gICAgbGV0IGUgPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICAgIGxldCB2YWx1ZSA9IG1hdHJpeDtcbiAgICBsZXQgaSwgajtcblxuICAgIGxldCBpc1N5bW1ldHJpYyA9IGZhbHNlO1xuICAgIGlmIChhc3N1bWVTeW1tZXRyaWMpIHtcbiAgICAgIGlzU3ltbWV0cmljID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNTeW1tZXRyaWMgPSBtYXRyaXguaXNTeW1tZXRyaWMoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTeW1tZXRyaWMpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAgIFYuc2V0KGksIGosIHZhbHVlLmdldChpLCBqKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyZWQyKG4sIGUsIGQsIFYpO1xuICAgICAgdHFsMihuLCBlLCBkLCBWKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IEggPSBuZXcgTWF0cml4KG4sIG4pO1xuICAgICAgbGV0IG9ydCA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBILnNldChpLCBqLCB2YWx1ZS5nZXQoaSwgaikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcnRoZXMobiwgSCwgb3J0LCBWKTtcbiAgICAgIGhxcjIobiwgZSwgZCwgViwgSCk7XG4gICAgfVxuXG4gICAgdGhpcy5uID0gbjtcbiAgICB0aGlzLmUgPSBlO1xuICAgIHRoaXMuZCA9IGQ7XG4gICAgdGhpcy5WID0gVjtcbiAgfVxuXG4gIGdldCByZWFsRWlnZW52YWx1ZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5kKTtcbiAgfVxuXG4gIGdldCBpbWFnaW5hcnlFaWdlbnZhbHVlcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmUpO1xuICB9XG5cbiAgZ2V0IGVpZ2VudmVjdG9yTWF0cml4KCkge1xuICAgIHJldHVybiB0aGlzLlY7XG4gIH1cblxuICBnZXQgZGlhZ29uYWxNYXRyaXgoKSB7XG4gICAgbGV0IG4gPSB0aGlzLm47XG4gICAgbGV0IGUgPSB0aGlzLmU7XG4gICAgbGV0IGQgPSB0aGlzLmQ7XG4gICAgbGV0IFggPSBuZXcgTWF0cml4KG4sIG4pO1xuICAgIGxldCBpLCBqO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgWC5zZXQoaSwgaiwgMCk7XG4gICAgICB9XG4gICAgICBYLnNldChpLCBpLCBkW2ldKTtcbiAgICAgIGlmIChlW2ldID4gMCkge1xuICAgICAgICBYLnNldChpLCBpICsgMSwgZVtpXSk7XG4gICAgICB9IGVsc2UgaWYgKGVbaV0gPCAwKSB7XG4gICAgICAgIFguc2V0KGksIGkgLSAxLCBlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFg7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJlZDIobiwgZSwgZCwgVikge1xuICBsZXQgZiwgZywgaCwgaSwgaiwgaywgaGgsIHNjYWxlO1xuXG4gIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICBkW2pdID0gVi5nZXQobiAtIDEsIGopO1xuICB9XG5cbiAgZm9yIChpID0gbiAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICBzY2FsZSA9IDA7XG4gICAgaCA9IDA7XG4gICAgZm9yIChrID0gMDsgayA8IGk7IGsrKykge1xuICAgICAgc2NhbGUgPSBzY2FsZSArIE1hdGguYWJzKGRba10pO1xuICAgIH1cblxuICAgIGlmIChzY2FsZSA9PT0gMCkge1xuICAgICAgZVtpXSA9IGRbaSAtIDFdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICBkW2pdID0gVi5nZXQoaSAtIDEsIGopO1xuICAgICAgICBWLnNldChpLCBqLCAwKTtcbiAgICAgICAgVi5zZXQoaiwgaSwgMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoayA9IDA7IGsgPCBpOyBrKyspIHtcbiAgICAgICAgZFtrXSAvPSBzY2FsZTtcbiAgICAgICAgaCArPSBkW2tdICogZFtrXTtcbiAgICAgIH1cblxuICAgICAgZiA9IGRbaSAtIDFdO1xuICAgICAgZyA9IE1hdGguc3FydChoKTtcbiAgICAgIGlmIChmID4gMCkge1xuICAgICAgICBnID0gLWc7XG4gICAgICB9XG5cbiAgICAgIGVbaV0gPSBzY2FsZSAqIGc7XG4gICAgICBoID0gaCAtIGYgKiBnO1xuICAgICAgZFtpIC0gMV0gPSBmIC0gZztcbiAgICAgIGZvciAoaiA9IDA7IGogPCBpOyBqKyspIHtcbiAgICAgICAgZVtqXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBpOyBqKyspIHtcbiAgICAgICAgZiA9IGRbal07XG4gICAgICAgIFYuc2V0KGosIGksIGYpO1xuICAgICAgICBnID0gZVtqXSArIFYuZ2V0KGosIGopICogZjtcbiAgICAgICAgZm9yIChrID0gaiArIDE7IGsgPD0gaSAtIDE7IGsrKykge1xuICAgICAgICAgIGcgKz0gVi5nZXQoaywgaikgKiBkW2tdO1xuICAgICAgICAgIGVba10gKz0gVi5nZXQoaywgaikgKiBmO1xuICAgICAgICB9XG4gICAgICAgIGVbal0gPSBnO1xuICAgICAgfVxuXG4gICAgICBmID0gMDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBpOyBqKyspIHtcbiAgICAgICAgZVtqXSAvPSBoO1xuICAgICAgICBmICs9IGVbal0gKiBkW2pdO1xuICAgICAgfVxuXG4gICAgICBoaCA9IGYgLyAoaCArIGgpO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICBlW2pdIC09IGhoICogZFtqXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICBmID0gZFtqXTtcbiAgICAgICAgZyA9IGVbal07XG4gICAgICAgIGZvciAoayA9IGo7IGsgPD0gaSAtIDE7IGsrKykge1xuICAgICAgICAgIFYuc2V0KGssIGosIFYuZ2V0KGssIGopIC0gKGYgKiBlW2tdICsgZyAqIGRba10pKTtcbiAgICAgICAgfVxuICAgICAgICBkW2pdID0gVi5nZXQoaSAtIDEsIGopO1xuICAgICAgICBWLnNldChpLCBqLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZFtpXSA9IGg7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xuICAgIFYuc2V0KG4gLSAxLCBpLCBWLmdldChpLCBpKSk7XG4gICAgVi5zZXQoaSwgaSwgMSk7XG4gICAgaCA9IGRbaSArIDFdO1xuICAgIGlmIChoICE9PSAwKSB7XG4gICAgICBmb3IgKGsgPSAwOyBrIDw9IGk7IGsrKykge1xuICAgICAgICBkW2tdID0gVi5nZXQoaywgaSArIDEpIC8gaDtcbiAgICAgIH1cblxuICAgICAgZm9yIChqID0gMDsgaiA8PSBpOyBqKyspIHtcbiAgICAgICAgZyA9IDA7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPD0gaTsgaysrKSB7XG4gICAgICAgICAgZyArPSBWLmdldChrLCBpICsgMSkgKiBWLmdldChrLCBqKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGsgPSAwOyBrIDw9IGk7IGsrKykge1xuICAgICAgICAgIFYuc2V0KGssIGosIFYuZ2V0KGssIGopIC0gZyAqIGRba10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChrID0gMDsgayA8PSBpOyBrKyspIHtcbiAgICAgIFYuc2V0KGssIGkgKyAxLCAwKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgZFtqXSA9IFYuZ2V0KG4gLSAxLCBqKTtcbiAgICBWLnNldChuIC0gMSwgaiwgMCk7XG4gIH1cblxuICBWLnNldChuIC0gMSwgbiAtIDEsIDEpO1xuICBlWzBdID0gMDtcbn1cblxuZnVuY3Rpb24gdHFsMihuLCBlLCBkLCBWKSB7XG4gIGxldCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBwLCByLCBkbDEsIGMsIGMyLCBjMywgZWwxLCBzLCBzMiwgaXRlcjtcblxuICBmb3IgKGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgZVtpIC0gMV0gPSBlW2ldO1xuICB9XG5cbiAgZVtuIC0gMV0gPSAwO1xuXG4gIGxldCBmID0gMDtcbiAgbGV0IHRzdDEgPSAwO1xuICBsZXQgZXBzID0gTnVtYmVyLkVQU0lMT047XG5cbiAgZm9yIChsID0gMDsgbCA8IG47IGwrKykge1xuICAgIHRzdDEgPSBNYXRoLm1heCh0c3QxLCBNYXRoLmFicyhkW2xdKSArIE1hdGguYWJzKGVbbF0pKTtcbiAgICBtID0gbDtcbiAgICB3aGlsZSAobSA8IG4pIHtcbiAgICAgIGlmIChNYXRoLmFicyhlW21dKSA8PSBlcHMgKiB0c3QxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbSsrO1xuICAgIH1cblxuICAgIGlmIChtID4gbCkge1xuICAgICAgaXRlciA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIGl0ZXIgPSBpdGVyICsgMTtcblxuICAgICAgICBnID0gZFtsXTtcbiAgICAgICAgcCA9IChkW2wgKyAxXSAtIGcpIC8gKDIgKiBlW2xdKTtcbiAgICAgICAgciA9IGh5cG90ZW51c2UocCwgMSk7XG4gICAgICAgIGlmIChwIDwgMCkge1xuICAgICAgICAgIHIgPSAtcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRbbF0gPSBlW2xdIC8gKHAgKyByKTtcbiAgICAgICAgZFtsICsgMV0gPSBlW2xdICogKHAgKyByKTtcbiAgICAgICAgZGwxID0gZFtsICsgMV07XG4gICAgICAgIGggPSBnIC0gZFtsXTtcbiAgICAgICAgZm9yIChpID0gbCArIDI7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBkW2ldIC09IGg7XG4gICAgICAgIH1cblxuICAgICAgICBmID0gZiArIGg7XG5cbiAgICAgICAgcCA9IGRbbV07XG4gICAgICAgIGMgPSAxO1xuICAgICAgICBjMiA9IGM7XG4gICAgICAgIGMzID0gYztcbiAgICAgICAgZWwxID0gZVtsICsgMV07XG4gICAgICAgIHMgPSAwO1xuICAgICAgICBzMiA9IDA7XG4gICAgICAgIGZvciAoaSA9IG0gLSAxOyBpID49IGw7IGktLSkge1xuICAgICAgICAgIGMzID0gYzI7XG4gICAgICAgICAgYzIgPSBjO1xuICAgICAgICAgIHMyID0gcztcbiAgICAgICAgICBnID0gYyAqIGVbaV07XG4gICAgICAgICAgaCA9IGMgKiBwO1xuICAgICAgICAgIHIgPSBoeXBvdGVudXNlKHAsIGVbaV0pO1xuICAgICAgICAgIGVbaSArIDFdID0gcyAqIHI7XG4gICAgICAgICAgcyA9IGVbaV0gLyByO1xuICAgICAgICAgIGMgPSBwIC8gcjtcbiAgICAgICAgICBwID0gYyAqIGRbaV0gLSBzICogZztcbiAgICAgICAgICBkW2kgKyAxXSA9IGggKyBzICogKGMgKiBnICsgcyAqIGRbaV0pO1xuXG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IG47IGsrKykge1xuICAgICAgICAgICAgaCA9IFYuZ2V0KGssIGkgKyAxKTtcbiAgICAgICAgICAgIFYuc2V0KGssIGkgKyAxLCBzICogVi5nZXQoaywgaSkgKyBjICogaCk7XG4gICAgICAgICAgICBWLnNldChrLCBpLCBjICogVi5nZXQoaywgaSkgLSBzICogaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcCA9ICgtcyAqIHMyICogYzMgKiBlbDEgKiBlW2xdKSAvIGRsMTtcbiAgICAgICAgZVtsXSA9IHMgKiBwO1xuICAgICAgICBkW2xdID0gYyAqIHA7XG4gICAgICB9IHdoaWxlIChNYXRoLmFicyhlW2xdKSA+IGVwcyAqIHRzdDEpO1xuICAgIH1cbiAgICBkW2xdID0gZFtsXSArIGY7XG4gICAgZVtsXSA9IDA7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xuICAgIGsgPSBpO1xuICAgIHAgPSBkW2ldO1xuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgaisrKSB7XG4gICAgICBpZiAoZFtqXSA8IHApIHtcbiAgICAgICAgayA9IGo7XG4gICAgICAgIHAgPSBkW2pdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrICE9PSBpKSB7XG4gICAgICBkW2tdID0gZFtpXTtcbiAgICAgIGRbaV0gPSBwO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBwID0gVi5nZXQoaiwgaSk7XG4gICAgICAgIFYuc2V0KGosIGksIFYuZ2V0KGosIGspKTtcbiAgICAgICAgVi5zZXQoaiwgaywgcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9ydGhlcyhuLCBILCBvcnQsIFYpIHtcbiAgbGV0IGxvdyA9IDA7XG4gIGxldCBoaWdoID0gbiAtIDE7XG4gIGxldCBmLCBnLCBoLCBpLCBqLCBtO1xuICBsZXQgc2NhbGU7XG5cbiAgZm9yIChtID0gbG93ICsgMTsgbSA8PSBoaWdoIC0gMTsgbSsrKSB7XG4gICAgc2NhbGUgPSAwO1xuICAgIGZvciAoaSA9IG07IGkgPD0gaGlnaDsgaSsrKSB7XG4gICAgICBzY2FsZSA9IHNjYWxlICsgTWF0aC5hYnMoSC5nZXQoaSwgbSAtIDEpKTtcbiAgICB9XG5cbiAgICBpZiAoc2NhbGUgIT09IDApIHtcbiAgICAgIGggPSAwO1xuICAgICAgZm9yIChpID0gaGlnaDsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgb3J0W2ldID0gSC5nZXQoaSwgbSAtIDEpIC8gc2NhbGU7XG4gICAgICAgIGggKz0gb3J0W2ldICogb3J0W2ldO1xuICAgICAgfVxuXG4gICAgICBnID0gTWF0aC5zcXJ0KGgpO1xuICAgICAgaWYgKG9ydFttXSA+IDApIHtcbiAgICAgICAgZyA9IC1nO1xuICAgICAgfVxuXG4gICAgICBoID0gaCAtIG9ydFttXSAqIGc7XG4gICAgICBvcnRbbV0gPSBvcnRbbV0gLSBnO1xuXG4gICAgICBmb3IgKGogPSBtOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGYgPSAwO1xuICAgICAgICBmb3IgKGkgPSBoaWdoOyBpID49IG07IGktLSkge1xuICAgICAgICAgIGYgKz0gb3J0W2ldICogSC5nZXQoaSwgaik7XG4gICAgICAgIH1cblxuICAgICAgICBmID0gZiAvIGg7XG4gICAgICAgIGZvciAoaSA9IG07IGkgPD0gaGlnaDsgaSsrKSB7XG4gICAgICAgICAgSC5zZXQoaSwgaiwgSC5nZXQoaSwgaikgLSBmICogb3J0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDw9IGhpZ2g7IGkrKykge1xuICAgICAgICBmID0gMDtcbiAgICAgICAgZm9yIChqID0gaGlnaDsgaiA+PSBtOyBqLS0pIHtcbiAgICAgICAgICBmICs9IG9ydFtqXSAqIEguZ2V0KGksIGopO1xuICAgICAgICB9XG5cbiAgICAgICAgZiA9IGYgLyBoO1xuICAgICAgICBmb3IgKGogPSBtOyBqIDw9IGhpZ2g7IGorKykge1xuICAgICAgICAgIEguc2V0KGksIGosIEguZ2V0KGksIGopIC0gZiAqIG9ydFtqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3J0W21dID0gc2NhbGUgKiBvcnRbbV07XG4gICAgICBILnNldChtLCBtIC0gMSwgc2NhbGUgKiBnKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgVi5zZXQoaSwgaiwgaSA9PT0gaiA/IDEgOiAwKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKG0gPSBoaWdoIC0gMTsgbSA+PSBsb3cgKyAxOyBtLS0pIHtcbiAgICBpZiAoSC5nZXQobSwgbSAtIDEpICE9PSAwKSB7XG4gICAgICBmb3IgKGkgPSBtICsgMTsgaSA8PSBoaWdoOyBpKyspIHtcbiAgICAgICAgb3J0W2ldID0gSC5nZXQoaSwgbSAtIDEpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSBtOyBqIDw9IGhpZ2g7IGorKykge1xuICAgICAgICBnID0gMDtcbiAgICAgICAgZm9yIChpID0gbTsgaSA8PSBoaWdoOyBpKyspIHtcbiAgICAgICAgICBnICs9IG9ydFtpXSAqIFYuZ2V0KGksIGopO1xuICAgICAgICB9XG5cbiAgICAgICAgZyA9IGcgLyBvcnRbbV0gLyBILmdldChtLCBtIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IG07IGkgPD0gaGlnaDsgaSsrKSB7XG4gICAgICAgICAgVi5zZXQoaSwgaiwgVi5nZXQoaSwgaikgKyBnICogb3J0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBocXIyKG5uLCBlLCBkLCBWLCBIKSB7XG4gIGxldCBuID0gbm4gLSAxO1xuICBsZXQgbG93ID0gMDtcbiAgbGV0IGhpZ2ggPSBubiAtIDE7XG4gIGxldCBlcHMgPSBOdW1iZXIuRVBTSUxPTjtcbiAgbGV0IGV4c2hpZnQgPSAwO1xuICBsZXQgbm9ybSA9IDA7XG4gIGxldCBwID0gMDtcbiAgbGV0IHEgPSAwO1xuICBsZXQgciA9IDA7XG4gIGxldCBzID0gMDtcbiAgbGV0IHogPSAwO1xuICBsZXQgaXRlciA9IDA7XG4gIGxldCBpLCBqLCBrLCBsLCBtLCB0LCB3LCB4LCB5O1xuICBsZXQgcmEsIHNhLCB2ciwgdmk7XG4gIGxldCBub3RsYXN0LCBjZGl2cmVzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBubjsgaSsrKSB7XG4gICAgaWYgKGkgPCBsb3cgfHwgaSA+IGhpZ2gpIHtcbiAgICAgIGRbaV0gPSBILmdldChpLCBpKTtcbiAgICAgIGVbaV0gPSAwO1xuICAgIH1cblxuICAgIGZvciAoaiA9IE1hdGgubWF4KGkgLSAxLCAwKTsgaiA8IG5uOyBqKyspIHtcbiAgICAgIG5vcm0gPSBub3JtICsgTWF0aC5hYnMoSC5nZXQoaSwgaikpO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChuID49IGxvdykge1xuICAgIGwgPSBuO1xuICAgIHdoaWxlIChsID4gbG93KSB7XG4gICAgICBzID0gTWF0aC5hYnMoSC5nZXQobCAtIDEsIGwgLSAxKSkgKyBNYXRoLmFicyhILmdldChsLCBsKSk7XG4gICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICBzID0gbm9ybTtcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyhILmdldChsLCBsIC0gMSkpIDwgZXBzICogcykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGwtLTtcbiAgICB9XG5cbiAgICBpZiAobCA9PT0gbikge1xuICAgICAgSC5zZXQobiwgbiwgSC5nZXQobiwgbikgKyBleHNoaWZ0KTtcbiAgICAgIGRbbl0gPSBILmdldChuLCBuKTtcbiAgICAgIGVbbl0gPSAwO1xuICAgICAgbi0tO1xuICAgICAgaXRlciA9IDA7XG4gICAgfSBlbHNlIGlmIChsID09PSBuIC0gMSkge1xuICAgICAgdyA9IEguZ2V0KG4sIG4gLSAxKSAqIEguZ2V0KG4gLSAxLCBuKTtcbiAgICAgIHAgPSAoSC5nZXQobiAtIDEsIG4gLSAxKSAtIEguZ2V0KG4sIG4pKSAvIDI7XG4gICAgICBxID0gcCAqIHAgKyB3O1xuICAgICAgeiA9IE1hdGguc3FydChNYXRoLmFicyhxKSk7XG4gICAgICBILnNldChuLCBuLCBILmdldChuLCBuKSArIGV4c2hpZnQpO1xuICAgICAgSC5zZXQobiAtIDEsIG4gLSAxLCBILmdldChuIC0gMSwgbiAtIDEpICsgZXhzaGlmdCk7XG4gICAgICB4ID0gSC5nZXQobiwgbik7XG5cbiAgICAgIGlmIChxID49IDApIHtcbiAgICAgICAgeiA9IHAgPj0gMCA/IHAgKyB6IDogcCAtIHo7XG4gICAgICAgIGRbbiAtIDFdID0geCArIHo7XG4gICAgICAgIGRbbl0gPSBkW24gLSAxXTtcbiAgICAgICAgaWYgKHogIT09IDApIHtcbiAgICAgICAgICBkW25dID0geCAtIHcgLyB6O1xuICAgICAgICB9XG4gICAgICAgIGVbbiAtIDFdID0gMDtcbiAgICAgICAgZVtuXSA9IDA7XG4gICAgICAgIHggPSBILmdldChuLCBuIC0gMSk7XG4gICAgICAgIHMgPSBNYXRoLmFicyh4KSArIE1hdGguYWJzKHopO1xuICAgICAgICBwID0geCAvIHM7XG4gICAgICAgIHEgPSB6IC8gcztcbiAgICAgICAgciA9IE1hdGguc3FydChwICogcCArIHEgKiBxKTtcbiAgICAgICAgcCA9IHAgLyByO1xuICAgICAgICBxID0gcSAvIHI7XG5cbiAgICAgICAgZm9yIChqID0gbiAtIDE7IGogPCBubjsgaisrKSB7XG4gICAgICAgICAgeiA9IEguZ2V0KG4gLSAxLCBqKTtcbiAgICAgICAgICBILnNldChuIC0gMSwgaiwgcSAqIHogKyBwICogSC5nZXQobiwgaikpO1xuICAgICAgICAgIEguc2V0KG4sIGosIHEgKiBILmdldChuLCBqKSAtIHAgKiB6KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgICAgeiA9IEguZ2V0KGksIG4gLSAxKTtcbiAgICAgICAgICBILnNldChpLCBuIC0gMSwgcSAqIHogKyBwICogSC5nZXQoaSwgbikpO1xuICAgICAgICAgIEguc2V0KGksIG4sIHEgKiBILmdldChpLCBuKSAtIHAgKiB6KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IGxvdzsgaSA8PSBoaWdoOyBpKyspIHtcbiAgICAgICAgICB6ID0gVi5nZXQoaSwgbiAtIDEpO1xuICAgICAgICAgIFYuc2V0KGksIG4gLSAxLCBxICogeiArIHAgKiBWLmdldChpLCBuKSk7XG4gICAgICAgICAgVi5zZXQoaSwgbiwgcSAqIFYuZ2V0KGksIG4pIC0gcCAqIHopO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkW24gLSAxXSA9IHggKyBwO1xuICAgICAgICBkW25dID0geCArIHA7XG4gICAgICAgIGVbbiAtIDFdID0gejtcbiAgICAgICAgZVtuXSA9IC16O1xuICAgICAgfVxuXG4gICAgICBuID0gbiAtIDI7XG4gICAgICBpdGVyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IEguZ2V0KG4sIG4pO1xuICAgICAgeSA9IDA7XG4gICAgICB3ID0gMDtcbiAgICAgIGlmIChsIDwgbikge1xuICAgICAgICB5ID0gSC5nZXQobiAtIDEsIG4gLSAxKTtcbiAgICAgICAgdyA9IEguZ2V0KG4sIG4gLSAxKSAqIEguZ2V0KG4gLSAxLCBuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZXIgPT09IDEwKSB7XG4gICAgICAgIGV4c2hpZnQgKz0geDtcbiAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IG47IGkrKykge1xuICAgICAgICAgIEguc2V0KGksIGksIEguZ2V0KGksIGkpIC0geCk7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IE1hdGguYWJzKEguZ2V0KG4sIG4gLSAxKSkgKyBNYXRoLmFicyhILmdldChuIC0gMSwgbiAtIDIpKTtcbiAgICAgICAgeCA9IHkgPSAwLjc1ICogcztcbiAgICAgICAgdyA9IC0wLjQzNzUgKiBzICogcztcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZXIgPT09IDMwKSB7XG4gICAgICAgIHMgPSAoeSAtIHgpIC8gMjtcbiAgICAgICAgcyA9IHMgKiBzICsgdztcbiAgICAgICAgaWYgKHMgPiAwKSB7XG4gICAgICAgICAgcyA9IE1hdGguc3FydChzKTtcbiAgICAgICAgICBpZiAoeSA8IHgpIHtcbiAgICAgICAgICAgIHMgPSAtcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcyA9IHggLSB3IC8gKCh5IC0geCkgLyAyICsgcyk7XG4gICAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IG47IGkrKykge1xuICAgICAgICAgICAgSC5zZXQoaSwgaSwgSC5nZXQoaSwgaSkgLSBzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhzaGlmdCArPSBzO1xuICAgICAgICAgIHggPSB5ID0gdyA9IDAuOTY0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGl0ZXIgPSBpdGVyICsgMTtcblxuICAgICAgbSA9IG4gLSAyO1xuICAgICAgd2hpbGUgKG0gPj0gbCkge1xuICAgICAgICB6ID0gSC5nZXQobSwgbSk7XG4gICAgICAgIHIgPSB4IC0gejtcbiAgICAgICAgcyA9IHkgLSB6O1xuICAgICAgICBwID0gKHIgKiBzIC0gdykgLyBILmdldChtICsgMSwgbSkgKyBILmdldChtLCBtICsgMSk7XG4gICAgICAgIHEgPSBILmdldChtICsgMSwgbSArIDEpIC0geiAtIHIgLSBzO1xuICAgICAgICByID0gSC5nZXQobSArIDIsIG0gKyAxKTtcbiAgICAgICAgcyA9IE1hdGguYWJzKHApICsgTWF0aC5hYnMocSkgKyBNYXRoLmFicyhyKTtcbiAgICAgICAgcCA9IHAgLyBzO1xuICAgICAgICBxID0gcSAvIHM7XG4gICAgICAgIHIgPSByIC8gcztcbiAgICAgICAgaWYgKG0gPT09IGwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgTWF0aC5hYnMoSC5nZXQobSwgbSAtIDEpKSAqIChNYXRoLmFicyhxKSArIE1hdGguYWJzKHIpKSA8XG4gICAgICAgICAgZXBzICpcbiAgICAgICAgICAgIChNYXRoLmFicyhwKSAqXG4gICAgICAgICAgICAgIChNYXRoLmFicyhILmdldChtIC0gMSwgbSAtIDEpKSArXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoeikgK1xuICAgICAgICAgICAgICAgIE1hdGguYWJzKEguZ2V0KG0gKyAxLCBtICsgMSkpKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbS0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBtICsgMjsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgSC5zZXQoaSwgaSAtIDIsIDApO1xuICAgICAgICBpZiAoaSA+IG0gKyAyKSB7XG4gICAgICAgICAgSC5zZXQoaSwgaSAtIDMsIDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoayA9IG07IGsgPD0gbiAtIDE7IGsrKykge1xuICAgICAgICBub3RsYXN0ID0gayAhPT0gbiAtIDE7XG4gICAgICAgIGlmIChrICE9PSBtKSB7XG4gICAgICAgICAgcCA9IEguZ2V0KGssIGsgLSAxKTtcbiAgICAgICAgICBxID0gSC5nZXQoayArIDEsIGsgLSAxKTtcbiAgICAgICAgICByID0gbm90bGFzdCA/IEguZ2V0KGsgKyAyLCBrIC0gMSkgOiAwO1xuICAgICAgICAgIHggPSBNYXRoLmFicyhwKSArIE1hdGguYWJzKHEpICsgTWF0aC5hYnMocik7XG4gICAgICAgICAgaWYgKHggIT09IDApIHtcbiAgICAgICAgICAgIHAgPSBwIC8geDtcbiAgICAgICAgICAgIHEgPSBxIC8geDtcbiAgICAgICAgICAgIHIgPSByIC8geDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcyA9IE1hdGguc3FydChwICogcCArIHEgKiBxICsgciAqIHIpO1xuICAgICAgICBpZiAocCA8IDApIHtcbiAgICAgICAgICBzID0gLXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocyAhPT0gMCkge1xuICAgICAgICAgIGlmIChrICE9PSBtKSB7XG4gICAgICAgICAgICBILnNldChrLCBrIC0gMSwgLXMgKiB4KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGwgIT09IG0pIHtcbiAgICAgICAgICAgIEguc2V0KGssIGsgLSAxLCAtSC5nZXQoaywgayAtIDEpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwID0gcCArIHM7XG4gICAgICAgICAgeCA9IHAgLyBzO1xuICAgICAgICAgIHkgPSBxIC8gcztcbiAgICAgICAgICB6ID0gciAvIHM7XG4gICAgICAgICAgcSA9IHEgLyBwO1xuICAgICAgICAgIHIgPSByIC8gcDtcblxuICAgICAgICAgIGZvciAoaiA9IGs7IGogPCBubjsgaisrKSB7XG4gICAgICAgICAgICBwID0gSC5nZXQoaywgaikgKyBxICogSC5nZXQoayArIDEsIGopO1xuICAgICAgICAgICAgaWYgKG5vdGxhc3QpIHtcbiAgICAgICAgICAgICAgcCA9IHAgKyByICogSC5nZXQoayArIDIsIGopO1xuICAgICAgICAgICAgICBILnNldChrICsgMiwgaiwgSC5nZXQoayArIDIsIGopIC0gcCAqIHopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBILnNldChrLCBqLCBILmdldChrLCBqKSAtIHAgKiB4KTtcbiAgICAgICAgICAgIEguc2V0KGsgKyAxLCBqLCBILmdldChrICsgMSwgaikgLSBwICogeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBNYXRoLm1pbihuLCBrICsgMyk7IGkrKykge1xuICAgICAgICAgICAgcCA9IHggKiBILmdldChpLCBrKSArIHkgKiBILmdldChpLCBrICsgMSk7XG4gICAgICAgICAgICBpZiAobm90bGFzdCkge1xuICAgICAgICAgICAgICBwID0gcCArIHogKiBILmdldChpLCBrICsgMik7XG4gICAgICAgICAgICAgIEguc2V0KGksIGsgKyAyLCBILmdldChpLCBrICsgMikgLSBwICogcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEguc2V0KGksIGssIEguZ2V0KGksIGspIC0gcCk7XG4gICAgICAgICAgICBILnNldChpLCBrICsgMSwgSC5nZXQoaSwgayArIDEpIC0gcCAqIHEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaSA9IGxvdzsgaSA8PSBoaWdoOyBpKyspIHtcbiAgICAgICAgICAgIHAgPSB4ICogVi5nZXQoaSwgaykgKyB5ICogVi5nZXQoaSwgayArIDEpO1xuICAgICAgICAgICAgaWYgKG5vdGxhc3QpIHtcbiAgICAgICAgICAgICAgcCA9IHAgKyB6ICogVi5nZXQoaSwgayArIDIpO1xuICAgICAgICAgICAgICBWLnNldChpLCBrICsgMiwgVi5nZXQoaSwgayArIDIpIC0gcCAqIHIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBWLnNldChpLCBrLCBWLmdldChpLCBrKSAtIHApO1xuICAgICAgICAgICAgVi5zZXQoaSwgayArIDEsIFYuZ2V0KGksIGsgKyAxKSAtIHAgKiBxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobm9ybSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAobiA9IG5uIC0gMTsgbiA+PSAwOyBuLS0pIHtcbiAgICBwID0gZFtuXTtcbiAgICBxID0gZVtuXTtcblxuICAgIGlmIChxID09PSAwKSB7XG4gICAgICBsID0gbjtcbiAgICAgIEguc2V0KG4sIG4sIDEpO1xuICAgICAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHcgPSBILmdldChpLCBpKSAtIHA7XG4gICAgICAgIHIgPSAwO1xuICAgICAgICBmb3IgKGogPSBsOyBqIDw9IG47IGorKykge1xuICAgICAgICAgIHIgPSByICsgSC5nZXQoaSwgaikgKiBILmdldChqLCBuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlW2ldIDwgMCkge1xuICAgICAgICAgIHogPSB3O1xuICAgICAgICAgIHMgPSByO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGwgPSBpO1xuICAgICAgICAgIGlmIChlW2ldID09PSAwKSB7XG4gICAgICAgICAgICBILnNldChpLCBuLCB3ICE9PSAwID8gLXIgLyB3IDogLXIgLyAoZXBzICogbm9ybSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gSC5nZXQoaSwgaSArIDEpO1xuICAgICAgICAgICAgeSA9IEguZ2V0KGkgKyAxLCBpKTtcbiAgICAgICAgICAgIHEgPSAoZFtpXSAtIHApICogKGRbaV0gLSBwKSArIGVbaV0gKiBlW2ldO1xuICAgICAgICAgICAgdCA9ICh4ICogcyAtIHogKiByKSAvIHE7XG4gICAgICAgICAgICBILnNldChpLCBuLCB0KTtcbiAgICAgICAgICAgIEguc2V0KFxuICAgICAgICAgICAgICBpICsgMSxcbiAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgTWF0aC5hYnMoeCkgPiBNYXRoLmFicyh6KSA/ICgtciAtIHcgKiB0KSAvIHggOiAoLXMgLSB5ICogdCkgLyB6LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0ID0gTWF0aC5hYnMoSC5nZXQoaSwgbikpO1xuICAgICAgICAgIGlmIChlcHMgKiB0ICogdCA+IDEpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IGk7IGogPD0gbjsgaisrKSB7XG4gICAgICAgICAgICAgIEguc2V0KGosIG4sIEguZ2V0KGosIG4pIC8gdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChxIDwgMCkge1xuICAgICAgbCA9IG4gLSAxO1xuXG4gICAgICBpZiAoTWF0aC5hYnMoSC5nZXQobiwgbiAtIDEpKSA+IE1hdGguYWJzKEguZ2V0KG4gLSAxLCBuKSkpIHtcbiAgICAgICAgSC5zZXQobiAtIDEsIG4gLSAxLCBxIC8gSC5nZXQobiwgbiAtIDEpKTtcbiAgICAgICAgSC5zZXQobiAtIDEsIG4sIC0oSC5nZXQobiwgbikgLSBwKSAvIEguZ2V0KG4sIG4gLSAxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZGl2cmVzID0gY2RpdigwLCAtSC5nZXQobiAtIDEsIG4pLCBILmdldChuIC0gMSwgbiAtIDEpIC0gcCwgcSk7XG4gICAgICAgIEguc2V0KG4gLSAxLCBuIC0gMSwgY2RpdnJlc1swXSk7XG4gICAgICAgIEguc2V0KG4gLSAxLCBuLCBjZGl2cmVzWzFdKTtcbiAgICAgIH1cblxuICAgICAgSC5zZXQobiwgbiAtIDEsIDApO1xuICAgICAgSC5zZXQobiwgbiwgMSk7XG4gICAgICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmEgPSAwO1xuICAgICAgICBzYSA9IDA7XG4gICAgICAgIGZvciAoaiA9IGw7IGogPD0gbjsgaisrKSB7XG4gICAgICAgICAgcmEgPSByYSArIEguZ2V0KGksIGopICogSC5nZXQoaiwgbiAtIDEpO1xuICAgICAgICAgIHNhID0gc2EgKyBILmdldChpLCBqKSAqIEguZ2V0KGosIG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdyA9IEguZ2V0KGksIGkpIC0gcDtcblxuICAgICAgICBpZiAoZVtpXSA8IDApIHtcbiAgICAgICAgICB6ID0gdztcbiAgICAgICAgICByID0gcmE7XG4gICAgICAgICAgcyA9IHNhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGwgPSBpO1xuICAgICAgICAgIGlmIChlW2ldID09PSAwKSB7XG4gICAgICAgICAgICBjZGl2cmVzID0gY2RpdigtcmEsIC1zYSwgdywgcSk7XG4gICAgICAgICAgICBILnNldChpLCBuIC0gMSwgY2RpdnJlc1swXSk7XG4gICAgICAgICAgICBILnNldChpLCBuLCBjZGl2cmVzWzFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IEguZ2V0KGksIGkgKyAxKTtcbiAgICAgICAgICAgIHkgPSBILmdldChpICsgMSwgaSk7XG4gICAgICAgICAgICB2ciA9IChkW2ldIC0gcCkgKiAoZFtpXSAtIHApICsgZVtpXSAqIGVbaV0gLSBxICogcTtcbiAgICAgICAgICAgIHZpID0gKGRbaV0gLSBwKSAqIDIgKiBxO1xuICAgICAgICAgICAgaWYgKHZyID09PSAwICYmIHZpID09PSAwKSB7XG4gICAgICAgICAgICAgIHZyID1cbiAgICAgICAgICAgICAgICBlcHMgKlxuICAgICAgICAgICAgICAgIG5vcm0gKlxuICAgICAgICAgICAgICAgIChNYXRoLmFicyh3KSArXG4gICAgICAgICAgICAgICAgICBNYXRoLmFicyhxKSArXG4gICAgICAgICAgICAgICAgICBNYXRoLmFicyh4KSArXG4gICAgICAgICAgICAgICAgICBNYXRoLmFicyh5KSArXG4gICAgICAgICAgICAgICAgICBNYXRoLmFicyh6KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZGl2cmVzID0gY2RpdihcbiAgICAgICAgICAgICAgeCAqIHIgLSB6ICogcmEgKyBxICogc2EsXG4gICAgICAgICAgICAgIHggKiBzIC0geiAqIHNhIC0gcSAqIHJhLFxuICAgICAgICAgICAgICB2cixcbiAgICAgICAgICAgICAgdmksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgSC5zZXQoaSwgbiAtIDEsIGNkaXZyZXNbMF0pO1xuICAgICAgICAgICAgSC5zZXQoaSwgbiwgY2RpdnJlc1sxXSk7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoeCkgPiBNYXRoLmFicyh6KSArIE1hdGguYWJzKHEpKSB7XG4gICAgICAgICAgICAgIEguc2V0KFxuICAgICAgICAgICAgICAgIGkgKyAxLFxuICAgICAgICAgICAgICAgIG4gLSAxLFxuICAgICAgICAgICAgICAgICgtcmEgLSB3ICogSC5nZXQoaSwgbiAtIDEpICsgcSAqIEguZ2V0KGksIG4pKSAvIHgsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIEguc2V0KFxuICAgICAgICAgICAgICAgIGkgKyAxLFxuICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgKC1zYSAtIHcgKiBILmdldChpLCBuKSAtIHEgKiBILmdldChpLCBuIC0gMSkpIC8geCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNkaXZyZXMgPSBjZGl2KFxuICAgICAgICAgICAgICAgIC1yIC0geSAqIEguZ2V0KGksIG4gLSAxKSxcbiAgICAgICAgICAgICAgICAtcyAtIHkgKiBILmdldChpLCBuKSxcbiAgICAgICAgICAgICAgICB6LFxuICAgICAgICAgICAgICAgIHEsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIEguc2V0KGkgKyAxLCBuIC0gMSwgY2RpdnJlc1swXSk7XG4gICAgICAgICAgICAgIEguc2V0KGkgKyAxLCBuLCBjZGl2cmVzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0ID0gTWF0aC5tYXgoTWF0aC5hYnMoSC5nZXQoaSwgbiAtIDEpKSwgTWF0aC5hYnMoSC5nZXQoaSwgbikpKTtcbiAgICAgICAgICBpZiAoZXBzICogdCAqIHQgPiAxKSB7XG4gICAgICAgICAgICBmb3IgKGogPSBpOyBqIDw9IG47IGorKykge1xuICAgICAgICAgICAgICBILnNldChqLCBuIC0gMSwgSC5nZXQoaiwgbiAtIDEpIC8gdCk7XG4gICAgICAgICAgICAgIEguc2V0KGosIG4sIEguZ2V0KGosIG4pIC8gdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG5uOyBpKyspIHtcbiAgICBpZiAoaSA8IGxvdyB8fCBpID4gaGlnaCkge1xuICAgICAgZm9yIChqID0gaTsgaiA8IG5uOyBqKyspIHtcbiAgICAgICAgVi5zZXQoaSwgaiwgSC5nZXQoaSwgaikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoaiA9IG5uIC0gMTsgaiA+PSBsb3c7IGotLSkge1xuICAgIGZvciAoaSA9IGxvdzsgaSA8PSBoaWdoOyBpKyspIHtcbiAgICAgIHogPSAwO1xuICAgICAgZm9yIChrID0gbG93OyBrIDw9IE1hdGgubWluKGosIGhpZ2gpOyBrKyspIHtcbiAgICAgICAgeiA9IHogKyBWLmdldChpLCBrKSAqIEguZ2V0KGssIGopO1xuICAgICAgfVxuICAgICAgVi5zZXQoaSwgaiwgeik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNkaXYoeHIsIHhpLCB5ciwgeWkpIHtcbiAgbGV0IHIsIGQ7XG4gIGlmIChNYXRoLmFicyh5cikgPiBNYXRoLmFicyh5aSkpIHtcbiAgICByID0geWkgLyB5cjtcbiAgICBkID0geXIgKyByICogeWk7XG4gICAgcmV0dXJuIFsoeHIgKyByICogeGkpIC8gZCwgKHhpIC0gciAqIHhyKSAvIGRdO1xuICB9IGVsc2Uge1xuICAgIHIgPSB5ciAvIHlpO1xuICAgIGQgPSB5aSArIHIgKiB5cjtcbiAgICByZXR1cm4gWyhyICogeHIgKyB4aSkgLyBkLCAociAqIHhpIC0geHIpIC8gZF07XG4gIH1cbn1cbiIsImltcG9ydCBNYXRyaXggZnJvbSAnLi4vbWF0cml4JztcbmltcG9ydCBXcmFwcGVyTWF0cml4MkQgZnJvbSAnLi4vd3JhcC9XcmFwcGVyTWF0cml4MkQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMdURlY29tcG9zaXRpb24ge1xuICBjb25zdHJ1Y3RvcihtYXRyaXgpIHtcbiAgICBtYXRyaXggPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgobWF0cml4KTtcblxuICAgIGxldCBsdSA9IG1hdHJpeC5jbG9uZSgpO1xuICAgIGxldCByb3dzID0gbHUucm93cztcbiAgICBsZXQgY29sdW1ucyA9IGx1LmNvbHVtbnM7XG4gICAgbGV0IHBpdm90VmVjdG9yID0gbmV3IEZsb2F0NjRBcnJheShyb3dzKTtcbiAgICBsZXQgcGl2b3RTaWduID0gMTtcbiAgICBsZXQgaSwgaiwgaywgcCwgcywgdCwgdjtcbiAgICBsZXQgTFVjb2xqLCBrbWF4O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgcGl2b3RWZWN0b3JbaV0gPSBpO1xuICAgIH1cblxuICAgIExVY29saiA9IG5ldyBGbG9hdDY0QXJyYXkocm93cyk7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgIExVY29saltpXSA9IGx1LmdldChpLCBqKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICBrbWF4ID0gTWF0aC5taW4oaSwgaik7XG4gICAgICAgIHMgPSAwO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwga21heDsgaysrKSB7XG4gICAgICAgICAgcyArPSBsdS5nZXQoaSwgaykgKiBMVWNvbGpba107XG4gICAgICAgIH1cbiAgICAgICAgTFVjb2xqW2ldIC09IHM7XG4gICAgICAgIGx1LnNldChpLCBqLCBMVWNvbGpbaV0pO1xuICAgICAgfVxuXG4gICAgICBwID0gajtcbiAgICAgIGZvciAoaSA9IGogKyAxOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhMVWNvbGpbaV0pID4gTWF0aC5hYnMoTFVjb2xqW3BdKSkge1xuICAgICAgICAgIHAgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwICE9PSBqKSB7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBjb2x1bW5zOyBrKyspIHtcbiAgICAgICAgICB0ID0gbHUuZ2V0KHAsIGspO1xuICAgICAgICAgIGx1LnNldChwLCBrLCBsdS5nZXQoaiwgaykpO1xuICAgICAgICAgIGx1LnNldChqLCBrLCB0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHYgPSBwaXZvdFZlY3RvcltwXTtcbiAgICAgICAgcGl2b3RWZWN0b3JbcF0gPSBwaXZvdFZlY3RvcltqXTtcbiAgICAgICAgcGl2b3RWZWN0b3Jbal0gPSB2O1xuXG4gICAgICAgIHBpdm90U2lnbiA9IC1waXZvdFNpZ247XG4gICAgICB9XG5cbiAgICAgIGlmIChqIDwgcm93cyAmJiBsdS5nZXQoaiwgaikgIT09IDApIHtcbiAgICAgICAgZm9yIChpID0gaiArIDE7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICBsdS5zZXQoaSwgaiwgbHUuZ2V0KGksIGopIC8gbHUuZ2V0KGosIGopKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuTFUgPSBsdTtcbiAgICB0aGlzLnBpdm90VmVjdG9yID0gcGl2b3RWZWN0b3I7XG4gICAgdGhpcy5waXZvdFNpZ24gPSBwaXZvdFNpZ247XG4gIH1cblxuICBpc1Npbmd1bGFyKCkge1xuICAgIGxldCBkYXRhID0gdGhpcy5MVTtcbiAgICBsZXQgY29sID0gZGF0YS5jb2x1bW5zO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sOyBqKyspIHtcbiAgICAgIGlmIChkYXRhLmdldChqLCBqKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc29sdmUodmFsdWUpIHtcbiAgICB2YWx1ZSA9IE1hdHJpeC5jaGVja01hdHJpeCh2YWx1ZSk7XG5cbiAgICBsZXQgbHUgPSB0aGlzLkxVO1xuICAgIGxldCByb3dzID0gbHUucm93cztcblxuICAgIGlmIChyb3dzICE9PSB2YWx1ZS5yb3dzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWF0cml4IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaW5ndWxhcigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xVIG1hdHJpeCBpcyBzaW5ndWxhcicpO1xuICAgIH1cblxuICAgIGxldCBjb3VudCA9IHZhbHVlLmNvbHVtbnM7XG4gICAgbGV0IFggPSB2YWx1ZS5zdWJNYXRyaXhSb3codGhpcy5waXZvdFZlY3RvciwgMCwgY291bnQgLSAxKTtcbiAgICBsZXQgY29sdW1ucyA9IGx1LmNvbHVtbnM7XG4gICAgbGV0IGksIGosIGs7XG5cbiAgICBmb3IgKGsgPSAwOyBrIDwgY29sdW1uczsgaysrKSB7XG4gICAgICBmb3IgKGkgPSBrICsgMTsgaSA8IGNvbHVtbnM7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICAgIFguc2V0KGksIGosIFguZ2V0KGksIGopIC0gWC5nZXQoaywgaikgKiBsdS5nZXQoaSwgaykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoayA9IGNvbHVtbnMgLSAxOyBrID49IDA7IGstLSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgWC5zZXQoaywgaiwgWC5nZXQoaywgaikgLyBsdS5nZXQoaywgaykpO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICAgIFguc2V0KGksIGosIFguZ2V0KGksIGopIC0gWC5nZXQoaywgaikgKiBsdS5nZXQoaSwgaykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBYO1xuICB9XG5cbiAgZ2V0IGRldGVybWluYW50KCkge1xuICAgIGxldCBkYXRhID0gdGhpcy5MVTtcbiAgICBpZiAoIWRhdGEuaXNTcXVhcmUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaXggbXVzdCBiZSBzcXVhcmUnKTtcbiAgICB9XG4gICAgbGV0IGRldGVybWluYW50ID0gdGhpcy5waXZvdFNpZ247XG4gICAgbGV0IGNvbCA9IGRhdGEuY29sdW1ucztcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbDsgaisrKSB7XG4gICAgICBkZXRlcm1pbmFudCAqPSBkYXRhLmdldChqLCBqKTtcbiAgICB9XG4gICAgcmV0dXJuIGRldGVybWluYW50O1xuICB9XG5cbiAgZ2V0IGxvd2VyVHJpYW5ndWxhck1hdHJpeCgpIHtcbiAgICBsZXQgZGF0YSA9IHRoaXMuTFU7XG4gICAgbGV0IHJvd3MgPSBkYXRhLnJvd3M7XG4gICAgbGV0IGNvbHVtbnMgPSBkYXRhLmNvbHVtbnM7XG4gICAgbGV0IFggPSBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgICBYLnNldChpLCBqLCBkYXRhLmdldChpLCBqKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gaikge1xuICAgICAgICAgIFguc2V0KGksIGosIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFguc2V0KGksIGosIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBYO1xuICB9XG5cbiAgZ2V0IHVwcGVyVHJpYW5ndWxhck1hdHJpeCgpIHtcbiAgICBsZXQgZGF0YSA9IHRoaXMuTFU7XG4gICAgbGV0IHJvd3MgPSBkYXRhLnJvd3M7XG4gICAgbGV0IGNvbHVtbnMgPSBkYXRhLmNvbHVtbnM7XG4gICAgbGV0IFggPSBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgICBpZiAoaSA8PSBqKSB7XG4gICAgICAgICAgWC5zZXQoaSwgaiwgZGF0YS5nZXQoaSwgaikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFguc2V0KGksIGosIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBYO1xuICB9XG5cbiAgZ2V0IHBpdm90UGVybXV0YXRpb25WZWN0b3IoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5waXZvdFZlY3Rvcik7XG4gIH1cbn1cbiIsImltcG9ydCBNYXRyaXggZnJvbSAnLi4vbWF0cml4JztcbmltcG9ydCBXcmFwcGVyTWF0cml4MkQgZnJvbSAnLi4vd3JhcC9XcmFwcGVyTWF0cml4MkQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBuaXBhbHMge1xuICBjb25zdHJ1Y3RvcihYLCBvcHRpb25zID0ge30pIHtcbiAgICBYID0gV3JhcHBlck1hdHJpeDJELmNoZWNrTWF0cml4KFgpO1xuICAgIGxldCB7IFkgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgc2NhbGVTY29yZXMgPSBmYWxzZSxcbiAgICAgIG1heEl0ZXJhdGlvbnMgPSAxMDAwLFxuICAgICAgdGVybWluYXRpb25Dcml0ZXJpYSA9IDFlLTEwLFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgbGV0IHU7XG4gICAgaWYgKFkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KFkpICYmIHR5cGVvZiBZWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICBZID0gTWF0cml4LmNvbHVtblZlY3RvcihZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFkgPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgoWSk7XG4gICAgICB9XG4gICAgICBpZiAoIVkuaXNDb2x1bW5WZWN0b3IoKSB8fCBZLnJvd3MgIT09IFgucm93cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1kgbXVzdCBiZSBhIGNvbHVtbiB2ZWN0b3Igb2YgbGVuZ3RoIFgucm93cycpO1xuICAgICAgfVxuICAgICAgdSA9IFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHUgPSBYLmdldENvbHVtblZlY3RvcigwKTtcbiAgICB9XG5cbiAgICBsZXQgZGlmZiA9IDE7XG4gICAgbGV0IHQsIHEsIHcsIHRPbGQ7XG5cbiAgICBmb3IgKFxuICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgY291bnRlciA8IG1heEl0ZXJhdGlvbnMgJiYgZGlmZiA+IHRlcm1pbmF0aW9uQ3JpdGVyaWE7XG4gICAgICBjb3VudGVyKytcbiAgICApIHtcbiAgICAgIHcgPSBYLnRyYW5zcG9zZSgpLm1tdWwodSkuZGl2KHUudHJhbnNwb3NlKCkubW11bCh1KS5nZXQoMCwgMCkpO1xuICAgICAgdyA9IHcuZGl2KHcubm9ybSgpKTtcblxuICAgICAgdCA9IFgubW11bCh3KS5kaXYody50cmFuc3Bvc2UoKS5tbXVsKHcpLmdldCgwLCAwKSk7XG5cbiAgICAgIGlmIChjb3VudGVyID4gMCkge1xuICAgICAgICBkaWZmID0gdC5jbG9uZSgpLnN1Yih0T2xkKS5wb3coMikuc3VtKCk7XG4gICAgICB9XG4gICAgICB0T2xkID0gdC5jbG9uZSgpO1xuXG4gICAgICBpZiAoWSkge1xuICAgICAgICBxID0gWS50cmFuc3Bvc2UoKS5tbXVsKHQpLmRpdih0LnRyYW5zcG9zZSgpLm1tdWwodCkuZ2V0KDAsIDApKTtcbiAgICAgICAgcSA9IHEuZGl2KHEubm9ybSgpKTtcblxuICAgICAgICB1ID0gWS5tbXVsKHEpLmRpdihxLnRyYW5zcG9zZSgpLm1tdWwocSkuZ2V0KDAsIDApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHUgPSB0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChZKSB7XG4gICAgICBsZXQgcCA9IFgudHJhbnNwb3NlKCkubW11bCh0KS5kaXYodC50cmFuc3Bvc2UoKS5tbXVsKHQpLmdldCgwLCAwKSk7XG4gICAgICBwID0gcC5kaXYocC5ub3JtKCkpO1xuICAgICAgbGV0IHhSZXNpZHVhbCA9IFguY2xvbmUoKS5zdWIodC5jbG9uZSgpLm1tdWwocC50cmFuc3Bvc2UoKSkpO1xuICAgICAgbGV0IHJlc2lkdWFsID0gdS50cmFuc3Bvc2UoKS5tbXVsKHQpLmRpdih0LnRyYW5zcG9zZSgpLm1tdWwodCkuZ2V0KDAsIDApKTtcbiAgICAgIGxldCB5UmVzaWR1YWwgPSBZLmNsb25lKCkuc3ViKFxuICAgICAgICB0LmNsb25lKCkubXVsUyhyZXNpZHVhbC5nZXQoMCwgMCkpLm1tdWwocS50cmFuc3Bvc2UoKSksXG4gICAgICApO1xuXG4gICAgICB0aGlzLnQgPSB0O1xuICAgICAgdGhpcy5wID0gcC50cmFuc3Bvc2UoKTtcbiAgICAgIHRoaXMudyA9IHcudHJhbnNwb3NlKCk7XG4gICAgICB0aGlzLnEgPSBxO1xuICAgICAgdGhpcy51ID0gdTtcbiAgICAgIHRoaXMucyA9IHQudHJhbnNwb3NlKCkubW11bCh0KTtcbiAgICAgIHRoaXMueFJlc2lkdWFsID0geFJlc2lkdWFsO1xuICAgICAgdGhpcy55UmVzaWR1YWwgPSB5UmVzaWR1YWw7XG4gICAgICB0aGlzLmJldGFzID0gcmVzaWR1YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudyA9IHcudHJhbnNwb3NlKCk7XG4gICAgICB0aGlzLnMgPSB0LnRyYW5zcG9zZSgpLm1tdWwodCkuc3FydCgpO1xuICAgICAgaWYgKHNjYWxlU2NvcmVzKSB7XG4gICAgICAgIHRoaXMudCA9IHQuY2xvbmUoKS5kaXYodGhpcy5zLmdldCgwLCAwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnQgPSB0O1xuICAgICAgfVxuICAgICAgdGhpcy54UmVzaWR1YWwgPSBYLnN1Yih0Lm1tdWwody50cmFuc3Bvc2UoKSkpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IE1hdHJpeCBmcm9tICcuLi9tYXRyaXgnO1xuaW1wb3J0IFdyYXBwZXJNYXRyaXgyRCBmcm9tICcuLi93cmFwL1dyYXBwZXJNYXRyaXgyRCc7XG5cbmltcG9ydCB7IGh5cG90ZW51c2UgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRckRlY29tcG9zaXRpb24ge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHZhbHVlID0gV3JhcHBlck1hdHJpeDJELmNoZWNrTWF0cml4KHZhbHVlKTtcblxuICAgIGxldCBxciA9IHZhbHVlLmNsb25lKCk7XG4gICAgbGV0IG0gPSB2YWx1ZS5yb3dzO1xuICAgIGxldCBuID0gdmFsdWUuY29sdW1ucztcbiAgICBsZXQgcmRpYWcgPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICAgIGxldCBpLCBqLCBrLCBzO1xuXG4gICAgZm9yIChrID0gMDsgayA8IG47IGsrKykge1xuICAgICAgbGV0IG5ybSA9IDA7XG4gICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgIG5ybSA9IGh5cG90ZW51c2UobnJtLCBxci5nZXQoaSwgaykpO1xuICAgICAgfVxuICAgICAgaWYgKG5ybSAhPT0gMCkge1xuICAgICAgICBpZiAocXIuZ2V0KGssIGspIDwgMCkge1xuICAgICAgICAgIG5ybSA9IC1ucm07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgIHFyLnNldChpLCBrLCBxci5nZXQoaSwgaykgLyBucm0pO1xuICAgICAgICB9XG4gICAgICAgIHFyLnNldChrLCBrLCBxci5nZXQoaywgaykgKyAxKTtcbiAgICAgICAgZm9yIChqID0gayArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICBzID0gMDtcbiAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICBzICs9IHFyLmdldChpLCBrKSAqIHFyLmdldChpLCBqKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcyA9IC1zIC8gcXIuZ2V0KGssIGspO1xuICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgIHFyLnNldChpLCBqLCBxci5nZXQoaSwgaikgKyBzICogcXIuZ2V0KGksIGspKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJkaWFnW2tdID0gLW5ybTtcbiAgICB9XG5cbiAgICB0aGlzLlFSID0gcXI7XG4gICAgdGhpcy5SZGlhZyA9IHJkaWFnO1xuICB9XG5cbiAgc29sdmUodmFsdWUpIHtcbiAgICB2YWx1ZSA9IE1hdHJpeC5jaGVja01hdHJpeCh2YWx1ZSk7XG5cbiAgICBsZXQgcXIgPSB0aGlzLlFSO1xuICAgIGxldCBtID0gcXIucm93cztcblxuICAgIGlmICh2YWx1ZS5yb3dzICE9PSBtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCByb3cgZGltZW5zaW9ucyBtdXN0IGFncmVlJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0Z1bGxSYW5rKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWF0cml4IGlzIHJhbmsgZGVmaWNpZW50Jyk7XG4gICAgfVxuXG4gICAgbGV0IGNvdW50ID0gdmFsdWUuY29sdW1ucztcbiAgICBsZXQgWCA9IHZhbHVlLmNsb25lKCk7XG4gICAgbGV0IG4gPSBxci5jb2x1bW5zO1xuICAgIGxldCBpLCBqLCBrLCBzO1xuXG4gICAgZm9yIChrID0gMDsgayA8IG47IGsrKykge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgcyA9IDA7XG4gICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICBzICs9IHFyLmdldChpLCBrKSAqIFguZ2V0KGksIGopO1xuICAgICAgICB9XG4gICAgICAgIHMgPSAtcyAvIHFyLmdldChrLCBrKTtcbiAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgIFguc2V0KGksIGosIFguZ2V0KGksIGopICsgcyAqIHFyLmdldChpLCBrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChrID0gbiAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICBYLnNldChrLCBqLCBYLmdldChrLCBqKSAvIHRoaXMuUmRpYWdba10pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICAgIFguc2V0KGksIGosIFguZ2V0KGksIGopIC0gWC5nZXQoaywgaikgKiBxci5nZXQoaSwgaykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFguc3ViTWF0cml4KDAsIG4gLSAxLCAwLCBjb3VudCAtIDEpO1xuICB9XG5cbiAgaXNGdWxsUmFuaygpIHtcbiAgICBsZXQgY29sdW1ucyA9IHRoaXMuUVIuY29sdW1ucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnM7IGkrKykge1xuICAgICAgaWYgKHRoaXMuUmRpYWdbaV0gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldCB1cHBlclRyaWFuZ3VsYXJNYXRyaXgoKSB7XG4gICAgbGV0IHFyID0gdGhpcy5RUjtcbiAgICBsZXQgbiA9IHFyLmNvbHVtbnM7XG4gICAgbGV0IFggPSBuZXcgTWF0cml4KG4sIG4pO1xuICAgIGxldCBpLCBqO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaWYgKGkgPCBqKSB7XG4gICAgICAgICAgWC5zZXQoaSwgaiwgcXIuZ2V0KGksIGopKTtcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgWC5zZXQoaSwgaiwgdGhpcy5SZGlhZ1tpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgWC5zZXQoaSwgaiwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFg7XG4gIH1cblxuICBnZXQgb3J0aG9nb25hbE1hdHJpeCgpIHtcbiAgICBsZXQgcXIgPSB0aGlzLlFSO1xuICAgIGxldCByb3dzID0gcXIucm93cztcbiAgICBsZXQgY29sdW1ucyA9IHFyLmNvbHVtbnM7XG4gICAgbGV0IFggPSBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xuICAgIGxldCBpLCBqLCBrLCBzO1xuXG4gICAgZm9yIChrID0gY29sdW1ucyAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgIFguc2V0KGksIGssIDApO1xuICAgICAgfVxuICAgICAgWC5zZXQoaywgaywgMSk7XG4gICAgICBmb3IgKGogPSBrOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgIGlmIChxci5nZXQoaywgaykgIT09IDApIHtcbiAgICAgICAgICBzID0gMDtcbiAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgICBzICs9IHFyLmdldChpLCBrKSAqIFguZ2V0KGksIGopO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHMgPSAtcyAvIHFyLmdldChrLCBrKTtcblxuICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAgIFguc2V0KGksIGosIFguZ2V0KGksIGopICsgcyAqIHFyLmdldChpLCBrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBYO1xuICB9XG59XG4iLCJpbXBvcnQgTWF0cml4IGZyb20gJy4uL21hdHJpeCc7XG5pbXBvcnQgV3JhcHBlck1hdHJpeDJEIGZyb20gJy4uL3dyYXAvV3JhcHBlck1hdHJpeDJEJztcblxuaW1wb3J0IHsgaHlwb3RlbnVzZSB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHZhbHVlID0gV3JhcHBlck1hdHJpeDJELmNoZWNrTWF0cml4KHZhbHVlKTtcblxuICAgIGxldCBtID0gdmFsdWUucm93cztcbiAgICBsZXQgbiA9IHZhbHVlLmNvbHVtbnM7XG5cbiAgICBjb25zdCB7XG4gICAgICBjb21wdXRlTGVmdFNpbmd1bGFyVmVjdG9ycyA9IHRydWUsXG4gICAgICBjb21wdXRlUmlnaHRTaW5ndWxhclZlY3RvcnMgPSB0cnVlLFxuICAgICAgYXV0b1RyYW5zcG9zZSA9IGZhbHNlLFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgbGV0IHdhbnR1ID0gQm9vbGVhbihjb21wdXRlTGVmdFNpbmd1bGFyVmVjdG9ycyk7XG4gICAgbGV0IHdhbnR2ID0gQm9vbGVhbihjb21wdXRlUmlnaHRTaW5ndWxhclZlY3RvcnMpO1xuXG4gICAgbGV0IHN3YXBwZWQgPSBmYWxzZTtcbiAgICBsZXQgYTtcbiAgICBpZiAobSA8IG4pIHtcbiAgICAgIGlmICghYXV0b1RyYW5zcG9zZSkge1xuICAgICAgICBhID0gdmFsdWUuY2xvbmUoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdDb21wdXRpbmcgU1ZEIG9uIGEgbWF0cml4IHdpdGggbW9yZSBjb2x1bW5zIHRoYW4gcm93cy4gQ29uc2lkZXIgZW5hYmxpbmcgYXV0b1RyYW5zcG9zZScsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhID0gdmFsdWUudHJhbnNwb3NlKCk7XG4gICAgICAgIG0gPSBhLnJvd3M7XG4gICAgICAgIG4gPSBhLmNvbHVtbnM7XG4gICAgICAgIHN3YXBwZWQgPSB0cnVlO1xuICAgICAgICBsZXQgYXV4ID0gd2FudHU7XG4gICAgICAgIHdhbnR1ID0gd2FudHY7XG4gICAgICAgIHdhbnR2ID0gYXV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhID0gdmFsdWUuY2xvbmUoKTtcbiAgICB9XG5cbiAgICBsZXQgbnUgPSBNYXRoLm1pbihtLCBuKTtcbiAgICBsZXQgbmkgPSBNYXRoLm1pbihtICsgMSwgbik7XG4gICAgbGV0IHMgPSBuZXcgRmxvYXQ2NEFycmF5KG5pKTtcbiAgICBsZXQgVSA9IG5ldyBNYXRyaXgobSwgbnUpO1xuICAgIGxldCBWID0gbmV3IE1hdHJpeChuLCBuKTtcblxuICAgIGxldCBlID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgICBsZXQgd29yayA9IG5ldyBGbG9hdDY0QXJyYXkobSk7XG5cbiAgICBsZXQgc2kgPSBuZXcgRmxvYXQ2NEFycmF5KG5pKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5pOyBpKyspIHNpW2ldID0gaTtcblxuICAgIGxldCBuY3QgPSBNYXRoLm1pbihtIC0gMSwgbik7XG4gICAgbGV0IG5ydCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG4gLSAyLCBtKSk7XG4gICAgbGV0IG1yYyA9IE1hdGgubWF4KG5jdCwgbnJ0KTtcblxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbXJjOyBrKyspIHtcbiAgICAgIGlmIChrIDwgbmN0KSB7XG4gICAgICAgIHNba10gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgIHNba10gPSBoeXBvdGVudXNlKHNba10sIGEuZ2V0KGksIGspKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc1trXSAhPT0gMCkge1xuICAgICAgICAgIGlmIChhLmdldChrLCBrKSA8IDApIHtcbiAgICAgICAgICAgIHNba10gPSAtc1trXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgIGEuc2V0KGksIGssIGEuZ2V0KGksIGspIC8gc1trXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGEuc2V0KGssIGssIGEuZ2V0KGssIGspICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc1trXSA9IC1zW2tdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBqID0gayArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaWYgKGsgPCBuY3QgJiYgc1trXSAhPT0gMCkge1xuICAgICAgICAgIGxldCB0ID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgdCArPSBhLmdldChpLCBrKSAqIGEuZ2V0KGksIGopO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ID0gLXQgLyBhLmdldChrLCBrKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgYS5zZXQoaSwgaiwgYS5nZXQoaSwgaikgKyB0ICogYS5nZXQoaSwgaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlW2pdID0gYS5nZXQoaywgaik7XG4gICAgICB9XG5cbiAgICAgIGlmICh3YW50dSAmJiBrIDwgbmN0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgVS5zZXQoaSwgaywgYS5nZXQoaSwgaykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChrIDwgbnJ0KSB7XG4gICAgICAgIGVba10gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gayArIDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBlW2tdID0gaHlwb3RlbnVzZShlW2tdLCBlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZVtrXSAhPT0gMCkge1xuICAgICAgICAgIGlmIChlW2sgKyAxXSA8IDApIHtcbiAgICAgICAgICAgIGVba10gPSAwIC0gZVtrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGsgKyAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBlW2ldIC89IGVba107XG4gICAgICAgICAgfVxuICAgICAgICAgIGVbayArIDFdICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZVtrXSA9IC1lW2tdO1xuICAgICAgICBpZiAoayArIDEgPCBtICYmIGVba10gIT09IDApIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gayArIDE7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgIHdvcmtbaV0gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBpID0gayArIDE7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBrICsgMTsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICB3b3JrW2ldICs9IGVbal0gKiBhLmdldChpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaiA9IGsgKyAxOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICBsZXQgdCA9IC1lW2pdIC8gZVtrICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gayArIDE7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgYS5zZXQoaSwgaiwgYS5nZXQoaSwgaikgKyB0ICogd29ya1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3YW50dikge1xuICAgICAgICAgIGZvciAobGV0IGkgPSBrICsgMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgVi5zZXQoaSwgaywgZVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHAgPSBNYXRoLm1pbihuLCBtICsgMSk7XG4gICAgaWYgKG5jdCA8IG4pIHtcbiAgICAgIHNbbmN0XSA9IGEuZ2V0KG5jdCwgbmN0KTtcbiAgICB9XG4gICAgaWYgKG0gPCBwKSB7XG4gICAgICBzW3AgLSAxXSA9IDA7XG4gICAgfVxuICAgIGlmIChucnQgKyAxIDwgcCkge1xuICAgICAgZVtucnRdID0gYS5nZXQobnJ0LCBwIC0gMSk7XG4gICAgfVxuICAgIGVbcCAtIDFdID0gMDtcblxuICAgIGlmICh3YW50dSkge1xuICAgICAgZm9yIChsZXQgaiA9IG5jdDsgaiA8IG51OyBqKyspIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICBVLnNldChpLCBqLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBVLnNldChqLCBqLCAxKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGsgPSBuY3QgLSAxOyBrID49IDA7IGstLSkge1xuICAgICAgICBpZiAoc1trXSAhPT0gMCkge1xuICAgICAgICAgIGZvciAobGV0IGogPSBrICsgMTsgaiA8IG51OyBqKyspIHtcbiAgICAgICAgICAgIGxldCB0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgIHQgKz0gVS5nZXQoaSwgaykgKiBVLmdldChpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSAtdCAvIFUuZ2V0KGssIGspO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgVS5zZXQoaSwgaiwgVS5nZXQoaSwgaikgKyB0ICogVS5nZXQoaSwgaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgVS5zZXQoaSwgaywgLVUuZ2V0KGksIGspKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgVS5zZXQoaywgaywgMSArIFUuZ2V0KGssIGspKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGsgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIFUuc2V0KGksIGssIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgVS5zZXQoaSwgaywgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFUuc2V0KGssIGssIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdhbnR2KSB7XG4gICAgICBmb3IgKGxldCBrID0gbiAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgIGlmIChrIDwgbnJ0ICYmIGVba10gIT09IDApIHtcbiAgICAgICAgICBmb3IgKGxldCBqID0gayArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgIGxldCB0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBrICsgMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICB0ICs9IFYuZ2V0KGksIGspICogVi5nZXQoaSwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gLXQgLyBWLmdldChrICsgMSwgayk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gayArIDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgVi5zZXQoaSwgaiwgVi5nZXQoaSwgaikgKyB0ICogVi5nZXQoaSwgaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIFYuc2V0KGksIGssIDApO1xuICAgICAgICB9XG4gICAgICAgIFYuc2V0KGssIGssIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBwcCA9IHAgLSAxO1xuICAgIGxldCBpdGVyID0gMDtcbiAgICBsZXQgZXBzID0gTnVtYmVyLkVQU0lMT047XG4gICAgd2hpbGUgKHAgPiAwKSB7XG4gICAgICBsZXQgaywga2FzZTtcbiAgICAgIGZvciAoayA9IHAgLSAyOyBrID49IC0xOyBrLS0pIHtcbiAgICAgICAgaWYgKGsgPT09IC0xKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxwaGEgPVxuICAgICAgICAgIE51bWJlci5NSU5fVkFMVUUgKyBlcHMgKiBNYXRoLmFicyhzW2tdICsgTWF0aC5hYnMoc1trICsgMV0pKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGVba10pIDw9IGFscGhhIHx8IE51bWJlci5pc05hTihlW2tdKSkge1xuICAgICAgICAgIGVba10gPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoayA9PT0gcCAtIDIpIHtcbiAgICAgICAga2FzZSA9IDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQga3M7XG4gICAgICAgIGZvciAoa3MgPSBwIC0gMTsga3MgPj0gazsga3MtLSkge1xuICAgICAgICAgIGlmIChrcyA9PT0gaykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB0ID1cbiAgICAgICAgICAgIChrcyAhPT0gcCA/IE1hdGguYWJzKGVba3NdKSA6IDApICtcbiAgICAgICAgICAgIChrcyAhPT0gayArIDEgPyBNYXRoLmFicyhlW2tzIC0gMV0pIDogMCk7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKHNba3NdKSA8PSBlcHMgKiB0KSB7XG4gICAgICAgICAgICBzW2tzXSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtzID09PSBrKSB7XG4gICAgICAgICAga2FzZSA9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAoa3MgPT09IHAgLSAxKSB7XG4gICAgICAgICAga2FzZSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2FzZSA9IDI7XG4gICAgICAgICAgayA9IGtzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGsrKztcblxuICAgICAgc3dpdGNoIChrYXNlKSB7XG4gICAgICAgIGNhc2UgMToge1xuICAgICAgICAgIGxldCBmID0gZVtwIC0gMl07XG4gICAgICAgICAgZVtwIC0gMl0gPSAwO1xuICAgICAgICAgIGZvciAobGV0IGogPSBwIC0gMjsgaiA+PSBrOyBqLS0pIHtcbiAgICAgICAgICAgIGxldCB0ID0gaHlwb3RlbnVzZShzW2pdLCBmKTtcbiAgICAgICAgICAgIGxldCBjcyA9IHNbal0gLyB0O1xuICAgICAgICAgICAgbGV0IHNuID0gZiAvIHQ7XG4gICAgICAgICAgICBzW2pdID0gdDtcbiAgICAgICAgICAgIGlmIChqICE9PSBrKSB7XG4gICAgICAgICAgICAgIGYgPSAtc24gKiBlW2ogLSAxXTtcbiAgICAgICAgICAgICAgZVtqIC0gMV0gPSBjcyAqIGVbaiAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdhbnR2KSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdCA9IGNzICogVi5nZXQoaSwgaikgKyBzbiAqIFYuZ2V0KGksIHAgLSAxKTtcbiAgICAgICAgICAgICAgICBWLnNldChpLCBwIC0gMSwgLXNuICogVi5nZXQoaSwgaikgKyBjcyAqIFYuZ2V0KGksIHAgLSAxKSk7XG4gICAgICAgICAgICAgICAgVi5zZXQoaSwgaiwgdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgbGV0IGYgPSBlW2sgLSAxXTtcbiAgICAgICAgICBlW2sgLSAxXSA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IGs7IGogPCBwOyBqKyspIHtcbiAgICAgICAgICAgIGxldCB0ID0gaHlwb3RlbnVzZShzW2pdLCBmKTtcbiAgICAgICAgICAgIGxldCBjcyA9IHNbal0gLyB0O1xuICAgICAgICAgICAgbGV0IHNuID0gZiAvIHQ7XG4gICAgICAgICAgICBzW2pdID0gdDtcbiAgICAgICAgICAgIGYgPSAtc24gKiBlW2pdO1xuICAgICAgICAgICAgZVtqXSA9IGNzICogZVtqXTtcbiAgICAgICAgICAgIGlmICh3YW50dSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgIHQgPSBjcyAqIFUuZ2V0KGksIGopICsgc24gKiBVLmdldChpLCBrIC0gMSk7XG4gICAgICAgICAgICAgICAgVS5zZXQoaSwgayAtIDEsIC1zbiAqIFUuZ2V0KGksIGopICsgY3MgKiBVLmdldChpLCBrIC0gMSkpO1xuICAgICAgICAgICAgICAgIFUuc2V0KGksIGosIHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5tYXgoXG4gICAgICAgICAgICBNYXRoLmFicyhzW3AgLSAxXSksXG4gICAgICAgICAgICBNYXRoLmFicyhzW3AgLSAyXSksXG4gICAgICAgICAgICBNYXRoLmFicyhlW3AgLSAyXSksXG4gICAgICAgICAgICBNYXRoLmFicyhzW2tdKSxcbiAgICAgICAgICAgIE1hdGguYWJzKGVba10pLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qgc3AgPSBzW3AgLSAxXSAvIHNjYWxlO1xuICAgICAgICAgIGNvbnN0IHNwbTEgPSBzW3AgLSAyXSAvIHNjYWxlO1xuICAgICAgICAgIGNvbnN0IGVwbTEgPSBlW3AgLSAyXSAvIHNjYWxlO1xuICAgICAgICAgIGNvbnN0IHNrID0gc1trXSAvIHNjYWxlO1xuICAgICAgICAgIGNvbnN0IGVrID0gZVtrXSAvIHNjYWxlO1xuICAgICAgICAgIGNvbnN0IGIgPSAoKHNwbTEgKyBzcCkgKiAoc3BtMSAtIHNwKSArIGVwbTEgKiBlcG0xKSAvIDI7XG4gICAgICAgICAgY29uc3QgYyA9IHNwICogZXBtMSAqIChzcCAqIGVwbTEpO1xuICAgICAgICAgIGxldCBzaGlmdCA9IDA7XG4gICAgICAgICAgaWYgKGIgIT09IDAgfHwgYyAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKGIgPCAwKSB7XG4gICAgICAgICAgICAgIHNoaWZ0ID0gMCAtIE1hdGguc3FydChiICogYiArIGMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2hpZnQgPSBNYXRoLnNxcnQoYiAqIGIgKyBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoaWZ0ID0gYyAvIChiICsgc2hpZnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZiA9IChzayArIHNwKSAqIChzayAtIHNwKSArIHNoaWZ0O1xuICAgICAgICAgIGxldCBnID0gc2sgKiBlaztcbiAgICAgICAgICBmb3IgKGxldCBqID0gazsgaiA8IHAgLSAxOyBqKyspIHtcbiAgICAgICAgICAgIGxldCB0ID0gaHlwb3RlbnVzZShmLCBnKTtcbiAgICAgICAgICAgIGlmICh0ID09PSAwKSB0ID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICAgICAgICAgIGxldCBjcyA9IGYgLyB0O1xuICAgICAgICAgICAgbGV0IHNuID0gZyAvIHQ7XG4gICAgICAgICAgICBpZiAoaiAhPT0gaykge1xuICAgICAgICAgICAgICBlW2ogLSAxXSA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmID0gY3MgKiBzW2pdICsgc24gKiBlW2pdO1xuICAgICAgICAgICAgZVtqXSA9IGNzICogZVtqXSAtIHNuICogc1tqXTtcbiAgICAgICAgICAgIGcgPSBzbiAqIHNbaiArIDFdO1xuICAgICAgICAgICAgc1tqICsgMV0gPSBjcyAqIHNbaiArIDFdO1xuICAgICAgICAgICAgaWYgKHdhbnR2KSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdCA9IGNzICogVi5nZXQoaSwgaikgKyBzbiAqIFYuZ2V0KGksIGogKyAxKTtcbiAgICAgICAgICAgICAgICBWLnNldChpLCBqICsgMSwgLXNuICogVi5nZXQoaSwgaikgKyBjcyAqIFYuZ2V0KGksIGogKyAxKSk7XG4gICAgICAgICAgICAgICAgVi5zZXQoaSwgaiwgdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSBoeXBvdGVudXNlKGYsIGcpO1xuICAgICAgICAgICAgaWYgKHQgPT09IDApIHQgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgICAgICAgICAgY3MgPSBmIC8gdDtcbiAgICAgICAgICAgIHNuID0gZyAvIHQ7XG4gICAgICAgICAgICBzW2pdID0gdDtcbiAgICAgICAgICAgIGYgPSBjcyAqIGVbal0gKyBzbiAqIHNbaiArIDFdO1xuICAgICAgICAgICAgc1tqICsgMV0gPSAtc24gKiBlW2pdICsgY3MgKiBzW2ogKyAxXTtcbiAgICAgICAgICAgIGcgPSBzbiAqIGVbaiArIDFdO1xuICAgICAgICAgICAgZVtqICsgMV0gPSBjcyAqIGVbaiArIDFdO1xuICAgICAgICAgICAgaWYgKHdhbnR1ICYmIGogPCBtIC0gMSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgIHQgPSBjcyAqIFUuZ2V0KGksIGopICsgc24gKiBVLmdldChpLCBqICsgMSk7XG4gICAgICAgICAgICAgICAgVS5zZXQoaSwgaiArIDEsIC1zbiAqIFUuZ2V0KGksIGopICsgY3MgKiBVLmdldChpLCBqICsgMSkpO1xuICAgICAgICAgICAgICAgIFUuc2V0KGksIGosIHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVbcCAtIDJdID0gZjtcbiAgICAgICAgICBpdGVyID0gaXRlciArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgaWYgKHNba10gPD0gMCkge1xuICAgICAgICAgICAgc1trXSA9IHNba10gPCAwID8gLXNba10gOiAwO1xuICAgICAgICAgICAgaWYgKHdhbnR2KSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHBwOyBpKyspIHtcbiAgICAgICAgICAgICAgICBWLnNldChpLCBrLCAtVi5nZXQoaSwgaykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChrIDwgcHApIHtcbiAgICAgICAgICAgIGlmIChzW2tdID49IHNbayArIDFdKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHQgPSBzW2tdO1xuICAgICAgICAgICAgc1trXSA9IHNbayArIDFdO1xuICAgICAgICAgICAgc1trICsgMV0gPSB0O1xuICAgICAgICAgICAgaWYgKHdhbnR2ICYmIGsgPCBuIC0gMSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHQgPSBWLmdldChpLCBrICsgMSk7XG4gICAgICAgICAgICAgICAgVi5zZXQoaSwgayArIDEsIFYuZ2V0KGksIGspKTtcbiAgICAgICAgICAgICAgICBWLnNldChpLCBrLCB0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdhbnR1ICYmIGsgPCBtIC0gMSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgIHQgPSBVLmdldChpLCBrICsgMSk7XG4gICAgICAgICAgICAgICAgVS5zZXQoaSwgayArIDEsIFUuZ2V0KGksIGspKTtcbiAgICAgICAgICAgICAgICBVLnNldChpLCBrLCB0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVyID0gMDtcbiAgICAgICAgICBwLS07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm8gZGVmYXVsdFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzd2FwcGVkKSB7XG4gICAgICBsZXQgdG1wID0gVjtcbiAgICAgIFYgPSBVO1xuICAgICAgVSA9IHRtcDtcbiAgICB9XG5cbiAgICB0aGlzLm0gPSBtO1xuICAgIHRoaXMubiA9IG47XG4gICAgdGhpcy5zID0gcztcbiAgICB0aGlzLlUgPSBVO1xuICAgIHRoaXMuViA9IFY7XG4gIH1cblxuICBzb2x2ZSh2YWx1ZSkge1xuICAgIGxldCBZID0gdmFsdWU7XG4gICAgbGV0IGUgPSB0aGlzLnRocmVzaG9sZDtcbiAgICBsZXQgc2NvbHMgPSB0aGlzLnMubGVuZ3RoO1xuICAgIGxldCBMcyA9IE1hdHJpeC56ZXJvcyhzY29scywgc2NvbHMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY29sczsgaSsrKSB7XG4gICAgICBpZiAoTWF0aC5hYnModGhpcy5zW2ldKSA8PSBlKSB7XG4gICAgICAgIExzLnNldChpLCBpLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIExzLnNldChpLCBpLCAxIC8gdGhpcy5zW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgVSA9IHRoaXMuVTtcbiAgICBsZXQgViA9IHRoaXMucmlnaHRTaW5ndWxhclZlY3RvcnM7XG5cbiAgICBsZXQgVkwgPSBWLm1tdWwoTHMpO1xuICAgIGxldCB2cm93cyA9IFYucm93cztcbiAgICBsZXQgdXJvd3MgPSBVLnJvd3M7XG4gICAgbGV0IFZMVSA9IE1hdHJpeC56ZXJvcyh2cm93cywgdXJvd3MpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2cm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHVyb3dzOyBqKyspIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgc2NvbHM7IGsrKykge1xuICAgICAgICAgIHN1bSArPSBWTC5nZXQoaSwgaykgKiBVLmdldChqLCBrKTtcbiAgICAgICAgfVxuICAgICAgICBWTFUuc2V0KGksIGosIHN1bSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFZMVS5tbXVsKFkpO1xuICB9XG5cbiAgc29sdmVGb3JEaWFnb25hbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnNvbHZlKE1hdHJpeC5kaWFnKHZhbHVlKSk7XG4gIH1cblxuICBpbnZlcnNlKCkge1xuICAgIGxldCBWID0gdGhpcy5WO1xuICAgIGxldCBlID0gdGhpcy50aHJlc2hvbGQ7XG4gICAgbGV0IHZyb3dzID0gVi5yb3dzO1xuICAgIGxldCB2Y29scyA9IFYuY29sdW1ucztcbiAgICBsZXQgWCA9IG5ldyBNYXRyaXgodnJvd3MsIHRoaXMucy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2cm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZjb2xzOyBqKyspIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuc1tqXSkgPiBlKSB7XG4gICAgICAgICAgWC5zZXQoaSwgaiwgVi5nZXQoaSwgaikgLyB0aGlzLnNbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IFUgPSB0aGlzLlU7XG5cbiAgICBsZXQgdXJvd3MgPSBVLnJvd3M7XG4gICAgbGV0IHVjb2xzID0gVS5jb2x1bW5zO1xuICAgIGxldCBZID0gbmV3IE1hdHJpeCh2cm93cywgdXJvd3MpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2cm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHVyb3dzOyBqKyspIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdWNvbHM7IGsrKykge1xuICAgICAgICAgIHN1bSArPSBYLmdldChpLCBrKSAqIFUuZ2V0KGosIGspO1xuICAgICAgICB9XG4gICAgICAgIFkuc2V0KGksIGosIHN1bSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFk7XG4gIH1cblxuICBnZXQgY29uZGl0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNbMF0gLyB0aGlzLnNbTWF0aC5taW4odGhpcy5tLCB0aGlzLm4pIC0gMV07XG4gIH1cblxuICBnZXQgbm9ybTIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc1swXTtcbiAgfVxuXG4gIGdldCByYW5rKCkge1xuICAgIGxldCB0b2wgPSBNYXRoLm1heCh0aGlzLm0sIHRoaXMubikgKiB0aGlzLnNbMF0gKiBOdW1iZXIuRVBTSUxPTjtcbiAgICBsZXQgciA9IDA7XG4gICAgbGV0IHMgPSB0aGlzLnM7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZiAoc1tpXSA+IHRvbCkge1xuICAgICAgICByKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgZ2V0IGRpYWdvbmFsKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucyk7XG4gIH1cblxuICBnZXQgdGhyZXNob2xkKCkge1xuICAgIHJldHVybiAoTnVtYmVyLkVQU0lMT04gLyAyKSAqIE1hdGgubWF4KHRoaXMubSwgdGhpcy5uKSAqIHRoaXMuc1swXTtcbiAgfVxuXG4gIGdldCBsZWZ0U2luZ3VsYXJWZWN0b3JzKCkge1xuICAgIHJldHVybiB0aGlzLlU7XG4gIH1cblxuICBnZXQgcmlnaHRTaW5ndWxhclZlY3RvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuVjtcbiAgfVxuXG4gIGdldCBkaWFnb25hbE1hdHJpeCgpIHtcbiAgICByZXR1cm4gTWF0cml4LmRpYWcodGhpcy5zKTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGh5cG90ZW51c2UoYSwgYikge1xuICBsZXQgciA9IDA7XG4gIGlmIChNYXRoLmFicyhhKSA+IE1hdGguYWJzKGIpKSB7XG4gICAgciA9IGIgLyBhO1xuICAgIHJldHVybiBNYXRoLmFicyhhKSAqIE1hdGguc3FydCgxICsgciAqIHIpO1xuICB9XG4gIGlmIChiICE9PSAwKSB7XG4gICAgciA9IGEgLyBiO1xuICAgIHJldHVybiBNYXRoLmFicyhiKSAqIE1hdGguc3FydCgxICsgciAqIHIpO1xuICB9XG4gIHJldHVybiAwO1xufVxuIiwiaW1wb3J0IEx1RGVjb21wb3NpdGlvbiBmcm9tICcuL2RjL2x1JztcbmltcG9ydCBRckRlY29tcG9zaXRpb24gZnJvbSAnLi9kYy9xcic7XG5pbXBvcnQgU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24gZnJvbSAnLi9kYy9zdmQnO1xuaW1wb3J0IE1hdHJpeCBmcm9tICcuL21hdHJpeCc7XG5pbXBvcnQgV3JhcHBlck1hdHJpeDJEIGZyb20gJy4vd3JhcC9XcmFwcGVyTWF0cml4MkQnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShtYXRyaXgsIHVzZVNWRCA9IGZhbHNlKSB7XG4gIG1hdHJpeCA9IFdyYXBwZXJNYXRyaXgyRC5jaGVja01hdHJpeChtYXRyaXgpO1xuICBpZiAodXNlU1ZEKSB7XG4gICAgcmV0dXJuIG5ldyBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbihtYXRyaXgpLmludmVyc2UoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc29sdmUobWF0cml4LCBNYXRyaXguZXllKG1hdHJpeC5yb3dzKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvbHZlKGxlZnRIYW5kU2lkZSwgcmlnaHRIYW5kU2lkZSwgdXNlU1ZEID0gZmFsc2UpIHtcbiAgbGVmdEhhbmRTaWRlID0gV3JhcHBlck1hdHJpeDJELmNoZWNrTWF0cml4KGxlZnRIYW5kU2lkZSk7XG4gIHJpZ2h0SGFuZFNpZGUgPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgocmlnaHRIYW5kU2lkZSk7XG4gIGlmICh1c2VTVkQpIHtcbiAgICByZXR1cm4gbmV3IFNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uKGxlZnRIYW5kU2lkZSkuc29sdmUocmlnaHRIYW5kU2lkZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxlZnRIYW5kU2lkZS5pc1NxdWFyZSgpXG4gICAgICA/IG5ldyBMdURlY29tcG9zaXRpb24obGVmdEhhbmRTaWRlKS5zb2x2ZShyaWdodEhhbmRTaWRlKVxuICAgICAgOiBuZXcgUXJEZWNvbXBvc2l0aW9uKGxlZnRIYW5kU2lkZSkuc29sdmUocmlnaHRIYW5kU2lkZSk7XG4gIH1cbn1cbiIsImltcG9ydCBMdURlY29tcG9zaXRpb24gZnJvbSAnLi9kYy9sdSc7XG5pbXBvcnQgTWF0cml4IGZyb20gJy4vbWF0cml4JztcbmltcG9ydCBNYXRyaXhTZWxlY3Rpb25WaWV3IGZyb20gJy4vdmlld3Mvc2VsZWN0aW9uJztcblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KG1hdHJpeCkge1xuICBtYXRyaXggPSBNYXRyaXguY2hlY2tNYXRyaXgobWF0cml4KTtcbiAgaWYgKG1hdHJpeC5pc1NxdWFyZSgpKSB7XG4gICAgbGV0IGEsIGIsIGMsIGQ7XG4gICAgaWYgKG1hdHJpeC5jb2x1bW5zID09PSAyKSB7XG4gICAgICAvLyAyIHggMiBtYXRyaXhcbiAgICAgIGEgPSBtYXRyaXguZ2V0KDAsIDApO1xuICAgICAgYiA9IG1hdHJpeC5nZXQoMCwgMSk7XG4gICAgICBjID0gbWF0cml4LmdldCgxLCAwKTtcbiAgICAgIGQgPSBtYXRyaXguZ2V0KDEsIDEpO1xuXG4gICAgICByZXR1cm4gYSAqIGQgLSBiICogYztcbiAgICB9IGVsc2UgaWYgKG1hdHJpeC5jb2x1bW5zID09PSAzKSB7XG4gICAgICAvLyAzIHggMyBtYXRyaXhcbiAgICAgIGxldCBzdWJNYXRyaXgwLCBzdWJNYXRyaXgxLCBzdWJNYXRyaXgyO1xuICAgICAgc3ViTWF0cml4MCA9IG5ldyBNYXRyaXhTZWxlY3Rpb25WaWV3KG1hdHJpeCwgWzEsIDJdLCBbMSwgMl0pO1xuICAgICAgc3ViTWF0cml4MSA9IG5ldyBNYXRyaXhTZWxlY3Rpb25WaWV3KG1hdHJpeCwgWzEsIDJdLCBbMCwgMl0pO1xuICAgICAgc3ViTWF0cml4MiA9IG5ldyBNYXRyaXhTZWxlY3Rpb25WaWV3KG1hdHJpeCwgWzEsIDJdLCBbMCwgMV0pO1xuICAgICAgYSA9IG1hdHJpeC5nZXQoMCwgMCk7XG4gICAgICBiID0gbWF0cml4LmdldCgwLCAxKTtcbiAgICAgIGMgPSBtYXRyaXguZ2V0KDAsIDIpO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBhICogZGV0ZXJtaW5hbnQoc3ViTWF0cml4MCkgLVxuICAgICAgICBiICogZGV0ZXJtaW5hbnQoc3ViTWF0cml4MSkgK1xuICAgICAgICBjICogZGV0ZXJtaW5hbnQoc3ViTWF0cml4MilcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdlbmVyYWwgcHVycG9zZSBkZXRlcm1pbmFudCB1c2luZyB0aGUgTFUgZGVjb21wb3NpdGlvblxuICAgICAgcmV0dXJuIG5ldyBMdURlY29tcG9zaXRpb24obWF0cml4KS5kZXRlcm1pbmFudDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoJ2RldGVybWluYW50IGNhbiBvbmx5IGJlIGNhbGN1bGF0ZWQgZm9yIGEgc3F1YXJlIG1hdHJpeCcpO1xuICB9XG59XG4iLCJleHBvcnQgeyBBYnN0cmFjdE1hdHJpeCwgZGVmYXVsdCwgZGVmYXVsdCBhcyBNYXRyaXggfSBmcm9tICcuL21hdHJpeCc7XG5leHBvcnQgKiBmcm9tICcuL3ZpZXdzL2luZGV4JztcblxuZXhwb3J0IHsgd3JhcCB9IGZyb20gJy4vd3JhcC93cmFwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgV3JhcHBlck1hdHJpeDFEIH0gZnJvbSAnLi93cmFwL1dyYXBwZXJNYXRyaXgxRCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFdyYXBwZXJNYXRyaXgyRCB9IGZyb20gJy4vd3JhcC9XcmFwcGVyTWF0cml4MkQnO1xuXG5leHBvcnQgeyBzb2x2ZSwgaW52ZXJzZSB9IGZyb20gJy4vZGVjb21wb3NpdGlvbnMnO1xuZXhwb3J0IHsgZGV0ZXJtaW5hbnQgfSBmcm9tICcuL2RldGVybWluYW50JztcbmV4cG9ydCB7IGxpbmVhckRlcGVuZGVuY2llcyB9IGZyb20gJy4vbGluZWFyRGVwZW5kZW5jaWVzJztcbmV4cG9ydCB7IHBzZXVkb0ludmVyc2UgfSBmcm9tICcuL3BzZXVkb0ludmVyc2UnO1xuZXhwb3J0IHsgY292YXJpYW5jZSB9IGZyb20gJy4vY292YXJpYW5jZSc7XG5leHBvcnQgeyBjb3JyZWxhdGlvbiB9IGZyb20gJy4vY29ycmVsYXRpb24nO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIFNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uLFxuICBkZWZhdWx0IGFzIFNWRCxcbn0gZnJvbSAnLi9kYy9zdmQuanMnO1xuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBFaWdlbnZhbHVlRGVjb21wb3NpdGlvbixcbiAgZGVmYXVsdCBhcyBFVkQsXG59IGZyb20gJy4vZGMvZXZkLmpzJztcbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgQ2hvbGVza3lEZWNvbXBvc2l0aW9uLFxuICBkZWZhdWx0IGFzIENITyxcbn0gZnJvbSAnLi9kYy9jaG9sZXNreS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEx1RGVjb21wb3NpdGlvbiwgZGVmYXVsdCBhcyBMVSB9IGZyb20gJy4vZGMvbHUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBRckRlY29tcG9zaXRpb24sIGRlZmF1bHQgYXMgUVIgfSBmcm9tICcuL2RjL3FyLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTmlwYWxzLCBkZWZhdWx0IGFzIE5JUEFMUyB9IGZyb20gJy4vZGMvbmlwYWxzLmpzJztcbiIsImNvbnN0IGluZGVudCA9ICcgJy5yZXBlYXQoMik7XG5jb25zdCBpbmRlbnREYXRhID0gJyAnLnJlcGVhdCg0KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGluc3BlY3RNYXRyaXgoKSB7XG4gIHJldHVybiBpbnNwZWN0TWF0cml4V2l0aE9wdGlvbnModGhpcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnNwZWN0TWF0cml4V2l0aE9wdGlvbnMobWF0cml4LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBtYXhSb3dzID0gMTUsIG1heENvbHVtbnMgPSAxMCwgbWF4TnVtU2l6ZSA9IDggfSA9IG9wdGlvbnM7XG4gIHJldHVybiBgJHttYXRyaXguY29uc3RydWN0b3IubmFtZX0ge1xuJHtpbmRlbnR9W1xuJHtpbmRlbnREYXRhfSR7aW5zcGVjdERhdGEobWF0cml4LCBtYXhSb3dzLCBtYXhDb2x1bW5zLCBtYXhOdW1TaXplKX1cbiR7aW5kZW50fV1cbiR7aW5kZW50fXJvd3M6ICR7bWF0cml4LnJvd3N9XG4ke2luZGVudH1jb2x1bW5zOiAke21hdHJpeC5jb2x1bW5zfVxufWA7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3REYXRhKG1hdHJpeCwgbWF4Um93cywgbWF4Q29sdW1ucywgbWF4TnVtU2l6ZSkge1xuICBjb25zdCB7IHJvd3MsIGNvbHVtbnMgfSA9IG1hdHJpeDtcbiAgY29uc3QgbWF4SSA9IE1hdGgubWluKHJvd3MsIG1heFJvd3MpO1xuICBjb25zdCBtYXhKID0gTWF0aC5taW4oY29sdW1ucywgbWF4Q29sdW1ucyk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEk7IGkrKykge1xuICAgIGxldCBsaW5lID0gW107XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXhKOyBqKyspIHtcbiAgICAgIGxpbmUucHVzaChmb3JtYXROdW1iZXIobWF0cml4LmdldChpLCBqKSwgbWF4TnVtU2l6ZSkpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChgJHtsaW5lLmpvaW4oJyAnKX1gKTtcbiAgfVxuICBpZiAobWF4SiAhPT0gY29sdW1ucykge1xuICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gKz0gYCAuLi4gJHtjb2x1bW5zIC0gbWF4Q29sdW1uc30gbW9yZSBjb2x1bW5zYDtcbiAgfVxuICBpZiAobWF4SSAhPT0gcm93cykge1xuICAgIHJlc3VsdC5wdXNoKGAuLi4gJHtyb3dzIC0gbWF4Um93c30gbW9yZSByb3dzYCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5qb2luKGBcXG4ke2luZGVudERhdGF9YCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW0sIG1heE51bVNpemUpIHtcbiAgY29uc3QgbnVtU3RyID0gU3RyaW5nKG51bSk7XG4gIGlmIChudW1TdHIubGVuZ3RoIDw9IG1heE51bVNpemUpIHtcbiAgICByZXR1cm4gbnVtU3RyLnBhZEVuZChtYXhOdW1TaXplLCAnICcpO1xuICB9XG4gIGNvbnN0IHByZWNpc2UgPSBudW0udG9QcmVjaXNpb24obWF4TnVtU2l6ZSAtIDIpO1xuICBpZiAocHJlY2lzZS5sZW5ndGggPD0gbWF4TnVtU2l6ZSkge1xuICAgIHJldHVybiBwcmVjaXNlO1xuICB9XG4gIGNvbnN0IGV4cG9uZW50aWFsID0gbnVtLnRvRXhwb25lbnRpYWwobWF4TnVtU2l6ZSAtIDIpO1xuICBjb25zdCBlSW5kZXggPSBleHBvbmVudGlhbC5pbmRleE9mKCdlJyk7XG4gIGNvbnN0IGUgPSBleHBvbmVudGlhbC5zbGljZShlSW5kZXgpO1xuICByZXR1cm4gZXhwb25lbnRpYWwuc2xpY2UoMCwgbWF4TnVtU2l6ZSAtIGUubGVuZ3RoKSArIGU7XG59XG4iLCJpbXBvcnQgU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24gZnJvbSAnLi9kYy9zdmQnO1xuaW1wb3J0IE1hdHJpeCBmcm9tICcuL21hdHJpeCc7XG5cbmZ1bmN0aW9uIHhyYW5nZShuLCBleGNlcHRpb24pIHtcbiAgbGV0IHJhbmdlID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKGkgIT09IGV4Y2VwdGlvbikge1xuICAgICAgcmFuZ2UucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhbmdlO1xufVxuXG5mdW5jdGlvbiBkZXBlbmRlbmNpZXNPbmVSb3coXG4gIGVycm9yLFxuICBtYXRyaXgsXG4gIGluZGV4LFxuICB0aHJlc2hvbGRWYWx1ZSA9IDEwZS0xMCxcbiAgdGhyZXNob2xkRXJyb3IgPSAxMGUtMTAsXG4pIHtcbiAgaWYgKGVycm9yID4gdGhyZXNob2xkRXJyb3IpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5KG1hdHJpeC5yb3dzICsgMSkuZmlsbCgwKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcmV0dXJuQXJyYXkgPSBtYXRyaXguYWRkUm93KGluZGV4LCBbMF0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0dXJuQXJyYXkucm93czsgaSsrKSB7XG4gICAgICBpZiAoTWF0aC5hYnMocmV0dXJuQXJyYXkuZ2V0KGksIDApKSA8IHRocmVzaG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybkFycmF5LnNldChpLCAwLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVybkFycmF5LnRvMURBcnJheSgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJEZXBlbmRlbmNpZXMobWF0cml4LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB0aHJlc2hvbGRWYWx1ZSA9IDEwZS0xMCwgdGhyZXNob2xkRXJyb3IgPSAxMGUtMTAgfSA9IG9wdGlvbnM7XG4gIG1hdHJpeCA9IE1hdHJpeC5jaGVja01hdHJpeChtYXRyaXgpO1xuXG4gIGxldCBuID0gbWF0cml4LnJvd3M7XG4gIGxldCByZXN1bHRzID0gbmV3IE1hdHJpeChuLCBuKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGxldCBiID0gTWF0cml4LmNvbHVtblZlY3RvcihtYXRyaXguZ2V0Um93KGkpKTtcbiAgICBsZXQgQWJpcyA9IG1hdHJpeC5zdWJNYXRyaXhSb3coeHJhbmdlKG4sIGkpKS50cmFuc3Bvc2UoKTtcbiAgICBsZXQgc3ZkID0gbmV3IFNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uKEFiaXMpO1xuICAgIGxldCB4ID0gc3ZkLnNvbHZlKGIpO1xuICAgIGxldCBlcnJvciA9IE1hdHJpeC5zdWIoYiwgQWJpcy5tbXVsKHgpKS5hYnMoKS5tYXgoKTtcbiAgICByZXN1bHRzLnNldFJvdyhcbiAgICAgIGksXG4gICAgICBkZXBlbmRlbmNpZXNPbmVSb3coZXJyb3IsIHgsIGksIHRocmVzaG9sZFZhbHVlLCB0aHJlc2hvbGRFcnJvciksXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsTWF0aE9wZXJhdGlvbnMoQWJzdHJhY3RNYXRyaXgsIE1hdHJpeCkge1xuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzLmFkZFModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmFkZE0odmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5hZGRTID0gZnVuY3Rpb24gYWRkUyh2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5hZGRNID0gZnVuY3Rpb24gYWRkTShtYXRyaXgpIHtcbiAgICBtYXRyaXggPSBNYXRyaXguY2hlY2tNYXRyaXgobWF0cml4KTtcbiAgICBpZiAodGhpcy5yb3dzICE9PSBtYXRyaXgucm93cyB8fFxuICAgICAgdGhpcy5jb2x1bW5zICE9PSBtYXRyaXguY29sdW1ucykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopICsgbWF0cml4LmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmFkZCA9IGZ1bmN0aW9uIGFkZChtYXRyaXgsIHZhbHVlKSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguYWRkKHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzLnN1YlModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLnN1Yk0odmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zdWJTID0gZnVuY3Rpb24gc3ViUyh2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgLSB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zdWJNID0gZnVuY3Rpb24gc3ViTShtYXRyaXgpIHtcbiAgICBtYXRyaXggPSBNYXRyaXguY2hlY2tNYXRyaXgobWF0cml4KTtcbiAgICBpZiAodGhpcy5yb3dzICE9PSBtYXRyaXgucm93cyB8fFxuICAgICAgdGhpcy5jb2x1bW5zICE9PSBtYXRyaXguY29sdW1ucykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIC0gbWF0cml4LmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnN1YiA9IGZ1bmN0aW9uIHN1YihtYXRyaXgsIHZhbHVlKSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguc3ViKHZhbHVlKTtcbiAgfTtcbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnN1YnRyYWN0ID0gQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnN1YjtcbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnN1YnRyYWN0UyA9IEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zdWJTO1xuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuc3VidHJhY3RNID0gQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnN1Yk07XG4gIEFic3RyYWN0TWF0cml4LnN1YnRyYWN0ID0gQWJzdHJhY3RNYXRyaXguc3ViO1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIHRoaXMubXVsUyh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMubXVsTSh2YWx1ZSk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm11bFMgPSBmdW5jdGlvbiBtdWxTKHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAqIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm11bE0gPSBmdW5jdGlvbiBtdWxNKG1hdHJpeCkge1xuICAgIG1hdHJpeCA9IE1hdHJpeC5jaGVja01hdHJpeChtYXRyaXgpO1xuICAgIGlmICh0aGlzLnJvd3MgIT09IG1hdHJpeC5yb3dzIHx8XG4gICAgICB0aGlzLmNvbHVtbnMgIT09IG1hdHJpeC5jb2x1bW5zKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgKiBtYXRyaXguZ2V0KGksIGopKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgubXVsID0gZnVuY3Rpb24gbXVsKG1hdHJpeCwgdmFsdWUpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5tdWwodmFsdWUpO1xuICB9O1xuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubXVsdGlwbHkgPSBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubXVsO1xuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubXVsdGlwbHlTID0gQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm11bFM7XG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5tdWx0aXBseU0gPSBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubXVsTTtcbiAgQWJzdHJhY3RNYXRyaXgubXVsdGlwbHkgPSBBYnN0cmFjdE1hdHJpeC5tdWw7XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gdGhpcy5kaXZTKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5kaXZNKHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuZGl2UyA9IGZ1bmN0aW9uIGRpdlModmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIC8gdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuZGl2TSA9IGZ1bmN0aW9uIGRpdk0obWF0cml4KSB7XG4gICAgbWF0cml4ID0gTWF0cml4LmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgaWYgKHRoaXMucm93cyAhPT0gbWF0cml4LnJvd3MgfHxcbiAgICAgIHRoaXMuY29sdW1ucyAhPT0gbWF0cml4LmNvbHVtbnMpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAvIG1hdHJpeC5nZXQoaSwgaikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5kaXYgPSBmdW5jdGlvbiBkaXYobWF0cml4LCB2YWx1ZSkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LmRpdih2YWx1ZSk7XG4gIH07XG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5kaXZpZGUgPSBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuZGl2O1xuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuZGl2aWRlUyA9IEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5kaXZTO1xuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuZGl2aWRlTSA9IEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5kaXZNO1xuICBBYnN0cmFjdE1hdHJpeC5kaXZpZGUgPSBBYnN0cmFjdE1hdHJpeC5kaXY7XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gdGhpcy5tb2RTKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5tb2RNKHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubW9kUyA9IGZ1bmN0aW9uIG1vZFModmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopICUgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubW9kTSA9IGZ1bmN0aW9uIG1vZE0obWF0cml4KSB7XG4gICAgbWF0cml4ID0gTWF0cml4LmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgaWYgKHRoaXMucm93cyAhPT0gbWF0cml4LnJvd3MgfHxcbiAgICAgIHRoaXMuY29sdW1ucyAhPT0gbWF0cml4LmNvbHVtbnMpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAlIG1hdHJpeC5nZXQoaSwgaikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5tb2QgPSBmdW5jdGlvbiBtb2QobWF0cml4LCB2YWx1ZSkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4Lm1vZCh2YWx1ZSk7XG4gIH07XG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5tb2R1bHVzID0gQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm1vZDtcbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm1vZHVsdXNTID0gQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm1vZFM7XG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5tb2R1bHVzTSA9IEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5tb2RNO1xuICBBYnN0cmFjdE1hdHJpeC5tb2R1bHVzID0gQWJzdHJhY3RNYXRyaXgubW9kO1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIHRoaXMuYW5kUyh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuYW5kTSh2YWx1ZSk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmFuZFMgPSBmdW5jdGlvbiBhbmRTKHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAmIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmFuZE0gPSBmdW5jdGlvbiBhbmRNKG1hdHJpeCkge1xuICAgIG1hdHJpeCA9IE1hdHJpeC5jaGVja01hdHJpeChtYXRyaXgpO1xuICAgIGlmICh0aGlzLnJvd3MgIT09IG1hdHJpeC5yb3dzIHx8XG4gICAgICB0aGlzLmNvbHVtbnMgIT09IG1hdHJpeC5jb2x1bW5zKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgJiBtYXRyaXguZ2V0KGksIGopKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXguYW5kID0gZnVuY3Rpb24gYW5kKG1hdHJpeCwgdmFsdWUpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5hbmQodmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzLm9yUyh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMub3JNKHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUub3JTID0gZnVuY3Rpb24gb3JTKHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSB8IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm9yTSA9IGZ1bmN0aW9uIG9yTShtYXRyaXgpIHtcbiAgICBtYXRyaXggPSBNYXRyaXguY2hlY2tNYXRyaXgobWF0cml4KTtcbiAgICBpZiAodGhpcy5yb3dzICE9PSBtYXRyaXgucm93cyB8fFxuICAgICAgdGhpcy5jb2x1bW5zICE9PSBtYXRyaXguY29sdW1ucykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIHwgbWF0cml4LmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4Lm9yID0gZnVuY3Rpb24gb3IobWF0cml4LCB2YWx1ZSkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4Lm9yKHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzLnhvclModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLnhvck0odmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS54b3JTID0gZnVuY3Rpb24geG9yUyh2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgXiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS54b3JNID0gZnVuY3Rpb24geG9yTShtYXRyaXgpIHtcbiAgICBtYXRyaXggPSBNYXRyaXguY2hlY2tNYXRyaXgobWF0cml4KTtcbiAgICBpZiAodGhpcy5yb3dzICE9PSBtYXRyaXgucm93cyB8fFxuICAgICAgdGhpcy5jb2x1bW5zICE9PSBtYXRyaXguY29sdW1ucykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIF4gbWF0cml4LmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnhvciA9IGZ1bmN0aW9uIHhvcihtYXRyaXgsIHZhbHVlKSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXgueG9yKHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubGVmdFNoaWZ0ID0gZnVuY3Rpb24gbGVmdFNoaWZ0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzLmxlZnRTaGlmdFModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmxlZnRTaGlmdE0odmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5sZWZ0U2hpZnRTID0gZnVuY3Rpb24gbGVmdFNoaWZ0Uyh2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgPDwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubGVmdFNoaWZ0TSA9IGZ1bmN0aW9uIGxlZnRTaGlmdE0obWF0cml4KSB7XG4gICAgbWF0cml4ID0gTWF0cml4LmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgaWYgKHRoaXMucm93cyAhPT0gbWF0cml4LnJvd3MgfHxcbiAgICAgIHRoaXMuY29sdW1ucyAhPT0gbWF0cml4LmNvbHVtbnMpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSA8PCBtYXRyaXguZ2V0KGksIGopKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgubGVmdFNoaWZ0ID0gZnVuY3Rpb24gbGVmdFNoaWZ0KG1hdHJpeCwgdmFsdWUpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5sZWZ0U2hpZnQodmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0ID0gZnVuY3Rpb24gc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gdGhpcy5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0Uyh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdE0odmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0UyA9IGZ1bmN0aW9uIHNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRTKHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSA+PiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0TSA9IGZ1bmN0aW9uIHNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRNKG1hdHJpeCkge1xuICAgIG1hdHJpeCA9IE1hdHJpeC5jaGVja01hdHJpeChtYXRyaXgpO1xuICAgIGlmICh0aGlzLnJvd3MgIT09IG1hdHJpeC5yb3dzIHx8XG4gICAgICB0aGlzLmNvbHVtbnMgIT09IG1hdHJpeC5jb2x1bW5zKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgPj4gbWF0cml4LmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnQgPSBmdW5jdGlvbiBzaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0KG1hdHJpeCwgdmFsdWUpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0KHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUucmlnaHRTaGlmdCA9IGZ1bmN0aW9uIHJpZ2h0U2hpZnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIHRoaXMucmlnaHRTaGlmdFModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLnJpZ2h0U2hpZnRNKHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUucmlnaHRTaGlmdFMgPSBmdW5jdGlvbiByaWdodFNoaWZ0Uyh2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgPj4+IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnJpZ2h0U2hpZnRNID0gZnVuY3Rpb24gcmlnaHRTaGlmdE0obWF0cml4KSB7XG4gICAgbWF0cml4ID0gTWF0cml4LmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgaWYgKHRoaXMucm93cyAhPT0gbWF0cml4LnJvd3MgfHxcbiAgICAgIHRoaXMuY29sdW1ucyAhPT0gbWF0cml4LmNvbHVtbnMpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSA+Pj4gbWF0cml4LmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnJpZ2h0U2hpZnQgPSBmdW5jdGlvbiByaWdodFNoaWZ0KG1hdHJpeCwgdmFsdWUpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5yaWdodFNoaWZ0KHZhbHVlKTtcbiAgfTtcbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdCA9IEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5yaWdodFNoaWZ0O1xuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuemVyb0ZpbGxSaWdodFNoaWZ0UyA9IEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5yaWdodFNoaWZ0UztcbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdE0gPSBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUucmlnaHRTaGlmdE07XG4gIEFic3RyYWN0TWF0cml4Lnplcm9GaWxsUmlnaHRTaGlmdCA9IEFic3RyYWN0TWF0cml4LnJpZ2h0U2hpZnQ7XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIH4odGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgubm90ID0gZnVuY3Rpb24gbm90KG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4Lm5vdCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmFicyh0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5hYnMgPSBmdW5jdGlvbiBhYnMobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguYWJzKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmFjb3MgPSBmdW5jdGlvbiBhY29zKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC5hY29zKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmFjb3MgPSBmdW5jdGlvbiBhY29zKG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LmFjb3MoKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuYWNvc2ggPSBmdW5jdGlvbiBhY29zaCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGguYWNvc2godGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXguYWNvc2ggPSBmdW5jdGlvbiBhY29zaChtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5hY29zaCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5hc2luID0gZnVuY3Rpb24gYXNpbigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGguYXNpbih0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5hc2luID0gZnVuY3Rpb24gYXNpbihtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5hc2luKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmFzaW5oID0gZnVuY3Rpb24gYXNpbmgoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmFzaW5oKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmFzaW5oID0gZnVuY3Rpb24gYXNpbmgobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguYXNpbmgoKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuYXRhbiA9IGZ1bmN0aW9uIGF0YW4oKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmF0YW4odGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXguYXRhbiA9IGZ1bmN0aW9uIGF0YW4obWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguYXRhbigpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5hdGFuaCA9IGZ1bmN0aW9uIGF0YW5oKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC5hdGFuaCh0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5hdGFuaCA9IGZ1bmN0aW9uIGF0YW5oKG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LmF0YW5oKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmNicnQgPSBmdW5jdGlvbiBjYnJ0KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC5jYnJ0KHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmNicnQgPSBmdW5jdGlvbiBjYnJ0KG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LmNicnQoKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuY2VpbCA9IGZ1bmN0aW9uIGNlaWwoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmNlaWwodGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXguY2VpbCA9IGZ1bmN0aW9uIGNlaWwobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguY2VpbCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5jbHozMiA9IGZ1bmN0aW9uIGNsejMyKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC5jbHozMih0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5jbHozMiA9IGZ1bmN0aW9uIGNsejMyKG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LmNsejMyKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmNvcyA9IGZ1bmN0aW9uIGNvcygpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGguY29zKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmNvcyA9IGZ1bmN0aW9uIGNvcyhtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5jb3MoKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuY29zaCA9IGZ1bmN0aW9uIGNvc2goKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmNvc2godGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXguY29zaCA9IGZ1bmN0aW9uIGNvc2gobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguY29zaCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiBleHAoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmV4cCh0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5leHAgPSBmdW5jdGlvbiBleHAobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguZXhwKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmV4cG0xID0gZnVuY3Rpb24gZXhwbTEoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmV4cG0xKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmV4cG0xID0gZnVuY3Rpb24gZXhwbTEobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguZXhwbTEoKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuZmxvb3IgPSBmdW5jdGlvbiBmbG9vcigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGguZmxvb3IodGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXguZmxvb3IgPSBmdW5jdGlvbiBmbG9vcihtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5mbG9vcigpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5mcm91bmQgPSBmdW5jdGlvbiBmcm91bmQoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmZyb3VuZCh0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5mcm91bmQgPSBmdW5jdGlvbiBmcm91bmQobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguZnJvdW5kKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIGxvZygpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGgubG9nKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmxvZyA9IGZ1bmN0aW9uIGxvZyhtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5sb2coKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubG9nMXAgPSBmdW5jdGlvbiBsb2cxcCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGgubG9nMXAodGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgubG9nMXAgPSBmdW5jdGlvbiBsb2cxcChtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5sb2cxcCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5sb2cxMCA9IGZ1bmN0aW9uIGxvZzEwKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC5sb2cxMCh0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5sb2cxMCA9IGZ1bmN0aW9uIGxvZzEwKG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LmxvZzEwKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmxvZzIgPSBmdW5jdGlvbiBsb2cyKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC5sb2cyKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmxvZzIgPSBmdW5jdGlvbiBsb2cyKG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LmxvZzIoKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUucm91bmQgPSBmdW5jdGlvbiByb3VuZCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGgucm91bmQodGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucm91bmQgPSBmdW5jdGlvbiByb3VuZChtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5yb3VuZCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGguc2lnbih0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5zaWduID0gZnVuY3Rpb24gc2lnbihtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5zaWduKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnNpbiA9IGZ1bmN0aW9uIHNpbigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGguc2luKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnNpbiA9IGZ1bmN0aW9uIHNpbihtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5zaW4oKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuc2luaCA9IGZ1bmN0aW9uIHNpbmgoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLnNpbmgodGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXguc2luaCA9IGZ1bmN0aW9uIHNpbmgobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguc2luaCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGguc3FydCh0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5zcXJ0ID0gZnVuY3Rpb24gc3FydChtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5zcXJ0KCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnRhbiA9IGZ1bmN0aW9uIHRhbigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGgudGFuKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnRhbiA9IGZ1bmN0aW9uIHRhbihtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC50YW4oKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUudGFuaCA9IGZ1bmN0aW9uIHRhbmgoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLnRhbmgodGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgudGFuaCA9IGZ1bmN0aW9uIHRhbmgobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXgudGFuaCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS50cnVuYyA9IGZ1bmN0aW9uIHRydW5jKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC50cnVuYyh0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC50cnVuYyA9IGZ1bmN0aW9uIHRydW5jKG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LnRydW5jKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucG93ID0gZnVuY3Rpb24gcG93KG1hdHJpeCwgYXJnMCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LnBvdyhhcmcwKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzLnBvd1ModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLnBvd00odmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5wb3dTID0gZnVuY3Rpb24gcG93Uyh2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC5wb3codGhpcy5nZXQoaSwgaiksIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5wb3dNID0gZnVuY3Rpb24gcG93TShtYXRyaXgpIHtcbiAgICBtYXRyaXggPSBNYXRyaXguY2hlY2tNYXRyaXgobWF0cml4KTtcbiAgICBpZiAodGhpcy5yb3dzICE9PSBtYXRyaXgucm93cyB8fFxuICAgICAgdGhpcy5jb2x1bW5zICE9PSBtYXRyaXguY29sdW1ucykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGgucG93KHRoaXMuZ2V0KGksIGopLCBtYXRyaXguZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuIiwiaW1wb3J0IHJlc2NhbGUgZnJvbSAnbWwtYXJyYXktcmVzY2FsZSc7XG5cbmltcG9ydCB7IGluc3BlY3RNYXRyaXgsIGluc3BlY3RNYXRyaXhXaXRoT3B0aW9ucyB9IGZyb20gJy4vaW5zcGVjdCc7XG5pbXBvcnQgeyBpbnN0YWxsTWF0aE9wZXJhdGlvbnMgfSBmcm9tICcuL21hdGhPcGVyYXRpb25zJztcbmltcG9ydCB7XG4gIHN1bUJ5Um93LFxuICBzdW1CeUNvbHVtbixcbiAgc3VtQWxsLFxuICBwcm9kdWN0QnlSb3csXG4gIHByb2R1Y3RCeUNvbHVtbixcbiAgcHJvZHVjdEFsbCxcbiAgdmFyaWFuY2VCeVJvdyxcbiAgdmFyaWFuY2VCeUNvbHVtbixcbiAgdmFyaWFuY2VBbGwsXG4gIGNlbnRlckJ5Um93LFxuICBjZW50ZXJCeUNvbHVtbixcbiAgY2VudGVyQWxsLFxuICBzY2FsZUJ5Um93LFxuICBzY2FsZUJ5Q29sdW1uLFxuICBzY2FsZUFsbCxcbiAgZ2V0U2NhbGVCeVJvdyxcbiAgZ2V0U2NhbGVCeUNvbHVtbixcbiAgZ2V0U2NhbGVBbGwsXG59IGZyb20gJy4vc3RhdCc7XG5pbXBvcnQge1xuICBjaGVja1Jvd1ZlY3RvcixcbiAgY2hlY2tSb3dJbmRleCxcbiAgY2hlY2tDb2x1bW5JbmRleCxcbiAgY2hlY2tDb2x1bW5WZWN0b3IsXG4gIGNoZWNrUmFuZ2UsXG4gIGNoZWNrSW5kaWNlcyxcbn0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGNsYXNzIEFic3RyYWN0TWF0cml4IHtcbiAgc3RhdGljIGZyb20xREFycmF5KG5ld1Jvd3MsIG5ld0NvbHVtbnMsIG5ld0RhdGEpIHtcbiAgICBsZXQgbGVuZ3RoID0gbmV3Um93cyAqIG5ld0NvbHVtbnM7XG4gICAgaWYgKGxlbmd0aCAhPT0gbmV3RGF0YS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdkYXRhIGxlbmd0aCBkb2VzIG5vdCBtYXRjaCBnaXZlbiBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIGxldCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG5ld1Jvd3MsIG5ld0NvbHVtbnMpO1xuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG5ld1Jvd3M7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2x1bW4gPSAwOyBjb2x1bW4gPCBuZXdDb2x1bW5zOyBjb2x1bW4rKykge1xuICAgICAgICBuZXdNYXRyaXguc2V0KHJvdywgY29sdW1uLCBuZXdEYXRhW3JvdyAqIG5ld0NvbHVtbnMgKyBjb2x1bW5dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld01hdHJpeDtcbiAgfVxuXG4gIHN0YXRpYyByb3dWZWN0b3IobmV3RGF0YSkge1xuICAgIGxldCB2ZWN0b3IgPSBuZXcgTWF0cml4KDEsIG5ld0RhdGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZlY3Rvci5zZXQoMCwgaSwgbmV3RGF0YVtpXSk7XG4gICAgfVxuICAgIHJldHVybiB2ZWN0b3I7XG4gIH1cblxuICBzdGF0aWMgY29sdW1uVmVjdG9yKG5ld0RhdGEpIHtcbiAgICBsZXQgdmVjdG9yID0gbmV3IE1hdHJpeChuZXdEYXRhLmxlbmd0aCwgMSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2ZWN0b3Iuc2V0KGksIDAsIG5ld0RhdGFbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmVjdG9yO1xuICB9XG5cbiAgc3RhdGljIHplcm9zKHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeChyb3dzLCBjb2x1bW5zKTtcbiAgfVxuXG4gIHN0YXRpYyBvbmVzKHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeChyb3dzLCBjb2x1bW5zKS5maWxsKDEpO1xuICB9XG5cbiAgc3RhdGljIHJhbmQocm93cywgY29sdW1ucywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICBjb25zdCB7IHJhbmRvbSA9IE1hdGgucmFuZG9tIH0gPSBvcHRpb25zO1xuICAgIGxldCBtYXRyaXggPSBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgICBtYXRyaXguc2V0KGksIGosIHJhbmRvbSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuXG4gIHN0YXRpYyByYW5kSW50KHJvd3MsIGNvbHVtbnMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgY29uc3QgeyBtaW4gPSAwLCBtYXggPSAxMDAwLCByYW5kb20gPSBNYXRoLnJhbmRvbSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWluKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbWluIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXgpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXggbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgaWYgKG1pbiA+PSBtYXgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaW4gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4Jyk7XG4gICAgbGV0IGludGVydmFsID0gbWF4IC0gbWluO1xuICAgIGxldCBtYXRyaXggPSBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgICBsZXQgdmFsdWUgPSBtaW4gKyBNYXRoLnJvdW5kKHJhbmRvbSgpICogaW50ZXJ2YWwpO1xuICAgICAgICBtYXRyaXguc2V0KGksIGosIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuXG4gIHN0YXRpYyBleWUocm93cywgY29sdW1ucywgdmFsdWUpIHtcbiAgICBpZiAoY29sdW1ucyA9PT0gdW5kZWZpbmVkKSBjb2x1bW5zID0gcm93cztcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdmFsdWUgPSAxO1xuICAgIGxldCBtaW4gPSBNYXRoLm1pbihyb3dzLCBjb2x1bW5zKTtcbiAgICBsZXQgbWF0cml4ID0gdGhpcy56ZXJvcyhyb3dzLCBjb2x1bW5zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pbjsgaSsrKSB7XG4gICAgICBtYXRyaXguc2V0KGksIGksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuXG4gIHN0YXRpYyBkaWFnKGRhdGEsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICBsZXQgbCA9IGRhdGEubGVuZ3RoO1xuICAgIGlmIChyb3dzID09PSB1bmRlZmluZWQpIHJvd3MgPSBsO1xuICAgIGlmIChjb2x1bW5zID09PSB1bmRlZmluZWQpIGNvbHVtbnMgPSByb3dzO1xuICAgIGxldCBtaW4gPSBNYXRoLm1pbihsLCByb3dzLCBjb2x1bW5zKTtcbiAgICBsZXQgbWF0cml4ID0gdGhpcy56ZXJvcyhyb3dzLCBjb2x1bW5zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pbjsgaSsrKSB7XG4gICAgICBtYXRyaXguc2V0KGksIGksIGRhdGFbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG5cbiAgc3RhdGljIG1pbihtYXRyaXgxLCBtYXRyaXgyKSB7XG4gICAgbWF0cml4MSA9IHRoaXMuY2hlY2tNYXRyaXgobWF0cml4MSk7XG4gICAgbWF0cml4MiA9IHRoaXMuY2hlY2tNYXRyaXgobWF0cml4Mik7XG4gICAgbGV0IHJvd3MgPSBtYXRyaXgxLnJvd3M7XG4gICAgbGV0IGNvbHVtbnMgPSBtYXRyaXgxLmNvbHVtbnM7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBNYXRyaXgocm93cywgY29sdW1ucyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgIHJlc3VsdC5zZXQoaSwgaiwgTWF0aC5taW4obWF0cml4MS5nZXQoaSwgaiksIG1hdHJpeDIuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBzdGF0aWMgbWF4KG1hdHJpeDEsIG1hdHJpeDIpIHtcbiAgICBtYXRyaXgxID0gdGhpcy5jaGVja01hdHJpeChtYXRyaXgxKTtcbiAgICBtYXRyaXgyID0gdGhpcy5jaGVja01hdHJpeChtYXRyaXgyKTtcbiAgICBsZXQgcm93cyA9IG1hdHJpeDEucm93cztcbiAgICBsZXQgY29sdW1ucyA9IG1hdHJpeDEuY29sdW1ucztcbiAgICBsZXQgcmVzdWx0ID0gbmV3IHRoaXMocm93cywgY29sdW1ucyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgIHJlc3VsdC5zZXQoaSwgaiwgTWF0aC5tYXgobWF0cml4MS5nZXQoaSwgaiksIG1hdHJpeDIuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBzdGF0aWMgY2hlY2tNYXRyaXgodmFsdWUpIHtcbiAgICByZXR1cm4gQWJzdHJhY3RNYXRyaXguaXNNYXRyaXgodmFsdWUpID8gdmFsdWUgOiBuZXcgTWF0cml4KHZhbHVlKTtcbiAgfVxuXG4gIHN0YXRpYyBpc01hdHJpeCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlLmtsYXNzID09PSAnTWF0cml4JztcbiAgfVxuXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnJvd3MgKiB0aGlzLmNvbHVtbnM7XG4gIH1cblxuICBhcHBseShjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgaSwgaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdG8xREFycmF5KCkge1xuICAgIGxldCBhcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgYXJyYXkucHVzaCh0aGlzLmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIHRvMkRBcnJheSgpIHtcbiAgICBsZXQgY29weSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGNvcHkucHVzaChbXSk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIGNvcHlbaV0ucHVzaCh0aGlzLmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvMkRBcnJheSgpO1xuICB9XG5cbiAgaXNSb3dWZWN0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMucm93cyA9PT0gMTtcbiAgfVxuXG4gIGlzQ29sdW1uVmVjdG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbHVtbnMgPT09IDE7XG4gIH1cblxuICBpc1ZlY3RvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yb3dzID09PSAxIHx8IHRoaXMuY29sdW1ucyA9PT0gMTtcbiAgfVxuXG4gIGlzU3F1YXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJvd3MgPT09IHRoaXMuY29sdW1ucztcbiAgfVxuXG4gIGlzU3ltbWV0cmljKCkge1xuICAgIGlmICh0aGlzLmlzU3F1YXJlKCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gaTsgaisrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZ2V0KGksIGopICE9PSB0aGlzLmdldChqLCBpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzRWNoZWxvbkZvcm0oKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBqID0gMDtcbiAgICBsZXQgcHJldmlvdXNDb2x1bW4gPSAtMTtcbiAgICBsZXQgaXNFY2hlbG9uRm9ybSA9IHRydWU7XG4gICAgbGV0IGNoZWNrZWQgPSBmYWxzZTtcbiAgICB3aGlsZSAoaSA8IHRoaXMucm93cyAmJiBpc0VjaGVsb25Gb3JtKSB7XG4gICAgICBqID0gMDtcbiAgICAgIGNoZWNrZWQgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChqIDwgdGhpcy5jb2x1bW5zICYmIGNoZWNrZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLmdldChpLCBqKSA9PT0gMCkge1xuICAgICAgICAgIGorKztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmdldChpLCBqKSA9PT0gMSAmJiBqID4gcHJldmlvdXNDb2x1bW4pIHtcbiAgICAgICAgICBjaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICBwcmV2aW91c0NvbHVtbiA9IGo7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNFY2hlbG9uRm9ybSA9IGZhbHNlO1xuICAgICAgICAgIGNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBpc0VjaGVsb25Gb3JtO1xuICB9XG5cbiAgaXNSZWR1Y2VkRWNoZWxvbkZvcm0oKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBqID0gMDtcbiAgICBsZXQgcHJldmlvdXNDb2x1bW4gPSAtMTtcbiAgICBsZXQgaXNSZWR1Y2VkRWNoZWxvbkZvcm0gPSB0cnVlO1xuICAgIGxldCBjaGVja2VkID0gZmFsc2U7XG4gICAgd2hpbGUgKGkgPCB0aGlzLnJvd3MgJiYgaXNSZWR1Y2VkRWNoZWxvbkZvcm0pIHtcbiAgICAgIGogPSAwO1xuICAgICAgY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKGogPCB0aGlzLmNvbHVtbnMgJiYgY2hlY2tlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0KGksIGopID09PSAwKSB7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0KGksIGopID09PSAxICYmIGogPiBwcmV2aW91c0NvbHVtbikge1xuICAgICAgICAgIGNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgIHByZXZpb3VzQ29sdW1uID0gajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1JlZHVjZWRFY2hlbG9uRm9ybSA9IGZhbHNlO1xuICAgICAgICAgIGNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBrID0gaiArIDE7IGsgPCB0aGlzLnJvd3M7IGsrKykge1xuICAgICAgICBpZiAodGhpcy5nZXQoaSwgaykgIT09IDApIHtcbiAgICAgICAgICBpc1JlZHVjZWRFY2hlbG9uRm9ybSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBpc1JlZHVjZWRFY2hlbG9uRm9ybTtcbiAgfVxuXG4gIGVjaGVsb25Gb3JtKCkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbGV0IGggPSAwO1xuICAgIGxldCBrID0gMDtcbiAgICB3aGlsZSAoaCA8IHJlc3VsdC5yb3dzICYmIGsgPCByZXN1bHQuY29sdW1ucykge1xuICAgICAgbGV0IGlNYXggPSBoO1xuICAgICAgZm9yIChsZXQgaSA9IGg7IGkgPCByZXN1bHQucm93czsgaSsrKSB7XG4gICAgICAgIGlmIChyZXN1bHQuZ2V0KGksIGspID4gcmVzdWx0LmdldChpTWF4LCBrKSkge1xuICAgICAgICAgIGlNYXggPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmdldChpTWF4LCBrKSA9PT0gMCkge1xuICAgICAgICBrKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQuc3dhcFJvd3MoaCwgaU1heCk7XG4gICAgICAgIGxldCB0bXAgPSByZXN1bHQuZ2V0KGgsIGspO1xuICAgICAgICBmb3IgKGxldCBqID0gazsgaiA8IHJlc3VsdC5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICByZXN1bHQuc2V0KGgsIGosIHJlc3VsdC5nZXQoaCwgaikgLyB0bXApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBoICsgMTsgaSA8IHJlc3VsdC5yb3dzOyBpKyspIHtcbiAgICAgICAgICBsZXQgZmFjdG9yID0gcmVzdWx0LmdldChpLCBrKSAvIHJlc3VsdC5nZXQoaCwgayk7XG4gICAgICAgICAgcmVzdWx0LnNldChpLCBrLCAwKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gayArIDE7IGogPCByZXN1bHQuY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGksIGosIHJlc3VsdC5nZXQoaSwgaikgLSByZXN1bHQuZ2V0KGgsIGopICogZmFjdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaCsrO1xuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZWR1Y2VkRWNoZWxvbkZvcm0oKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuZWNoZWxvbkZvcm0oKTtcbiAgICBsZXQgbSA9IHJlc3VsdC5jb2x1bW5zO1xuICAgIGxldCBuID0gcmVzdWx0LnJvd3M7XG4gICAgbGV0IGggPSBuIC0gMTtcbiAgICB3aGlsZSAoaCA+PSAwKSB7XG4gICAgICBpZiAocmVzdWx0Lm1heFJvdyhoKSA9PT0gMCkge1xuICAgICAgICBoLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcCA9IDA7XG4gICAgICAgIGxldCBwaXZvdCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAocCA8IG4gJiYgcGl2b3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5nZXQoaCwgcCkgPT09IDEpIHtcbiAgICAgICAgICAgIHBpdm90ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGg7IGkrKykge1xuICAgICAgICAgIGxldCBmYWN0b3IgPSByZXN1bHQuZ2V0KGksIHApO1xuICAgICAgICAgIGZvciAobGV0IGogPSBwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBsZXQgdG1wID0gcmVzdWx0LmdldChpLCBqKSAtIGZhY3RvciAqIHJlc3VsdC5nZXQoaCwgaik7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGksIGosIHRtcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGgtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHNldCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldCBtZXRob2QgaXMgdW5pbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgZ2V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2V0IG1ldGhvZCBpcyB1bmltcGxlbWVudGVkJyk7XG4gIH1cblxuICByZXBlYXQob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICBjb25zdCB7IHJvd3MgPSAxLCBjb2x1bW5zID0gMSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIocm93cykgfHwgcm93cyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyb3dzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb2x1bW5zKSB8fCBjb2x1bW5zIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbHVtbnMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9XG4gICAgbGV0IG1hdHJpeCA9IG5ldyBNYXRyaXgodGhpcy5yb3dzICogcm93cywgdGhpcy5jb2x1bW5zICogY29sdW1ucyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgIG1hdHJpeC5zZXRTdWJNYXRyaXgodGhpcywgdGhpcy5yb3dzICogaSwgdGhpcy5jb2x1bW5zICogaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRyaXg7XG4gIH1cblxuICBmaWxsKHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbmVnKCkge1xuICAgIHJldHVybiB0aGlzLm11bFMoLTEpO1xuICB9XG5cbiAgZ2V0Um93KGluZGV4KSB7XG4gICAgY2hlY2tSb3dJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgbGV0IHJvdyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcbiAgICAgIHJvdy5wdXNoKHRoaXMuZ2V0KGluZGV4LCBpKSk7XG4gICAgfVxuICAgIHJldHVybiByb3c7XG4gIH1cblxuICBnZXRSb3dWZWN0b3IoaW5kZXgpIHtcbiAgICByZXR1cm4gTWF0cml4LnJvd1ZlY3Rvcih0aGlzLmdldFJvdyhpbmRleCkpO1xuICB9XG5cbiAgc2V0Um93KGluZGV4LCBhcnJheSkge1xuICAgIGNoZWNrUm93SW5kZXgodGhpcywgaW5kZXgpO1xuICAgIGFycmF5ID0gY2hlY2tSb3dWZWN0b3IodGhpcywgYXJyYXkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcbiAgICAgIHRoaXMuc2V0KGluZGV4LCBpLCBhcnJheVtpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3dhcFJvd3Mocm93MSwgcm93Mikge1xuICAgIGNoZWNrUm93SW5kZXgodGhpcywgcm93MSk7XG4gICAgY2hlY2tSb3dJbmRleCh0aGlzLCByb3cyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG4gICAgICBsZXQgdGVtcCA9IHRoaXMuZ2V0KHJvdzEsIGkpO1xuICAgICAgdGhpcy5zZXQocm93MSwgaSwgdGhpcy5nZXQocm93MiwgaSkpO1xuICAgICAgdGhpcy5zZXQocm93MiwgaSwgdGVtcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0Q29sdW1uKGluZGV4KSB7XG4gICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBpbmRleCk7XG4gICAgbGV0IGNvbHVtbiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGNvbHVtbi5wdXNoKHRoaXMuZ2V0KGksIGluZGV4KSk7XG4gICAgfVxuICAgIHJldHVybiBjb2x1bW47XG4gIH1cblxuICBnZXRDb2x1bW5WZWN0b3IoaW5kZXgpIHtcbiAgICByZXR1cm4gTWF0cml4LmNvbHVtblZlY3Rvcih0aGlzLmdldENvbHVtbihpbmRleCkpO1xuICB9XG5cbiAgc2V0Q29sdW1uKGluZGV4LCBhcnJheSkge1xuICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgaW5kZXgpO1xuICAgIGFycmF5ID0gY2hlY2tDb2x1bW5WZWN0b3IodGhpcywgYXJyYXkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIHRoaXMuc2V0KGksIGluZGV4LCBhcnJheVtpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3dhcENvbHVtbnMoY29sdW1uMSwgY29sdW1uMikge1xuICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgY29sdW1uMSk7XG4gICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBjb2x1bW4yKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBsZXQgdGVtcCA9IHRoaXMuZ2V0KGksIGNvbHVtbjEpO1xuICAgICAgdGhpcy5zZXQoaSwgY29sdW1uMSwgdGhpcy5nZXQoaSwgY29sdW1uMikpO1xuICAgICAgdGhpcy5zZXQoaSwgY29sdW1uMiwgdGVtcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYWRkUm93VmVjdG9yKHZlY3Rvcikge1xuICAgIHZlY3RvciA9IGNoZWNrUm93VmVjdG9yKHRoaXMsIHZlY3Rvcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSArIHZlY3RvcltqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3ViUm93VmVjdG9yKHZlY3Rvcikge1xuICAgIHZlY3RvciA9IGNoZWNrUm93VmVjdG9yKHRoaXMsIHZlY3Rvcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAtIHZlY3RvcltqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbXVsUm93VmVjdG9yKHZlY3Rvcikge1xuICAgIHZlY3RvciA9IGNoZWNrUm93VmVjdG9yKHRoaXMsIHZlY3Rvcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAqIHZlY3RvcltqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGl2Um93VmVjdG9yKHZlY3Rvcikge1xuICAgIHZlY3RvciA9IGNoZWNrUm93VmVjdG9yKHRoaXMsIHZlY3Rvcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAvIHZlY3RvcltqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYWRkQ29sdW1uVmVjdG9yKHZlY3Rvcikge1xuICAgIHZlY3RvciA9IGNoZWNrQ29sdW1uVmVjdG9yKHRoaXMsIHZlY3Rvcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSArIHZlY3RvcltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3ViQ29sdW1uVmVjdG9yKHZlY3Rvcikge1xuICAgIHZlY3RvciA9IGNoZWNrQ29sdW1uVmVjdG9yKHRoaXMsIHZlY3Rvcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAtIHZlY3RvcltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbXVsQ29sdW1uVmVjdG9yKHZlY3Rvcikge1xuICAgIHZlY3RvciA9IGNoZWNrQ29sdW1uVmVjdG9yKHRoaXMsIHZlY3Rvcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAqIHZlY3RvcltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGl2Q29sdW1uVmVjdG9yKHZlY3Rvcikge1xuICAgIHZlY3RvciA9IGNoZWNrQ29sdW1uVmVjdG9yKHRoaXMsIHZlY3Rvcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAvIHZlY3RvcltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbXVsUm93KGluZGV4LCB2YWx1ZSkge1xuICAgIGNoZWNrUm93SW5kZXgodGhpcywgaW5kZXgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcbiAgICAgIHRoaXMuc2V0KGluZGV4LCBpLCB0aGlzLmdldChpbmRleCwgaSkgKiB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbXVsQ29sdW1uKGluZGV4LCB2YWx1ZSkge1xuICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgaW5kZXgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIHRoaXMuc2V0KGksIGluZGV4LCB0aGlzLmdldChpLCBpbmRleCkgKiB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbWF4KCkge1xuICAgIGxldCB2ID0gdGhpcy5nZXQoMCwgMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICBpZiAodGhpcy5nZXQoaSwgaikgPiB2KSB7XG4gICAgICAgICAgdiA9IHRoaXMuZ2V0KGksIGopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG5cbiAgbWF4SW5kZXgoKSB7XG4gICAgbGV0IHYgPSB0aGlzLmdldCgwLCAwKTtcbiAgICBsZXQgaWR4ID0gWzAsIDBdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0KGksIGopID4gdikge1xuICAgICAgICAgIHYgPSB0aGlzLmdldChpLCBqKTtcbiAgICAgICAgICBpZHhbMF0gPSBpO1xuICAgICAgICAgIGlkeFsxXSA9IGo7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkeDtcbiAgfVxuXG4gIG1pbigpIHtcbiAgICBsZXQgdiA9IHRoaXMuZ2V0KDAsIDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0KGksIGopIDwgdikge1xuICAgICAgICAgIHYgPSB0aGlzLmdldChpLCBqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIG1pbkluZGV4KCkge1xuICAgIGxldCB2ID0gdGhpcy5nZXQoMCwgMCk7XG4gICAgbGV0IGlkeCA9IFswLCAwXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIGlmICh0aGlzLmdldChpLCBqKSA8IHYpIHtcbiAgICAgICAgICB2ID0gdGhpcy5nZXQoaSwgaik7XG4gICAgICAgICAgaWR4WzBdID0gaTtcbiAgICAgICAgICBpZHhbMV0gPSBqO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZHg7XG4gIH1cblxuICBtYXhSb3cocm93KSB7XG4gICAgY2hlY2tSb3dJbmRleCh0aGlzLCByb3cpO1xuICAgIGxldCB2ID0gdGhpcy5nZXQocm93LCAwKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5nZXQocm93LCBpKSA+IHYpIHtcbiAgICAgICAgdiA9IHRoaXMuZ2V0KHJvdywgaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG5cbiAgbWF4Um93SW5kZXgocm93KSB7XG4gICAgY2hlY2tSb3dJbmRleCh0aGlzLCByb3cpO1xuICAgIGxldCB2ID0gdGhpcy5nZXQocm93LCAwKTtcbiAgICBsZXQgaWR4ID0gW3JvdywgMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZ2V0KHJvdywgaSkgPiB2KSB7XG4gICAgICAgIHYgPSB0aGlzLmdldChyb3csIGkpO1xuICAgICAgICBpZHhbMV0gPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWR4O1xuICB9XG5cbiAgbWluUm93KHJvdykge1xuICAgIGNoZWNrUm93SW5kZXgodGhpcywgcm93KTtcbiAgICBsZXQgdiA9IHRoaXMuZ2V0KHJvdywgMCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZ2V0KHJvdywgaSkgPCB2KSB7XG4gICAgICAgIHYgPSB0aGlzLmdldChyb3csIGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIG1pblJvd0luZGV4KHJvdykge1xuICAgIGNoZWNrUm93SW5kZXgodGhpcywgcm93KTtcbiAgICBsZXQgdiA9IHRoaXMuZ2V0KHJvdywgMCk7XG4gICAgbGV0IGlkeCA9IFtyb3csIDBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmdldChyb3csIGkpIDwgdikge1xuICAgICAgICB2ID0gdGhpcy5nZXQocm93LCBpKTtcbiAgICAgICAgaWR4WzFdID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkeDtcbiAgfVxuXG4gIG1heENvbHVtbihjb2x1bW4pIHtcbiAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGNvbHVtbik7XG4gICAgbGV0IHYgPSB0aGlzLmdldCgwLCBjb2x1bW4pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmdldChpLCBjb2x1bW4pID4gdikge1xuICAgICAgICB2ID0gdGhpcy5nZXQoaSwgY29sdW1uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cblxuICBtYXhDb2x1bW5JbmRleChjb2x1bW4pIHtcbiAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGNvbHVtbik7XG4gICAgbGV0IHYgPSB0aGlzLmdldCgwLCBjb2x1bW4pO1xuICAgIGxldCBpZHggPSBbMCwgY29sdW1uXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5nZXQoaSwgY29sdW1uKSA+IHYpIHtcbiAgICAgICAgdiA9IHRoaXMuZ2V0KGksIGNvbHVtbik7XG4gICAgICAgIGlkeFswXSA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZHg7XG4gIH1cblxuICBtaW5Db2x1bW4oY29sdW1uKSB7XG4gICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBjb2x1bW4pO1xuICAgIGxldCB2ID0gdGhpcy5nZXQoMCwgY29sdW1uKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5nZXQoaSwgY29sdW1uKSA8IHYpIHtcbiAgICAgICAgdiA9IHRoaXMuZ2V0KGksIGNvbHVtbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG5cbiAgbWluQ29sdW1uSW5kZXgoY29sdW1uKSB7XG4gICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBjb2x1bW4pO1xuICAgIGxldCB2ID0gdGhpcy5nZXQoMCwgY29sdW1uKTtcbiAgICBsZXQgaWR4ID0gWzAsIGNvbHVtbl07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZ2V0KGksIGNvbHVtbikgPCB2KSB7XG4gICAgICAgIHYgPSB0aGlzLmdldChpLCBjb2x1bW4pO1xuICAgICAgICBpZHhbMF0gPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWR4O1xuICB9XG5cbiAgZGlhZygpIHtcbiAgICBsZXQgbWluID0gTWF0aC5taW4odGhpcy5yb3dzLCB0aGlzLmNvbHVtbnMpO1xuICAgIGxldCBkaWFnID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgZGlhZy5wdXNoKHRoaXMuZ2V0KGksIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpYWc7XG4gIH1cblxuICBub3JtKHR5cGUgPSAnZnJvYmVuaXVzJykge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGlmICh0eXBlID09PSAnbWF4Jykge1xuICAgICAgcmV0dXJuIHRoaXMubWF4KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZnJvYmVuaXVzJykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgdGhpcy5nZXQoaSwgaikgKiB0aGlzLmdldChpLCBqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguc3FydChyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdW5rbm93biBub3JtIHR5cGU6ICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cblxuICBjdW11bGF0aXZlU3VtKCkge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgc3VtICs9IHRoaXMuZ2V0KGksIGopO1xuICAgICAgICB0aGlzLnNldChpLCBqLCBzdW0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRvdCh2ZWN0b3IyKSB7XG4gICAgaWYgKEFic3RyYWN0TWF0cml4LmlzTWF0cml4KHZlY3RvcjIpKSB2ZWN0b3IyID0gdmVjdG9yMi50bzFEQXJyYXkoKTtcbiAgICBsZXQgdmVjdG9yMSA9IHRoaXMudG8xREFycmF5KCk7XG4gICAgaWYgKHZlY3RvcjEubGVuZ3RoICE9PSB2ZWN0b3IyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZlY3RvcnMgZG8gbm90IGhhdmUgdGhlIHNhbWUgc2l6ZScpO1xuICAgIH1cbiAgICBsZXQgZG90ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlY3RvcjEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRvdCArPSB2ZWN0b3IxW2ldICogdmVjdG9yMltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGRvdDtcbiAgfVxuXG4gIG1tdWwob3RoZXIpIHtcbiAgICBvdGhlciA9IE1hdHJpeC5jaGVja01hdHJpeChvdGhlcik7XG5cbiAgICBsZXQgbSA9IHRoaXMucm93cztcbiAgICBsZXQgbiA9IHRoaXMuY29sdW1ucztcbiAgICBsZXQgcCA9IG90aGVyLmNvbHVtbnM7XG5cbiAgICBsZXQgcmVzdWx0ID0gbmV3IE1hdHJpeChtLCBwKTtcblxuICAgIGxldCBCY29saiA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwOyBqKyspIHtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICAgIEJjb2xqW2tdID0gb3RoZXIuZ2V0KGssIGopO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICBsZXQgcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICAgICAgcyArPSB0aGlzLmdldChpLCBrKSAqIEJjb2xqW2tdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnNldChpLCBqLCBzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHN0cmFzc2VuMngyKG90aGVyKSB7XG4gICAgb3RoZXIgPSBNYXRyaXguY2hlY2tNYXRyaXgob3RoZXIpO1xuICAgIGxldCByZXN1bHQgPSBuZXcgTWF0cml4KDIsIDIpO1xuICAgIGNvbnN0IGExMSA9IHRoaXMuZ2V0KDAsIDApO1xuICAgIGNvbnN0IGIxMSA9IG90aGVyLmdldCgwLCAwKTtcbiAgICBjb25zdCBhMTIgPSB0aGlzLmdldCgwLCAxKTtcbiAgICBjb25zdCBiMTIgPSBvdGhlci5nZXQoMCwgMSk7XG4gICAgY29uc3QgYTIxID0gdGhpcy5nZXQoMSwgMCk7XG4gICAgY29uc3QgYjIxID0gb3RoZXIuZ2V0KDEsIDApO1xuICAgIGNvbnN0IGEyMiA9IHRoaXMuZ2V0KDEsIDEpO1xuICAgIGNvbnN0IGIyMiA9IG90aGVyLmdldCgxLCAxKTtcblxuICAgIC8vIENvbXB1dGUgaW50ZXJtZWRpYXRlIHZhbHVlcy5cbiAgICBjb25zdCBtMSA9IChhMTEgKyBhMjIpICogKGIxMSArIGIyMik7XG4gICAgY29uc3QgbTIgPSAoYTIxICsgYTIyKSAqIGIxMTtcbiAgICBjb25zdCBtMyA9IGExMSAqIChiMTIgLSBiMjIpO1xuICAgIGNvbnN0IG00ID0gYTIyICogKGIyMSAtIGIxMSk7XG4gICAgY29uc3QgbTUgPSAoYTExICsgYTEyKSAqIGIyMjtcbiAgICBjb25zdCBtNiA9IChhMjEgLSBhMTEpICogKGIxMSArIGIxMik7XG4gICAgY29uc3QgbTcgPSAoYTEyIC0gYTIyKSAqIChiMjEgKyBiMjIpO1xuXG4gICAgLy8gQ29tYmluZSBpbnRlcm1lZGlhdGUgdmFsdWVzIGludG8gdGhlIG91dHB1dC5cbiAgICBjb25zdCBjMDAgPSBtMSArIG00IC0gbTUgKyBtNztcbiAgICBjb25zdCBjMDEgPSBtMyArIG01O1xuICAgIGNvbnN0IGMxMCA9IG0yICsgbTQ7XG4gICAgY29uc3QgYzExID0gbTEgLSBtMiArIG0zICsgbTY7XG5cbiAgICByZXN1bHQuc2V0KDAsIDAsIGMwMCk7XG4gICAgcmVzdWx0LnNldCgwLCAxLCBjMDEpO1xuICAgIHJlc3VsdC5zZXQoMSwgMCwgYzEwKTtcbiAgICByZXN1bHQuc2V0KDEsIDEsIGMxMSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHN0cmFzc2VuM3gzKG90aGVyKSB7XG4gICAgb3RoZXIgPSBNYXRyaXguY2hlY2tNYXRyaXgob3RoZXIpO1xuICAgIGxldCByZXN1bHQgPSBuZXcgTWF0cml4KDMsIDMpO1xuXG4gICAgY29uc3QgYTAwID0gdGhpcy5nZXQoMCwgMCk7XG4gICAgY29uc3QgYTAxID0gdGhpcy5nZXQoMCwgMSk7XG4gICAgY29uc3QgYTAyID0gdGhpcy5nZXQoMCwgMik7XG4gICAgY29uc3QgYTEwID0gdGhpcy5nZXQoMSwgMCk7XG4gICAgY29uc3QgYTExID0gdGhpcy5nZXQoMSwgMSk7XG4gICAgY29uc3QgYTEyID0gdGhpcy5nZXQoMSwgMik7XG4gICAgY29uc3QgYTIwID0gdGhpcy5nZXQoMiwgMCk7XG4gICAgY29uc3QgYTIxID0gdGhpcy5nZXQoMiwgMSk7XG4gICAgY29uc3QgYTIyID0gdGhpcy5nZXQoMiwgMik7XG5cbiAgICBjb25zdCBiMDAgPSBvdGhlci5nZXQoMCwgMCk7XG4gICAgY29uc3QgYjAxID0gb3RoZXIuZ2V0KDAsIDEpO1xuICAgIGNvbnN0IGIwMiA9IG90aGVyLmdldCgwLCAyKTtcbiAgICBjb25zdCBiMTAgPSBvdGhlci5nZXQoMSwgMCk7XG4gICAgY29uc3QgYjExID0gb3RoZXIuZ2V0KDEsIDEpO1xuICAgIGNvbnN0IGIxMiA9IG90aGVyLmdldCgxLCAyKTtcbiAgICBjb25zdCBiMjAgPSBvdGhlci5nZXQoMiwgMCk7XG4gICAgY29uc3QgYjIxID0gb3RoZXIuZ2V0KDIsIDEpO1xuICAgIGNvbnN0IGIyMiA9IG90aGVyLmdldCgyLCAyKTtcblxuICAgIGNvbnN0IG0xID0gKGEwMCArIGEwMSArIGEwMiAtIGExMCAtIGExMSAtIGEyMSAtIGEyMikgKiBiMTE7XG4gICAgY29uc3QgbTIgPSAoYTAwIC0gYTEwKSAqICgtYjAxICsgYjExKTtcbiAgICBjb25zdCBtMyA9IGExMSAqICgtYjAwICsgYjAxICsgYjEwIC0gYjExIC0gYjEyIC0gYjIwICsgYjIyKTtcbiAgICBjb25zdCBtNCA9ICgtYTAwICsgYTEwICsgYTExKSAqIChiMDAgLSBiMDEgKyBiMTEpO1xuICAgIGNvbnN0IG01ID0gKGExMCArIGExMSkgKiAoLWIwMCArIGIwMSk7XG4gICAgY29uc3QgbTYgPSBhMDAgKiBiMDA7XG4gICAgY29uc3QgbTcgPSAoLWEwMCArIGEyMCArIGEyMSkgKiAoYjAwIC0gYjAyICsgYjEyKTtcbiAgICBjb25zdCBtOCA9ICgtYTAwICsgYTIwKSAqIChiMDIgLSBiMTIpO1xuICAgIGNvbnN0IG05ID0gKGEyMCArIGEyMSkgKiAoLWIwMCArIGIwMik7XG4gICAgY29uc3QgbTEwID0gKGEwMCArIGEwMSArIGEwMiAtIGExMSAtIGExMiAtIGEyMCAtIGEyMSkgKiBiMTI7XG4gICAgY29uc3QgbTExID0gYTIxICogKC1iMDAgKyBiMDIgKyBiMTAgLSBiMTEgLSBiMTIgLSBiMjAgKyBiMjEpO1xuICAgIGNvbnN0IG0xMiA9ICgtYTAyICsgYTIxICsgYTIyKSAqIChiMTEgKyBiMjAgLSBiMjEpO1xuICAgIGNvbnN0IG0xMyA9IChhMDIgLSBhMjIpICogKGIxMSAtIGIyMSk7XG4gICAgY29uc3QgbTE0ID0gYTAyICogYjIwO1xuICAgIGNvbnN0IG0xNSA9IChhMjEgKyBhMjIpICogKC1iMjAgKyBiMjEpO1xuICAgIGNvbnN0IG0xNiA9ICgtYTAyICsgYTExICsgYTEyKSAqIChiMTIgKyBiMjAgLSBiMjIpO1xuICAgIGNvbnN0IG0xNyA9IChhMDIgLSBhMTIpICogKGIxMiAtIGIyMik7XG4gICAgY29uc3QgbTE4ID0gKGExMSArIGExMikgKiAoLWIyMCArIGIyMik7XG4gICAgY29uc3QgbTE5ID0gYTAxICogYjEwO1xuICAgIGNvbnN0IG0yMCA9IGExMiAqIGIyMTtcbiAgICBjb25zdCBtMjEgPSBhMTAgKiBiMDI7XG4gICAgY29uc3QgbTIyID0gYTIwICogYjAxO1xuICAgIGNvbnN0IG0yMyA9IGEyMiAqIGIyMjtcblxuICAgIGNvbnN0IGMwMCA9IG02ICsgbTE0ICsgbTE5O1xuICAgIGNvbnN0IGMwMSA9IG0xICsgbTQgKyBtNSArIG02ICsgbTEyICsgbTE0ICsgbTE1O1xuICAgIGNvbnN0IGMwMiA9IG02ICsgbTcgKyBtOSArIG0xMCArIG0xNCArIG0xNiArIG0xODtcbiAgICBjb25zdCBjMTAgPSBtMiArIG0zICsgbTQgKyBtNiArIG0xNCArIG0xNiArIG0xNztcbiAgICBjb25zdCBjMTEgPSBtMiArIG00ICsgbTUgKyBtNiArIG0yMDtcbiAgICBjb25zdCBjMTIgPSBtMTQgKyBtMTYgKyBtMTcgKyBtMTggKyBtMjE7XG4gICAgY29uc3QgYzIwID0gbTYgKyBtNyArIG04ICsgbTExICsgbTEyICsgbTEzICsgbTE0O1xuICAgIGNvbnN0IGMyMSA9IG0xMiArIG0xMyArIG0xNCArIG0xNSArIG0yMjtcbiAgICBjb25zdCBjMjIgPSBtNiArIG03ICsgbTggKyBtOSArIG0yMztcblxuICAgIHJlc3VsdC5zZXQoMCwgMCwgYzAwKTtcbiAgICByZXN1bHQuc2V0KDAsIDEsIGMwMSk7XG4gICAgcmVzdWx0LnNldCgwLCAyLCBjMDIpO1xuICAgIHJlc3VsdC5zZXQoMSwgMCwgYzEwKTtcbiAgICByZXN1bHQuc2V0KDEsIDEsIGMxMSk7XG4gICAgcmVzdWx0LnNldCgxLCAyLCBjMTIpO1xuICAgIHJlc3VsdC5zZXQoMiwgMCwgYzIwKTtcbiAgICByZXN1bHQuc2V0KDIsIDEsIGMyMSk7XG4gICAgcmVzdWx0LnNldCgyLCAyLCBjMjIpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBtbXVsU3RyYXNzZW4oeSkge1xuICAgIHkgPSBNYXRyaXguY2hlY2tNYXRyaXgoeSk7XG4gICAgbGV0IHggPSB0aGlzLmNsb25lKCk7XG4gICAgbGV0IHIxID0geC5yb3dzO1xuICAgIGxldCBjMSA9IHguY29sdW1ucztcbiAgICBsZXQgcjIgPSB5LnJvd3M7XG4gICAgbGV0IGMyID0geS5jb2x1bW5zO1xuICAgIGlmIChjMSAhPT0gcjIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBNdWx0aXBseWluZyAke3IxfSB4ICR7YzF9IGFuZCAke3IyfSB4ICR7YzJ9IG1hdHJpeDogZGltZW5zaW9ucyBkbyBub3QgbWF0Y2guYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUHV0IGEgbWF0cml4IGludG8gdGhlIHRvcCBsZWZ0IG9mIGEgbWF0cml4IG9mIHplcm9zLlxuICAgIC8vIGByb3dzYCBhbmQgYGNvbHNgIGFyZSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb3V0cHV0IG1hdHJpeC5cbiAgICBmdW5jdGlvbiBlbWJlZChtYXQsIHJvd3MsIGNvbHMpIHtcbiAgICAgIGxldCByID0gbWF0LnJvd3M7XG4gICAgICBsZXQgYyA9IG1hdC5jb2x1bW5zO1xuICAgICAgaWYgKHIgPT09IHJvd3MgJiYgYyA9PT0gY29scykge1xuICAgICAgICByZXR1cm4gbWF0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHJlc3VsdGF0ID0gQWJzdHJhY3RNYXRyaXguemVyb3Mocm93cywgY29scyk7XG4gICAgICAgIHJlc3VsdGF0ID0gcmVzdWx0YXQuc2V0U3ViTWF0cml4KG1hdCwgMCwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHRhdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgYm90aCBtYXRyaWNlcyBhcmUgdGhlIHNhbWUgc2l6ZS5cbiAgICAvLyBUaGlzIGlzIGV4Y2x1c2l2ZWx5IGZvciBzaW1wbGljaXR5OlxuICAgIC8vIHRoaXMgYWxnb3JpdGhtIGNhbiBiZSBpbXBsZW1lbnRlZCB3aXRoIG1hdHJpY2VzIG9mIGRpZmZlcmVudCBzaXplcy5cblxuICAgIGxldCByID0gTWF0aC5tYXgocjEsIHIyKTtcbiAgICBsZXQgYyA9IE1hdGgubWF4KGMxLCBjMik7XG4gICAgeCA9IGVtYmVkKHgsIHIsIGMpO1xuICAgIHkgPSBlbWJlZCh5LCByLCBjKTtcblxuICAgIC8vIE91ciByZWN1cnNpdmUgbXVsdGlwbGljYXRpb24gZnVuY3Rpb24uXG4gICAgZnVuY3Rpb24gYmxvY2tNdWx0KGEsIGIsIHJvd3MsIGNvbHMpIHtcbiAgICAgIC8vIEZvciBzbWFsbCBtYXRyaWNlcywgcmVzb3J0IHRvIG5haXZlIG11bHRpcGxpY2F0aW9uLlxuICAgICAgaWYgKHJvd3MgPD0gNTEyIHx8IGNvbHMgPD0gNTEyKSB7XG4gICAgICAgIHJldHVybiBhLm1tdWwoYik7IC8vIGEgaXMgZXF1aXZhbGVudCB0byB0aGlzXG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGx5IGR5bmFtaWMgcGFkZGluZy5cbiAgICAgIGlmIChyb3dzICUgMiA9PT0gMSAmJiBjb2xzICUgMiA9PT0gMSkge1xuICAgICAgICBhID0gZW1iZWQoYSwgcm93cyArIDEsIGNvbHMgKyAxKTtcbiAgICAgICAgYiA9IGVtYmVkKGIsIHJvd3MgKyAxLCBjb2xzICsgMSk7XG4gICAgICB9IGVsc2UgaWYgKHJvd3MgJSAyID09PSAxKSB7XG4gICAgICAgIGEgPSBlbWJlZChhLCByb3dzICsgMSwgY29scyk7XG4gICAgICAgIGIgPSBlbWJlZChiLCByb3dzICsgMSwgY29scyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbHMgJSAyID09PSAxKSB7XG4gICAgICAgIGEgPSBlbWJlZChhLCByb3dzLCBjb2xzICsgMSk7XG4gICAgICAgIGIgPSBlbWJlZChiLCByb3dzLCBjb2xzICsgMSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBoYWxmUm93cyA9IHBhcnNlSW50KGEucm93cyAvIDIsIDEwKTtcbiAgICAgIGxldCBoYWxmQ29scyA9IHBhcnNlSW50KGEuY29sdW1ucyAvIDIsIDEwKTtcbiAgICAgIC8vIFN1YmRpdmlkZSBpbnB1dCBtYXRyaWNlcy5cbiAgICAgIGxldCBhMTEgPSBhLnN1Yk1hdHJpeCgwLCBoYWxmUm93cyAtIDEsIDAsIGhhbGZDb2xzIC0gMSk7XG4gICAgICBsZXQgYjExID0gYi5zdWJNYXRyaXgoMCwgaGFsZlJvd3MgLSAxLCAwLCBoYWxmQ29scyAtIDEpO1xuXG4gICAgICBsZXQgYTEyID0gYS5zdWJNYXRyaXgoMCwgaGFsZlJvd3MgLSAxLCBoYWxmQ29scywgYS5jb2x1bW5zIC0gMSk7XG4gICAgICBsZXQgYjEyID0gYi5zdWJNYXRyaXgoMCwgaGFsZlJvd3MgLSAxLCBoYWxmQ29scywgYi5jb2x1bW5zIC0gMSk7XG5cbiAgICAgIGxldCBhMjEgPSBhLnN1Yk1hdHJpeChoYWxmUm93cywgYS5yb3dzIC0gMSwgMCwgaGFsZkNvbHMgLSAxKTtcbiAgICAgIGxldCBiMjEgPSBiLnN1Yk1hdHJpeChoYWxmUm93cywgYi5yb3dzIC0gMSwgMCwgaGFsZkNvbHMgLSAxKTtcblxuICAgICAgbGV0IGEyMiA9IGEuc3ViTWF0cml4KGhhbGZSb3dzLCBhLnJvd3MgLSAxLCBoYWxmQ29scywgYS5jb2x1bW5zIC0gMSk7XG4gICAgICBsZXQgYjIyID0gYi5zdWJNYXRyaXgoaGFsZlJvd3MsIGIucm93cyAtIDEsIGhhbGZDb2xzLCBiLmNvbHVtbnMgLSAxKTtcblxuICAgICAgLy8gQ29tcHV0ZSBpbnRlcm1lZGlhdGUgdmFsdWVzLlxuICAgICAgbGV0IG0xID0gYmxvY2tNdWx0KFxuICAgICAgICBBYnN0cmFjdE1hdHJpeC5hZGQoYTExLCBhMjIpLFxuICAgICAgICBBYnN0cmFjdE1hdHJpeC5hZGQoYjExLCBiMjIpLFxuICAgICAgICBoYWxmUm93cyxcbiAgICAgICAgaGFsZkNvbHMsXG4gICAgICApO1xuICAgICAgbGV0IG0yID0gYmxvY2tNdWx0KEFic3RyYWN0TWF0cml4LmFkZChhMjEsIGEyMiksIGIxMSwgaGFsZlJvd3MsIGhhbGZDb2xzKTtcbiAgICAgIGxldCBtMyA9IGJsb2NrTXVsdChhMTEsIEFic3RyYWN0TWF0cml4LnN1YihiMTIsIGIyMiksIGhhbGZSb3dzLCBoYWxmQ29scyk7XG4gICAgICBsZXQgbTQgPSBibG9ja011bHQoYTIyLCBBYnN0cmFjdE1hdHJpeC5zdWIoYjIxLCBiMTEpLCBoYWxmUm93cywgaGFsZkNvbHMpO1xuICAgICAgbGV0IG01ID0gYmxvY2tNdWx0KEFic3RyYWN0TWF0cml4LmFkZChhMTEsIGExMiksIGIyMiwgaGFsZlJvd3MsIGhhbGZDb2xzKTtcbiAgICAgIGxldCBtNiA9IGJsb2NrTXVsdChcbiAgICAgICAgQWJzdHJhY3RNYXRyaXguc3ViKGEyMSwgYTExKSxcbiAgICAgICAgQWJzdHJhY3RNYXRyaXguYWRkKGIxMSwgYjEyKSxcbiAgICAgICAgaGFsZlJvd3MsXG4gICAgICAgIGhhbGZDb2xzLFxuICAgICAgKTtcbiAgICAgIGxldCBtNyA9IGJsb2NrTXVsdChcbiAgICAgICAgQWJzdHJhY3RNYXRyaXguc3ViKGExMiwgYTIyKSxcbiAgICAgICAgQWJzdHJhY3RNYXRyaXguYWRkKGIyMSwgYjIyKSxcbiAgICAgICAgaGFsZlJvd3MsXG4gICAgICAgIGhhbGZDb2xzLFxuICAgICAgKTtcblxuICAgICAgLy8gQ29tYmluZSBpbnRlcm1lZGlhdGUgdmFsdWVzIGludG8gdGhlIG91dHB1dC5cbiAgICAgIGxldCBjMTEgPSBBYnN0cmFjdE1hdHJpeC5hZGQobTEsIG00KTtcbiAgICAgIGMxMS5zdWIobTUpO1xuICAgICAgYzExLmFkZChtNyk7XG4gICAgICBsZXQgYzEyID0gQWJzdHJhY3RNYXRyaXguYWRkKG0zLCBtNSk7XG4gICAgICBsZXQgYzIxID0gQWJzdHJhY3RNYXRyaXguYWRkKG0yLCBtNCk7XG4gICAgICBsZXQgYzIyID0gQWJzdHJhY3RNYXRyaXguc3ViKG0xLCBtMik7XG4gICAgICBjMjIuYWRkKG0zKTtcbiAgICAgIGMyMi5hZGQobTYpO1xuXG4gICAgICAvLyBDcm9wIG91dHB1dCB0byB0aGUgZGVzaXJlZCBzaXplICh1bmRvIGR5bmFtaWMgcGFkZGluZykuXG4gICAgICBsZXQgcmVzdWx0YXQgPSBBYnN0cmFjdE1hdHJpeC56ZXJvcygyICogYzExLnJvd3MsIDIgKiBjMTEuY29sdW1ucyk7XG4gICAgICByZXN1bHRhdCA9IHJlc3VsdGF0LnNldFN1Yk1hdHJpeChjMTEsIDAsIDApO1xuICAgICAgcmVzdWx0YXQgPSByZXN1bHRhdC5zZXRTdWJNYXRyaXgoYzEyLCBjMTEucm93cywgMCk7XG4gICAgICByZXN1bHRhdCA9IHJlc3VsdGF0LnNldFN1Yk1hdHJpeChjMjEsIDAsIGMxMS5jb2x1bW5zKTtcbiAgICAgIHJlc3VsdGF0ID0gcmVzdWx0YXQuc2V0U3ViTWF0cml4KGMyMiwgYzExLnJvd3MsIGMxMS5jb2x1bW5zKTtcbiAgICAgIHJldHVybiByZXN1bHRhdC5zdWJNYXRyaXgoMCwgcm93cyAtIDEsIDAsIGNvbHMgLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2NrTXVsdCh4LCB5LCByLCBjKTtcbiAgfVxuXG4gIHNjYWxlUm93cyhvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHsgbWluID0gMCwgbWF4ID0gMSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShtaW4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG1heCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKG1pbiA+PSBtYXgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaW4gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4Jyk7XG4gICAgbGV0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgodGhpcy5yb3dzLCB0aGlzLmNvbHVtbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ2V0Um93KGkpO1xuICAgICAgcmVzY2FsZShyb3csIHsgbWluLCBtYXgsIG91dHB1dDogcm93IH0pO1xuICAgICAgbmV3TWF0cml4LnNldFJvdyhpLCByb3cpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3TWF0cml4O1xuICB9XG5cbiAgc2NhbGVDb2x1bW5zKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgY29uc3QgeyBtaW4gPSAwLCBtYXggPSAxIH0gPSBvcHRpb25zO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG1pbikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobWF4KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAobWluID49IG1heCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgnKTtcbiAgICBsZXQgbmV3TWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLnJvd3MsIHRoaXMuY29sdW1ucyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5nZXRDb2x1bW4oaSk7XG4gICAgICByZXNjYWxlKGNvbHVtbiwge1xuICAgICAgICBtaW46IG1pbixcbiAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgIG91dHB1dDogY29sdW1uLFxuICAgICAgfSk7XG4gICAgICBuZXdNYXRyaXguc2V0Q29sdW1uKGksIGNvbHVtbik7XG4gICAgfVxuICAgIHJldHVybiBuZXdNYXRyaXg7XG4gIH1cblxuICBmbGlwUm93cygpIHtcbiAgICBjb25zdCBtaWRkbGUgPSBNYXRoLmNlaWwodGhpcy5jb2x1bW5zIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtaWRkbGU7IGorKykge1xuICAgICAgICBsZXQgZmlyc3QgPSB0aGlzLmdldChpLCBqKTtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmdldChpLCB0aGlzLmNvbHVtbnMgLSAxIC0gaik7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIGxhc3QpO1xuICAgICAgICB0aGlzLnNldChpLCB0aGlzLmNvbHVtbnMgLSAxIC0gaiwgZmlyc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZsaXBDb2x1bW5zKCkge1xuICAgIGNvbnN0IG1pZGRsZSA9IE1hdGguY2VpbCh0aGlzLnJvd3MgLyAyKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pZGRsZTsgaSsrKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IHRoaXMuZ2V0KGksIGopO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuZ2V0KHRoaXMucm93cyAtIDEgLSBpLCBqKTtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgbGFzdCk7XG4gICAgICAgIHRoaXMuc2V0KHRoaXMucm93cyAtIDEgLSBpLCBqLCBmaXJzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAga3JvbmVja2VyUHJvZHVjdChvdGhlcikge1xuICAgIG90aGVyID0gTWF0cml4LmNoZWNrTWF0cml4KG90aGVyKTtcblxuICAgIGxldCBtID0gdGhpcy5yb3dzO1xuICAgIGxldCBuID0gdGhpcy5jb2x1bW5zO1xuICAgIGxldCBwID0gb3RoZXIucm93cztcbiAgICBsZXQgcSA9IG90aGVyLmNvbHVtbnM7XG5cbiAgICBsZXQgcmVzdWx0ID0gbmV3IE1hdHJpeChtICogcCwgbiAqIHEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHA7IGsrKykge1xuICAgICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgcTsgbCsrKSB7XG4gICAgICAgICAgICByZXN1bHQuc2V0KHAgKiBpICsgaywgcSAqIGogKyBsLCB0aGlzLmdldChpLCBqKSAqIG90aGVyLmdldChrLCBsKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB0cmFuc3Bvc2UoKSB7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBNYXRyaXgodGhpcy5jb2x1bW5zLCB0aGlzLnJvd3MpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgcmVzdWx0LnNldChqLCBpLCB0aGlzLmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBzb3J0Um93cyhjb21wYXJlRnVuY3Rpb24gPSBjb21wYXJlTnVtYmVycykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIHRoaXMuc2V0Um93KGksIHRoaXMuZ2V0Um93KGkpLnNvcnQoY29tcGFyZUZ1bmN0aW9uKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc29ydENvbHVtbnMoY29tcGFyZUZ1bmN0aW9uID0gY29tcGFyZU51bWJlcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG4gICAgICB0aGlzLnNldENvbHVtbihpLCB0aGlzLmdldENvbHVtbihpKS5zb3J0KGNvbXBhcmVGdW5jdGlvbikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN1Yk1hdHJpeChzdGFydFJvdywgZW5kUm93LCBzdGFydENvbHVtbiwgZW5kQ29sdW1uKSB7XG4gICAgY2hlY2tSYW5nZSh0aGlzLCBzdGFydFJvdywgZW5kUm93LCBzdGFydENvbHVtbiwgZW5kQ29sdW1uKTtcbiAgICBsZXQgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChcbiAgICAgIGVuZFJvdyAtIHN0YXJ0Um93ICsgMSxcbiAgICAgIGVuZENvbHVtbiAtIHN0YXJ0Q29sdW1uICsgMSxcbiAgICApO1xuICAgIGZvciAobGV0IGkgPSBzdGFydFJvdzsgaSA8PSBlbmRSb3c7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0Q29sdW1uOyBqIDw9IGVuZENvbHVtbjsgaisrKSB7XG4gICAgICAgIG5ld01hdHJpeC5zZXQoaSAtIHN0YXJ0Um93LCBqIC0gc3RhcnRDb2x1bW4sIHRoaXMuZ2V0KGksIGopKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld01hdHJpeDtcbiAgfVxuXG4gIHN1Yk1hdHJpeFJvdyhpbmRpY2VzLCBzdGFydENvbHVtbiwgZW5kQ29sdW1uKSB7XG4gICAgaWYgKHN0YXJ0Q29sdW1uID09PSB1bmRlZmluZWQpIHN0YXJ0Q29sdW1uID0gMDtcbiAgICBpZiAoZW5kQ29sdW1uID09PSB1bmRlZmluZWQpIGVuZENvbHVtbiA9IHRoaXMuY29sdW1ucyAtIDE7XG4gICAgaWYgKFxuICAgICAgc3RhcnRDb2x1bW4gPiBlbmRDb2x1bW4gfHxcbiAgICAgIHN0YXJ0Q29sdW1uIDwgMCB8fFxuICAgICAgc3RhcnRDb2x1bW4gPj0gdGhpcy5jb2x1bW5zIHx8XG4gICAgICBlbmRDb2x1bW4gPCAwIHx8XG4gICAgICBlbmRDb2x1bW4gPj0gdGhpcy5jb2x1bW5zXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXJndW1lbnQgb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuXG4gICAgbGV0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgoaW5kaWNlcy5sZW5ndGgsIGVuZENvbHVtbiAtIHN0YXJ0Q29sdW1uICsgMSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gc3RhcnRDb2x1bW47IGogPD0gZW5kQ29sdW1uOyBqKyspIHtcbiAgICAgICAgaWYgKGluZGljZXNbaV0gPCAwIHx8IGluZGljZXNbaV0gPj0gdGhpcy5yb3dzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFJvdyBpbmRleCBvdXQgb2YgcmFuZ2U6ICR7aW5kaWNlc1tpXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdNYXRyaXguc2V0KGksIGogLSBzdGFydENvbHVtbiwgdGhpcy5nZXQoaW5kaWNlc1tpXSwgaikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3TWF0cml4O1xuICB9XG5cbiAgc3ViTWF0cml4Q29sdW1uKGluZGljZXMsIHN0YXJ0Um93LCBlbmRSb3cpIHtcbiAgICBpZiAoc3RhcnRSb3cgPT09IHVuZGVmaW5lZCkgc3RhcnRSb3cgPSAwO1xuICAgIGlmIChlbmRSb3cgPT09IHVuZGVmaW5lZCkgZW5kUm93ID0gdGhpcy5yb3dzIC0gMTtcbiAgICBpZiAoXG4gICAgICBzdGFydFJvdyA+IGVuZFJvdyB8fFxuICAgICAgc3RhcnRSb3cgPCAwIHx8XG4gICAgICBzdGFydFJvdyA+PSB0aGlzLnJvd3MgfHxcbiAgICAgIGVuZFJvdyA8IDAgfHxcbiAgICAgIGVuZFJvdyA+PSB0aGlzLnJvd3NcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBcmd1bWVudCBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG5cbiAgICBsZXQgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChlbmRSb3cgLSBzdGFydFJvdyArIDEsIGluZGljZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBzdGFydFJvdzsgaiA8PSBlbmRSb3c7IGorKykge1xuICAgICAgICBpZiAoaW5kaWNlc1tpXSA8IDAgfHwgaW5kaWNlc1tpXSA+PSB0aGlzLmNvbHVtbnMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQ29sdW1uIGluZGV4IG91dCBvZiByYW5nZTogJHtpbmRpY2VzW2ldfWApO1xuICAgICAgICB9XG4gICAgICAgIG5ld01hdHJpeC5zZXQoaiAtIHN0YXJ0Um93LCBpLCB0aGlzLmdldChqLCBpbmRpY2VzW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdNYXRyaXg7XG4gIH1cblxuICBzZXRTdWJNYXRyaXgobWF0cml4LCBzdGFydFJvdywgc3RhcnRDb2x1bW4pIHtcbiAgICBtYXRyaXggPSBNYXRyaXguY2hlY2tNYXRyaXgobWF0cml4KTtcbiAgICBsZXQgZW5kUm93ID0gc3RhcnRSb3cgKyBtYXRyaXgucm93cyAtIDE7XG4gICAgbGV0IGVuZENvbHVtbiA9IHN0YXJ0Q29sdW1uICsgbWF0cml4LmNvbHVtbnMgLSAxO1xuICAgIGNoZWNrUmFuZ2UodGhpcywgc3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdHJpeC5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoc3RhcnRSb3cgKyBpLCBzdGFydENvbHVtbiArIGosIG1hdHJpeC5nZXQoaSwgaikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNlbGVjdGlvbihyb3dJbmRpY2VzLCBjb2x1bW5JbmRpY2VzKSB7XG4gICAgbGV0IGluZGljZXMgPSBjaGVja0luZGljZXModGhpcywgcm93SW5kaWNlcywgY29sdW1uSW5kaWNlcyk7XG4gICAgbGV0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgocm93SW5kaWNlcy5sZW5ndGgsIGNvbHVtbkluZGljZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMucm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcm93SW5kZXggPSBpbmRpY2VzLnJvd1tpXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5kaWNlcy5jb2x1bW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbGV0IGNvbHVtbkluZGV4ID0gaW5kaWNlcy5jb2x1bW5bal07XG4gICAgICAgIG5ld01hdHJpeC5zZXQoaSwgaiwgdGhpcy5nZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdNYXRyaXg7XG4gIH1cblxuICB0cmFjZSgpIHtcbiAgICBsZXQgbWluID0gTWF0aC5taW4odGhpcy5yb3dzLCB0aGlzLmNvbHVtbnMpO1xuICAgIGxldCB0cmFjZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgdHJhY2UgKz0gdGhpcy5nZXQoaSwgaSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFjZTtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIGxldCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KHRoaXMucm93cywgdGhpcy5jb2x1bW5zKTtcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLnJvd3M7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2x1bW4gPSAwOyBjb2x1bW4gPCB0aGlzLmNvbHVtbnM7IGNvbHVtbisrKSB7XG4gICAgICAgIG5ld01hdHJpeC5zZXQocm93LCBjb2x1bW4sIHRoaXMuZ2V0KHJvdywgY29sdW1uKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdNYXRyaXg7XG4gIH1cblxuICBzdW0oYnkpIHtcbiAgICBzd2l0Y2ggKGJ5KSB7XG4gICAgICBjYXNlICdyb3cnOlxuICAgICAgICByZXR1cm4gc3VtQnlSb3codGhpcyk7XG4gICAgICBjYXNlICdjb2x1bW4nOlxuICAgICAgICByZXR1cm4gc3VtQnlDb2x1bW4odGhpcyk7XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHN1bUFsbCh0aGlzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7Ynl9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJvZHVjdChieSkge1xuICAgIHN3aXRjaCAoYnkpIHtcbiAgICAgIGNhc2UgJ3Jvdyc6XG4gICAgICAgIHJldHVybiBwcm9kdWN0QnlSb3codGhpcyk7XG4gICAgICBjYXNlICdjb2x1bW4nOlxuICAgICAgICByZXR1cm4gcHJvZHVjdEJ5Q29sdW1uKHRoaXMpO1xuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiBwcm9kdWN0QWxsKHRoaXMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9wdGlvbjogJHtieX1gKTtcbiAgICB9XG4gIH1cblxuICBtZWFuKGJ5KSB7XG4gICAgY29uc3Qgc3VtID0gdGhpcy5zdW0oYnkpO1xuICAgIHN3aXRjaCAoYnkpIHtcbiAgICAgIGNhc2UgJ3Jvdyc6IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgIHN1bVtpXSAvPSB0aGlzLmNvbHVtbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2NvbHVtbic6IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuICAgICAgICAgIHN1bVtpXSAvPSB0aGlzLnJvd3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgIH1cbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gc3VtIC8gdGhpcy5zaXplO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9wdGlvbjogJHtieX1gKTtcbiAgICB9XG4gIH1cblxuICB2YXJpYW5jZShieSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBieSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSBieTtcbiAgICAgIGJ5ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHsgdW5iaWFzZWQgPSB0cnVlLCBtZWFuID0gdGhpcy5tZWFuKGJ5KSB9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHVuYmlhc2VkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuYmlhc2VkIG11c3QgYmUgYSBib29sZWFuJyk7XG4gICAgfVxuICAgIHN3aXRjaCAoYnkpIHtcbiAgICAgIGNhc2UgJ3Jvdyc6IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lYW4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWVhbiBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhcmlhbmNlQnlSb3codGhpcywgdW5iaWFzZWQsIG1lYW4pO1xuICAgICAgfVxuICAgICAgY2FzZSAnY29sdW1uJzoge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVhbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtZWFuIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyaWFuY2VCeUNvbHVtbih0aGlzLCB1bmJpYXNlZCwgbWVhbik7XG4gICAgICB9XG4gICAgICBjYXNlIHVuZGVmaW5lZDoge1xuICAgICAgICBpZiAodHlwZW9mIG1lYW4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWVhbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhcmlhbmNlQWxsKHRoaXMsIHVuYmlhc2VkLCBtZWFuKTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7Ynl9YCk7XG4gICAgfVxuICB9XG5cbiAgc3RhbmRhcmREZXZpYXRpb24oYnksIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IGJ5O1xuICAgICAgYnkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHZhcmlhbmNlID0gdGhpcy52YXJpYW5jZShieSwgb3B0aW9ucyk7XG4gICAgaWYgKGJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQodmFyaWFuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhcmlhbmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhcmlhbmNlW2ldID0gTWF0aC5zcXJ0KHZhcmlhbmNlW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YXJpYW5jZTtcbiAgICB9XG4gIH1cblxuICBjZW50ZXIoYnksIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgYnkgPT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0gYnk7XG4gICAgICBieSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGNlbnRlciA9IHRoaXMubWVhbihieSkgfSA9IG9wdGlvbnM7XG4gICAgc3dpdGNoIChieSkge1xuICAgICAgY2FzZSAncm93Jzoge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2VudGVyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NlbnRlciBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY2VudGVyQnlSb3codGhpcywgY2VudGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBjYXNlICdjb2x1bW4nOiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjZW50ZXIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2VudGVyIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBjZW50ZXJCeUNvbHVtbih0aGlzLCBjZW50ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGNhc2UgdW5kZWZpbmVkOiB7XG4gICAgICAgIGlmICh0eXBlb2YgY2VudGVyICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NlbnRlciBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2VudGVyQWxsKHRoaXMsIGNlbnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9wdGlvbjogJHtieX1gKTtcbiAgICB9XG4gIH1cblxuICBzY2FsZShieSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBieSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSBieTtcbiAgICAgIGJ5ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIGxldCBzY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gICAgc3dpdGNoIChieSkge1xuICAgICAgY2FzZSAncm93Jzoge1xuICAgICAgICBpZiAoc2NhbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNjYWxlID0gZ2V0U2NhbGVCeVJvdyh0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShzY2FsZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzY2FsZSBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc2NhbGVCeVJvdyh0aGlzLCBzY2FsZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY2FzZSAnY29sdW1uJzoge1xuICAgICAgICBpZiAoc2NhbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNjYWxlID0gZ2V0U2NhbGVCeUNvbHVtbih0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShzY2FsZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzY2FsZSBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc2NhbGVCeUNvbHVtbih0aGlzLCBzY2FsZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY2FzZSB1bmRlZmluZWQ6IHtcbiAgICAgICAgaWYgKHNjYWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzY2FsZSA9IGdldFNjYWxlQWxsKHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzY2FsZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzY2FsZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2NhbGVBbGwodGhpcywgc2NhbGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7Ynl9YCk7XG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiBpbnNwZWN0TWF0cml4V2l0aE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIH1cbn1cblxuQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmtsYXNzID0gJ01hdHJpeCc7XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlW1xuICAgIFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJylcbiAgXSA9IGluc3BlY3RNYXRyaXg7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuXG4vLyBTeW5vbnltc1xuQWJzdHJhY3RNYXRyaXgucmFuZG9tID0gQWJzdHJhY3RNYXRyaXgucmFuZDtcbkFic3RyYWN0TWF0cml4LnJhbmRvbUludCA9IEFic3RyYWN0TWF0cml4LnJhbmRJbnQ7XG5BYnN0cmFjdE1hdHJpeC5kaWFnb25hbCA9IEFic3RyYWN0TWF0cml4LmRpYWc7XG5BYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuZGlhZ29uYWwgPSBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuZGlhZztcbkFic3RyYWN0TWF0cml4LmlkZW50aXR5ID0gQWJzdHJhY3RNYXRyaXguZXllO1xuQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm5lZ2F0ZSA9IEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5uZWc7XG5BYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUudGVuc29yUHJvZHVjdCA9XG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5rcm9uZWNrZXJQcm9kdWN0O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRyaXggZXh0ZW5kcyBBYnN0cmFjdE1hdHJpeCB7XG4gIGNvbnN0cnVjdG9yKG5Sb3dzLCBuQ29sdW1ucykge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKE1hdHJpeC5pc01hdHJpeChuUm93cykpIHtcbiAgICAgIHJldHVybiBuUm93cy5jbG9uZSgpO1xuICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcihuUm93cykgJiYgblJvd3MgPiAwKSB7XG4gICAgICAvLyBDcmVhdGUgYW4gZW1wdHkgbWF0cml4XG4gICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKG5Db2x1bW5zKSAmJiBuQ29sdW1ucyA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuUm93czsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kYXRhLnB1c2gobmV3IEZsb2F0NjRBcnJheShuQ29sdW1ucykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduQ29sdW1ucyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShuUm93cykpIHtcbiAgICAgIC8vIENvcHkgdGhlIHZhbHVlcyBmcm9tIHRoZSAyRCBhcnJheVxuICAgICAgY29uc3QgYXJyYXlEYXRhID0gblJvd3M7XG4gICAgICBuUm93cyA9IGFycmF5RGF0YS5sZW5ndGg7XG4gICAgICBuQ29sdW1ucyA9IGFycmF5RGF0YVswXS5sZW5ndGg7XG4gICAgICBpZiAodHlwZW9mIG5Db2x1bW5zICE9PSAnbnVtYmVyJyB8fCBuQ29sdW1ucyA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdEYXRhIG11c3QgYmUgYSAyRCBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBlbGVtZW50JyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuUm93czsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheURhdGFbaV0ubGVuZ3RoICE9PSBuQ29sdW1ucykge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmNvbnNpc3RlbnQgYXJyYXkgZGltZW5zaW9ucycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKEZsb2F0NjRBcnJheS5mcm9tKGFycmF5RGF0YVtpXSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlciBvciBhbiBhcnJheScsXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnJvd3MgPSBuUm93cztcbiAgICB0aGlzLmNvbHVtbnMgPSBuQ29sdW1ucztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgdGhpcy5kYXRhW3Jvd0luZGV4XVtjb2x1bW5JbmRleF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW3Jvd0luZGV4XVtjb2x1bW5JbmRleF07XG4gIH1cblxuICByZW1vdmVSb3coaW5kZXgpIHtcbiAgICBjaGVja1Jvd0luZGV4KHRoaXMsIGluZGV4KTtcbiAgICBpZiAodGhpcy5yb3dzID09PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQSBtYXRyaXggY2Fubm90IGhhdmUgbGVzcyB0aGFuIG9uZSByb3cnKTtcbiAgICB9XG4gICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5yb3dzIC09IDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGRSb3coaW5kZXgsIGFycmF5KSB7XG4gICAgaWYgKGFycmF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFycmF5ID0gaW5kZXg7XG4gICAgICBpbmRleCA9IHRoaXMucm93cztcbiAgICB9XG4gICAgY2hlY2tSb3dJbmRleCh0aGlzLCBpbmRleCwgdHJ1ZSk7XG4gICAgYXJyYXkgPSBGbG9hdDY0QXJyYXkuZnJvbShjaGVja1Jvd1ZlY3Rvcih0aGlzLCBhcnJheSwgdHJ1ZSkpO1xuICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDAsIGFycmF5KTtcbiAgICB0aGlzLnJvd3MgKz0gMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlbW92ZUNvbHVtbihpbmRleCkge1xuICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgaW5kZXgpO1xuICAgIGlmICh0aGlzLmNvbHVtbnMgPT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBIG1hdHJpeCBjYW5ub3QgaGF2ZSBsZXNzIHRoYW4gb25lIGNvbHVtbicpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBjb25zdCBuZXdSb3cgPSBuZXcgRmxvYXQ2NEFycmF5KHRoaXMuY29sdW1ucyAtIDEpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmRleDsgaisrKSB7XG4gICAgICAgIG5ld1Jvd1tqXSA9IHRoaXMuZGF0YVtpXVtqXTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSBpbmRleCArIDE7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICBuZXdSb3dbaiAtIDFdID0gdGhpcy5kYXRhW2ldW2pdO1xuICAgICAgfVxuICAgICAgdGhpcy5kYXRhW2ldID0gbmV3Um93O1xuICAgIH1cbiAgICB0aGlzLmNvbHVtbnMgLT0gMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZENvbHVtbihpbmRleCwgYXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGFycmF5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgYXJyYXkgPSBpbmRleDtcbiAgICAgIGluZGV4ID0gdGhpcy5jb2x1bW5zO1xuICAgIH1cbiAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGluZGV4LCB0cnVlKTtcbiAgICBhcnJheSA9IGNoZWNrQ29sdW1uVmVjdG9yKHRoaXMsIGFycmF5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBjb25zdCBuZXdSb3cgPSBuZXcgRmxvYXQ2NEFycmF5KHRoaXMuY29sdW1ucyArIDEpO1xuICAgICAgbGV0IGogPSAwO1xuICAgICAgZm9yICg7IGogPCBpbmRleDsgaisrKSB7XG4gICAgICAgIG5ld1Jvd1tqXSA9IHRoaXMuZGF0YVtpXVtqXTtcbiAgICAgIH1cbiAgICAgIG5ld1Jvd1tqKytdID0gYXJyYXlbaV07XG4gICAgICBmb3IgKDsgaiA8IHRoaXMuY29sdW1ucyArIDE7IGorKykge1xuICAgICAgICBuZXdSb3dbal0gPSB0aGlzLmRhdGFbaV1baiAtIDFdO1xuICAgICAgfVxuICAgICAgdGhpcy5kYXRhW2ldID0gbmV3Um93O1xuICAgIH1cbiAgICB0aGlzLmNvbHVtbnMgKz0gMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5pbnN0YWxsTWF0aE9wZXJhdGlvbnMoQWJzdHJhY3RNYXRyaXgsIE1hdHJpeCk7XG4iLCJpbXBvcnQgU1ZEIGZyb20gJy4vZGMvc3ZkJztcbmltcG9ydCBNYXRyaXggZnJvbSAnLi9tYXRyaXgnO1xuXG5leHBvcnQgZnVuY3Rpb24gcHNldWRvSW52ZXJzZShtYXRyaXgsIHRocmVzaG9sZCA9IE51bWJlci5FUFNJTE9OKSB7XG4gIG1hdHJpeCA9IE1hdHJpeC5jaGVja01hdHJpeChtYXRyaXgpO1xuICBsZXQgc3ZkU29sdXRpb24gPSBuZXcgU1ZEKG1hdHJpeCwgeyBhdXRvVHJhbnNwb3NlOiB0cnVlIH0pO1xuXG4gIGxldCBVID0gc3ZkU29sdXRpb24ubGVmdFNpbmd1bGFyVmVjdG9ycztcbiAgbGV0IFYgPSBzdmRTb2x1dGlvbi5yaWdodFNpbmd1bGFyVmVjdG9ycztcbiAgbGV0IHMgPSBzdmRTb2x1dGlvbi5kaWFnb25hbDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoTWF0aC5hYnMoc1tpXSkgPiB0aHJlc2hvbGQpIHtcbiAgICAgIHNbaV0gPSAxLjAgLyBzW2ldO1xuICAgIH0gZWxzZSB7XG4gICAgICBzW2ldID0gMC4wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBWLm1tdWwoTWF0cml4LmRpYWcocykubW11bChVLnRyYW5zcG9zZSgpKSk7XG59XG4iLCJpbXBvcnQgeyBuZXdBcnJheSB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdW1CeVJvdyhtYXRyaXgpIHtcbiAgbGV0IHN1bSA9IG5ld0FycmF5KG1hdHJpeC5yb3dzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgKytqKSB7XG4gICAgICBzdW1baV0gKz0gbWF0cml4LmdldChpLCBqKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1bUJ5Q29sdW1uKG1hdHJpeCkge1xuICBsZXQgc3VtID0gbmV3QXJyYXkobWF0cml4LmNvbHVtbnMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdHJpeC5yb3dzOyArK2kpIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdHJpeC5jb2x1bW5zOyArK2opIHtcbiAgICAgIHN1bVtqXSArPSBtYXRyaXguZ2V0KGksIGopO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3VtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VtQWxsKG1hdHJpeCkge1xuICBsZXQgdiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4LnJvd3M7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0cml4LmNvbHVtbnM7IGorKykge1xuICAgICAgdiArPSBtYXRyaXguZ2V0KGksIGopO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2R1Y3RCeVJvdyhtYXRyaXgpIHtcbiAgbGV0IHN1bSA9IG5ld0FycmF5KG1hdHJpeC5yb3dzLCAxKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgKytqKSB7XG4gICAgICBzdW1baV0gKj0gbWF0cml4LmdldChpLCBqKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2R1Y3RCeUNvbHVtbihtYXRyaXgpIHtcbiAgbGV0IHN1bSA9IG5ld0FycmF5KG1hdHJpeC5jb2x1bW5zLCAxKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgKytqKSB7XG4gICAgICBzdW1bal0gKj0gbWF0cml4LmdldChpLCBqKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2R1Y3RBbGwobWF0cml4KSB7XG4gIGxldCB2ID0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgaisrKSB7XG4gICAgICB2ICo9IG1hdHJpeC5nZXQoaSwgaik7XG4gICAgfVxuICB9XG4gIHJldHVybiB2O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFuY2VCeVJvdyhtYXRyaXgsIHVuYmlhc2VkLCBtZWFuKSB7XG4gIGNvbnN0IHJvd3MgPSBtYXRyaXgucm93cztcbiAgY29uc3QgY29scyA9IG1hdHJpeC5jb2x1bW5zO1xuICBjb25zdCB2YXJpYW5jZSA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgbGV0IHN1bTEgPSAwO1xuICAgIGxldCBzdW0yID0gMDtcbiAgICBsZXQgeCA9IDA7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyBqKyspIHtcbiAgICAgIHggPSBtYXRyaXguZ2V0KGksIGopIC0gbWVhbltpXTtcbiAgICAgIHN1bTEgKz0geDtcbiAgICAgIHN1bTIgKz0geCAqIHg7XG4gICAgfVxuICAgIGlmICh1bmJpYXNlZCkge1xuICAgICAgdmFyaWFuY2UucHVzaCgoc3VtMiAtIChzdW0xICogc3VtMSkgLyBjb2xzKSAvIChjb2xzIC0gMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXJpYW5jZS5wdXNoKChzdW0yIC0gKHN1bTEgKiBzdW0xKSAvIGNvbHMpIC8gY29scyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YXJpYW5jZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhbmNlQnlDb2x1bW4obWF0cml4LCB1bmJpYXNlZCwgbWVhbikge1xuICBjb25zdCByb3dzID0gbWF0cml4LnJvd3M7XG4gIGNvbnN0IGNvbHMgPSBtYXRyaXguY29sdW1ucztcbiAgY29uc3QgdmFyaWFuY2UgPSBbXTtcblxuICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7IGorKykge1xuICAgIGxldCBzdW0xID0gMDtcbiAgICBsZXQgc3VtMiA9IDA7XG4gICAgbGV0IHggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICB4ID0gbWF0cml4LmdldChpLCBqKSAtIG1lYW5bal07XG4gICAgICBzdW0xICs9IHg7XG4gICAgICBzdW0yICs9IHggKiB4O1xuICAgIH1cbiAgICBpZiAodW5iaWFzZWQpIHtcbiAgICAgIHZhcmlhbmNlLnB1c2goKHN1bTIgLSAoc3VtMSAqIHN1bTEpIC8gcm93cykgLyAocm93cyAtIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyaWFuY2UucHVzaCgoc3VtMiAtIChzdW0xICogc3VtMSkgLyByb3dzKSAvIHJvd3MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFyaWFuY2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYW5jZUFsbChtYXRyaXgsIHVuYmlhc2VkLCBtZWFuKSB7XG4gIGNvbnN0IHJvd3MgPSBtYXRyaXgucm93cztcbiAgY29uc3QgY29scyA9IG1hdHJpeC5jb2x1bW5zO1xuICBjb25zdCBzaXplID0gcm93cyAqIGNvbHM7XG5cbiAgbGV0IHN1bTEgPSAwO1xuICBsZXQgc3VtMiA9IDA7XG4gIGxldCB4ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7IGorKykge1xuICAgICAgeCA9IG1hdHJpeC5nZXQoaSwgaikgLSBtZWFuO1xuICAgICAgc3VtMSArPSB4O1xuICAgICAgc3VtMiArPSB4ICogeDtcbiAgICB9XG4gIH1cbiAgaWYgKHVuYmlhc2VkKSB7XG4gICAgcmV0dXJuIChzdW0yIC0gKHN1bTEgKiBzdW0xKSAvIHNpemUpIC8gKHNpemUgLSAxKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHN1bTIgLSAoc3VtMSAqIHN1bTEpIC8gc2l6ZSkgLyBzaXplO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjZW50ZXJCeVJvdyhtYXRyaXgsIG1lYW4pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgaisrKSB7XG4gICAgICBtYXRyaXguc2V0KGksIGosIG1hdHJpeC5nZXQoaSwgaikgLSBtZWFuW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNlbnRlckJ5Q29sdW1uKG1hdHJpeCwgbWVhbikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdHJpeC5yb3dzOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdHJpeC5jb2x1bW5zOyBqKyspIHtcbiAgICAgIG1hdHJpeC5zZXQoaSwgaiwgbWF0cml4LmdldChpLCBqKSAtIG1lYW5bal0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2VudGVyQWxsKG1hdHJpeCwgbWVhbikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdHJpeC5yb3dzOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdHJpeC5jb2x1bW5zOyBqKyspIHtcbiAgICAgIG1hdHJpeC5zZXQoaSwgaiwgbWF0cml4LmdldChpLCBqKSAtIG1lYW4pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGVCeVJvdyhtYXRyaXgpIHtcbiAgY29uc3Qgc2NhbGUgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgaSsrKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgaisrKSB7XG4gICAgICBzdW0gKz0gTWF0aC5wb3cobWF0cml4LmdldChpLCBqKSwgMikgLyAobWF0cml4LmNvbHVtbnMgLSAxKTtcbiAgICB9XG4gICAgc2NhbGUucHVzaChNYXRoLnNxcnQoc3VtKSk7XG4gIH1cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVCeVJvdyhtYXRyaXgsIHNjYWxlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4LnJvd3M7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0cml4LmNvbHVtbnM7IGorKykge1xuICAgICAgbWF0cml4LnNldChpLCBqLCBtYXRyaXguZ2V0KGksIGopIC8gc2NhbGVbaV0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGVCeUNvbHVtbihtYXRyaXgpIHtcbiAgY29uc3Qgc2NhbGUgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgaisrKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgaSsrKSB7XG4gICAgICBzdW0gKz0gTWF0aC5wb3cobWF0cml4LmdldChpLCBqKSwgMikgLyAobWF0cml4LnJvd3MgLSAxKTtcbiAgICB9XG4gICAgc2NhbGUucHVzaChNYXRoLnNxcnQoc3VtKSk7XG4gIH1cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVCeUNvbHVtbihtYXRyaXgsIHNjYWxlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4LnJvd3M7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0cml4LmNvbHVtbnM7IGorKykge1xuICAgICAgbWF0cml4LnNldChpLCBqLCBtYXRyaXguZ2V0KGksIGopIC8gc2NhbGVbal0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGVBbGwobWF0cml4KSB7XG4gIGNvbnN0IGRpdmlkZXIgPSBtYXRyaXguc2l6ZSAtIDE7XG4gIGxldCBzdW0gPSAwO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdHJpeC5jb2x1bW5zOyBqKyspIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdHJpeC5yb3dzOyBpKyspIHtcbiAgICAgIHN1bSArPSBNYXRoLnBvdyhtYXRyaXguZ2V0KGksIGopLCAyKSAvIGRpdmlkZXI7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLnNxcnQoc3VtKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQWxsKG1hdHJpeCwgc2NhbGUpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgaisrKSB7XG4gICAgICBtYXRyaXguc2V0KGksIGosIG1hdHJpeC5nZXQoaSwgaikgLyBzY2FsZSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiBDaGVjayB0aGF0IGEgcm93IGluZGV4IGlzIG5vdCBvdXQgb2YgYm91bmRzXG4gKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW291dGVyXVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSb3dJbmRleChtYXRyaXgsIGluZGV4LCBvdXRlcikge1xuICBsZXQgbWF4ID0gb3V0ZXIgPyBtYXRyaXgucm93cyA6IG1hdHJpeC5yb3dzIC0gMTtcbiAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IG1heCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdSb3cgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ2hlY2sgdGhhdCBhIGNvbHVtbiBpbmRleCBpcyBub3Qgb3V0IG9mIGJvdW5kc1xuICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdXRlcl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrQ29sdW1uSW5kZXgobWF0cml4LCBpbmRleCwgb3V0ZXIpIHtcbiAgbGV0IG1heCA9IG91dGVyID8gbWF0cml4LmNvbHVtbnMgOiBtYXRyaXguY29sdW1ucyAtIDE7XG4gIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ29sdW1uIGluZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENoZWNrIHRoYXQgdGhlIHByb3ZpZGVkIHZlY3RvciBpcyBhbiBhcnJheSB3aXRoIHRoZSByaWdodCBsZW5ndGhcbiAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXhcbiAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3JcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUm93VmVjdG9yKG1hdHJpeCwgdmVjdG9yKSB7XG4gIGlmICh2ZWN0b3IudG8xREFycmF5KSB7XG4gICAgdmVjdG9yID0gdmVjdG9yLnRvMURBcnJheSgpO1xuICB9XG4gIGlmICh2ZWN0b3IubGVuZ3RoICE9PSBtYXRyaXguY29sdW1ucykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgJ3ZlY3RvciBzaXplIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIG51bWJlciBvZiBjb2x1bW5zJyxcbiAgICApO1xuICB9XG4gIHJldHVybiB2ZWN0b3I7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENoZWNrIHRoYXQgdGhlIHByb3ZpZGVkIHZlY3RvciBpcyBhbiBhcnJheSB3aXRoIHRoZSByaWdodCBsZW5ndGhcbiAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXhcbiAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3JcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrQ29sdW1uVmVjdG9yKG1hdHJpeCwgdmVjdG9yKSB7XG4gIGlmICh2ZWN0b3IudG8xREFycmF5KSB7XG4gICAgdmVjdG9yID0gdmVjdG9yLnRvMURBcnJheSgpO1xuICB9XG4gIGlmICh2ZWN0b3IubGVuZ3RoICE9PSBtYXRyaXgucm93cykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd2ZWN0b3Igc2l6ZSBtdXN0IGJlIHRoZSBzYW1lIGFzIHRoZSBudW1iZXIgb2Ygcm93cycpO1xuICB9XG4gIHJldHVybiB2ZWN0b3I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0luZGljZXMobWF0cml4LCByb3dJbmRpY2VzLCBjb2x1bW5JbmRpY2VzKSB7XG4gIHJldHVybiB7XG4gICAgcm93OiBjaGVja1Jvd0luZGljZXMobWF0cml4LCByb3dJbmRpY2VzKSxcbiAgICBjb2x1bW46IGNoZWNrQ29sdW1uSW5kaWNlcyhtYXRyaXgsIGNvbHVtbkluZGljZXMpLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSb3dJbmRpY2VzKG1hdHJpeCwgcm93SW5kaWNlcykge1xuICBpZiAodHlwZW9mIHJvd0luZGljZXMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCB0eXBlIGZvciByb3cgaW5kaWNlcycpO1xuICB9XG5cbiAgbGV0IHJvd091dCA9IHJvd0luZGljZXMuc29tZSgocikgPT4ge1xuICAgIHJldHVybiByIDwgMCB8fCByID49IG1hdHJpeC5yb3dzO1xuICB9KTtcblxuICBpZiAocm93T3V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3JvdyBpbmRpY2VzIGFyZSBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShyb3dJbmRpY2VzKSkgcm93SW5kaWNlcyA9IEFycmF5LmZyb20ocm93SW5kaWNlcyk7XG5cbiAgcmV0dXJuIHJvd0luZGljZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0NvbHVtbkluZGljZXMobWF0cml4LCBjb2x1bW5JbmRpY2VzKSB7XG4gIGlmICh0eXBlb2YgY29sdW1uSW5kaWNlcyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmV4cGVjdGVkIHR5cGUgZm9yIGNvbHVtbiBpbmRpY2VzJyk7XG4gIH1cblxuICBsZXQgY29sdW1uT3V0ID0gY29sdW1uSW5kaWNlcy5zb21lKChjKSA9PiB7XG4gICAgcmV0dXJuIGMgPCAwIHx8IGMgPj0gbWF0cml4LmNvbHVtbnM7XG4gIH0pO1xuXG4gIGlmIChjb2x1bW5PdXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignY29sdW1uIGluZGljZXMgYXJlIG91dCBvZiByYW5nZScpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShjb2x1bW5JbmRpY2VzKSkgY29sdW1uSW5kaWNlcyA9IEFycmF5LmZyb20oY29sdW1uSW5kaWNlcyk7XG5cbiAgcmV0dXJuIGNvbHVtbkluZGljZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1JhbmdlKG1hdHJpeCwgc3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gNSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdleHBlY3RlZCA0IGFyZ3VtZW50cycpO1xuICB9XG4gIGNoZWNrTnVtYmVyKCdzdGFydFJvdycsIHN0YXJ0Um93KTtcbiAgY2hlY2tOdW1iZXIoJ2VuZFJvdycsIGVuZFJvdyk7XG4gIGNoZWNrTnVtYmVyKCdzdGFydENvbHVtbicsIHN0YXJ0Q29sdW1uKTtcbiAgY2hlY2tOdW1iZXIoJ2VuZENvbHVtbicsIGVuZENvbHVtbik7XG4gIGlmIChcbiAgICBzdGFydFJvdyA+IGVuZFJvdyB8fFxuICAgIHN0YXJ0Q29sdW1uID4gZW5kQ29sdW1uIHx8XG4gICAgc3RhcnRSb3cgPCAwIHx8XG4gICAgc3RhcnRSb3cgPj0gbWF0cml4LnJvd3MgfHxcbiAgICBlbmRSb3cgPCAwIHx8XG4gICAgZW5kUm93ID49IG1hdHJpeC5yb3dzIHx8XG4gICAgc3RhcnRDb2x1bW4gPCAwIHx8XG4gICAgc3RhcnRDb2x1bW4gPj0gbWF0cml4LmNvbHVtbnMgfHxcbiAgICBlbmRDb2x1bW4gPCAwIHx8XG4gICAgZW5kQ29sdW1uID49IG1hdHJpeC5jb2x1bW5zXG4gICkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdTdWJtYXRyaXggaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlJyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld0FycmF5KGxlbmd0aCwgdmFsdWUgPSAwKSB7XG4gIGxldCBhcnJheSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBjaGVja051bWJlcihuYW1lLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBhIG51bWJlcmApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBBYnN0cmFjdE1hdHJpeCB9IGZyb20gJy4uL21hdHJpeCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VWaWV3IGV4dGVuZHMgQWJzdHJhY3RNYXRyaXgge1xuICBjb25zdHJ1Y3RvcihtYXRyaXgsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWF0cml4ID0gbWF0cml4O1xuICAgIHRoaXMucm93cyA9IHJvd3M7XG4gICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucztcbiAgfVxufVxuIiwiaW1wb3J0IHsgY2hlY2tDb2x1bW5JbmRleCB9IGZyb20gJy4uL3V0aWwnO1xuXG5pbXBvcnQgQmFzZVZpZXcgZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0cml4Q29sdW1uVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcbiAgY29uc3RydWN0b3IobWF0cml4LCBjb2x1bW4pIHtcbiAgICBjaGVja0NvbHVtbkluZGV4KG1hdHJpeCwgY29sdW1uKTtcbiAgICBzdXBlcihtYXRyaXgsIG1hdHJpeC5yb3dzLCAxKTtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgfVxuXG4gIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXRyaXguc2V0KHJvd0luZGV4LCB0aGlzLmNvbHVtbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KHJvd0luZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0cml4LmdldChyb3dJbmRleCwgdGhpcy5jb2x1bW4pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjaGVja0NvbHVtbkluZGljZXMgfSBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IEJhc2VWaWV3IGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdHJpeENvbHVtblNlbGVjdGlvblZpZXcgZXh0ZW5kcyBCYXNlVmlldyB7XG4gIGNvbnN0cnVjdG9yKG1hdHJpeCwgY29sdW1uSW5kaWNlcykge1xuICAgIGNvbHVtbkluZGljZXMgPSBjaGVja0NvbHVtbkluZGljZXMobWF0cml4LCBjb2x1bW5JbmRpY2VzKTtcbiAgICBzdXBlcihtYXRyaXgsIG1hdHJpeC5yb3dzLCBjb2x1bW5JbmRpY2VzLmxlbmd0aCk7XG4gICAgdGhpcy5jb2x1bW5JbmRpY2VzID0gY29sdW1uSW5kaWNlcztcbiAgfVxuXG4gIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXRyaXguc2V0KHJvd0luZGV4LCB0aGlzLmNvbHVtbkluZGljZXNbY29sdW1uSW5kZXhdLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0cml4LmdldChyb3dJbmRleCwgdGhpcy5jb2x1bW5JbmRpY2VzW2NvbHVtbkluZGV4XSk7XG4gIH1cbn1cbiIsImltcG9ydCBCYXNlVmlldyBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRyaXhGbGlwQ29sdW1uVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcbiAgY29uc3RydWN0b3IobWF0cml4KSB7XG4gICAgc3VwZXIobWF0cml4LCBtYXRyaXgucm93cywgbWF0cml4LmNvbHVtbnMpO1xuICB9XG5cbiAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcbiAgICB0aGlzLm1hdHJpeC5zZXQocm93SW5kZXgsIHRoaXMuY29sdW1ucyAtIGNvbHVtbkluZGV4IC0gMSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1hdHJpeC5nZXQocm93SW5kZXgsIHRoaXMuY29sdW1ucyAtIGNvbHVtbkluZGV4IC0gMSk7XG4gIH1cbn1cbiIsImltcG9ydCBCYXNlVmlldyBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRyaXhGbGlwUm93VmlldyBleHRlbmRzIEJhc2VWaWV3IHtcbiAgY29uc3RydWN0b3IobWF0cml4KSB7XG4gICAgc3VwZXIobWF0cml4LCBtYXRyaXgucm93cywgbWF0cml4LmNvbHVtbnMpO1xuICB9XG5cbiAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcbiAgICB0aGlzLm1hdHJpeC5zZXQodGhpcy5yb3dzIC0gcm93SW5kZXggLSAxLCBjb2x1bW5JbmRleCwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1hdHJpeC5nZXQodGhpcy5yb3dzIC0gcm93SW5kZXggLSAxLCBjb2x1bW5JbmRleCk7XG4gIH1cbn1cbiIsImV4cG9ydCB7IGRlZmF1bHQgYXMgTWF0cml4Q29sdW1uVmlldyB9IGZyb20gJy4vY29sdW1uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWF0cml4Q29sdW1uU2VsZWN0aW9uVmlldyB9IGZyb20gJy4vY29sdW1uU2VsZWN0aW9uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWF0cml4RmxpcENvbHVtblZpZXcgfSBmcm9tICcuL2ZsaXBDb2x1bW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXRyaXhGbGlwUm93VmlldyB9IGZyb20gJy4vZmxpcFJvdyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hdHJpeFJvd1ZpZXcgfSBmcm9tICcuL3Jvdyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hdHJpeFJvd1NlbGVjdGlvblZpZXcgfSBmcm9tICcuL3Jvd1NlbGVjdGlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hdHJpeFNlbGVjdGlvblZpZXcgfSBmcm9tICcuL3NlbGVjdGlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hdHJpeFN1YlZpZXcgfSBmcm9tICcuL3N1Yic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hdHJpeFRyYW5zcG9zZVZpZXcgfSBmcm9tICcuL3RyYW5zcG9zZSc7XG4iLCJpbXBvcnQgeyBjaGVja1Jvd0luZGV4IH0gZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCBCYXNlVmlldyBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRyaXhSb3dWaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xuICBjb25zdHJ1Y3RvcihtYXRyaXgsIHJvdykge1xuICAgIGNoZWNrUm93SW5kZXgobWF0cml4LCByb3cpO1xuICAgIHN1cGVyKG1hdHJpeCwgMSwgbWF0cml4LmNvbHVtbnMpO1xuICAgIHRoaXMucm93ID0gcm93O1xuICB9XG5cbiAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcbiAgICB0aGlzLm1hdHJpeC5zZXQodGhpcy5yb3csIGNvbHVtbkluZGV4LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0cml4LmdldCh0aGlzLnJvdywgY29sdW1uSW5kZXgpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjaGVja1Jvd0luZGljZXMgfSBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IEJhc2VWaWV3IGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdHJpeFJvd1NlbGVjdGlvblZpZXcgZXh0ZW5kcyBCYXNlVmlldyB7XG4gIGNvbnN0cnVjdG9yKG1hdHJpeCwgcm93SW5kaWNlcykge1xuICAgIHJvd0luZGljZXMgPSBjaGVja1Jvd0luZGljZXMobWF0cml4LCByb3dJbmRpY2VzKTtcbiAgICBzdXBlcihtYXRyaXgsIHJvd0luZGljZXMubGVuZ3RoLCBtYXRyaXguY29sdW1ucyk7XG4gICAgdGhpcy5yb3dJbmRpY2VzID0gcm93SW5kaWNlcztcbiAgfVxuXG4gIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXRyaXguc2V0KHRoaXMucm93SW5kaWNlc1tyb3dJbmRleF0sIGNvbHVtbkluZGV4LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0cml4LmdldCh0aGlzLnJvd0luZGljZXNbcm93SW5kZXhdLCBjb2x1bW5JbmRleCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGNoZWNrSW5kaWNlcyB9IGZyb20gJy4uL3V0aWwnO1xuXG5pbXBvcnQgQmFzZVZpZXcgZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0cml4U2VsZWN0aW9uVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcbiAgY29uc3RydWN0b3IobWF0cml4LCByb3dJbmRpY2VzLCBjb2x1bW5JbmRpY2VzKSB7XG4gICAgbGV0IGluZGljZXMgPSBjaGVja0luZGljZXMobWF0cml4LCByb3dJbmRpY2VzLCBjb2x1bW5JbmRpY2VzKTtcbiAgICBzdXBlcihtYXRyaXgsIGluZGljZXMucm93Lmxlbmd0aCwgaW5kaWNlcy5jb2x1bW4ubGVuZ3RoKTtcbiAgICB0aGlzLnJvd0luZGljZXMgPSBpbmRpY2VzLnJvdztcbiAgICB0aGlzLmNvbHVtbkluZGljZXMgPSBpbmRpY2VzLmNvbHVtbjtcbiAgfVxuXG4gIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXRyaXguc2V0KFxuICAgICAgdGhpcy5yb3dJbmRpY2VzW3Jvd0luZGV4XSxcbiAgICAgIHRoaXMuY29sdW1uSW5kaWNlc1tjb2x1bW5JbmRleF0sXG4gICAgICB2YWx1ZSxcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1hdHJpeC5nZXQoXG4gICAgICB0aGlzLnJvd0luZGljZXNbcm93SW5kZXhdLFxuICAgICAgdGhpcy5jb2x1bW5JbmRpY2VzW2NvbHVtbkluZGV4XSxcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjaGVja1JhbmdlIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCBCYXNlVmlldyBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRyaXhTdWJWaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xuICBjb25zdHJ1Y3RvcihtYXRyaXgsIHN0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pIHtcbiAgICBjaGVja1JhbmdlKG1hdHJpeCwgc3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbik7XG4gICAgc3VwZXIobWF0cml4LCBlbmRSb3cgLSBzdGFydFJvdyArIDEsIGVuZENvbHVtbiAtIHN0YXJ0Q29sdW1uICsgMSk7XG4gICAgdGhpcy5zdGFydFJvdyA9IHN0YXJ0Um93O1xuICAgIHRoaXMuc3RhcnRDb2x1bW4gPSBzdGFydENvbHVtbjtcbiAgfVxuXG4gIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXRyaXguc2V0KFxuICAgICAgdGhpcy5zdGFydFJvdyArIHJvd0luZGV4LFxuICAgICAgdGhpcy5zdGFydENvbHVtbiArIGNvbHVtbkluZGV4LFxuICAgICAgdmFsdWUsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRyaXguZ2V0KFxuICAgICAgdGhpcy5zdGFydFJvdyArIHJvd0luZGV4LFxuICAgICAgdGhpcy5zdGFydENvbHVtbiArIGNvbHVtbkluZGV4LFxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCBCYXNlVmlldyBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRyaXhUcmFuc3Bvc2VWaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xuICBjb25zdHJ1Y3RvcihtYXRyaXgpIHtcbiAgICBzdXBlcihtYXRyaXgsIG1hdHJpeC5jb2x1bW5zLCBtYXRyaXgucm93cyk7XG4gIH1cblxuICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuICAgIHRoaXMubWF0cml4LnNldChjb2x1bW5JbmRleCwgcm93SW5kZXgsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRyaXguZ2V0KGNvbHVtbkluZGV4LCByb3dJbmRleCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEFic3RyYWN0TWF0cml4IH0gZnJvbSAnLi4vbWF0cml4JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV3JhcHBlck1hdHJpeDFEIGV4dGVuZHMgQWJzdHJhY3RNYXRyaXgge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHJvd3MgPSAxIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKGRhdGEubGVuZ3RoICUgcm93cyAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgZGF0YSBsZW5ndGggaXMgbm90IGRpdmlzaWJsZSBieSB0aGUgbnVtYmVyIG9mIHJvd3MnKTtcbiAgICB9XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgIHRoaXMuY29sdW1ucyA9IGRhdGEubGVuZ3RoIC8gcm93cztcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcbiAgICBsZXQgaW5kZXggPSB0aGlzLl9jYWxjdWxhdGVJbmRleChyb3dJbmRleCwgY29sdW1uSW5kZXgpO1xuICAgIHRoaXMuZGF0YVtpbmRleF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcbiAgICBsZXQgaW5kZXggPSB0aGlzLl9jYWxjdWxhdGVJbmRleChyb3dJbmRleCwgY29sdW1uSW5kZXgpO1xuICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXhdO1xuICB9XG5cbiAgX2NhbGN1bGF0ZUluZGV4KHJvdywgY29sdW1uKSB7XG4gICAgcmV0dXJuIHJvdyAqIHRoaXMuY29sdW1ucyArIGNvbHVtbjtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQWJzdHJhY3RNYXRyaXggfSBmcm9tICcuLi9tYXRyaXgnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXcmFwcGVyTWF0cml4MkQgZXh0ZW5kcyBBYnN0cmFjdE1hdHJpeCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5yb3dzID0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5jb2x1bW5zID0gZGF0YVswXS5sZW5ndGg7XG4gIH1cblxuICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuICAgIHRoaXMuZGF0YVtyb3dJbmRleF1bY29sdW1uSW5kZXhdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtyb3dJbmRleF1bY29sdW1uSW5kZXhdO1xuICB9XG59XG4iLCJpbXBvcnQgV3JhcHBlck1hdHJpeDFEIGZyb20gJy4vV3JhcHBlck1hdHJpeDFEJztcbmltcG9ydCBXcmFwcGVyTWF0cml4MkQgZnJvbSAnLi9XcmFwcGVyTWF0cml4MkQnO1xuXG5leHBvcnQgZnVuY3Rpb24gd3JhcChhcnJheSwgb3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICBpZiAoYXJyYXlbMF0gJiYgQXJyYXkuaXNBcnJheShhcnJheVswXSkpIHtcbiAgICAgIHJldHVybiBuZXcgV3JhcHBlck1hdHJpeDJEKGFycmF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBXcmFwcGVyTWF0cml4MUQoYXJyYXksIG9wdGlvbnMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBhcmd1bWVudCBpcyBub3QgYW4gYXJyYXknKTtcbiAgfVxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlueVF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gW10sIGNvbXBhcmUgPSBkZWZhdWx0Q29tcGFyZSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG5cbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9ICh0aGlzLmxlbmd0aCA+PiAxKSAtIDE7IGkgPj0gMDsgaS0tKSB0aGlzLl9kb3duKGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVzaChpdGVtKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKGl0ZW0pO1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICB0aGlzLl91cCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIHBvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMuZGF0YVswXTtcbiAgICAgICAgY29uc3QgYm90dG9tID0gdGhpcy5kYXRhLnBvcCgpO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVswXSA9IGJvdHRvbTtcbiAgICAgICAgICAgIHRoaXMuX2Rvd24oMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9wO1xuICAgIH1cblxuICAgIHBlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbMF07XG4gICAgfVxuXG4gICAgX3VwKHBvcykge1xuICAgICAgICBjb25zdCB7ZGF0YSwgY29tcGFyZX0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpdGVtID0gZGF0YVtwb3NdO1xuXG4gICAgICAgIHdoaWxlIChwb3MgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSAocG9zIC0gMSkgPj4gMTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBkYXRhW3BhcmVudF07XG4gICAgICAgICAgICBpZiAoY29tcGFyZShpdGVtLCBjdXJyZW50KSA+PSAwKSBicmVhaztcbiAgICAgICAgICAgIGRhdGFbcG9zXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBwb3MgPSBwYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW3Bvc10gPSBpdGVtO1xuICAgIH1cblxuICAgIF9kb3duKHBvcykge1xuICAgICAgICBjb25zdCB7ZGF0YSwgY29tcGFyZX0gPSB0aGlzO1xuICAgICAgICBjb25zdCBoYWxmTGVuZ3RoID0gdGhpcy5sZW5ndGggPj4gMTtcbiAgICAgICAgY29uc3QgaXRlbSA9IGRhdGFbcG9zXTtcblxuICAgICAgICB3aGlsZSAocG9zIDwgaGFsZkxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGxlZnQgPSAocG9zIDw8IDEpICsgMTtcbiAgICAgICAgICAgIGxldCBiZXN0ID0gZGF0YVtsZWZ0XTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCArIDE7XG5cbiAgICAgICAgICAgIGlmIChyaWdodCA8IHRoaXMubGVuZ3RoICYmIGNvbXBhcmUoZGF0YVtyaWdodF0sIGJlc3QpIDwgMCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgICAgICAgICAgICBiZXN0ID0gZGF0YVtyaWdodF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGFyZShiZXN0LCBpdGVtKSA+PSAwKSBicmVhaztcblxuICAgICAgICAgICAgZGF0YVtwb3NdID0gYmVzdDtcbiAgICAgICAgICAgIHBvcyA9IGxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW3Bvc10gPSBpdGVtO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbn1cbiIsImNvbnN0IFdvcmtlciA9IHJlcXVpcmUoXCIuL2NvbXBpbGVyLndvcmtlci5qc1wiKTtcbmNvbnN0IHtidWlsZEltYWdlTGlzdH0gPSByZXF1aXJlKCcuL2ltYWdlLXRhcmdldC9pbWFnZS1saXN0LmpzJyk7XG5jb25zdCBtc2dwYWNrID0gcmVxdWlyZSgnQG1zZ3BhY2svbXNncGFjaycpO1xuLy8gVE9ETzogYmV0dGVyIGNvbXByZXNzaW9uIG1ldGhvZC4gbm93IGdyZXkgaW1hZ2Ugc2F2ZWQgaW4gcGl4ZWxzLCB3aGljaCBjb3VsZCBiZSBsYXJnZXJlIHRoYW4gb3JpZ2luYWwgaW1hZ2VcblxuY2xhc3MgQ29tcGlsZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICB9XG5cbiAgLy8gaW5wdXQgaHRtbCBJbWFnZXNcbiAgY29tcGlsZUltYWdlVGFyZ2V0cyhpbWFnZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0SW1hZ2VzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbWcgPSBpbWFnZXNbaV07XG4gICAgICAgIGNvbnN0IHByb2Nlc3NDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgcHJvY2Vzc0NhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgcHJvY2Vzc0NhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgICAgICBjb25zdCBwcm9jZXNzQ29udGV4dCA9IHByb2Nlc3NDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgcHJvY2Vzc0NvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc0RhdGEgPSBwcm9jZXNzQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KTtcblxuICAgICAgICBjb25zdCBncmV5SW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW1nLndpZHRoICogaW1nLmhlaWdodCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmV5SW1hZ2VEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDQ7XG4gICAgICAgICAgZ3JleUltYWdlRGF0YVtpXSA9IE1hdGguZmxvb3IoKHByb2Nlc3NEYXRhLmRhdGFbb2Zmc2V0XSArIHByb2Nlc3NEYXRhLmRhdGFbb2Zmc2V0KzFdICsgcHJvY2Vzc0RhdGEuZGF0YVtvZmZzZXQrMl0pLzMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldEltYWdlID0ge2RhdGE6IGdyZXlJbWFnZURhdGEsIGhlaWdodDogaW1nLmhlaWdodCwgd2lkdGg6IGltZy53aWR0aH07XG4gICAgICAgIHRhcmdldEltYWdlcy5wdXNoKHRhcmdldEltYWdlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcigpO1xuICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHtsaXN0fSA9IGUuZGF0YTtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHtcbiAgICAgICAgICAgIHRhcmdldEltYWdlOiBsaXN0W2ldLnRhcmdldEltYWdlLFxuICAgICAgICAgICAgaW1hZ2VMaXN0OiBsaXN0W2ldLmltYWdlTGlzdCxcbiAgICAgICAgICAgIHRyYWNraW5nRGF0YTogbGlzdFtpXS50cmFja2luZ0RhdGEsXG4gICAgICAgICAgICBtYXRjaGluZ0RhdGE6IGxpc3RbaV0ubWF0Y2hpbmdEYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSh0aGlzLmRhdGEpO1xuICAgICAgfTtcbiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTogJ2NvbXBpbGUnLCB0YXJnZXRJbWFnZXN9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIG5vdCBleHBvcnRpbmcgaW1hZ2VMaXN0IGJlY2F1c2UgdG9vIGxhcmdlLiByZWJ1aWxkIHRoaXMgdXNpbmcgdGFyZ2V0SW1hZ2VcbiAgZXhwb3J0RGF0YSgpIHtcbiAgICBjb25zdCBkYXRhTGlzdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhTGlzdC5wdXNoKHtcbiAgICAgICAgdGFyZ2V0SW1hZ2U6IHRoaXMuZGF0YVtpXS50YXJnZXRJbWFnZSxcbiAgICAgICAgdHJhY2tpbmdEYXRhOiB0aGlzLmRhdGFbaV0udHJhY2tpbmdEYXRhLFxuICAgICAgICBtYXRjaGluZ0RhdGE6IHRoaXMuZGF0YVtpXS5tYXRjaGluZ0RhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBtc2dwYWNrLmVuY29kZShkYXRhTGlzdCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG4gIGltcG9ydERhdGEoYnVmZmVyKSB7XG4gICAgY29uc3QgZGF0YUxpc3QgPSBtc2dwYWNrLmRlY29kZShuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbWFnZUxpc3QgPSBidWlsZEltYWdlTGlzdChkYXRhTGlzdFtpXS50YXJnZXRJbWFnZSk7XG4gICAgICB0aGlzLmRhdGEucHVzaCh7XG4gICAgICAgIGltYWdlTGlzdDogaW1hZ2VMaXN0LFxuICAgICAgICB0YXJnZXRJbWFnZTogZGF0YUxpc3RbaV0udGFyZ2V0SW1hZ2UsXG4gICAgICAgIHRyYWNraW5nRGF0YTogZGF0YUxpc3RbaV0udHJhY2tpbmdEYXRhLFxuICAgICAgICBtYXRjaGluZ0RhdGE6IGRhdGFMaXN0W2ldLm1hdGNoaW5nRGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENvbXBpbGVyXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFdvcmtlcihfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwid29ya2VyLmpzXCIpO1xufTsiLCJjb25zdCB7SW1hZ2VUYXJnZXR9ID0gcmVxdWlyZSgnLi9pbWFnZS10YXJnZXQvaW5kZXguanMnKTtcbmNvbnN0IHtEZXRlY3Rvcn0gPSByZXF1aXJlKCcuL2ltYWdlLXRhcmdldC9kZXRlY3RvckdQVS9kZXRlY3Rvci5qcycpO1xuLy9jb25zdCB7RGV0ZWN0b3J9ID0gcmVxdWlyZSgnLi9pbWFnZS10YXJnZXQvZGV0ZWN0b3JDUFUvZGV0ZWN0b3IuanMnKTtcbmNvbnN0IHtDb21waWxlcn0gPSByZXF1aXJlKCcuL2NvbXBpbGVyLmpzJyk7XG5cbmNsYXNzIENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihpbnB1dFdpZHRoLCBpbnB1dEhlaWdodCkge1xuICAgIHRoaXMuaW5wdXRXaWR0aCA9IGlucHV0V2lkdGg7XG4gICAgdGhpcy5pbnB1dEhlaWdodCA9IGlucHV0SGVpZ2h0O1xuICAgIHRoaXMuZGV0ZWN0b3IgPSBuZXcgRGV0ZWN0b3IodGhpcy5pbnB1dFdpZHRoLCB0aGlzLmlucHV0SGVpZ2h0KTtcbiAgICB0aGlzLmltYWdlVGFyZ2V0cyA9IFtdO1xuICAgIHRoaXMudHJhY2tpbmdJbmRleCA9IC0xO1xuXG4gICAgY29uc3QgbmVhciA9IDEwO1xuICAgIGNvbnN0IGZhciA9IDEwMDAwO1xuICAgIGNvbnN0IGZvdnkgPSA0NS4wICogTWF0aC5QSSAvIDE4MDsgLy8gNDUgaW4gcmFkaWFuLiBmaWVsZCBvZiB2aWV3IHZlcnRpY2FsXG4gICAgY29uc3QgZiA9ICh0aGlzLmlucHV0SGVpZ2h0LzIpIC8gTWF0aC50YW4oZm92eS8yKTtcbiAgICAvLyAgICAgW2Z4ICBzIGN4XVxuICAgIC8vIEsgPSBbIDAgZnggY3ldXG4gICAgLy8gICAgIFsgMCAgMCAgMV1cbiAgICB0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm0gPSBbXG4gICAgICBbZiwgMCwgdGhpcy5pbnB1dFdpZHRoIC8gMl0sXG4gICAgICBbMCwgZiwgdGhpcy5pbnB1dEhlaWdodCAvIDJdLFxuICAgICAgWzAsIDAsIDFdXG4gICAgXTtcblxuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IF9nbFByb2plY3Rpb25NYXRyaXgoe1xuICAgICAgcHJvamVjdGlvblRyYW5zZm9ybTogdGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtLFxuICAgICAgLy93aWR0aDogdGhpcy5pbnB1dFdpZHRoIC0gMSwgLy8gLTEgaXMgbm90IG5lY2Vzc2FyeT9cbiAgICAgIC8vaGVpZ2h0OiB0aGlzLmlucHV0SGVpZ2h0IC0gMSxcbiAgICAgIHdpZHRoOiB0aGlzLmlucHV0V2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaW5wdXRIZWlnaHQsXG4gICAgICBuZWFyOiBuZWFyLFxuICAgICAgZmFyOiBmYXIsXG4gICAgfSk7XG4gIH1cblxuICBnZXRQcm9qZWN0aW9uTWF0cml4KCkge1xuICAgIHJldHVybiB0aGlzLnByb2plY3Rpb25NYXRyaXg7XG4gIH1cblxuICBhZGRJbWFnZVRhcmdldHMoZmlsZVVSTCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjb21waWxlciA9IG5ldyBDb21waWxlcigpO1xuICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IGZldGNoKGZpbGVVUkwpO1xuICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgY29udGVudC5hcnJheUJ1ZmZlcigpO1xuICAgICAgY29uc3QgZGF0YUxpc3QgPSBjb21waWxlci5pbXBvcnREYXRhKGJ1ZmZlcik7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW1hZ2VUYXJnZXQgPSBuZXcgSW1hZ2VUYXJnZXQoe1xuICAgICAgICAgIHByb2plY3Rpb25UcmFuc2Zvcm06IHRoaXMucHJvamVjdGlvblRyYW5zZm9ybSxcbiAgICAgICAgICBpbWFnZUxpc3Q6IGRhdGFMaXN0W2ldLmltYWdlTGlzdCxcbiAgICAgICAgICB0YXJnZXRJbWFnZTogZGF0YUxpc3RbaV0udGFyZ2V0SW1hZ2UsXG4gICAgICAgICAgbWF0Y2hpbmdEYXRhOiBkYXRhTGlzdFtpXS5tYXRjaGluZ0RhdGEsXG4gICAgICAgICAgdHJhY2tpbmdEYXRhOiBkYXRhTGlzdFtpXS50cmFja2luZ0RhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICBpbWFnZVRhcmdldC5zZXR1cFF1ZXJ5KHRoaXMuaW5wdXRXaWR0aCwgdGhpcy5pbnB1dEhlaWdodCk7XG4gICAgICAgIHRoaXMuaW1hZ2VUYXJnZXRzLnB1c2goaW1hZ2VUYXJnZXQpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHdhcm0gdXAgZ3B1IC0gYnVpbGQga2VybmVscyBpcyBzbG93XG4gIGR1bW15UnVuKGlucHV0KSB7XG4gICAgdGhpcy5kZXRlY3Rvci5kZXRlY3QoaW5wdXQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbWFnZVRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuaW1hZ2VUYXJnZXRzW2ldLmR1bW15UnVuKGlucHV0KTtcbiAgICB9XG4gIH1cblxuICBnZXRJbWFnZVRhcmdldERpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbWFnZVRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRhcmdldEltYWdlID0gdGhpcy5pbWFnZVRhcmdldHNbaV0udGFyZ2V0SW1hZ2U7XG4gICAgICBkaW1lbnNpb25zLnB1c2goW3RhcmdldEltYWdlLndpZHRoLCB0YXJnZXRJbWFnZS5oZWlnaHRdKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpbWVuc2lvbnM7XG4gIH1cblxuICAvLyBpbnB1dCBpcyBlaXRoZXIgSFRNTCB2aWRlbyBvciBIVE1MIGltYWdlXG4gIHByb2Nlc3MoaW5wdXQpIHtcbiAgICBsb2dUaW1lKFwiZW5naW5lIHByb2Nlc3NcIik7XG5cbiAgICBpZiAodGhpcy50cmFja2luZ0luZGV4ID09PSAtMSkge1xuICAgICAgbGV0IGZlYXR1cmVQb2ludHMgPSB0aGlzLmRldGVjdG9yLmRldGVjdChpbnB1dCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW1hZ2VUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGltYWdlVGFyZ2V0ID0gdGhpcy5pbWFnZVRhcmdldHNbaV07XG4gICAgICAgIGltYWdlVGFyZ2V0Lm1hdGNoKGZlYXR1cmVQb2ludHMpO1xuICAgICAgICBpZiAoaW1hZ2VUYXJnZXQuaXNUcmFja2luZykge1xuICAgICAgICAgIHRoaXMudHJhY2tpbmdJbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW1hZ2VUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbWFnZVRhcmdldCA9IHRoaXMuaW1hZ2VUYXJnZXRzW2ldO1xuICAgICAgbGV0IHdvcmxkTWF0cml4ID0gbnVsbDtcbiAgICAgIGlmIChpbWFnZVRhcmdldC5pc1RyYWNraW5nKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsVmlld1RyYW5zZm9ybSA9IGltYWdlVGFyZ2V0LnRyYWNrKGlucHV0KTtcbiAgICAgICAgd29ybGRNYXRyaXggPSBtb2RlbFZpZXdUcmFuc2Zvcm0gPT09IG51bGw/IG51bGw6IF9nbE1vZGVsVmlld01hdHJpeCh7bW9kZWxWaWV3VHJhbnNmb3JtfSk7XG4gICAgICAgIGlmICh3b3JsZE1hdHJpeCA9PT0gbnVsbCkgdGhpcy50cmFja2luZ0luZGV4ID0gLTE7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIHdvcmxkTWF0cml4OiB3b3JsZE1hdHJpeFxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbi8vIGJ1aWxkIG9wZW5HTCBtb2RlbFZpZXcgbWF0cml4XG5jb25zdCBfZ2xNb2RlbFZpZXdNYXRyaXggPSAoe21vZGVsVmlld1RyYW5zZm9ybX0pID0+IHtcbiAgY29uc3Qgb3BlbkdMV29ybGRNYXRyaXggPSBbXG4gICAgbW9kZWxWaWV3VHJhbnNmb3JtWzBdWzBdLCAtbW9kZWxWaWV3VHJhbnNmb3JtWzFdWzBdLCAtbW9kZWxWaWV3VHJhbnNmb3JtWzJdWzBdLCAwLFxuICAgIG1vZGVsVmlld1RyYW5zZm9ybVswXVsxXSwgLW1vZGVsVmlld1RyYW5zZm9ybVsxXVsxXSwgLW1vZGVsVmlld1RyYW5zZm9ybVsyXVsxXSwgMCxcbiAgICBtb2RlbFZpZXdUcmFuc2Zvcm1bMF1bMl0sIC1tb2RlbFZpZXdUcmFuc2Zvcm1bMV1bMl0sIC1tb2RlbFZpZXdUcmFuc2Zvcm1bMl1bMl0sIDAsXG4gICAgbW9kZWxWaWV3VHJhbnNmb3JtWzBdWzNdLCAtbW9kZWxWaWV3VHJhbnNmb3JtWzFdWzNdLCAtbW9kZWxWaWV3VHJhbnNmb3JtWzJdWzNdLCAxXG4gIF07XG4gIHJldHVybiBvcGVuR0xXb3JsZE1hdHJpeDtcbn1cblxuLy8gYnVpbGQgb3BlbkdMIHByb2plY3Rpb24gbWF0cml4XG5jb25zdCBfZ2xQcm9qZWN0aW9uTWF0cml4ID0gKHtwcm9qZWN0aW9uVHJhbnNmb3JtLCB3aWR0aCwgaGVpZ2h0LCBuZWFyLCBmYXJ9KSA9PiB7XG4gIGNvbnN0IHByb2ogPSBbXG4gICAgWzIgKiBwcm9qZWN0aW9uVHJhbnNmb3JtWzBdWzBdIC8gd2lkdGgsIDAsIC0oMiAqIHByb2plY3Rpb25UcmFuc2Zvcm1bMF1bMl0gLyB3aWR0aCAtIDEpLCAwXSxcbiAgICBbMCwgMiAqIHByb2plY3Rpb25UcmFuc2Zvcm1bMV1bMV0gLyBoZWlnaHQsIC0oMiAqIHByb2plY3Rpb25UcmFuc2Zvcm1bMV1bMl0gLyBoZWlnaHQgLSAxKSwgMF0sXG4gICAgWzAsIDAsIC0oZmFyICsgbmVhcikgLyAoZmFyIC0gbmVhciksIC0yICogZmFyICogbmVhciAvIChmYXIgLSBuZWFyKV0sXG4gICAgWzAsIDAsIC0xLCAwXVxuICBdO1xuXG4gIGNvbnN0IHByb2pNYXRyaXggPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgcHJvak1hdHJpeC5wdXNoKHByb2pbal1baV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvak1hdHJpeDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gQ29udHJvbGxlclxufVxuIiwiY29uc3Qge0dQVX0gPSByZXF1aXJlKCdncHUuanMnKTtcbi8vY29uc3QgZ3B1ID0gbmV3IEdQVSh7bW9kZTogJ2dwdSd9KTtcbi8vY29uc3QgZ3B1ID0gbmV3IEdQVSgpO1xuLy9jb25zb2xlLmxvZyhcImdwdVwiLCBncHUpO1xuXG5jb25zdCBQWVJBTUlEX05VTV9TQ0FMRVNfUEVSX09DVEFWRVMgPSAzO1xuY29uc3QgUFlSQU1JRF9NSU5fU0laRSA9IDg7XG5cbmNvbnN0IExBUExBQ0lBTl9TUVJfVEhSRVNIT0xEID0gMyAqIDM7XG5jb25zdCBNQVhfU1VCUElYRUxfRElTVEFOQ0VfU1FSID0gMyAqIDM7XG5jb25zdCBFREdFX1RIUkVTSE9MRCA9IDQuMDtcbmNvbnN0IEVER0VfSEVTU0lBTl9USFJFU0hPTEQgPSAoKEVER0VfVEhSRVNIT0xEKzEpICogKEVER0VfVEhSRVNIT0xEKzEpIC8gRURHRV9USFJFU0hPTEQpO1xuXG4vLyBUT0RPOiBjYW4gdHJ5IDIwIHBlciBkaW1lbnNpb24gYW5kIG1heCBmZWF0dXJlIDEgZm9yIG1vcmUgZWZmaWNpZW50IGNvbXB1dGF0aW9uXG5jb25zdCBOVU1fQlVDS0VUU19QRVJfRElNRU5TSU9OID0gMTA7XG4vL2NvbnN0IE5VTV9CVUNLRVRTX1BFUl9ESU1FTlNJT04gPSAyMDtcbmNvbnN0IE5VTV9CVUNLRVRTID0gTlVNX0JVQ0tFVFNfUEVSX0RJTUVOU0lPTiAqIE5VTV9CVUNLRVRTX1BFUl9ESU1FTlNJT047XG5jb25zdCBNQVhfRkVBVFVSRVNfUEVSX0JVQ0tFVCA9IDU7XG4vL2NvbnN0IE1BWF9GRUFUVVJFU19QRVJfQlVDS0VUID0gMTtcbi8vIHRvdGFsIG1heCBmZWF0dXJlIHBvaW50cyA9IE5VTV9CVUNLRVRTICogTUFYX0ZFQVRVUkVTX1BFUl9CVUNLRVRcblxuY29uc3QgT1JJRU5UQVRJT05fTlVNX0JJTlMgPSAzNjtcbmNvbnN0IE9SSUVOVEFUSU9OX1NNT09USElOR19JVEVSQVRJT05TID0gNTtcblxuY29uc3QgT1JJRU5UQVRJT05fR0FVU1NJQU5fRVhQQU5TSU9OX0ZBQ1RPUiA9IDMuMDtcbmNvbnN0IE9SSUVOVEFUSU9OX1JFR0lPTl9FWFBBTlNJT05fRkFDVE9SID0gMS41O1xuY29uc3QgRlJFQUtfRVhQQU5TSU9OX0ZBQ1RPUiA9IDcuMDtcblxuLy8gMzcgcG9pbnRzID0gNiByaW5ncyB4IDYgcG9pbnRzIHBlciByaW5nICsgMSBjZW50ZXJcbmNvbnN0IEZSRUFLX1JJTkdTID0gW1xuICAvLyByaW5nIDVcbiAge1xuICAgIHNpZ21hOiAwLjU1MDAwMCxcbiAgICBwb2ludHM6IFtcbiAgICAgIFstMS4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgICAgIFstMC41MDAwMDAsIC0wLjg2NjAyNV0sXG4gICAgICBbMC41MDAwMDAsIC0wLjg2NjAyNV0sXG4gICAgICBbMS4wMDAwMDAsIC0wLjAwMDAwMF0sXG4gICAgICBbMC41MDAwMDAsIDAuODY2MDI1XSxcbiAgICAgIFstMC41MDAwMDAsIDAuODY2MDI1XVxuICAgIF1cbiAgfSxcbiAgLy8gcmluZyA0XG4gIHtcbiAgICBzaWdtYTogMC40NzUwMDAsXG4gICAgcG9pbnRzOiBbXG4gICAgICBbMC4wMDAwMDAsIDAuOTMwOTY5XSxcbiAgICAgIFstMC44MDYyNDMsIDAuNDY1NDg1XSxcbiAgICAgIFstMC44MDYyNDMsIC0wLjQ2NTQ4NV0sXG4gICAgICBbLTAuMDAwMDAwLCAtMC45MzA5NjldLFxuICAgICAgWzAuODA2MjQzLCAtMC40NjU0ODVdLFxuICAgICAgWzAuODA2MjQzLCAwLjQ2NTQ4NV1cbiAgICBdXG4gIH0sXG4gIC8vIHJpbmcgM1xuICB7XG4gICAgc2lnbWE6IDAuNDAwMDAwLFxuICAgIHBvaW50czogW1xuICAgICAgWzAuODQ3MzA2LCAtMC4wMDAwMDBdLFxuICAgICAgWzAuNDIzNjUzLCAwLjczMzc4OV0sXG4gICAgICBbLTAuNDIzNjUzLCAwLjczMzc4OV0sXG4gICAgICBbLTAuODQ3MzA2LCAwLjAwMDAwMF0sXG4gICAgICBbLTAuNDIzNjUzLCAtMC43MzM3ODldLFxuICAgICAgWzAuNDIzNjUzLCAtMC43MzM3ODldXG4gICAgXVxuICB9LFxuICAvLyByaW5nIDJcbiAge1xuICAgIHNpZ21hOiAwLjMyNTAwMCxcbiAgICBwb2ludHM6IFtcbiAgICAgIFstMC4wMDAwMDAsIC0wLjc0MTA5NF0sXG4gICAgICBbMC42NDE4MDYsIC0wLjM3MDU0N10sXG4gICAgICBbMC42NDE4MDYsIDAuMzcwNTQ3XSxcbiAgICAgIFswLjAwMDAwMCwgMC43NDEwOTRdLFxuICAgICAgWy0wLjY0MTgwNiwgMC4zNzA1NDddLFxuICAgICAgWy0wLjY0MTgwNiwgLTAuMzcwNTQ3XVxuICAgIF1cbiAgfSxcbiAgLy8gcmluZyAxXG4gIHtcbiAgICBzaWdtYTogMC4yNTAwMDAsXG4gICAgcG9pbnRzOiBbXG4gICAgICBbLTAuNTk1NTAyLCAwLjAwMDAwMF0sXG4gICAgICBbLTAuMjk3NzUxLCAtMC41MTU3MjBdLFxuICAgICAgWzAuMjk3NzUxLCAtMC41MTU3MjBdLFxuICAgICAgWzAuNTk1NTAyLCAtMC4wMDAwMDBdLFxuICAgICAgWzAuMjk3NzUxLCAwLjUxNTcyMF0sXG4gICAgICBbLTAuMjk3NzUxLCAwLjUxNTcyMF1cbiAgICBdXG4gIH0sXG4gIC8vIHJpbmcgMFxuICB7XG4gICAgc2lnbWE6IDAuMTc1MDAwLFxuICAgIHBvaW50czogW1xuICAgICAgWzAuMDAwMDAwLCAwLjM2Mjc4M10sXG4gICAgICBbLTAuMzE0MTc5LCAwLjE4MTM5MV0sXG4gICAgICBbLTAuMzE0MTc5LCAtMC4xODEzOTFdLFxuICAgICAgWy0wLjAwMDAwMCwgLTAuMzYyNzgzXSxcbiAgICAgIFswLjMxNDE3OSwgLTAuMTgxMzkxXSxcbiAgICAgIFswLjMxNDE3OSwgMC4xODEzOTFdXG4gICAgXVxuICB9LFxuICAvLyBjZW50ZXJcbiAge1xuICAgIHNpZ21hOiAwLjEwMDAwMCxcbiAgICBwb2ludHM6IFtcbiAgICAgIFswLCAwXVxuICAgIF1cbiAgfVxuXTtcblxuY29uc3QgRlJFQUtQT0lOVFMgPSBbXTtcbmZvciAobGV0IHIgPSAwOyByIDwgRlJFQUtfUklOR1MubGVuZ3RoOyByKyspIHtcbiAgY29uc3Qgc2lnbWEgPSBGUkVBS19SSU5HU1tyXS5zaWdtYTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBGUkVBS19SSU5HU1tyXS5wb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwb2ludCA9IEZSRUFLX1JJTkdTW3JdLnBvaW50c1tpXTtcbiAgICBGUkVBS1BPSU5UUy5wdXNoKFtzaWdtYSwgcG9pbnRbMF0sIHBvaW50WzFdXSk7XG4gIH1cbn1cblxuY29uc3QgRlJFQUtfQ09OUEFSSVNPTl9DT1VOVCA9IChGUkVBS1BPSU5UUy5sZW5ndGgtMSkgKiAoRlJFQUtQT0lOVFMubGVuZ3RoKSAvIDI7IC8vIDY2NlxuXG4vLyBncHUuanMgdXNlIDMyLWJpdCBmbG9hdCBudW1iZXIuIGl0IGhhcyAyNCBzaWduaWZpY2FudCBiaXQgYW5kIDggYml0IGV4cG9uZW50IChjYW4gY29uZmlybWVkPylcbi8vICAgdGhlcmVmb3JlLCBpdCBjYW4gb25seSBwdXQgMjQgYml0cyBvZiBpbmZvcm1hdGlvbiB3aXRoIGZ1bGwgYWNjdXJhY3lcbi8vICAgYW55IGJldHRlciB3YXkgdG8gdXRpbGl6ZSBhbGwgMzIgYml0cz9cbmNvbnN0IEZSRUFLXzI0QklUX0RFU0NSSVBUT1JfQ09VTlQgPSBNYXRoLmNlaWwoRlJFQUtfQ09OUEFSSVNPTl9DT1VOVCAvIDI0KTsgLy8gY2VpbCg2NjYvMjQpID0gMjggbnVtYmVyc1xuXG5sZXQgZ3B1ID0gbnVsbDtcblxuY2xhc3MgRGV0ZWN0b3Ige1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgbGV0IG51bU9jdGF2ZXMgPSAwO1xuICAgIHdoaWxlICh3aWR0aCA+PSBQWVJBTUlEX01JTl9TSVpFICYmIGhlaWdodCA+PSBQWVJBTUlEX01JTl9TSVpFKSB7XG4gICAgICB3aWR0aCAvPSAyO1xuICAgICAgaGVpZ2h0IC89IDI7XG4gICAgICBudW1PY3RhdmVzKys7XG4gICAgfVxuICAgIHRoaXMubnVtT2N0YXZlcyA9IG51bU9jdGF2ZXM7XG4gICAgdGhpcy5rZXJuZWxzID0gW107XG4gICAgLy90aGlzLmdwdSA9IG5ldyBHUFUoe21vZGU6ICd3ZWJnbCd9KTtcbiAgICB0aGlzLmdwdSA9IG5ldyBHUFUoKTtcbiAgICBncHUgPSB0aGlzLmdwdTtcblxuICAgIHRoaXMuaW5wdXRLZXJuZWwgPSBudWxsO1xuICB9XG5cbiAgZGV0ZWN0KGlucHV0KSB7XG4gICAgaWYgKHRoaXMuaW5wdXRLZXJuZWwgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuaW5wdXRLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGlucHV0RnJhbWUpIHtcbiAgICAgICAgY29uc3QgcGl4ZWwgPSBpbnB1dEZyYW1lW3RoaXMuY29uc3RhbnRzLmhlaWdodC0xLU1hdGguZmxvb3IodGhpcy50aHJlYWQueCAvIHRoaXMuY29uc3RhbnRzLndpZHRoKV1bdGhpcy50aHJlYWQueCAlIHRoaXMuY29uc3RhbnRzLndpZHRoXTtcbiAgICAgICAgcmV0dXJuIChwaXhlbFswXSArIHBpeGVsWzFdICsgcGl4ZWxbMl0pICogMjU1IC8gMztcbiAgICAgIH0sIHtcbiAgICAgICAgY29uc3RhbnRzOiB7d2lkdGg6IHRoaXMud2lkdGgsIGhlaWdodDogdGhpcy5oZWlnaHR9LFxuICAgICAgICBvdXRwdXQ6IFt0aGlzLndpZHRoICogdGhpcy5oZWlnaHRdLFxuICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaW5wdXRLZXJuZWwoaW5wdXQpO1xuICAgIHJldHVybiB0aGlzLmRldGVjdEltYWdlRGF0YShyZXN1bHQpO1xuICB9XG5cbiAgZGV0ZWN0SW1hZ2VEYXRhKGltYWdlZGF0YSkge1xuICAgIHRoaXMua2VybmVsSW5kZXggPSAwOyAvLyByZXNldCBrZXJuZWxJbmRleFxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19USU1FKSB7XG4gICAgICB2YXIgX3N0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXRJbWFnZSA9IHt3aWR0aDogdGhpcy53aWR0aCwgaGVpZ2h0OiB0aGlzLmhlaWdodCwgZGF0YTogaW1hZ2VkYXRhfTtcblxuICAgIGNvbnN0IG9yaWdpbmFsV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IG9yaWdpbmFsSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbnVtT2N0YXZlcyA9IHRoaXMubnVtT2N0YXZlcztcblxuICAgIC8vIEJ1aWxkIGdhdXNzaWFuIHB5cmFtaWQgaW1hZ2VzXG4gICAgY29uc3QgcHlyYW1pZEltYWdlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT2N0YXZlczsgaSsrKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBweXJhbWlkSW1hZ2VzLnB1c2godGhpcy5fYXBwbHlGaWx0ZXIoaW5wdXRJbWFnZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmlyc3QgaW1hZ2Ugb2YgZWFjaCBvY3RhdmUsIGRvd25zYW1wbGUgZnJvbSBwcmV2aW91c1xuICAgICAgICBweXJhbWlkSW1hZ2VzLnB1c2godGhpcy5fZG93bnNhbXBsZUJpbGluZWFyKHB5cmFtaWRJbWFnZXNbcHlyYW1pZEltYWdlcy5sZW5ndGgtMV0pKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtYWluaW5nIGltYWdlcyBvZiBvY3RhdmUsIDR0aCBvcmRlciBiaW5vbWFpbCBmcm9tIHByZXZpb3VzXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IFBZUkFNSURfTlVNX1NDQUxFU19QRVJfT0NUQVZFUyAtIDE7IGorKykge1xuICAgICAgICBweXJhbWlkSW1hZ2VzLnB1c2godGhpcy5fYXBwbHlGaWx0ZXIocHlyYW1pZEltYWdlc1tweXJhbWlkSW1hZ2VzLmxlbmd0aC0xXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkRFQlVHX1RJTUUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdleGVjIHRpbWUgdW50aWwgYnVpbGQgZ2F1c2lhbicsIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gX3N0YXJ0KTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCBkaWZmZXJlbmNlIG9mIGdhdXNzaWFuIHB5cmFtaWRcbiAgICBjb25zdCBkb2dQeXJhbWlkSW1hZ2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PY3RhdmVzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgUFlSQU1JRF9OVU1fU0NBTEVTX1BFUl9PQ1RBVkVTIC0gMTsgaisrKSB7XG4gICAgICAgIGNvbnN0IGltYWdlMSA9IHB5cmFtaWRJbWFnZXNbaSAqIFBZUkFNSURfTlVNX1NDQUxFU19QRVJfT0NUQVZFUyArIGpdO1xuICAgICAgICBjb25zdCBpbWFnZTIgPSBweXJhbWlkSW1hZ2VzW2kgKiBQWVJBTUlEX05VTV9TQ0FMRVNfUEVSX09DVEFWRVMgKyBqICsgMV07XG4gICAgICAgIGRvZ1B5cmFtaWRJbWFnZXMucHVzaCh0aGlzLl9kaWZmZXJlbmNlSW1hZ2VCaW5vbWlhbChpbWFnZTEsIGltYWdlMikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkRFQlVHX1RJTUUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdleGVjIHRpbWUgdW50aWwgYnVpbGQgZG9nJywgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBfc3RhcnQpO1xuICAgIH1cblxuICAgIGxldCBwcnVuZWRFeHRyZW1hcyA9IHRoaXMuX2luaXRpYWxpemVQcnVuZSgpO1xuXG4gICAgLy8gRmluZCBmZWF0dXJlIHBvaW50cyAoaS5lLiBleHRyZW1hcyBpbiBkb2cgaW1hZ2VzKVxuICAgIGZvciAobGV0IGsgPSAxOyBrIDwgZG9nUHlyYW1pZEltYWdlcy5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIEV4cGVyaW1lbnRhbCByZXN1bHQgc2hvd3MgdGhhdCBubyBleHRyZW1hIGlzIHBvc3NpYmxlIGZvciBvZGQgbnVtYmVyIG9mIGtcbiAgICAgIC8vIEkgYmVsaWV2ZSBpdCBoYXMgc29tZXRoaW5nIHRvIGRvIHdpdGggaG93IHRoZSBnYXVzc2lhbiBweXJhbWlkIGJlaW5nIGNvbnN0cnVjdGVkXG4gICAgICBpZiAoayAlIDIgPT09IDEpIGNvbnRpbnVlO1xuXG4gICAgICBsZXQgaW1hZ2UwID0gZG9nUHlyYW1pZEltYWdlc1trLTFdO1xuICAgICAgbGV0IGltYWdlMSA9IGRvZ1B5cmFtaWRJbWFnZXNba107XG4gICAgICBsZXQgaW1hZ2UyID0gZG9nUHlyYW1pZEltYWdlc1trKzFdO1xuXG4gICAgICBjb25zdCBvY3RhdmUgPSBNYXRoLmZsb29yKGsgLyAoUFlSQU1JRF9OVU1fU0NBTEVTX1BFUl9PQ1RBVkVTLTEpKTtcbiAgICAgIGNvbnN0IHNjYWxlID0gayAlIChQWVJBTUlEX05VTV9TQ0FMRVNfUEVSX09DVEFWRVMtMSk7XG5cbiAgICAgIGxldCBoYXNVcHNhbXBsZSA9IGZhbHNlO1xuICAgICAgbGV0IGhhc1BhZE9uZVdpZHRoID0gZmFsc2U7XG4gICAgICBsZXQgaGFzUGFkT25lSGVpZ2h0ID0gZmFsc2U7XG5cbiAgICAgIGlmICggTWF0aC5mbG9vcihpbWFnZTAud2lkdGgvMikgPT0gaW1hZ2UxLndpZHRoKSB7XG4gICAgICAgIGltYWdlMCA9IHRoaXMuX2Rvd25zYW1wbGVCaWxpbmVhcihpbWFnZTApO1xuICAgICAgfVxuICAgICAgaWYgKCBNYXRoLmZsb29yKGltYWdlMS53aWR0aC8yKSA9PSBpbWFnZTIud2lkdGgpIHtcbiAgICAgICAgaGFzVXBzYW1wbGUgPSB0cnVlO1xuICAgICAgICBoYXNQYWRPbmVXaWR0aCA9IGltYWdlMS53aWR0aCAlIDIgPT09IDE7XG4gICAgICAgIGhhc1BhZE9uZUhlaWdodCA9IGltYWdlMS5oZWlnaHQgJSAyID09PSAxO1xuICAgICAgICBpbWFnZTIgPSB0aGlzLl91cHNhbXBsZUJpbGluZWFyKGltYWdlMiwgaGFzUGFkT25lV2lkdGgsIGhhc1BhZE9uZUhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEluIHVwc2FtcGxlIGltYWdlLCBpZ25vcmUgdGhlIGJvcmRlclxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0byBmdXJ0aGVyIHBhZCBvbmUgbW9yZSBsaW5lIChpLmUuIHVwc2FjYWxlIDJ4MiAtPiA1eDUpLCBzbyBpZ25vcmUgb25lIG1vcmUgbGluZVxuICAgICAgbGV0IHN0YXJ0SSA9IGhhc1Vwc2FtcGxlPyAyOiAxO1xuICAgICAgbGV0IHN0YXJ0SiA9IHN0YXJ0STtcblxuICAgICAgLy8gc2hvdWxkIGl0IGJlIFwiaW1hZ2UxLndpZHRoIC0yXCIgPyBidXQgdGhpcyB5aWVsZCBjb25zaXN0ZW50IHJlc3VsdCB3aXRoIGFydG9vbGtpdFxuICAgICAgbGV0IGVuZEkgPSBoYXNVcHNhbXBsZT8gaW1hZ2UxLndpZHRoIC0gMzogaW1hZ2UxLndpZHRoIC0gMTtcbiAgICAgIGxldCBlbmRKID0gaGFzVXBzYW1wbGU/IGltYWdlMS5oZWlnaHQgLSAzOiBpbWFnZTEuaGVpZ2h0IC0gMTtcbiAgICAgIGlmIChoYXNQYWRPbmVXaWR0aCkgZW5kSSAtPSAxO1xuICAgICAgaWYgKGhhc1BhZE9uZUhlaWdodCkgZW5kSiAtPSAxO1xuXG5cbiAgICAgIC8vIGZpbmQgYWxsIGV4dHJlbWEgZm9yIGltYWdlMVxuICAgICAgY29uc3QgZXh0cmVtYXNSZXN1bHQgPSB0aGlzLl9idWlsZEV4dHJlbWFzKGltYWdlMCwgaW1hZ2UxLCBpbWFnZTIsIG9jdGF2ZSwgc2NhbGUsIHN0YXJ0SSwgc3RhcnRKLCBlbmRJLCBlbmRKKTtcblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19USU1FKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdleGVjIHRpbWUgdW50aWwgYnVpbGQgZXh0cmVtYXMnLCBrLCAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBfc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBjb21iaW5lIHRoaXMgZXh0cmVtYSB3aXRoIHRoZSBleGlzdGluZ1xuICAgICAgcHJ1bmVkRXh0cmVtYXMgPSB0aGlzLl9hcHBseVBydW5lKGssIHBydW5lZEV4dHJlbWFzLCBleHRyZW1hc1Jlc3VsdCwgaW1hZ2UxLndpZHRoLCBpbWFnZTEuaGVpZ2h0KTtcblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19USU1FKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdleGVjIHRpbWUgdW50aWwgYXBwbHkgcHJ1bmUnLCBrLCAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBfc3RhcnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgdGhlIG9yaWVudGF0aW9uIGFuZ2xlIG9mIHRoZSBleHRyZW1hXG4gICAgLy8gIGFydG9vbGtpdCBwaWNrcyBtdXRpcGxlIGFuZ2xlcyAodXN1YWxseSAxLTMpLCBidXQgd2UgcGljayBvbmUgb25seSBmb3Igc2ltcGxpY2l0eVxuICAgIGxldCBleHRyZW1hSGlzdG9ncmFtcyA9IHRoaXMuX2luaXRpYWxpemVIaXN0b2dyYW1zKCk7XG4gICAgZm9yIChsZXQgayA9IDE7IGsgPCBkb2dQeXJhbWlkSW1hZ2VzLmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgY29uc3Qgb2N0YXZlID0gTWF0aC5mbG9vcihrIC8gKFBZUkFNSURfTlVNX1NDQUxFU19QRVJfT0NUQVZFUy0xKSk7XG4gICAgICBjb25zdCBzY2FsZSA9IGsgJSAoUFlSQU1JRF9OVU1fU0NBTEVTX1BFUl9PQ1RBVkVTLTEpO1xuICAgICAgY29uc3QgZ2F1c3NpYW5JbmRleCA9IG9jdGF2ZSAqIFBZUkFNSURfTlVNX1NDQUxFU19QRVJfT0NUQVZFUyArIHNjYWxlO1xuICAgICAgY29uc3QgZ2F1c3NpYW5JbWFnZSA9IHB5cmFtaWRJbWFnZXNbZ2F1c3NpYW5JbmRleF1cbiAgICAgIGNvbnN0IGdyYWRpZW50UmVzdWx0ID0gdGhpcy5fY29tcHV0ZUdyYWRpZW50cyhnYXVzc2lhbkltYWdlKTtcblxuICAgICAgZXh0cmVtYUhpc3RvZ3JhbXMgPSB0aGlzLl9jb21wdXRlT3JpZW50YXRpb25IaXN0b2dyYW1zKGV4dHJlbWFIaXN0b2dyYW1zLCBncmFkaWVudFJlc3VsdCwgcHJ1bmVkRXh0cmVtYXMsIGssIGdhdXNzaWFuSW1hZ2Uud2lkdGgsIGdhdXNzaWFuSW1hZ2UuaGVpZ2h0KTtcbiAgICB9XG4gICAgZXh0cmVtYUhpc3RvZ3JhbXMgPSB0aGlzLl9zbW9vdGhIaXN0b2dyYW1zKGV4dHJlbWFIaXN0b2dyYW1zKTtcbiAgICBjb25zdCBleHRyZW1hQW5nbGVzID0gdGhpcy5fY29tcHV0ZUV4dHJlbWFBbmdsZXMoZXh0cmVtYUhpc3RvZ3JhbXMpO1xuXG4gICAgLy8gY29tcHV0ZSB0aGUgRlJFQUsgZGVzY3JpcHRvcnMgZm9yIGV4dHJlbWFzXG4gICAgY29uc3QgZXh0cmVtYUZyZWFrcyA9IHRoaXMuX2NvbXB1dGVFeHRyZW1hRnJlYWsocHlyYW1pZEltYWdlcywgbnVtT2N0YXZlcywgcHJ1bmVkRXh0cmVtYXMsIGV4dHJlbWFBbmdsZXMpO1xuICAgIGNvbnN0IGZyZWFrRGVzY3JpcHRvcnMgPSB0aGlzLl9jb21wdXRlRnJlYWtEZXNjcmlwdG9ycyhleHRyZW1hRnJlYWtzKTtcblxuICAgIC8vIGNvbWJpbmUgYWxsIG5lZWRlZCBkYXRhIGFuZCByZXR1cm4gdG8gQ1BVIHRvZ2V0aGVyXG4gICAgY29uc3QgY29tYmluZWRFeHRyZW1hcyA9IHRoaXMuX2NvbWJpbmUocHJ1bmVkRXh0cmVtYXMsIGV4dHJlbWFBbmdsZXMsIGZyZWFrRGVzY3JpcHRvcnMpO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfVElNRSkge1xuICAgICAgY29uc29sZS5sb2coJ2V4ZWMgdGltZSB1bnRpbCBjb21iaW5lJywgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBfc3RhcnQpO1xuICAgIH1cblxuICAgIC8vIHRvQXJyYXkoKSBpcyB2ZXJ5IHNsb3cuIGtpbmQgb2YgYSBwZXJmb3JtYW5jZSBib3R0bGVuZWNrLlxuICAgIGNvbnN0IGNvbWJpbmVkRXh0cmVtYXNBcnIgPSBjb21iaW5lZEV4dHJlbWFzLnRvQXJyYXkoKTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfVElNRSkge1xuICAgICAgY29uc29sZS5sb2coJ2V4ZWMgdGltZSB1bnRpbCBjb21iaW5lIHRvIGFycmF5JywgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBfc3RhcnQpO1xuICAgIH1cblxuICAgIGNvbnN0IGZlYXR1cmVQb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbWJpbmVkRXh0cmVtYXNBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29tYmluZWRFeHRyZW1hc0FycltpXS5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoY29tYmluZWRFeHRyZW1hc0FycltpXVtqXVswXSAhPT0gMCkge1xuICAgICAgICAgIGNvbnN0IGV4dCA9IGNvbWJpbmVkRXh0cmVtYXNBcnJbaV1bal07XG5cbiAgICAgICAgICBjb25zdCBkZXNjQml0MjQgPSBleHQuc2xpY2UoNSk7XG4gICAgICAgICAgLy8gY29udmVydCAyNC1iaXRzIGVuY29kZWQgdG8gMzItYml0cyBlbmNvZGVkLiBpLmUuIGV2ZXJ5IDQgbnVtYmVycyB0byAzIG51bWJlcnNcbiAgICAgICAgICAvLyAgWzI0ICsgOF0gWzE2ICsgMTZdIFs4ICsgMjRdXG4gICAgICAgICAgLy8gYWx0b2dldGhlciAyOCBudW1iZXJzLCBzbyBwZXJmZWN0bHkgY29udmVydCB0byAyMSBudW1iZXJzXG4gICAgICAgICAgY29uc3QgZGVzY3JpcHRvcnMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGRlc2NCaXQyNC5sZW5ndGg7IGsgKz0gNCkge1xuICAgICAgICAgICAgY29uc3QgdjEgPSBkZXNjQml0MjRba10gKiAyNTYgKyAoZGVzY0JpdDI0W2srMV0gPj4gMTYpO1xuICAgICAgICAgICAgY29uc3QgdjIgPSAoZGVzY0JpdDI0W2srMV0gJiA2NTUzNSkgKiA2NTUzNiArIChkZXNjQml0MjRbaysyXSA+PiA4KTtcbiAgICAgICAgICAgIGNvbnN0IHYzID0gKGRlc2NCaXQyNFtrKzJdICYgMjU1KSAqIDE2Nzc3MjE2ICsgZGVzY0JpdDI0W2srM107XG4gICAgICAgICAgICBkZXNjcmlwdG9ycy5wdXNoKHYxKTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3JzLnB1c2godjIpO1xuICAgICAgICAgICAgZGVzY3JpcHRvcnMucHVzaCh2Myk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHRoZXJlIGFyZSA2NjYgZnJlYWsgYml0cyB0byBlbmNvZGUsIHNvIHRoZSBsYXN0IGRlc2NyaXB0b3JzIG9ubHkgdXNlIDI2IGJpdHMuICg2NjYgJSAzMilcbiAgICAgICAgICAvLyBmb3IgaGlzdG9yaWNhbGx5IHJlYXNvbiwgaXQgc3RhcnRlZCBmcm9tIHRoZSAybmQgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyAoYnV0IG5vdCBuZWNlc3NhcnkpOyBzbyBub3cgd2Ugc2hpZnQgYnkgKDMyLTI2LTEpIGJpdHNcbiAgICAgICAgICBkZXNjcmlwdG9yc1tkZXNjcmlwdG9ycy5sZW5ndGgtMV0gPSAoZGVzY3JpcHRvcnNbZGVzY3JpcHRvcnMubGVuZ3RoLTFdID4+PiA1KTtcblxuICAgICAgICAgIGZlYXR1cmVQb2ludHMucHVzaCh7XG4gICAgICAgICAgICBzY29yZTogZXh0WzBdLFxuICAgICAgICAgICAgc2lnbWE6IGV4dFsxXSxcbiAgICAgICAgICAgIHg6IGV4dFsyXSxcbiAgICAgICAgICAgIHk6IGV4dFszXSxcbiAgICAgICAgICAgIGFuZ2xlOiBleHRbNF0sXG4gICAgICAgICAgICBkZXNjcmlwdG9yczogZGVzY3JpcHRvcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfVElNRSkge1xuICAgICAgY29uc29sZS5sb2coJ2V4ZWMgdGltZSB1bnRpbCBmZWF0dXJlIHBvaW50cyBhbmQgZGVzY3JpcHRvcnMnLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIF9zdGFydCk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlUG9pbnRzO1xuICB9XG5cbiAgX2luaXRpYWxpemVQcnVuZSgpIHtcbiAgICBpZiAodGhpcy5rZXJuZWxJbmRleCA9PT0gdGhpcy5rZXJuZWxzLmxlbmd0aCkge1xuICAgICAgdGhpcy5rZXJuZWxzLnB1c2goXG4gICAgICAgIGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvdXRwdXQ6IFs1LCBNQVhfRkVBVFVSRVNfUEVSX0JVQ0tFVCwgTlVNX0JVQ0tFVFNdLCAvLyBmaXJzdCBkaW1lbnNpb246IFtzY29yZSwgc2lnbWEsIHgsIHksIGRvZ0luZGV4XVxuICAgICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cbiAgICBjb25zdCBrZXJuZWwgPSB0aGlzLmtlcm5lbHNbdGhpcy5rZXJuZWxJbmRleCsrXTtcbiAgICBjb25zdCByZXN1bHQgPSBrZXJuZWwoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gY29tYmluZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gdG8gcmV0dXJuIHRvIGNwdVxuICAvLyBmaXJzdCBkaW1lbnNpb246IFtzY29yZSwgc2lnbWEsIHgsIHksIGFuZ2xlLCBmcmVhazEsIGZyZWFrMiwgLi4uLCBmcmVhazM3XVxuICBfY29tYmluZShwcnVuZWRFeHRyZW1hcywgZXh0cmVtYUFuZ2xlcywgZnJlYWtEZXNjcmlwdG9ycykge1xuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmtlcm5lbHMucHVzaChcbiAgICAgICAgZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihwcnVuZWRFeHRyZW1hcywgZXh0cmVtYUFuZ2xlcywgZnJlYWtEZXNjcmlwdG9ycykge1xuICAgICAgICAgIGlmICh0aGlzLnRocmVhZC54IDwgNCkge1xuICAgICAgICAgICAgcmV0dXJuIHBydW5lZEV4dHJlbWFzW3RoaXMudGhyZWFkLnpdW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy50aHJlYWQueCA8IDUpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRyZW1hQW5nbGVzW3RoaXMudGhyZWFkLnpdW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLngtNF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmcmVha0Rlc2NyaXB0b3JzW3RoaXMudGhyZWFkLnpdW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLngtNV07XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvdXRwdXQ6IFs1ICsgRlJFQUtfMjRCSVRfREVTQ1JJUFRPUl9DT1VOVCwgTUFYX0ZFQVRVUkVTX1BFUl9CVUNLRVQsIE5VTV9CVUNLRVRTXSxcbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG4gICAgY29uc3Qga2VybmVsID0gdGhpcy5rZXJuZWxzW3RoaXMua2VybmVsSW5kZXgrK107XG4gICAgY29uc3QgcmVzdWx0ID0ga2VybmVsKHBydW5lZEV4dHJlbWFzLCBleHRyZW1hQW5nbGVzLCBmcmVha0Rlc2NyaXB0b3JzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX2luaXRpYWxpemVIaXN0b2dyYW1zKCkge1xuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmtlcm5lbHMucHVzaChcbiAgICAgICAgZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSwge1xuICAgICAgICAgIG91dHB1dDogW09SSUVOVEFUSU9OX05VTV9CSU5TLCBNQVhfRkVBVFVSRVNfUEVSX0JVQ0tFVCwgTlVNX0JVQ0tFVFNdLFxuICAgICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cbiAgICBjb25zdCBrZXJuZWwgPSB0aGlzLmtlcm5lbHNbdGhpcy5rZXJuZWxJbmRleCsrXTtcbiAgICBjb25zdCByZXN1bHQgPSBrZXJuZWwoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX2NvbXB1dGVPcmllbnRhdGlvbkhpc3RvZ3JhbXMoZXh0cmVtYUhpc3RvZ3JhbXMsIGdyYWRpZW50UmVzdWx0LCBwcnVuZWRFeHRyZW1hcywgZG9nSW5kZXgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy5rZXJuZWxJbmRleCA9PT0gdGhpcy5rZXJuZWxzLmxlbmd0aCkge1xuICAgICAgdGhpcy5rZXJuZWxzLnB1c2goXG4gICAgICAgIGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oZXh0cmVtYUhpc3RvZ3JhbXMsIGdyYWRpZW50TWFncywgZ3JhZGllbnRBbmdsZXMsIHBydW5lZEV4dHJlbWFzKSB7XG4gICAgICAgICAgY29uc3QgZG9nSW5kZXggPSB0aGlzLmNvbnN0YW50cy5kb2dJbmRleDtcbiAgICAgICAgICBjb25zdCBidWNrZXRQb2ludEluZGV4ID0gdGhpcy50aHJlYWQueTtcbiAgICAgICAgICBjb25zdCBidWNrZXRJbmRleCA9IHRoaXMudGhyZWFkLno7XG5cbiAgICAgICAgICBjb25zdCB0aGlzRG9nSW5kZXggPSBwcnVuZWRFeHRyZW1hc1tidWNrZXRJbmRleF1bYnVja2V0UG9pbnRJbmRleF1bNF07XG4gICAgICAgICAgaWYgKGRvZ0luZGV4ICE9PSB0aGlzRG9nSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRyZW1hSGlzdG9ncmFtc1t0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBvY3RhdmUgPSB0aGlzLmNvbnN0YW50cy5vY3RhdmU7XG4gICAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLmNvbnN0YW50cy5zY2FsZTtcbiAgICAgICAgICBjb25zdCBudW1CaW5zID0gdGhpcy5jb25zdGFudHMubnVtQmlucztcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuY29uc3RhbnRzLndpZHRoO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY29uc3RhbnRzLmhlaWdodDtcbiAgICAgICAgICBjb25zdCBvbmVPdmVyMlBJID0gMC4xNTkxNTQ5NDMwOTE4OTU7XG4gICAgICAgICAgY29uc3QgZ2F1c3NpYW5FeHBhbnNpb25GYWN0b3IgPSB0aGlzLmNvbnN0YW50cy5nYXVzc2lhbkV4cGFuc2lvbkZhY3RvcjtcbiAgICAgICAgICBjb25zdCByZWdpb25FeHBhbnNpb25GYWN0b3IgPSB0aGlzLmNvbnN0YW50cy5yZWdpb25FeHBhbnNpb25GYWN0b3I7XG5cbiAgICAgICAgICBjb25zdCBoaXN0b2dyYW1JbmRleCA9IHRoaXMudGhyZWFkLng7XG5cbiAgICAgICAgICBjb25zdCBvcmlnaW5hbFNpZ21hID0gcHJ1bmVkRXh0cmVtYXNbYnVja2V0SW5kZXhdW2J1Y2tldFBvaW50SW5kZXhdWzFdO1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsWCA9IHBydW5lZEV4dHJlbWFzW2J1Y2tldEluZGV4XVtidWNrZXRQb2ludEluZGV4XVsyXTtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbFkgPSBwcnVuZWRFeHRyZW1hc1tidWNrZXRJbmRleF1bYnVja2V0UG9pbnRJbmRleF1bM107XG5cbiAgICAgICAgICAvLyB4LCB5LCBzaWdtYSBpbiBjdXJyZW50IG9jdGF2ZVxuICAgICAgICAgIGNvbnN0IG9jdGF2ZUZhY3RvciA9IDEuMCAvIE1hdGgucG93KDIsIG9jdGF2ZSk7XG4gICAgICAgICAgY29uc3QgeCA9IE1hdGguZmxvb3Iob3JpZ2luYWxYICogb2N0YXZlRmFjdG9yICsgMC41ICogb2N0YXZlRmFjdG9yKTtcbiAgICAgICAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihvcmlnaW5hbFkgKiBvY3RhdmVGYWN0b3IgKyAwLjUgKiBvY3RhdmVGYWN0b3IpO1xuICAgICAgICAgIGNvbnN0IHNpZ21hID0gb3JpZ2luYWxTaWdtYSAqIG9jdGF2ZUZhY3RvcjtcblxuICAgICAgICAgIGNvbnN0IGd3U2lnbWEgPSBNYXRoLm1heCgxLjAsIGdhdXNzaWFuRXhwYW5zaW9uRmFjdG9yICogc2lnbWEpO1xuICAgICAgICAgIGNvbnN0IGd3U2NhbGUgPSAtMS4wIC8gKDIgKiBnd1NpZ21hICogZ3dTaWdtYSk7XG5cbiAgICAgICAgICBjb25zdCByYWRpdXMgPSByZWdpb25FeHBhbnNpb25GYWN0b3IgKiBnd1NpZ21hO1xuICAgICAgICAgIGNvbnN0IHJhZGl1czIgPSBNYXRoLmNlaWwocmFkaXVzICogcmFkaXVzIC0gMC41KTtcblxuICAgICAgICAgIGNvbnN0IHgwID0gTWF0aC5tYXgoMCwgeCAtIE1hdGguZmxvb3IocmFkaXVzICsgMC41KSk7XG4gICAgICAgICAgY29uc3QgeDEgPSBNYXRoLm1pbih3aWR0aC0xLCB4ICsgTWF0aC5mbG9vcihyYWRpdXMgKyAwLjUpKTtcbiAgICAgICAgICBjb25zdCB5MCA9IE1hdGgubWF4KDAsIHkgLSBNYXRoLmZsb29yKHJhZGl1cyArIDAuNSkpO1xuICAgICAgICAgIGNvbnN0IHkxID0gTWF0aC5taW4oaGVpZ2h0LTEsIHkgKyBNYXRoLmZsb29yKHJhZGl1cyArIDAuNSkpO1xuXG4gICAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgICBmb3IgKGxldCB5cCA9IHkwOyB5cCA8PSB5MTsgeXArKykge1xuICAgICAgICAgICAgY29uc3QgZHkgPSB5cCAtIHk7XG4gICAgICAgICAgICBjb25zdCBkeTIgPSBkeSAqIGR5O1xuICAgICAgICAgICAgZm9yIChsZXQgeHAgPSB4MDsgeHAgPD0geDE7IHhwKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgZHggPSB4cCAtIHg7XG4gICAgICAgICAgICAgIGNvbnN0IGR4MiA9IGR4ICogZHg7XG4gICAgICAgICAgICAgIGNvbnN0IHIyID0gZHgyICsgZHkyO1xuXG4gICAgICAgICAgICAgIGlmIChyMiA8PSByYWRpdXMyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFnID0gZ3JhZGllbnRNYWdzW3lwICogd2lkdGggKyB4cF07XG4gICAgICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBncmFkaWVudEFuZ2xlc1t5cCAqIHdpZHRoICsgeHBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IF94ID0gcjIgKiBnd1NjYWxlO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogZmFzdCBFeHA2XG4gICAgICAgICAgICAgICAgICogMC4wMSUgZXJyb3IgYXQgMS4wMzBcbiAgICAgICAgICAgICAgICAgKiAwLjEwJSBlcnJvciBhdCAxLjUyMFxuICAgICAgICAgICAgICAgICAqIDEuMDAlIGVycm9yIGF0IDIuMzMwXG4gICAgICAgICAgICAgICAgICogNS4wMCUgZXJyb3IgYXQgMy4yODVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCB3ID0gKDcyMCtfeCooNzIwK194KigzNjArX3gqKDEyMCtfeCooMzArX3gqKDYrX3gpKSkpKSkqMC4wMDEzODg4ODg4O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZmJpbiAgPSBudW1CaW5zICogYW5nbGUgKiBvbmVPdmVyMlBJO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpbiA9IE1hdGguZmxvb3IoZmJpbiAtIDAuNSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdzIgPSBmYmluIC0gYmluIC0gMC41O1xuICAgICAgICAgICAgICAgIGNvbnN0IHcxID0gKDEuMCAtIHcyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiMSA9IChiaW4gKyBudW1CaW5zKSAlIG51bUJpbnM7XG4gICAgICAgICAgICAgICAgY29uc3QgYjIgPSAoYmluICsgMSkgJSBudW1CaW5zO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hZ25pdHVkZSA9IHcgKiBtYWc7XG5cbiAgICAgICAgICAgICAgICBpZiAoYjEgPT09IHRoaXMudGhyZWFkLngpIHN1bSArPSB3MSAqIG1hZ25pdHVkZTtcbiAgICAgICAgICAgICAgICBpZiAoYjIgPT09IHRoaXMudGhyZWFkLngpIHN1bSArPSB3MiAqIG1hZ25pdHVkZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgY29uc3RhbnRzOiB7XG4gICAgICAgICAgICBkb2dJbmRleDogZG9nSW5kZXgsXG4gICAgICAgICAgICBvY3RhdmU6IE1hdGguZmxvb3IoZG9nSW5kZXggLyAoUFlSQU1JRF9OVU1fU0NBTEVTX1BFUl9PQ1RBVkVTLTEpKSxcbiAgICAgICAgICAgIHNjYWxlOiBkb2dJbmRleCAlIChQWVJBTUlEX05VTV9TQ0FMRVNfUEVSX09DVEFWRVMtMSksXG4gICAgICAgICAgICBudW1CaW5zOiBPUklFTlRBVElPTl9OVU1fQklOUyxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgZ2F1c3NpYW5FeHBhbnNpb25GYWN0b3I6IE9SSUVOVEFUSU9OX0dBVVNTSUFOX0VYUEFOU0lPTl9GQUNUT1IsXG4gICAgICAgICAgICByZWdpb25FeHBhbnNpb25GYWN0b3I6IE9SSUVOVEFUSU9OX1JFR0lPTl9FWFBBTlNJT05fRkFDVE9SXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvdXRwdXQ6IFtPUklFTlRBVElPTl9OVU1fQklOUywgTUFYX0ZFQVRVUkVTX1BFUl9CVUNLRVQsIE5VTV9CVUNLRVRTXSxcbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG4gICAgY29uc3Qga2VybmVsID0gdGhpcy5rZXJuZWxzW3RoaXMua2VybmVsSW5kZXgrK107XG4gICAgY29uc3QgZ3JhZGllbnRNYWdzID0gZ3JhZGllbnRSZXN1bHQuc2F2ZU1hZztcbiAgICBjb25zdCBncmFkaWVudEFuZ2xlcyA9IGdyYWRpZW50UmVzdWx0LnJlc3VsdDtcbiAgICBjb25zdCByZXN1bHQgPSBrZXJuZWwoZXh0cmVtYUhpc3RvZ3JhbXMsIGdyYWRpZW50TWFncywgZ3JhZGllbnRBbmdsZXMsIHBydW5lZEV4dHJlbWFzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX3Ntb290aEhpc3RvZ3JhbXMoaGlzdG9ncmFtcykge1xuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdWJrZXJuZWxzID0gW107XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IE9SSUVOVEFUSU9OX1NNT09USElOR19JVEVSQVRJT05TOyBrKyspIHtcbiAgICAgICAgc3Via2VybmVscy5wdXNoKFxuICAgICAgICAgIGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oaGlzdG9ncmFtcykge1xuICAgICAgICAgICAgY29uc3QgbnVtQmlucyA9IHRoaXMuY29uc3RhbnRzLm51bUJpbnM7XG4gICAgICAgICAgICAvLyBUaGUgaGlzdG9ncmFtIGlzIHNtb290aGVkIHdpdGggYSBHYXVzc2lhbiwgd2l0aCBzaWdtYSA9IDFcbiAgICAgICAgICAgIHJldHVybiAwLjI3NDA2ODYxOTA2MTE5NyAqIGhpc3RvZ3JhbXNbdGhpcy50aHJlYWQuel1bdGhpcy50aHJlYWQueV1bKHRoaXMudGhyZWFkLnggLSAxICsgbnVtQmlucykgJSBudW1CaW5zXVxuICAgICAgICAgICAgICAgICArIDAuNDUxODYyNzYxODc3NjA2ICogaGlzdG9ncmFtc1t0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XVxuICAgICAgICAgICAgICAgICArIDAuMjc0MDY4NjE5MDYxMTk3ICogaGlzdG9ncmFtc1t0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVsodGhpcy50aHJlYWQueCArIDEpICUgbnVtQmluc107XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY29uc3RhbnRzOiB7bnVtQmluczogT1JJRU5UQVRJT05fTlVNX0JJTlN9LFxuICAgICAgICAgICAgb3V0cHV0OiBbT1JJRU5UQVRJT05fTlVNX0JJTlMsIE1BWF9GRUFUVVJFU19QRVJfQlVDS0VULCBOVU1fQlVDS0VUU10sXG4gICAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXJuZWxzLnB1c2goc3Via2VybmVscyk7XG4gICAgfVxuICAgIGNvbnN0IHN1Ymtlcm5lbHMgPSB0aGlzLmtlcm5lbHNbdGhpcy5rZXJuZWxJbmRleCsrXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IE9SSUVOVEFUSU9OX1NNT09USElOR19JVEVSQVRJT05TOyBrKyspIHtcbiAgICAgIGhpc3RvZ3JhbXMgPSBzdWJrZXJuZWxzW2tdKGhpc3RvZ3JhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gaGlzdG9ncmFtcztcbiAgfVxuXG4gIF9jb21wdXRlRXh0cmVtYUFuZ2xlcyhoaXN0b2dyYW1zKSB7XG4gICAgaWYgKHRoaXMua2VybmVsSW5kZXggPT09IHRoaXMua2VybmVscy5sZW5ndGgpIHtcbiAgICAgIHRoaXMua2VybmVscy5wdXNoKFxuICAgICAgICBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGhpc3RvZ3JhbXMpIHtcbiAgICAgICAgICBjb25zdCBudW1CaW5zID0gdGhpcy5jb25zdGFudHMubnVtQmlucztcblxuICAgICAgICAgIGxldCBtYXhJbmRleCA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1CaW5zOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChoaXN0b2dyYW1zW3RoaXMudGhyZWFkLnpdW3RoaXMudGhyZWFkLnldW2ldID4gaGlzdG9ncmFtc1t0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVttYXhJbmRleF0pIHtcbiAgICAgICAgICAgICAgbWF4SW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwcmV2ID0gKG1heEluZGV4IC0gMSArIG51bUJpbnMpICUgbnVtQmlucztcbiAgICAgICAgICBjb25zdCBuZXh0ID0gKG1heEluZGV4ICsgMSkgJSBudW1CaW5zO1xuXG4gICAgICAgICAgbGV0IGZiaW4gPSBtYXhJbmRleDsgLy8gZGVmYXVsdCBpZiBubyBxdWFkcmF0aWMgZml0XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRml0IGEgcXVhdHJhdGljIHRvIDMgcG9pbnRzLiBUaGUgc3lzdGVtIG9mIGVxdWF0aW9ucyBpczpcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIHkwID0gQSp4MF4yICsgQip4MCArIENcbiAgICAgICAgICAgKiB5MSA9IEEqeDFeMiArIEIqeDEgKyBDXG4gICAgICAgICAgICogeTIgPSBBKngyXjIgKyBCKngyICsgQ1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhpcyBzeXN0ZW0gb2YgZXF1YXRpb25zIGlzIHNvbHZlZCBmb3IgQSxCLEMuXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgcDEwID0gbWF4SW5kZXgtMTtcbiAgICAgICAgICBjb25zdCBwMTEgPSBoaXN0b2dyYW1zW3RoaXMudGhyZWFkLnpdW3RoaXMudGhyZWFkLnldW3ByZXZdO1xuICAgICAgICAgIGNvbnN0IHAyMCA9IG1heEluZGV4O1xuICAgICAgICAgIGNvbnN0IHAyMSA9IGhpc3RvZ3JhbXNbdGhpcy50aHJlYWQuel1bdGhpcy50aHJlYWQueV1bbWF4SW5kZXhdO1xuICAgICAgICAgIGNvbnN0IHAzMCA9IG1heEluZGV4KzE7XG4gICAgICAgICAgY29uc3QgcDMxID0gaGlzdG9ncmFtc1t0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVtuZXh0XTtcblxuICAgICAgICAgIGNvbnN0IGQxID0gKHAzMC1wMjApKihwMzAtcDEwKTtcbiAgICAgICAgICBjb25zdCBkMiA9IChwMTAtcDIwKSoocDMwLXAxMCk7XG4gICAgICAgICAgY29uc3QgZDMgPSBwMTAtcDIwO1xuXG4gICAgICAgICAgLy8gSWYgYW55IG9mIHRoZSBkZW5vbWluYXRvcnMgYXJlIHplcm8gdGhlbiByZXR1cm4gRkFMU0UuXG4gICAgICAgICAgaWYgKGQxICE9IDAgJiYgZDIgIT0gMCAmJiBkMyAhPSAwKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcDEwKnAxMDtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBwMjAqcDIwO1xuXG4gICAgICAgICAgICAvLyBTb2x2ZSBmb3IgdGhlIGNvZWZmaWNpZW50cyBBLEIsQ1xuICAgICAgICAgICAgY29uc3QgQSA9ICgocDMxLXAyMSkvZDEpLSgocDExLXAyMSkvZDIpO1xuICAgICAgICAgICAgY29uc3QgQiA9ICgocDExLXAyMSkrKEEqKGItYSkpKS9kMztcbiAgICAgICAgICAgIGNvbnN0IEMgPSBwMTEtKEEqYSktKEIqcDEwKTtcbiAgICAgICAgICAgIGZiaW4gPSAtQiAvICgyICogQSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGFuID0gIDIuMCAqIE1hdGguUEkgKiAoKGZiaW4gKyAwLjUgKyBudW1CaW5zKSAvIG51bUJpbnMpO1xuICAgICAgICAgIHdoaWxlIChhbiA+IDIuMCAqIE1hdGguUEkpIHsgLy8gbW9kdWxhXG4gICAgICAgICAgICBhbiAtPSAyLjAgKiBNYXRoLlBJO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYW47XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjb25zdGFudHM6IHtudW1CaW5zOiBPUklFTlRBVElPTl9OVU1fQklOU30sXG4gICAgICAgICAgb3V0cHV0OiBbMSwgTUFYX0ZFQVRVUkVTX1BFUl9CVUNLRVQsIE5VTV9CVUNLRVRTXSxcbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVsc1t0aGlzLmtlcm5lbEluZGV4KytdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbChoaXN0b2dyYW1zKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX2FwcGx5UHJ1bmUoZG9nSW5kZXgsIHBydW5lZEV4dHJlbWFzLCBleHRyZW1hc1Jlc3VsdCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IGV4dHJlbWFTY29yZXMgPSBleHRyZW1hc1Jlc3VsdC5yZXN1bHQ7XG4gICAgY29uc3QgZXh0cmVtYVNpZ21hcyA9IGV4dHJlbWFzUmVzdWx0LnNhdmVTaWdtYTtcbiAgICBjb25zdCBleHRyZW1hWHMgPSBleHRyZW1hc1Jlc3VsdC5zYXZlWDtcbiAgICBjb25zdCBleHRyZW1hWXMgPSBleHRyZW1hc1Jlc3VsdC5zYXZlWTtcblxuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdWJrZXJuZWxzID0gW107XG5cbiAgICAgIHN1Ymtlcm5lbHMucHVzaCggLy9kdW1teVxuICAgICAgICBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIG91dHB1dDogWzEsIE5VTV9CVUNLRVRTXSxcbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIC8vIGNvbXB1dGUgdGhlIG9yZGVycyBvbmUgYnkgb25lLCBhbmQgc3RvcmUgdGhlIGluZGV4IGFzOlxuICAgICAgLy8gIGlmIG1heEluZGV4IDwgMDogaXQgbWVhbnMgY29taW5nIGZyb20gdGhlIGV4aXN0aW5nIHBydW5lZEV4dHJlbWFzLiB0aGUgcG9zaXRpb24gaXMgKC1tYXhJbmRleC0xKTtcbiAgICAgIC8vICAgICAgICBlLmcuIC0xIC0+IDAsIC0yIC0+IDEsIC0zIC0+IDJcbiAgICAgIC8vICBpZiBtYXhJbmRleCA+PSAwOiBpdCBtZWFucyBjb21pbmcgZnJvbSB0aGUgbmV3IGV4dHJlbWFzLiB0aGUgcG9zaXRpb24gaXMgdGhlIHBpeGVsIGluZGV4XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BWF9GRUFUVVJFU19QRVJfQlVDS0VUOyBpKyspIHtcbiAgICAgICAgc3Via2VybmVscy5wdXNoKFxuICAgICAgICAgIGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24ob3JkZXJzLCBwcnVuZWRFeHRyZW1hcywgZXh0cmVtYVNjb3Jlcykge1xuICAgICAgICAgICAgY29uc3QgYnVja2V0UG9pbnRJbmRleCA9IHRoaXMudGhyZWFkLng7XG4gICAgICAgICAgICBjb25zdCBidWNrZXRJbmRleCA9IHRoaXMudGhyZWFkLnk7XG4gICAgICAgICAgICBjb25zdCBvcmRlckluZGV4ID0gdGhpcy5jb25zdGFudHMub3JkZXJJbmRleDtcbiAgICAgICAgICAgIGlmIChidWNrZXRQb2ludEluZGV4IDwgb3JkZXJJbmRleCkgcmV0dXJuIG9yZGVyc1t0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcblxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmNvbnN0YW50cy53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodD0gdGhpcy5jb25zdGFudHMuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbnVtQnVja2V0c1BlckRpbWVuc2lvbiA9IHRoaXMuY29uc3RhbnRzLm51bUJ1Y2tldHNQZXJEaW1lbnNpb247XG4gICAgICAgICAgICBjb25zdCBkeCA9IHRoaXMuY29uc3RhbnRzLmJ1Y2tldFdpZHRoO1xuICAgICAgICAgICAgY29uc3QgZHkgPSB0aGlzLmNvbnN0YW50cy5idWNrZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1Y2tldFggPSBidWNrZXRJbmRleCAlIG51bUJ1Y2tldHNQZXJEaW1lbnNpb247XG4gICAgICAgICAgICBjb25zdCBidWNrZXRZID0gTWF0aC5mbG9vcihidWNrZXRJbmRleCAvIG51bUJ1Y2tldHNQZXJEaW1lbnNpb24pO1xuXG4gICAgICAgICAgICBsZXQgY3VycmVudFBydW5lZE1heEluZGV4ID0gLTE7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVySW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAob3JkZXJzW2J1Y2tldEluZGV4XVtpXSA8IDApIGN1cnJlbnRQcnVuZWRNYXhJbmRleCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1heEluZGV4ID0gY3VycmVudFBydW5lZE1heEluZGV4O1xuICAgICAgICAgICAgbGV0IG1heFNjb3JlID0gTWF0aC5hYnMocHJ1bmVkRXh0cmVtYXNbYnVja2V0SW5kZXhdWy0xICogY3VycmVudFBydW5lZE1heEluZGV4IC0gMV1bMF0pOyAvLyBzY29yZSBhdCBwcm9wZXJ0eUluZGV4IDBcbiAgICAgICAgICAgIG1heFNjb3JlID0gTWF0aC5tYXgobWF4U2NvcmUsIDAuMDAwMSk7IC8vIHNhZmVndWFyZCwgYnV0IHByb2JhYmx5IG5vdCBuZWVkZWRcblxuICAgICAgICAgICAgbGV0IHN0YXJ0WCA9IE1hdGguZmxvb3IoYnVja2V0WCAqIGR4KTtcbiAgICAgICAgICAgIGxldCBlbmRYID0gTWF0aC5mbG9vcigoYnVja2V0WCArIDEpICogZHgpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0WSA9IE1hdGguZmxvb3IoYnVja2V0WSAqIGR5KTtcbiAgICAgICAgICAgIGxldCBlbmRZID0gTWF0aC5mbG9vcigoYnVja2V0WSArIDEpICogZHkpO1xuXG4gICAgICAgICAgICAvL2ZvciAobGV0IGkgPSBidWNrZXRYICogZHg7IGkgPCBidWNrZXRYICogZHggKyBkeDsgaSsrKSB7XG4gICAgICAgICAgICAvLyAgZm9yIChsZXQgaiA9IGJ1Y2tldFkgKiBkeTsgaiA8IGJ1Y2tldFkgKiBkeSArIGR5OyBqKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydFg7IGkgPCBlbmRYOyBpKyspIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0WTsgaiA8IGVuZFk7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50SW5kZXggPSBqICogd2lkdGggKyBpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50U2NvcmUgPSBNYXRoLmFicyhleHRyZW1hU2NvcmVzW3BvaW50SW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRTY29yZSA+IG1heFNjb3JlKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgb3JkZXJJbmRleDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmRlcnNbYnVja2V0SW5kZXhdW2tdID09PSBwb2ludEluZGV4KSBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFNjb3JlID0gcG9pbnRTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgbWF4SW5kZXggPSBwb2ludEluZGV4O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1heEluZGV4O1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNvbnN0YW50czoge1xuICAgICAgICAgICAgICAvL2J1Y2tldFdpZHRoOiBNYXRoLmNlaWwod2lkdGggLyBOVU1fQlVDS0VUU19QRVJfRElNRU5TSU9OKSxcbiAgICAgICAgICAgICAgLy9idWNrZXRIZWlnaHQ6IE1hdGguY2VpbChoZWlnaHQgLyBOVU1fQlVDS0VUU19QRVJfRElNRU5TSU9OKSxcbiAgICAgICAgICAgICAgYnVja2V0V2lkdGg6IHdpZHRoIC8gTlVNX0JVQ0tFVFNfUEVSX0RJTUVOU0lPTixcbiAgICAgICAgICAgICAgYnVja2V0SGVpZ2h0OiBoZWlnaHQgLyBOVU1fQlVDS0VUU19QRVJfRElNRU5TSU9OLFxuICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICBudW1CdWNrZXRzUGVyRGltZW5zaW9uOiBOVU1fQlVDS0VUU19QRVJfRElNRU5TSU9OLFxuICAgICAgICAgICAgICBvcmRlckluZGV4OiBpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3V0cHV0OiBbaSsxLCBOVU1fQlVDS0VUU10sXG4gICAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9XG4gICAgICBzdWJrZXJuZWxzLnB1c2goXG4gICAgICAgIGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24ob3JkZXJzLCBwcnVuZWRFeHRyZW1hcywgZXh0cmVtYVNjb3JlcywgZXh0cmVtYVNpZ21hcywgZXh0cmVtYVhzLCBleHRyZW1hWXMpIHtcbiAgICAgICAgICBjb25zdCBkb2dJbmRleCA9IHRoaXMuY29uc3RhbnRzLmRvZ0luZGV4O1xuICAgICAgICAgIGNvbnN0IHByb3BlcnR5SW5kZXggPSB0aGlzLnRocmVhZC54O1xuICAgICAgICAgIGNvbnN0IGJ1Y2tldFBvaW50SW5kZXggPSB0aGlzLnRocmVhZC55O1xuICAgICAgICAgIGNvbnN0IGJ1Y2tldEluZGV4ID0gdGhpcy50aHJlYWQuejtcbiAgICAgICAgICBjb25zdCBtYXhJbmRleCA9IG9yZGVyc1tidWNrZXRJbmRleF1bYnVja2V0UG9pbnRJbmRleF07XG4gICAgICAgICAgaWYgKG1heEluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHBydW5lZEV4dHJlbWFzW2J1Y2tldEluZGV4XVstMSAqIG1heEluZGV4IC0xXVtwcm9wZXJ0eUluZGV4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5SW5kZXggPT09IDApIHJldHVybiBleHRyZW1hU2NvcmVzW21heEluZGV4XTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUluZGV4ID09PSAxKSByZXR1cm4gZXh0cmVtYVNpZ21hc1ttYXhJbmRleF07XG4gICAgICAgICAgICBpZiAocHJvcGVydHlJbmRleCA9PT0gMikgcmV0dXJuIGV4dHJlbWFYc1ttYXhJbmRleF07XG4gICAgICAgICAgICBpZiAocHJvcGVydHlJbmRleCA9PT0gMykgcmV0dXJuIGV4dHJlbWFZc1ttYXhJbmRleF07XG4gICAgICAgICAgICBpZiAocHJvcGVydHlJbmRleCA9PT0gNCkgcmV0dXJuIGRvZ0luZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGNvbnN0YW50czoge1xuICAgICAgICAgICAgZG9nSW5kZXg6IGRvZ0luZGV4LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3V0cHV0OiBbNSwgTUFYX0ZFQVRVUkVTX1BFUl9CVUNLRVQsIE5VTV9CVUNLRVRTXSwgLy8gZmlyc3QgZGltZW5zaW9uOiBbc2NvcmUsIHNpZ21hLCB4LCB5LCBkb2dJbmRleF1cbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICB0aGlzLmtlcm5lbHMucHVzaChzdWJrZXJuZWxzKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJrZXJuZWxzID0gdGhpcy5rZXJuZWxzW3RoaXMua2VybmVsSW5kZXgrK107XG4gICAgbGV0IGMgPSAwO1xuICAgIGxldCBvcmRlcnMgPSBzdWJrZXJuZWxzW2MrK10oKTsgLy8gZHVtbXlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BWF9GRUFUVVJFU19QRVJfQlVDS0VUOyBpKyspIHtcbiAgICAgIG9yZGVycyA9IHN1Ymtlcm5lbHNbYysrXShvcmRlcnMsIHBydW5lZEV4dHJlbWFzLCBleHRyZW1hU2NvcmVzKTsgLy8gYnVpbGQgbWF4IGluZGV4IG9uZSBieSBvbmVcbiAgICB9XG4gICAgLy8gcGFjayB0aGUgcmVzdWx0XG4gICAgY29uc3QgcmVzdWx0ID0gc3Via2VybmVsc1tjKytdKG9yZGVycywgcHJ1bmVkRXh0cmVtYXMsIGV4dHJlbWFTY29yZXMsIGV4dHJlbWFTaWdtYXMsIGV4dHJlbWFYcywgZXh0cmVtYVlzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX2NvbXB1dGVHcmFkaWVudHMoaW1hZ2UpIHtcbiAgICBpZiAodGhpcy5rZXJuZWxJbmRleCA9PT0gdGhpcy5rZXJuZWxzLmxlbmd0aCkge1xuICAgICAgdGhpcy5rZXJuZWxzLnB1c2goXG4gICAgICAgIGdwdS5jcmVhdGVLZXJuZWxNYXAoe1xuICAgICAgICAgIHNhdmVNYWc6IGZ1bmN0aW9uKGEpIHtyZXR1cm4gYX1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jb25zdGFudHMud2lkdGg7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jb25zdGFudHMuaGVpZ2h0O1xuXG4gICAgICAgICAgY29uc3QgaSA9IHRoaXMudGhyZWFkLnggJSB3aWR0aDtcbiAgICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcih0aGlzLnRocmVhZC54IC8gd2lkdGgpO1xuICAgICAgICAgIGNvbnN0IHByZXZKID0gaiA+IDA/IGogLSAxOiBqO1xuICAgICAgICAgIGNvbnN0IG5leHRKID0gaiA8IGhlaWdodCAtIDE/IGogKyAxOiBqO1xuICAgICAgICAgIGNvbnN0IHByZXZJID0gaSA+IDA/IGkgLSAxOiBpO1xuICAgICAgICAgIGNvbnN0IG5leHRJID0gaSA8IHdpZHRoIC0gMT8gaSArIDE6IGk7XG4gICAgICAgICAgY29uc3QgZHggPSBkYXRhW2ogKiB3aWR0aCArIG5leHRJXSAtIGRhdGFbaiAqIHdpZHRoICsgcHJldkldO1xuICAgICAgICAgIGNvbnN0IGR5ID0gZGF0YVtuZXh0SiAqIHdpZHRoICsgaV0gLSBkYXRhW3ByZXZKICogd2lkdGggKyBpXTtcblxuICAgICAgICAgIC8vIHNlZW1zIGxpa2UgZ3B1IGF0YW4yIGRvZXNuJ3QgaGFuZGxlIGR4ID09PSAwIHdlbGxcbiAgICAgICAgICAvLyBhbmdsZSA9IE1hdGguYXRhbjIoZHksIGR4KTsgY2FuIHNvbWVvbmUgdmVyaWZ5IGNvcnJlY3RuZXNzP1xuICAgICAgICAgIGxldCBhbmdsZSA9IDA7XG4gICAgICAgICAgaWYgKGR4ID09PSAwICYmIGR5ID09PSAwKSBhbmdsZSA9IDA7XG4gICAgICAgICAgZWxzZSBpZiAoZHkgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChkeCA8IDApIGFuZ2xlID0gTWF0aC5QSTtcbiAgICAgICAgICAgIGVsc2UgYW5nbGUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChkeCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGR5IDwgMCkgYW5nbGUgPSAtTWF0aC5QSSAvIDI7XG4gICAgICAgICAgICBlbHNlIGFuZ2xlID0gTWF0aC5QSSAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKE1hdGguYWJzKGR5KSwgTWF0aC5hYnMoZHgpKTtcbiAgICAgICAgICAgIGlmIChkeCA8IDAgJiYgZHkgPiAwKSBhbmdsZSA9IE1hdGguUEkgLSBhbmdsZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGR4IDwgMCAmJiBkeSA8IDApIGFuZ2xlID0gLShNYXRoLlBJIC0gYW5nbGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZHggPiAwICYmIGR5IDwgMCkgYW5nbGUgPSAtYW5nbGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFuZ2xlICs9IE1hdGguUEk7XG5cbiAgICAgICAgICBjb25zdCBtYWcgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgIHNhdmVNYWcobWFnKTtcbiAgICAgICAgICByZXR1cm4gYW5nbGU7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjb25zdGFudHM6IHt3aWR0aDogaW1hZ2Uud2lkdGgsIGhlaWdodDogaW1hZ2UuaGVpZ2h0fSxcbiAgICAgICAgICBvdXRwdXQ6IFtpbWFnZS53aWR0aCAqIGltYWdlLmhlaWdodF0sXG4gICAgICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVsc1t0aGlzLmtlcm5lbEluZGV4KytdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbChpbWFnZS5kYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX2NvbXB1dGVGcmVha0Rlc2NyaXB0b3JzKGZyZWFrUmVzdWx0KSB7XG4gICAgaWYgKHRoaXMua2VybmVsSW5kZXggPT09IHRoaXMua2VybmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN1Ymtlcm5lbHMgPSBbXTtcbiAgICAgIHN1Ymtlcm5lbHMucHVzaChcbiAgICAgICAgZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihmcmVha1Jlc3VsdCkge1xuICAgICAgICAgIGNvbnN0IG51bUZyZWFrUG9pbnRzID0gdGhpcy5jb25zdGFudHMubnVtRnJlYWtQb2ludHM7XG4gICAgICAgICAgY29uc3QgeCA9IHRoaXMudGhyZWFkLng7XG5cbiAgICAgICAgICAvLyBiaW5hcnkgc2VhcmNoIGZpcnN0IHBvaW50IGluZGV4XG4gICAgICAgICAgbGV0IGwgPSAwO1xuICAgICAgICAgIGxldCByID0gbnVtRnJlYWtQb2ludHMgLSAxO1xuICAgICAgICAgIGxldCBzdGFydEF0ID0gMDtcbiAgICAgICAgICBjb25zdCBtYXhsb29wID0gNzsgLy8gbD0wLCByPTM2LiBtYXggbnVtIG9mIGxvb3BzID0gbSA9IDE4LDksNSwzLDIsMSxcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heGxvb3A7IGkrKykge1xuICAgICAgICAgICAgaWYgKGwgIT09IHIpIHtcbiAgICAgICAgICAgICAgbGV0IG0gPSBNYXRoLmNlaWwoKGwgKyByKSAvIDIpO1xuICAgICAgICAgICAgICBzdGFydEF0ID0gKG51bUZyZWFrUG9pbnRzLW0gKyBudW1GcmVha1BvaW50cy0xKSAqIG0gLyAyO1xuICAgICAgICAgICAgICBpZiAoeCA8IHN0YXJ0QXQpIHtcbiAgICAgICAgICAgICAgICByID0gbSAtIDE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbCA9IG07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhcnRBdCA9IChudW1GcmVha1BvaW50cy1sICsgbnVtRnJlYWtQb2ludHMtMSkgKiBsIC8gMjtcbiAgICAgICAgICBjb25zdCBwMSA9IGw7XG4gICAgICAgICAgY29uc3QgcDIgPSB4IC0gc3RhcnRBdCArIChwMSsxKTtcblxuICAgICAgICAgIGlmIChmcmVha1Jlc3VsdFt0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVtwMV0gPCBmcmVha1Jlc3VsdFt0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVtwMl0gKyAwLjAwMDEpIHJldHVybiAxO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgY29uc3RhbnRzOiB7XG4gICAgICAgICAgICBudW1GcmVha1BvaW50czogRlJFQUtQT0lOVFMubGVuZ3RoXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvdXRwdXQ6IFtGUkVBS19DT05QQVJJU09OX0NPVU5ULCBNQVhfRkVBVFVSRVNfUEVSX0JVQ0tFVCwgTlVNX0JVQ0tFVFNdLFxuICAgICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgKVxuXG4gICAgICBzdWJrZXJuZWxzLnB1c2goXG4gICAgICAgIGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oZnJlYWtWYWx1ZXMpIHtcbiAgICAgICAgICBjb25zdCBjb21wYXJpc29uQ291bnQgPSB0aGlzLmNvbnN0YW50cy5jb21wYXJpc29uQ291bnQ7XG4gICAgICAgICAgY29uc3QgeCA9IHRoaXMudGhyZWFkLng7XG4gICAgICAgICAgY29uc3Qgc3RhcnQgPSAyNCAqIHg7XG4gICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyAyNDtcbiAgICAgICAgICBsZXQgdGVtcCA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgY29tcGFyaXNvbkNvdW50ICYmIGZyZWFrVmFsdWVzW3RoaXMudGhyZWFkLnpdW3RoaXMudGhyZWFkLnldW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgIHRlbXAgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXAgPSB0ZW1wICogMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGVtcCAvPSAyO1xuXG4gICAgICAgICAgcmV0dXJuIHRlbXA7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjb25zdGFudHM6IHtcbiAgICAgICAgICAgIGNvbXBhcmlzb25Db3VudDogRlJFQUtfQ09OUEFSSVNPTl9DT1VOVCxcbiAgICAgICAgICAgIG51bUZyZWFrUG9pbnRzOiBGUkVBS1BPSU5UUy5sZW5ndGhcbiAgICAgICAgICB9LFxuICAgICAgICAgIG91dHB1dDogW0ZSRUFLXzI0QklUX0RFU0NSSVBUT1JfQ09VTlQsIE1BWF9GRUFUVVJFU19QRVJfQlVDS0VULCBOVU1fQlVDS0VUU10sXG4gICAgICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICB0aGlzLmtlcm5lbHMucHVzaChzdWJrZXJuZWxzKTtcbiAgICB9XG4gICAgY29uc3Qgc3Via2VybmVscyA9IHRoaXMua2VybmVsc1t0aGlzLmtlcm5lbEluZGV4KytdO1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1Ymtlcm5lbHNbMF0oZnJlYWtSZXN1bHQpO1xuICAgIGNvbnN0IHJlc3VsdDIgPSBzdWJrZXJuZWxzWzFdKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cblxuICBfY29tcHV0ZUV4dHJlbWFGcmVhayhweXJhbWlkSW1hZ2VzLCBnYXVzc2lhbk51bU9jdGF2ZXMsIHBydW5lZEV4dHJlbWFzLCBwcnVuZWRFeHRyZW1hc0FuZ2xlcykge1xuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdWJrZXJuZWxzID0gW107XG5cbiAgICAgIHN1Ymtlcm5lbHMucHVzaChcbiAgICAgICAgZ3B1LmNyZWF0ZUtlcm5lbE1hcCh7XG4gICAgICAgICAgc2F2ZVhwOiBmdW5jdGlvbihhKSB7cmV0dXJuIGF9LFxuICAgICAgICAgIHNhdmVZcDogZnVuY3Rpb24oYSkge3JldHVybiBhfVxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihwcnVuZWRFeHRyZW1hcywgcHJ1bmVkRXh0cmVtYXNBbmdsZXMsIGZyZWFrUG9pbnRzKSB7XG4gICAgICAgICAgY29uc3QgZ2F1c3NpYW5OdW1PY3RhdmVzID0gdGhpcy5jb25zdGFudHMuZ2F1c3NpYW5OdW1PY3RhdmVzO1xuICAgICAgICAgIGNvbnN0IGdhdXNzaWFuTnVtU2NhbGVzUGVyT2N0YXZlcyA9IHRoaXMuY29uc3RhbnRzLmdhdXNzaWFuTnVtU2NhbGVzUGVyT2N0YXZlcztcbiAgICAgICAgICBjb25zdCBleHBhbnNpb25GYWN0b3IgPSB0aGlzLmNvbnN0YW50cy5leHBhbnNpb25GYWN0b3I7XG5cbiAgICAgICAgICBjb25zdCBidWNrZXRQb2ludEluZGV4ID0gdGhpcy50aHJlYWQueTtcbiAgICAgICAgICBjb25zdCBidWNrZXRJbmRleCA9IHRoaXMudGhyZWFkLno7XG5cbiAgICAgICAgICBjb25zdCBtSyA9IE1hdGgucG93KDIsIDEuMCAvIChnYXVzc2lhbk51bVNjYWxlc1Blck9jdGF2ZXMtMSkpO1xuICAgICAgICAgIGNvbnN0IG9uZU92ZXJMb2dLID0gMS4wIC8gTWF0aC5sb2cobUspO1xuXG4gICAgICAgICAgY29uc3QgaW5wdXRYID0gcHJ1bmVkRXh0cmVtYXNbYnVja2V0SW5kZXhdW2J1Y2tldFBvaW50SW5kZXhdWzJdO1xuICAgICAgICAgIGNvbnN0IGlucHV0WSA9IHBydW5lZEV4dHJlbWFzW2J1Y2tldEluZGV4XVtidWNrZXRQb2ludEluZGV4XVszXTtcbiAgICAgICAgICBjb25zdCBpbnB1dFNpZ21hID0gcHJ1bmVkRXh0cmVtYXNbYnVja2V0SW5kZXhdW2J1Y2tldFBvaW50SW5kZXhdWzFdO1xuICAgICAgICAgIGNvbnN0IGlucHV0QW5nbGUgPSBwcnVuZWRFeHRyZW1hc0FuZ2xlc1tidWNrZXRJbmRleF1bYnVja2V0UG9pbnRJbmRleF1bMF07XG5cbiAgICAgICAgICBjb25zdCBmcmVha1NpZ21hID0gZnJlYWtQb2ludHNbdGhpcy50aHJlYWQueF1bMF07XG4gICAgICAgICAgY29uc3QgZnJlYWtYID0gZnJlYWtQb2ludHNbdGhpcy50aHJlYWQueF1bMV07XG4gICAgICAgICAgY29uc3QgZnJlYWtZID0gZnJlYWtQb2ludHNbdGhpcy50aHJlYWQueF1bMl07XG5cbiAgICAgICAgICAvLyBFbnN1cmUgdGhlIHNjYWxlIG9mIHRoZSBzaW1pbGFyaXR5IHRyYW5zZm9ybSBpcyBhdCBsZWFzdCBcIjFcIi5cbiAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1TY2FsZSA9IE1hdGgubWF4KDEsIGlucHV0U2lnbWEgKiBleHBhbnNpb25GYWN0b3IpO1xuICAgICAgICAgIGNvbnN0IGMgPSB0cmFuc2Zvcm1TY2FsZSAqIE1hdGguY29zKGlucHV0QW5nbGUpO1xuICAgICAgICAgIGNvbnN0IHMgPSB0cmFuc2Zvcm1TY2FsZSAqIE1hdGguc2luKGlucHV0QW5nbGUpO1xuICAgICAgICAgIC8vIHNpbWlsYXJpdHkgbWF0cml4XG4gICAgICAgICAgLy8gY29uc3QgUyA9IFtcbiAgICAgICAgICAvLyAgYywgLXMsIHgsXG4gICAgICAgICAgLy8gIHMsIGMsIHksXG4gICAgICAgICAgLy8gIDAsIDAsIDFcbiAgICAgICAgICAvL11cbiAgICAgICAgICBjb25zdCBTMCA9IGM7XG4gICAgICAgICAgY29uc3QgUzEgPSAtcztcbiAgICAgICAgICBjb25zdCBTMiA9IGlucHV0WDtcbiAgICAgICAgICBjb25zdCBTMyA9IHM7XG4gICAgICAgICAgY29uc3QgUzQgPSBjO1xuICAgICAgICAgIGNvbnN0IFM1ID0gaW5wdXRZO1xuXG4gICAgICAgICAgY29uc3Qgc2lnbWEgPSB0cmFuc2Zvcm1TY2FsZSAqIGZyZWFrU2lnbWE7XG4gICAgICAgICAgbGV0IG9jdGF2ZSA9IE1hdGguZmxvb3IoTWF0aC5sb2cyKHNpZ21hKSk7XG4gICAgICAgICAgY29uc3QgZnNjYWxlID0gTWF0aC5sb2coc2lnbWEgLyBNYXRoLnBvdygyLCBvY3RhdmUpKSAqIG9uZU92ZXJMb2dLO1xuICAgICAgICAgIGxldCBzY2FsZSA9IE1hdGgucm91bmQoZnNjYWxlKTtcblxuICAgICAgICAgIC8vIHNnaW1hIG9mIGxhc3Qgc2NhbGUgPSBzaWdtYSBvZiB0aGUgZmlyc3Qgc2NhbGUgaW4gbmV4dCBvY3RhdmVcbiAgICAgICAgICAvLyBwcmVmZXIgY29hcnNlciBvY3RhdmVzIGZvciBlZmZpY2llbmN5XG4gICAgICAgICAgaWYgKHNjYWxlID09PSBnYXVzc2lhbk51bVNjYWxlc1Blck9jdGF2ZXMgLSAxKSB7XG4gICAgICAgICAgICBvY3RhdmUgPSBvY3RhdmUgKyAxO1xuICAgICAgICAgICAgc2NhbGUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjbGlwIG9jdGF2ZSBhbmQgc2NhbGVcbiAgICAgICAgICBpZiAob2N0YXZlIDwgMCkge1xuICAgICAgICAgICAgb2N0YXZlID0gMDtcbiAgICAgICAgICAgIHNjYWxlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9jdGF2ZSA+PSBnYXVzc2lhbk51bU9jdGF2ZXMpIHtcbiAgICAgICAgICAgIG9jdGF2ZSA9IGdhdXNzaWFuTnVtT2N0YXZlcyAtIDE7XG4gICAgICAgICAgICBzY2FsZSA9IGdhdXNzaWFuTnVtU2NhbGVzUGVyT2N0YXZlcyAtIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZm9yIGRvd25zYW1wbGUgcG9pbnRcbiAgICAgICAgICBjb25zdCBpbWFnZUluZGV4ID0gb2N0YXZlICogZ2F1c3NpYW5OdW1TY2FsZXNQZXJPY3RhdmVzICsgc2NhbGU7XG4gICAgICAgICAgY29uc3QgYSA9IDEuMCAvIChNYXRoLnBvdygyLCBvY3RhdmUpKTtcbiAgICAgICAgICBjb25zdCBiID0gMC41ICogYSAtIDAuNTtcblxuICAgICAgICAgIGNvbnN0IHggPSBTMCAqIGZyZWFrWCArIFMxICogZnJlYWtZICsgUzI7XG4gICAgICAgICAgY29uc3QgeSA9IFMzICogZnJlYWtYICsgUzQgKiBmcmVha1kgKyBTNTtcbiAgICAgICAgICBsZXQgeHAgPSB4ICogYSArIGI7IC8vIHggaW4gb2N0YXZlXG4gICAgICAgICAgbGV0IHlwID0geSAqIGEgKyBiOyAvLyB5IGluIG9jdGF2ZVxuXG4gICAgICAgICAgc2F2ZVhwKHhwKTtcbiAgICAgICAgICBzYXZlWXAoeXApO1xuICAgICAgICAgIHJldHVybiBpbWFnZUluZGV4O1xuICAgICAgICB9LCB7XG4gICAgICAgICAgY29uc3RhbnRzOiB7XG4gICAgICAgICAgICBnYXVzc2lhbk51bU9jdGF2ZXM6IGdhdXNzaWFuTnVtT2N0YXZlcyxcbiAgICAgICAgICAgIGdhdXNzaWFuTnVtU2NhbGVzUGVyT2N0YXZlczogUFlSQU1JRF9OVU1fU0NBTEVTX1BFUl9PQ1RBVkVTLFxuICAgICAgICAgICAgZXhwYW5zaW9uRmFjdG9yOiBGUkVBS19FWFBBTlNJT05fRkFDVE9SXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvdXRwdXQ6IFtGUkVBS1BPSU5UUy5sZW5ndGgsIE1BWF9GRUFUVVJFU19QRVJfQlVDS0VULCBOVU1fQlVDS0VUU10sXG4gICAgICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICApXG5cbiAgICAgIHN1Ymtlcm5lbHMucHVzaChcbiAgICAgICAgZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSwge1xuICAgICAgICAgIG91dHB1dDogW0ZSRUFLUE9JTlRTLmxlbmd0aCwgTUFYX0ZFQVRVUkVTX1BFUl9CVUNLRVQsIE5VTV9CVUNLRVRTXSxcbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHlyYW1pZEltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdWJrZXJuZWxzLnB1c2goXG4gICAgICAgICAgZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihmcmVha1Jlc3VsdCwgaW1hZ2VEYXRhLCB4cHMsIHlwcywgaW1hZ2VJbmRleGVzKSB7XG4gICAgICAgICAgICBjb25zdCBnYXVzc2lhbkluZGV4ID0gdGhpcy5jb25zdGFudHMuZ2F1c3NpYW5JbmRleDtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jb25zdGFudHMud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmNvbnN0YW50cy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChpbWFnZUluZGV4ZXNbdGhpcy50aHJlYWQuel1bdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF0gIT09IGdhdXNzaWFuSW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZyZWFrUmVzdWx0W3RoaXMudGhyZWFkLnpdW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgeHAgPSB4cHNbdGhpcy50aHJlYWQuel1bdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICAgICAgICBsZXQgeXAgPSB5cHNbdGhpcy50aHJlYWQuel1bdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG5cbiAgICAgICAgICAgIC8vIGJpbGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIHhwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oeHAsIHdpZHRoIC0gMikpO1xuICAgICAgICAgICAgeXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih5cCwgaGVpZ2h0IC0gMikpO1xuXG4gICAgICAgICAgICBjb25zdCB4MCA9IE1hdGguZmxvb3IoeHApO1xuICAgICAgICAgICAgY29uc3QgeDEgPSB4MCArIDE7XG4gICAgICAgICAgICBjb25zdCB5MCA9IE1hdGguZmxvb3IoeXApO1xuICAgICAgICAgICAgY29uc3QgeTEgPSB5MCArIDE7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9ICh4MS14cCkgKiAoeTEteXApICogaW1hZ2VEYXRhW3kwICogd2lkdGggKyB4MF1cbiAgICAgICAgICAgICAgICAgICAgICAgICsgKHhwLXgwKSAqICh5MS15cCkgKiBpbWFnZURhdGFbeTAgKiB3aWR0aCArIHgxXVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoeDEteHApICogKHlwLXkwKSAqIGltYWdlRGF0YVt5MSAqIHdpZHRoICsgeDBdXG4gICAgICAgICAgICAgICAgICAgICAgICArICh4cC14MCkgKiAoeXAteTApICogaW1hZ2VEYXRhW3kxICogd2lkdGggKyB4MV07XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY29uc3RhbnRzOiB7XG4gICAgICAgICAgICAgIGdhdXNzaWFuSW5kZXg6IGksXG4gICAgICAgICAgICAgIHdpZHRoOiBweXJhbWlkSW1hZ2VzW2ldLndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IHB5cmFtaWRJbWFnZXNbaV0uaGVpZ2h0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3V0cHV0OiBbRlJFQUtQT0lOVFMubGVuZ3RoLCBNQVhfRkVBVFVSRVNfUEVSX0JVQ0tFVCwgTlVNX0JVQ0tFVFNdLFxuICAgICAgICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgdGhpcy5rZXJuZWxzLnB1c2goc3Via2VybmVscyk7XG4gICAgfVxuICAgIGNvbnN0IHN1Ymtlcm5lbHMgPSB0aGlzLmtlcm5lbHNbdGhpcy5rZXJuZWxJbmRleCsrXTtcblxuICAgIC8vIGNvbXB1dGUgdGhlIGxvY2F0aW9ucyBvZiBhbGwgZnJlYWsgcG9pbnRzXG4gICAgY29uc3QgcmVzdWx0ID0gc3Via2VybmVsc1swXShwcnVuZWRFeHRyZW1hcywgcHJ1bmVkRXh0cmVtYXNBbmdsZXMsIEZSRUFLUE9JTlRTKTtcbiAgICBjb25zdCBpbWFnZUluZGV4ZXMgPSByZXN1bHQucmVzdWx0O1xuICAgIGNvbnN0IHhwcyA9IHJlc3VsdC5zYXZlWHA7XG4gICAgY29uc3QgeXBzID0gcmVzdWx0LnNhdmVZcDtcblxuICAgIC8vIGNvbXB1dGUgdGhlIGludGVycG9sYXRlZCB2YWx1ZXMgb2YgZWFjaCBmcmVhayBjb29yZGluYXRlcyAodGhpcyB2YWx1ZXMgaXMgdXNlZCB0byBidWlsZCB0aGUgZnJlYWsgZGVzY3JpcHRvcnMpXG4gICAgbGV0IGZyZWFrUmVzdWx0ID0gc3Via2VybmVsc1sxXSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHlyYW1pZEltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZnJlYWtSZXN1bHQgPSBzdWJrZXJuZWxzW2krMl0oZnJlYWtSZXN1bHQsIHB5cmFtaWRJbWFnZXNbaV0uZGF0YSwgeHBzLCB5cHMsIGltYWdlSW5kZXhlcyk7XG4gICAgfVxuICAgIHJldHVybiBmcmVha1Jlc3VsdDtcbiAgfVxuXG4gIF9idWlsZEV4dHJlbWFzKGltYWdlMCwgaW1hZ2UxLCBpbWFnZTIsIG9jdGF2ZSwgc2NhbGUsIHN0YXJ0SSwgc3RhcnRKLCBlbmRJLCBlbmRKKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY29uc3Qgb3JpZ2luYWxIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBkb2dOdW1TY2FsZXNQZXJPY3RhdmVzID0gUFlSQU1JRF9OVU1fU0NBTEVTX1BFUl9PQ1RBVkVTIC0gMTtcblxuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmtlcm5lbHMyID0gW107XG4gICAgICB0aGlzLmtlcm5lbHMyLnB1c2goXG4gICAgICAgIGdwdS5jcmVhdGVLZXJuZWxNYXAoW1xuICAgICAgICAgIGZ1bmN0aW9uIHNhdmVYKGEpIHtyZXR1cm4gYX1cbiAgICAgICAgXSxcbiAgICAgICAgZnVuY3Rpb24oZGF0YTAsIGRhdGExLCBkYXRhMiwgc3RhcnRJLCBzdGFydEosIGVuZEksIGVuZEopIHtcbiAgICAgICAgICBzYXZlWCgwKTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNvbnN0YW50czoge1xuICAgICAgICAgICAgTEFQTEFDSUFOX1NRUl9USFJFU0hPTEQ6IExBUExBQ0lBTl9TUVJfVEhSRVNIT0xELFxuICAgICAgICAgICAgTUFYX1NVQlBJWEVMX0RJU1RBTkNFX1NRUjogTUFYX1NVQlBJWEVMX0RJU1RBTkNFX1NRUixcbiAgICAgICAgICAgIEVER0VfSEVTU0lBTl9USFJFU0hPTEQ6IEVER0VfSEVTU0lBTl9USFJFU0hPTEQsXG4gICAgICAgICAgICBvcmlnaW5hbFdpZHRoOiBvcmlnaW5hbFdpZHRoLFxuICAgICAgICAgICAgb3JpZ2luYWxIZWlnaHQ6IG9yaWdpbmFsSGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IGltYWdlMS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaW1hZ2UxLmhlaWdodCxcbiAgICAgICAgICAgIG9jdGF2ZTogb2N0YXZlLFxuICAgICAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICAgICAgZG9nTnVtU2NhbGVzUGVyT2N0YXZlczogZG9nTnVtU2NhbGVzUGVyT2N0YXZlcyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIG91dHB1dDogW2ltYWdlMS53aWR0aCAqIGltYWdlMS5oZWlnaHRdLFxuICAgICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHRoaXMua2VybmVscy5wdXNoKFxuICAgICAgICAvLyByZXR1cm5cbiAgICAgICAgLy8gIDEuIHNjb3JlOiBob3cgc3Ryb25nIGlzIHRoZSBleHRyZW1hLiAodGhlIGxhcmdlciB0aGUgZGlmZmVyZW5jZSBvZiBnYXVzc2lhbiB2YWx1ZSwgdGhlIHN0cm9uZ2VyKVxuICAgICAgICAvLyAgICAgIHNjb3JlIGNhbiBiZSBwb3NpdGl2ZSAobWF4aW1hKSBvciBuZWdhdGl2ZSAobWluaW1hKVxuICAgICAgICAvLyAgMi4geCwgeTogdGhlIGVmZmVjdGl2ZSB4LCB5IGNvb3JkaW5hdGUgaW4gdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgICAgIC8vICAzLiBzaWdtYTogdGhlIGVmZmVjdGl2ZSBzaWdtYSBpbiB0aGUgb3JpZ2luYWwgaW1hZ2UgKEknbSBub3Qgc3VyZSB3aGF0IHNpZ21hIGlzLiBhbnkgZWR1Y2F0aW9uYWwgcmVmZXJlbmNlPylcbiAgICAgICAgZ3B1LmNyZWF0ZUtlcm5lbE1hcCh7XG4gICAgICAgICAgc2F2ZVNpZ21hOiBmdW5jdGlvbihhKSB7cmV0dXJuIGE7fSxcbiAgICAgICAgICBzYXZlWDogZnVuY3Rpb24oYSkge3JldHVybiBhO30sXG4gICAgICAgICAgc2F2ZVk6IGZ1bmN0aW9uKGEpIHtyZXR1cm4gYTt9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGRhdGEwLCBkYXRhMSwgZGF0YTIsIHN0YXJ0SSwgc3RhcnRKLCBlbmRJLCBlbmRKKSB7XG4gICAgICAgICAgY29uc3QgTEFQTEFDSUFOX1NRUl9USFJFU0hPTEQgPSB0aGlzLmNvbnN0YW50cy5MQVBMQUNJQU5fU1FSX1RIUkVTSE9MRDtcbiAgICAgICAgICBjb25zdCBNQVhfU1VCUElYRUxfRElTVEFOQ0VfU1FSID0gdGhpcy5jb25zdGFudHMuTUFYX1NVQlBJWEVMX0RJU1RBTkNFX1NRUjtcbiAgICAgICAgICBjb25zdCBFREdFX0hFU1NJQU5fVEhSRVNIT0xEID0gdGhpcy5jb25zdGFudHMuRURHRV9IRVNTSUFOX1RIUkVTSE9MRDtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbFdpZHRoID0gdGhpcy5jb25zdGFudHMub3JpZ2luYWxXaWR0aDtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbEhlaWdodCA9IHRoaXMuY29uc3RhbnRzLm9yaWdpbmFsSGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jb25zdGFudHMud2lkdGg7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jb25zdGFudHMuaGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IG9jdGF2ZSA9IHRoaXMuY29uc3RhbnRzLm9jdGF2ZTtcbiAgICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuY29uc3RhbnRzLnNjYWxlO1xuICAgICAgICAgIGNvbnN0IGRvZ051bVNjYWxlc1Blck9jdGF2ZXMgPSB0aGlzLmNvbnN0YW50cy5kb2dOdW1TY2FsZXNQZXJPY3RhdmVzO1xuXG4gICAgICAgICAgY29uc3QgcG9zID0gdGhpcy50aHJlYWQueDtcbiAgICAgICAgICBjb25zdCBwb3NJID0gcG9zICUgd2lkdGg7XG4gICAgICAgICAgY29uc3QgcG9zSiA9IE1hdGguZmxvb3IocG9zIC8gd2lkdGgpO1xuICAgICAgICAgIGlmIChwb3NJIDwgc3RhcnRJIHx8IHBvc0kgPiBlbmRJIHx8IHBvc0ogPCBzdGFydEogfHwgcG9zSiA+IGVuZEopIHJldHVybiAwO1xuXG4gICAgICAgICAgY29uc3QgdiA9IGRhdGExW3Bvc107XG4gICAgICAgICAgaWYgKHYgKiB2IDwgTEFQTEFDSUFOX1NRUl9USFJFU0hPTEQpIHJldHVybiAwO1xuXG4gICAgICAgICAgbGV0IGlzTWF4ID0gdHJ1ZTtcbiAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IDk7IGQrKykge1xuICAgICAgICAgICAgY29uc3QgaSA9IGQgJSAzO1xuICAgICAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoZCAvIDMpO1xuICAgICAgICAgICAgY29uc3QgcG9zMiA9IHBvcyArIChqLTEpICogd2lkdGggKyAoaS0xKTtcbiAgICAgICAgICAgIGlmIChkYXRhMVtwb3NdIDw9IGRhdGEwW3BvczJdKSB7aXNNYXggPSBmYWxzZTsgYnJlYWs7fTtcbiAgICAgICAgICAgIGlmIChkYXRhMVtwb3NdIDw9IGRhdGEyW3BvczJdKSB7aXNNYXggPSBmYWxzZTsgYnJlYWs7fTtcbiAgICAgICAgICAgIGlmIChwb3MgIT09IHBvczIgJiYgZGF0YTFbcG9zXSA8PSBkYXRhMVtwb3MyXSkge2lzTWF4ID0gZmFsc2U7IGJyZWFrO307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGlzTWluID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCFpc01heCkge1xuICAgICAgICAgICAgaXNNaW4gPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCA5OyBkKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgaSA9IGQgJSAzO1xuICAgICAgICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihkIC8gMyk7XG4gICAgICAgICAgICAgIGNvbnN0IHBvczIgPSBwb3MgKyAoai0xKSAqIHdpZHRoICsgKGktMSk7XG4gICAgICAgICAgICAgIGlmIChkYXRhMVtwb3NdID49IGRhdGEwW3BvczJdKSB7aXNNaW4gPSBmYWxzZTsgYnJlYWt9O1xuICAgICAgICAgICAgICBpZiAoZGF0YTFbcG9zXSA+PSBkYXRhMltwb3MyXSkge2lzTWluID0gZmFsc2U7IGJyZWFrfTtcbiAgICAgICAgICAgICAgaWYgKHBvcyAhPT0gcG9zMiAmJiBkYXRhMVtwb3NdID49IGRhdGExW3BvczJdKSB7aXNNaW4gPSBmYWxzZTsgYnJlYWt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzTWF4ICYmICFpc01pbikgcmV0dXJuIDA7XG5cbiAgICAgICAgICAvLyBTdGVwIDI6IHN1Yi1waXhlbCByZWZpbmVtZW50IChJJ20gbm90IHN1cmUgd2hhdCB0aGF0IG1lYW5zLiBBbnkgZWR1Y2F0aW9uYWwgcmVmPylcblxuICAgICAgICAgIC8vIENvbXB1dGUgc3BhdGlhbCBkZXJpdmF0aXZlc1xuICAgICAgICAgIGNvbnN0IGR4ID0gMC41ICogKGRhdGExW3BvcyArIDFdIC0gZGF0YTFbcG9zIC0gMV0pO1xuICAgICAgICAgIGNvbnN0IGR5ID0gMC41ICogKGRhdGExW3BvcyArIHdpZHRoXSAtIGRhdGExW3BvcyAtIHdpZHRoXSk7XG4gICAgICAgICAgY29uc3QgZHh4ID0gZGF0YTFbcG9zICsgMV0gKyBkYXRhMVtwb3MgLSAxXSAtIDIgKiBkYXRhMVtwb3NdO1xuICAgICAgICAgIGNvbnN0IGR5eSA9IGRhdGExW3BvcyArIHdpZHRoXSArIGRhdGExW3BvcyAtIHdpZHRoXSAtIDIgKiBkYXRhMVtwb3NdO1xuICAgICAgICAgIGNvbnN0IGR4eSA9IDAuMjUgKiAoZGF0YTFbcG9zIC0gd2lkdGggLTFdICsgZGF0YTFbcG9zICsgd2lkdGggKyAxXSAtIGRhdGExW3BvcyAtIHdpZHRoICsxXSAtIGRhdGExW3BvcyArIHdpZHRoIC0gMV0pO1xuXG4gICAgICAgICAgLy8gQ29tcHV0ZSBzY2FsZSBkZXJpdmF0ZXNcbiAgICAgICAgICBjb25zdCBkcyA9IDAuNSAqIChkYXRhMltwb3NdIC0gZGF0YTBbcG9zXSk7XG4gICAgICAgICAgY29uc3QgZHNzID0gZGF0YTJbcG9zXSArIGRhdGEwW3Bvc10gLSAyICogZGF0YTFbcG9zXTtcbiAgICAgICAgICBjb25zdCBkeHMgPSAwLjI1ICogKChkYXRhMFtwb3MtMV0gLSBkYXRhMFtwb3MrMV0pICsgKC1kYXRhMltwb3MtMV0gKyBkYXRhMltwb3MrMV0pKTtcbiAgICAgICAgICBjb25zdCBkeXMgPSAwLjI1ICogKChkYXRhMFtwb3Mtd2lkdGhdIC0gZGF0YTBbcG9zK3dpZHRoXSkgKyAoLWRhdGEyW3Bvcy13aWR0aF0gKyBkYXRhMltwb3Mrd2lkdGhdKSk7XG5cbiAgICAgICAgICAvLyBTb2x2ZSBIZXNzaWFuIEEgKiB1ID0gYjtcbiAgICAgICAgICBjb25zdCBBMCA9IGR4eDtcbiAgICAgICAgICBjb25zdCBBMSA9IGR4eTtcbiAgICAgICAgICBjb25zdCBBMiA9IGR4cztcbiAgICAgICAgICBjb25zdCBBMyA9IGR4eTtcbiAgICAgICAgICBjb25zdCBBNCA9IGR5eTtcbiAgICAgICAgICBjb25zdCBBNSA9IGR5cztcbiAgICAgICAgICBjb25zdCBBNiA9IGR4cztcbiAgICAgICAgICBjb25zdCBBNyA9IGR5cztcbiAgICAgICAgICBjb25zdCBBOCA9IGRzcztcbiAgICAgICAgICBjb25zdCBiMCA9IC1keDtcbiAgICAgICAgICBjb25zdCBiMSA9IC1keTtcbiAgICAgICAgICBjb25zdCBiMiA9IC1kcztcblxuICAgICAgICAgIGNvbnN0IGRldEEgPSBBMCAqIEE0ICogQThcbiAgICAgICAgICAgICAgICAgICAgLSBBMCAqIEE1ICogQTVcbiAgICAgICAgICAgICAgICAgICAgLSBBNCAqIEEyICogQTJcbiAgICAgICAgICAgICAgICAgICAgLSBBOCAqIEExICogQTFcbiAgICAgICAgICAgICAgICAgICAgKyAyICogQTEgKiBBMiAqIEE1O1xuXG4gICAgICAgICAgaWYgKCBNYXRoLmFicyhkZXRBKSA8IDAuMDAwMDAwMSkgcmV0dXJuIDA7IC8vIGRldGVybWluYW50IHVuZGVmaW5lZC4gbm8gc29sdXRpb25cblxuICAgICAgICAgIC8vIEIgPSBpbnZlcnNlIG9mIEFcbiAgICAgICAgICBjb25zdCBCMCA9IEE0ICogQTggLSBBNSAqIEE3O1xuICAgICAgICAgIGNvbnN0IEIxID0gQTIgKiBBNyAtIEExICogQTg7XG4gICAgICAgICAgY29uc3QgQjIgPSBBMSAqIEE1IC0gQTIgKiBBNDtcbiAgICAgICAgICBjb25zdCBCMyA9IEIxO1xuICAgICAgICAgIGNvbnN0IEI0ID0gQTAgKiBBOCAtIEEyICogQTY7XG4gICAgICAgICAgY29uc3QgQjUgPSBBMiAqIEEzIC0gQTAgKiBBNTtcbiAgICAgICAgICBjb25zdCBCNiA9IEIyO1xuICAgICAgICAgIGNvbnN0IEI3ID0gQjU7XG4gICAgICAgICAgY29uc3QgQjggPSBBMCAqIEE0IC0gQTEgKiBBMztcblxuICAgICAgICAgIGNvbnN0IHUwID0gKEIwICogYjAgKyBCMSAqIGIxICsgQjIgKiBiMikgLyBkZXRBO1xuICAgICAgICAgIGNvbnN0IHUxID0gKEIzICogYjAgKyBCNCAqIGIxICsgQjUgKiBiMikgLyBkZXRBO1xuICAgICAgICAgIGNvbnN0IHUyID0gKEI2ICogYjAgKyBCNyAqIGIxICsgQjggKiBiMikgLyBkZXRBO1xuXG4gICAgICAgICAgLy8gSWYgcG9pbnRzIG1vdmUgdG9vIG11Y2ggaW4gdGhlIHN1Yi1waXhlbCB1cGRhdGUsIHRoZW4gdGhlIHBvaW50IHByb2JhYmx5IHVuc3RhYmxlLlxuICAgICAgICAgIGlmICh1MCAqIHUwICsgdTEgKiB1MSA+IE1BWF9TVUJQSVhFTF9ESVNUQU5DRV9TUVIpIHJldHVybiAwO1xuXG4gICAgICAgICAgLy8gY29tcHV0ZSBlZGdlIHNjb3JlXG4gICAgICAgICAgY29uc3QgZGV0ID0gKGR4eCAqIGR5eSkgLSAoZHh5ICogZHh5KTtcbiAgICAgICAgICBpZiAoZGV0ID09PSAwKSByZXR1cm4gMDtcblxuICAgICAgICAgIGNvbnN0IGVkZ2VTY29yZSA9IChkeHggKyBkeXkpICogKGR4eCArIGR5eSkgLyBkZXQ7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGVkZ2VTY29yZSkgPj0gRURHRV9IRVNTSUFOX1RIUkVTSE9MRCApIHJldHVybiAwO1xuXG4gICAgICAgICAgY29uc3Qgc2NvcmUgPSB2IC0gKGIwICogdTAgKyBiMSAqIHUxICsgYjIgKiB1Mik7XG4gICAgICAgICAgaWYgKHNjb3JlICogc2NvcmUgPCBMQVBMQUNJQU5fU1FSX1RIUkVTSE9MRCkgcmV0dXJuIDA7XG5cbiAgICAgICAgICAvLyBvcmlnaW5hbCB4ID0geCoyXm4gKyAyXihuLTEpIC0gMC41XG4gICAgICAgICAgLy8gb3JpZ2luYWwgeSA9IHkqMl5uICsgMl4obi0xKSAtIDAuNVxuICAgICAgICAgIGxldCBvcmlnaW5hbFggPSBwb3NJICogTWF0aC5wb3coMiwgb2N0YXZlKSArIE1hdGgucG93KDIsIG9jdGF2ZS0xKSAtIDAuNTtcbiAgICAgICAgICBsZXQgb3JpZ2luYWxZID0gcG9zSiAqIE1hdGgucG93KDIsIG9jdGF2ZSkgKyBNYXRoLnBvdygyLCBvY3RhdmUtMSkgLSAwLjU7XG4gICAgICAgICAgb3JpZ2luYWxYID0gb3JpZ2luYWxYICsgdTAgKiBNYXRoLnBvdygyLCBvY3RhdmUpO1xuICAgICAgICAgIG9yaWdpbmFsWSA9IG9yaWdpbmFsWSArIHUxICogTWF0aC5wb3coMiwgb2N0YXZlKTtcbiAgICAgICAgICBpZiAob3JpZ2luYWxYIDwgMCB8fCBvcmlnaW5hbFggPj0gb3JpZ2luYWxXaWR0aCB8fCBvcmlnaW5hbFkgPCAwIHx8IG9yaWdpbmFsWSA+PSBvcmlnaW5hbEhlaWdodCkgcmV0dXJuIDA7XG5cbiAgICAgICAgICBjb25zdCBzcFNjYWxlID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgc2NhbGUgKyB1MiksIGRvZ051bVNjYWxlc1Blck9jdGF2ZXMpO1xuICAgICAgICAgIGNvbnN0IG1LID0gTWF0aC5wb3coMiwgMS4wIC8gZG9nTnVtU2NhbGVzUGVyT2N0YXZlcyk7XG4gICAgICAgICAgY29uc3QgbmV3U2lnbWEgPSBNYXRoLnBvdyhtSywgc3BTY2FsZSkgKiAoMSA8PCBvY3RhdmUpO1xuXG4gICAgICAgICAgc2F2ZVNpZ21hKG5ld1NpZ21hKTtcbiAgICAgICAgICBzYXZlWChvcmlnaW5hbFgpO1xuICAgICAgICAgIHNhdmVZKG9yaWdpbmFsWSk7XG4gICAgICAgICAgcmV0dXJuIHNjb3JlO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgY29uc3RhbnRzOiB7XG4gICAgICAgICAgICBMQVBMQUNJQU5fU1FSX1RIUkVTSE9MRDogTEFQTEFDSUFOX1NRUl9USFJFU0hPTEQsXG4gICAgICAgICAgICBNQVhfU1VCUElYRUxfRElTVEFOQ0VfU1FSOiBNQVhfU1VCUElYRUxfRElTVEFOQ0VfU1FSLFxuICAgICAgICAgICAgRURHRV9IRVNTSUFOX1RIUkVTSE9MRDogRURHRV9IRVNTSUFOX1RIUkVTSE9MRCxcbiAgICAgICAgICAgIG9yaWdpbmFsV2lkdGg6IG9yaWdpbmFsV2lkdGgsXG4gICAgICAgICAgICBvcmlnaW5hbEhlaWdodDogb3JpZ2luYWxIZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogaW1hZ2UxLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBpbWFnZTEuaGVpZ2h0LFxuICAgICAgICAgICAgb2N0YXZlOiBvY3RhdmUsXG4gICAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgICBkb2dOdW1TY2FsZXNQZXJPY3RhdmVzOiBkb2dOdW1TY2FsZXNQZXJPY3RhdmVzLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3V0cHV0OiBbaW1hZ2UxLndpZHRoICogaW1hZ2UxLmhlaWdodF0sXG4gICAgICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBrZXJuZWwgPSB0aGlzLmtlcm5lbHNbdGhpcy5rZXJuZWxJbmRleCsrXTtcbiAgICBjb25zdCByZXN1bHQgPSBrZXJuZWwoaW1hZ2UwLmRhdGEsIGltYWdlMS5kYXRhLCBpbWFnZTIuZGF0YSwgc3RhcnRJLCBzdGFydEosIGVuZEksIGVuZEopO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfZG93bnNhbXBsZUJpbGluZWFyKGltYWdlKSB7XG4gICAgY29uc3QgZHN0V2lkdGggPSBNYXRoLmZsb29yKGltYWdlLndpZHRoIC8gMik7XG4gICAgY29uc3QgZHN0SGVpZ2h0ID0gTWF0aC5mbG9vcihpbWFnZS5oZWlnaHQgLyAyKTtcblxuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmtlcm5lbHMucHVzaChcbiAgICAgICAgZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmNvbnN0YW50cy53aWR0aDtcbiAgICAgICAgICBjb25zdCBzcmNXaWR0aCA9IHRoaXMuY29uc3RhbnRzLnNyY1dpZHRoO1xuICAgICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKHRoaXMudGhyZWFkLnggLyB3aWR0aCk7XG4gICAgICAgICAgY29uc3QgaSA9IHRoaXMudGhyZWFkLnggJSB3aWR0aDtcbiAgICAgICAgICBjb25zdCBzcmNQb3MgPSBqICogMiAqIHNyY1dpZHRoICsgaSAqIDI7XG4gICAgICAgICAgY29uc3QgdiA9IChkYXRhW3NyY1Bvc10gKyBkYXRhW3NyY1BvcysxXSArIGRhdGFbc3JjUG9zK3NyY1dpZHRoXSArIGRhdGFbc3JjUG9zK3NyY1dpZHRoKzFdKSAqIDAuMjU7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjb25zdGFudHM6IHtzcmNXaWR0aDogaW1hZ2Uud2lkdGgsIHdpZHRoOiBkc3RXaWR0aH0sXG4gICAgICAgICAgb3V0cHV0OiBbZHN0V2lkdGggKiBkc3RIZWlnaHRdLFxuICAgICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsID0gdGhpcy5rZXJuZWxzW3RoaXMua2VybmVsSW5kZXgrK107XG4gICAgY29uc3QgcmVzdWx0ID0ga2VybmVsKGltYWdlLmRhdGEpO1xuICAgIHJldHVybiB7d2lkdGg6IGRzdFdpZHRoLCBoZWlnaHQ6IGRzdEhlaWdodCwgZGF0YTogcmVzdWx0fTtcbiAgfVxuXG4gIF91cHNhbXBsZUJpbGluZWFyKGltYWdlLCBwYWRPbmVXaWR0aCwgcGFkT25lSGVpZ2h0KSB7XG4gICAgY29uc3QgZHN0V2lkdGggPSBpbWFnZS53aWR0aCAqIDIgKyAocGFkT25lV2lkdGg/MTowKTtcbiAgICBjb25zdCBkc3RIZWlnaHQgPSBpbWFnZS5oZWlnaHQgKiAyICsgKHBhZE9uZUhlaWdodD8xOjApO1xuXG4gICAgaWYgKHRoaXMua2VybmVsSW5kZXggPT09IHRoaXMua2VybmVscy5sZW5ndGgpIHtcbiAgICAgIHRoaXMua2VybmVscy5wdXNoKFxuICAgICAgICBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuY29uc3RhbnRzLndpZHRoO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY29uc3RhbnRzLmhlaWdodDtcblxuICAgICAgICAgIGNvbnN0IHNyY1dpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAvIDIpO1xuICAgICAgICAgIGNvbnN0IHNyY0hlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcih0aGlzLnRocmVhZC54IC8gd2lkdGgpO1xuICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLnRocmVhZC54ICUgd2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2kgPSAwLjUgKiBpIC0gMC4yNTtcbiAgICAgICAgICBjb25zdCBzaiA9IDAuNSAqIGogLSAwLjI1O1xuICAgICAgICAgIGNvbnN0IHNpMCA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3Ioc2kpKTtcbiAgICAgICAgICBjb25zdCBzaTEgPSBNYXRoLm1pbihNYXRoLmNlaWwoc2kpLCBzcmNXaWR0aC0xKTtcbiAgICAgICAgICBjb25zdCBzajAgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHNqKSk7XG4gICAgICAgICAgY29uc3Qgc2oxID0gTWF0aC5taW4oTWF0aC5jZWlsKHNqKSwgc3JjSGVpZ2h0LTEpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gKHNpMSAtIHNpKSAqIChzajEgLSBzaikgKiBkYXRhWyBzajAgKiB3aWR0aCArIHNpMCBdICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzaTEgLSBzaSkgKiAoc2ogLSBzajApICogZGF0YVsgc2oxICogd2lkdGggKyBzaTAgXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2kgLSBzaTApICogKHNqMSAtIHNqKSAqIGRhdGFbIHNqMCAqIHdpZHRoICsgc2kxIF0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNpIC0gc2kwKSAqIChzaiAtIHNqMCkgKiBkYXRhWyBzajEgKiB3aWR0aCArIHNpMSBdO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNvbnN0YW50czoge3dpZHRoOiBkc3RXaWR0aCwgaGVpZ2h0OiBkc3RIZWlnaHR9LFxuICAgICAgICAgIG91dHB1dDogW2RzdFdpZHRoICogZHN0SGVpZ2h0XSxcbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVsc1t0aGlzLmtlcm5lbEluZGV4KytdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbChpbWFnZS5kYXRhKTtcbiAgICByZXR1cm4ge3dpZHRoOiBkc3RXaWR0aCwgaGVpZ2h0OiBkc3RIZWlnaHQsIGRhdGE6IHJlc3VsdH07XG4gIH1cblxuICAvLyA0dGggb3JkZXIgYmlub21haWwgZmlsdGVyXG4gIF9hcHBseUZpbHRlcihpbWFnZSkge1xuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBmMSA9IGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuY29uc3RhbnRzLndpZHRoO1xuICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcih0aGlzLnRocmVhZC54IC8gd2lkdGgpO1xuICAgICAgICBjb25zdCBpID0gdGhpcy50aHJlYWQueCAlIHdpZHRoO1xuICAgICAgICBjb25zdCBqb2Zmc2V0ID0gaiAqIHdpZHRoO1xuICAgICAgICBjb25zdCB2ID0gZGF0YVtqb2Zmc2V0ICsgTWF0aC5tYXgoaS0yLDApXSArXG4gICAgICAgICAgICAgICAgICBkYXRhW2pvZmZzZXQgKyBNYXRoLm1heChpLTEsMCldICogNCArXG4gICAgICAgICAgICAgICAgICBkYXRhW2pvZmZzZXQgKyBpXSAqIDYgK1xuICAgICAgICAgICAgICAgICAgZGF0YVtqb2Zmc2V0ICsgTWF0aC5taW4oaSsxLHdpZHRoLTEpXSAqIDQgK1xuICAgICAgICAgICAgICAgICAgZGF0YVtqb2Zmc2V0ICsgTWF0aC5taW4oaSsyLHdpZHRoLTEpXTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9LCB7XG4gICAgICAgIGNvbnN0YW50czoge3dpZHRoOiBpbWFnZS53aWR0aH0sXG4gICAgICAgIG91dHB1dDogW2ltYWdlLndpZHRoICogaW1hZ2UuaGVpZ2h0XSxcbiAgICAgICAgcGlwZWxpbmU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBmMiA9IGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuY29uc3RhbnRzLndpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmNvbnN0YW50cy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKHRoaXMudGhyZWFkLnggLyB3aWR0aCk7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLnRocmVhZC54ICUgd2lkdGg7XG4gICAgICAgIGNvbnN0IHYgPSBkYXRhW01hdGgubWF4KGotMiwwKSAqIHdpZHRoICsgaV0gK1xuICAgICAgICAgICAgICAgICAgZGF0YVtNYXRoLm1heChqLTEsMCkgKiB3aWR0aCArIGldICogNCArXG4gICAgICAgICAgICAgICAgICBkYXRhW2ogKiB3aWR0aCArIGldICogNiArXG4gICAgICAgICAgICAgICAgICBkYXRhW01hdGgubWluKGorMSxoZWlnaHQtMSkgKiB3aWR0aCArIGldICogNCArXG4gICAgICAgICAgICAgICAgICBkYXRhW01hdGgubWluKGorMixoZWlnaHQtMSkgKiB3aWR0aCArIGldO1xuXG4gICAgICAgIHJldHVybiB2IC8gMjU2OyAvLyBhbHRvZ2V0aGVyICgxKzQrNis0KzEpICogKDErNCs2KzQrMSkgbnVtYmVyc1xuICAgICAgfSwge1xuICAgICAgICBjb25zdGFudHM6IHt3aWR0aDogaW1hZ2Uud2lkdGgsIGhlaWdodDogaW1hZ2UuaGVpZ2h0fSxcbiAgICAgICAgb3V0cHV0OiBbaW1hZ2Uud2lkdGggKiBpbWFnZS5oZWlnaHRdLFxuICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5rZXJuZWxzLnB1c2goe2YxLCBmMn0pO1xuICAgIH1cbiAgICBjb25zdCB7ZjEsIGYyfSA9IHRoaXMua2VybmVsc1t0aGlzLmtlcm5lbEluZGV4KytdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGYyKGYxKGltYWdlLmRhdGEpKTtcbiAgICByZXR1cm4ge3dpZHRoOiBpbWFnZS53aWR0aCwgaGVpZ2h0OiBpbWFnZS5oZWlnaHQsIGRhdGE6IHJlc3VsdH07XG4gIH1cblxuICBfZGlmZmVyZW5jZUltYWdlQmlub21pYWwoaW1hZ2UxLCBpbWFnZTIpIHtcbiAgICBpZiAodGhpcy5rZXJuZWxJbmRleCA9PT0gdGhpcy5rZXJuZWxzLmxlbmd0aCkge1xuICAgICAgdGhpcy5rZXJuZWxzLnB1c2goXG4gICAgICAgIGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oZGF0YTEsIGRhdGEyKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGExW3RoaXMudGhyZWFkLnhdIC0gZGF0YTJbdGhpcy50aHJlYWQueF07XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvdXRwdXQ6IFtpbWFnZTEud2lkdGggKiBpbWFnZTEuaGVpZ2h0XSxcbiAgICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVsc1t0aGlzLmtlcm5lbEluZGV4KytdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbChpbWFnZTEuZGF0YSwgaW1hZ2UyLmRhdGEpO1xuICAgIHJldHVybiB7d2lkdGg6IGltYWdlMS53aWR0aCwgaGVpZ2h0OiBpbWFnZTEuaGVpZ2h0LCBkYXRhOiByZXN1bHR9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBEZXRlY3RvclxufTtcbiIsImNvbnN0IHtNYXRyaXgsIGludmVyc2V9ID0gcmVxdWlyZSgnbWwtbWF0cml4Jyk7XG5jb25zdCB7YXBwbHlNb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtLCBidWlsZE1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm0sIGNvbXB1dGVTY3JlZW5Db29yZGlhdGV9ID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xuXG4vLyBidWlsZCB3b3JsZCBtYXRyaXggd2l0aCBsaXN0IG9mIG1hdGNoaW5nIHdvcmxkQ29vcmRzfHNjcmVlbkNvb3Jkc1xuLy9cbi8vIFN0ZXAgMS4gZXN0aW1hdGUgaG9tb2dyYXBoeSB3aXRoIGxpc3Qgb2YgcGFpcnNcbi8vIFJlZjogaHR0cHM6Ly93d3cudWlvLm5vL3N0dWRpZXIvZW1uZXIvbWF0bmF0L2l0cy9URUs1MDMwL3YxOS9sZWN0L2xlY3R1cmVfNF8zLWVzdGltYXRpbmctaG9tb2dyYXBoaWVzLWZyb20tZmVhdHVyZS1jb3JyZXNwb25kZW5jZXMucGRmICAoQmFzaWMgaG9tb2dyYXBoeSBlc3RpbWF0aW9uIGZyb20gcG9pbnRzKVxuLy9cbi8vIFN0ZXAgMi4gZGVjb21wb3NlIGhvbW9ncmFwaHkgaW50byByb3RhdGlvbiBhbmQgdHJhbnNsYXRpb24gbWF0cml4ZXMgKGkuZS4gd29ybGQgbWF0cml4KVxuLy8gUmVmOiBjYW4gYW55b25lIHByb3ZpZGUgcmVmZXJlbmNlP1xuY29uc3QgZXN0aW1hdGVIb21vZ3JhcGh5ID0gKHtzY3JlZW5Db29yZHMsIHdvcmxkQ29vcmRzLCBwcm9qZWN0aW9uVHJhbnNmb3JtfSkgPT4ge1xuICBjb25zdCBudW0gPSBzY3JlZW5Db29yZHMubGVuZ3RoO1xuICBjb25zdCBBRGF0YSA9IFtdO1xuICBjb25zdCBCRGF0YSA9IFtdO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IG51bTsgaisrKSB7XG4gICAgY29uc3Qgcm93MSA9IFtcbiAgICAgIHdvcmxkQ29vcmRzW2pdLngsXG4gICAgICB3b3JsZENvb3Jkc1tqXS55LFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC0od29ybGRDb29yZHNbal0ueCAqIHNjcmVlbkNvb3Jkc1tqXS54KSxcbiAgICAgIC0od29ybGRDb29yZHNbal0ueSAqIHNjcmVlbkNvb3Jkc1tqXS54KSxcbiAgICBdO1xuICAgIGNvbnN0IHJvdzIgPSBbXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB3b3JsZENvb3Jkc1tqXS54LFxuICAgICAgd29ybGRDb29yZHNbal0ueSxcbiAgICAgIDEsXG4gICAgICAtKHdvcmxkQ29vcmRzW2pdLnggKiBzY3JlZW5Db29yZHNbal0ueSksXG4gICAgICAtKHdvcmxkQ29vcmRzW2pdLnkgKiBzY3JlZW5Db29yZHNbal0ueSksXG4gICAgXTtcbiAgICBBRGF0YS5wdXNoKHJvdzEpO1xuICAgIEFEYXRhLnB1c2gocm93Mik7XG5cbiAgICBCRGF0YS5wdXNoKFtzY3JlZW5Db29yZHNbal0ueF0pO1xuICAgIEJEYXRhLnB1c2goW3NjcmVlbkNvb3Jkc1tqXS55XSk7XG4gIH1cblxuICBjb25zdCBBID0gbmV3IE1hdHJpeChBRGF0YSk7XG4gIGNvbnN0IEIgPSBuZXcgTWF0cml4KEJEYXRhKTtcbiAgY29uc3QgQVQgPSBBLnRyYW5zcG9zZSgpO1xuICBjb25zdCBBVEEgPSBBVC5tbXVsKEEpO1xuICBjb25zdCBBVEIgPSBBVC5tbXVsKEIpO1xuICBjb25zdCBBVEFJbnYgPSBpbnZlcnNlKEFUQSk7XG4gIGNvbnN0IEMgPSBBVEFJbnYubW11bChBVEIpLnRvMURBcnJheSgpO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfTUFUQ0gpIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IEEuZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBLmRhdGFbal0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCF3aW5kb3cuY21wKEEuZGF0YVtqXVtpXSwgd2luZG93LmRlYnVnTWF0Y2gubWF0QVtqXVtpXSwgMC4xKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiSU5DT1JSRUNUIEFcIiwgaiwgaSwgQS5kYXRhW2pdW2ldLCB3aW5kb3cuZGVidWdNYXRjaC5tYXRBW2pdW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IEMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICghd2luZG93LmNtcChDW2pdLCB3aW5kb3cuZGVidWdNYXRjaC5tYXRDW2pdLCAwLjAwMSkpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJTkNPUlJFQ1QgQ1wiLCBqLCBDW2pdLCB3aW5kb3cuZGVidWdNYXRjaC5tYXRDW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBIID0gbmV3IE1hdHJpeChbXG4gICAgW0NbMF0sIENbMV0sIENbMl1dLFxuICAgIFtDWzNdLCBDWzRdLCBDWzVdXSxcbiAgICBbQ1s2XSwgQ1s3XSwgMV1cbiAgXSk7XG5cbiAgY29uc3QgSyA9IG5ldyBNYXRyaXgocHJvamVjdGlvblRyYW5zZm9ybSk7XG4gIGNvbnN0IEtJbnYgPSBpbnZlcnNlKEspO1xuXG4gIGNvbnN0IF9LSW52SCA9IEtJbnYubW11bChIKTtcbiAgY29uc3QgS0ludkggPSBfS0ludkgudG8xREFycmF5KCk7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19NQVRDSCkge1xuICAgIGNvbnN0IGR2ID0gd2luZG93LmRlYnVnTWF0Y2gudjtcbiAgICBjb25zdCBkdCA9IHdpbmRvdy5kZWJ1Z01hdGNoLnQ7XG4gICAgY29uc3QgZEtJbnZIID0gW1xuICAgICAgW2R2WzBdWzBdLGR2WzFdWzBdLGR0WzBdXSxcbiAgICAgIFtkdlswXVsxXSxkdlsxXVsxXSxkdFsxXV0sXG4gICAgICBbZHZbMF1bMl0sZHZbMV1bMl0sZHRbMl1dXG4gICAgXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgICAgaWYoIXdpbmRvdy5jbXAoX0tJbnZILmRhdGFbaV1bal0sIGRLSW52SFtpXVtqXSkpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIklOQ09SUkVDVCBLSW52SFwiLCBpLCBqLCBLSW52SC5kYXRhLCBkS0ludkgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgbm9ybTEgPSBNYXRoLnNxcnQoIEtJbnZIWzBdICogS0ludkhbMF0gKyBLSW52SFszXSAqIEtJbnZIWzNdICsgS0ludkhbNl0gKiBLSW52SFs2XSk7XG4gIGNvbnN0IG5vcm0yID0gTWF0aC5zcXJ0KCBLSW52SFsxXSAqIEtJbnZIWzFdICsgS0ludkhbNF0gKiBLSW52SFs0XSArIEtJbnZIWzddICogS0ludkhbN10pO1xuICBjb25zdCB0bm9ybSA9IChub3JtMSArIG5vcm0yKSAvIDI7XG5cbiAgY29uc3Qgcm90YXRlID0gW107XG4gIHJvdGF0ZVswXSA9IEtJbnZIWzBdIC8gbm9ybTE7XG4gIHJvdGF0ZVszXSA9IEtJbnZIWzNdIC8gbm9ybTE7XG4gIHJvdGF0ZVs2XSA9IEtJbnZIWzZdIC8gbm9ybTE7XG5cbiAgcm90YXRlWzFdID0gS0ludkhbMV0gLyBub3JtMjtcbiAgcm90YXRlWzRdID0gS0ludkhbNF0gLyBub3JtMjtcbiAgcm90YXRlWzddID0gS0ludkhbN10gLyBub3JtMjtcblxuICByb3RhdGVbMl0gPSByb3RhdGVbM10gKiByb3RhdGVbN10gLSByb3RhdGVbNl0gKiByb3RhdGVbNF07XG4gIHJvdGF0ZVs1XSA9IHJvdGF0ZVs2XSAqIHJvdGF0ZVsxXSAtIHJvdGF0ZVswXSAqIHJvdGF0ZVs3XTtcbiAgcm90YXRlWzhdID0gcm90YXRlWzBdICogcm90YXRlWzRdIC0gcm90YXRlWzFdICogcm90YXRlWzNdO1xuXG4gIGNvbnN0IG5vcm0zID0gTWF0aC5zcXJ0KHJvdGF0ZVsyXSAqIHJvdGF0ZVsyXSArIHJvdGF0ZVs1XSAqIHJvdGF0ZVs1XSArIHJvdGF0ZVs4XSAqIHJvdGF0ZVs4XSk7XG4gIHJvdGF0ZVsyXSAvPSBub3JtMztcbiAgcm90YXRlWzVdIC89IG5vcm0zO1xuICByb3RhdGVbOF0gLz0gbm9ybTM7XG5cbiAgLy8gVE9ETzogYXJ0b29sa2l0IGhhcyBjaGVja19yb3RhdGlvbigpIHRoYXQgc29tZWhvdyBzd2l0Y2ggdGhlIHJvdGF0ZSB2ZWN0b3IuIG5vdCBzdXJlIHdoYXQgdGhhdCBkb2VzLiBDYW4gYW55b25lIGFkdmljZT9cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FydG9vbGtpdHgvYXJ0b29sa2l0NS9ibG9iLzViZjBiNjcxZmYxNmVhZDUyN2I5Yjg5MmU2YWViMWEyNzcxZjk3YmUvbGliL1NSQy9BUklDUC9pY3BVdGlsLmMjTDIxNVxuXG4gIGNvbnN0IHRyYW4gPSBbXVxuICB0cmFuWzBdID0gS0ludkhbMl0gLyB0bm9ybTtcbiAgdHJhblsxXSA9IEtJbnZIWzVdIC8gdG5vcm07XG4gIHRyYW5bMl0gPSBLSW52SFs4XSAvIHRub3JtO1xuXG4gIGxldCBpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtID0gW1xuICAgIFtyb3RhdGVbMF0sIHJvdGF0ZVsxXSwgcm90YXRlWzJdLCB0cmFuWzBdXSxcbiAgICBbcm90YXRlWzNdLCByb3RhdGVbNF0sIHJvdGF0ZVs1XSwgdHJhblsxXV0sXG4gICAgW3JvdGF0ZVs2XSwgcm90YXRlWzddLCByb3RhdGVbOF0sIHRyYW5bMl1dXG4gIF07XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19NQVRDSCkge1xuICAgIGNvbnNvbGUubG9nKFwiaW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybVwiLCBpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtLCB3aW5kb3cuZGVidWdNYXRjaC5pbml0TWF0WHcyWGMpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybS5sZW5ndGg7IGorKykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtW2pdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghd2luZG93LmNtcChpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtW2pdW2ldLCB3aW5kb3cuZGVidWdNYXRjaC5pbml0TWF0WHcyWGNbal1baV0sIDAuMDAwMSkpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIklOQ09SUkVDVCBpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtXCIsIGosIGksIGluaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm1bal1baV0sIHdpbmRvdy5kZWJ1Z01hdGNoLmluaXRNYXRYdzJYY1tqXVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlc3RpbWF0ZUhvbW9ncmFwaHlcbn1cbiIsImNvbnN0IHtNYXRyaXgsIGludmVyc2V9ID0gcmVxdWlyZSgnbWwtbWF0cml4Jyk7XG5jb25zdCB7Z2V0UHJvamVjdGlvblRyYW5zZm9ybSwgYXBwbHlNb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtLCBidWlsZE1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm0sIGNvbXB1dGVTY3JlZW5Db29yZGlhdGV9ID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xuXG4vLyBUT0RPOiB0aGUgZXJyb3IgY29tcHV0YXRpb24gc2VlbXMgcHJvYmxlbWF0aWMuIHNob3VsZCBpdCBiZSByZWxhdGl2ZSB0byB0aGUgc2l6ZSBvZiBkZXRlY3Rpb24/XG4vLyAgICAgICBub3cgdGhlIHZhbHVlcyBhcmUgaGFyZGNvZGVkLCBlLmcuIEsyX0ZhY3RvciA9IDRcblxuY29uc3QgSzJfRkFDVE9SID0gNC4wO1xuY29uc3QgSUNQX01BWF9MT09QID0gMTA7XG5jb25zdCBJQ1BfQlJFQUtfTE9PUF9FUlJPUl9USFJFU0ggPSAwLjE7XG5jb25zdCBJQ1BfQlJFQUtfTE9PUF9FUlJPUl9SQVRJT19USFJFU0ggPSAwLjk5O1xuY29uc3QgSUNQX0JSRUFLX0xPT1BfRVJST1JfVEhSRVNIMiA9IDQuMDtcblxuLy8gSUNQIGl0ZXJhdGlvbiB3aXRoIHBvaW50c1xuLy8gQ2FuIHNvbWVvbmUgcHJvdmlkZSB0aGVvcmV0aWNhbCByZWZlcmVuY2U/XG5jb25zdCByZWZpbmVIb21vZ3JhcGh5ID0gKHtpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtLCBwcm9qZWN0aW9uVHJhbnNmb3JtLCB3b3JsZENvb3Jkcywgc2NyZWVuQ29vcmRzLCBpc1JvYnVzdE1vZGUsIGlubGllclByb2J9KSA9PiB7XG4gIGxldCBtb2RlbFZpZXdUcmFuc2Zvcm0gPSBpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtO1xuXG4gIGxldCBlcnIwID0gMC4wO1xuICBsZXQgZXJyMSA9IDAuMDtcbiAgZm9yIChsZXQgbCA9IDA7IGwgPD0gSUNQX01BWF9MT09QOyBsKyspIHtcblxuICAgIGNvbnN0IG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm0gPSBidWlsZE1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm0ocHJvamVjdGlvblRyYW5zZm9ybSwgbW9kZWxWaWV3VHJhbnNmb3JtKTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfTUFUQ0gpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJwcm9qZWN0aW9uVHJhbnNmb3JtXCIsIHByb2plY3Rpb25UcmFuc2Zvcm0pO1xuICAgICAgaWYgKCF3aW5kb3cuY21wMkRBcnJheShtb2RlbFZpZXdUcmFuc2Zvcm0sIHdpbmRvdy5kZWJ1Z01hdGNoLmljcF9tYXRYdzJYY1tsXSkpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJTkNPUlJFQ1QgSUNQIG1vZGVsVmlld1RyYW5zZm9ybVwiLCBsLCBtb2RlbFZpZXdUcmFuc2Zvcm0sIHdpbmRvdy5kZWJ1Z01hdGNoLmljcF9tYXRYdzJYY1tsXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghd2luZG93LmNtcDJEQXJyYXkobW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybSwgd2luZG93LmRlYnVnTWF0Y2guaWNwX21hdFh3MlVbbF0pKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSU5DT1JSRUNUIElDUCBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtXCIsIGwsIG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm0sIHdpbmRvdy5kZWJ1Z01hdGNoLmljcF9tYXRYdzJVW2xdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBFID0gW107XG4gICAgY29uc3QgZHhzID0gW107XG4gICAgY29uc3QgZHlzID0gW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCB3b3JsZENvb3Jkcy5sZW5ndGg7IG4rKykge1xuICAgICAgY29uc3QgdSA9IGNvbXB1dGVTY3JlZW5Db29yZGlhdGUobW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybSwgd29ybGRDb29yZHNbbl0ueCwgd29ybGRDb29yZHNbbl0ueSwgd29ybGRDb29yZHNbbl0ueik7XG4gICAgICBjb25zdCBkeCA9IHNjcmVlbkNvb3Jkc1tuXS54IC0gdS54O1xuICAgICAgY29uc3QgZHkgPSBzY3JlZW5Db29yZHNbbl0ueSAtIHUueTtcbiAgICAgIGR4cy5wdXNoKGR4KTtcbiAgICAgIGR5cy5wdXNoKGR5KTtcbiAgICAgIEUucHVzaChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19UUkFDSyAmJiBpc1JvYnVzdE1vZGUpIHtcbiAgICAgIGNvbnN0IGRyID0gd2luZG93LmRlYnVnTWF0Y2guaWNwX3JvYnVzdFt3aW5kb3cuZGVidWcuaWNwcm9idXN0SW5kZXhdW2xdO1xuICAgICAgLy9jb25zb2xlLmxvZyhcImljcCBFXCIsIEUsIGRyLkUpO1xuICAgIH1cblxuICAgIGxldCBLMjsgLy8gcm9idXN0IG1vZGUgb25seVxuICAgIGVycjEgPSAwLjA7XG4gICAgaWYgKGlzUm9idXN0TW9kZSkge1xuICAgICAgY29uc3QgaW5saWVyTnVtID0gTWF0aC5tYXgoMywgTWF0aC5mbG9vcih3b3JsZENvb3Jkcy5sZW5ndGggKiBpbmxpZXJQcm9iKSAtIDEpO1xuICAgICAgY29uc3QgRTIgPSBbXTsgLy8gZm9yIHJvYnVzdCBtb2RlIG9ubHlcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgd29ybGRDb29yZHMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgRTIucHVzaChFW25dKTtcbiAgICAgIH1cbiAgICAgIEUyLnNvcnQoKGEsIGIpID0+IHtyZXR1cm4gYS1iO30pO1xuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkRFQlVHX1RSQUNLICYmIGlzUm9idXN0TW9kZSkge1xuICAgICAgICBjb25zdCBkciA9IHdpbmRvdy5kZWJ1Z01hdGNoLmljcF9yb2J1c3Rbd2luZG93LmRlYnVnLmljcHJvYnVzdEluZGV4XVtsXTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImljcCBFXCIsIEUyLCBkci5FMik7XG4gICAgICB9XG5cbiAgICAgIEsyID0gTWF0aC5tYXgoRTJbaW5saWVyTnVtXSAqIEsyX0ZBQ1RPUiwgMTYuMCk7XG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IHdvcmxkQ29vcmRzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGlmIChFMltuXSA+IEsyKSBlcnIxICs9IEsyLyA2O1xuICAgICAgICBlbHNlIGVycjEgKz0gIEsyLzYuMCAqICgxLjAgLSAoMS4wLUUyW25dL0syKSooMS4wLUUyW25dL0syKSooMS4wLUUyW25dL0syKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgd29ybGRDb29yZHMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgZXJyMSArPSBFW25dO1xuICAgICAgfVxuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKFwiZXJyMSBiZWZvcmVcIiwgZXJyMSwgZXJyMS93b3JsZENvb3Jkcy5sZW5ndGgpO1xuICAgIGVycjEgLz0gd29ybGRDb29yZHMubGVuZ3RoO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19NQVRDSCkge1xuICAgICAgLy9pZiAoIXdpbmRvdy5jbXAoZXJyMSwgd2luZG93LmRlYnVnTWF0Y2guaWNwX2VycjFbbF0pKSB7XG4gICAgICAvLyAgY29uc29sZS5sb2coXCJJTkNPUlJFQ1QgSUNQIGVycjFcIiwgbCwgZXJyMSwgd2luZG93LmRlYnVnTWF0Y2guaWNwX2VycjFbbF0pO1xuICAgICAgLy99XG4gICAgfVxuXG4gICAgaWYgKGVycjEgPCBJQ1BfQlJFQUtfTE9PUF9FUlJPUl9USFJFU0gpIGJyZWFrO1xuICAgIGlmIChsID4gMCAmJiBlcnIxIDwgSUNQX0JSRUFLX0xPT1BfRVJST1JfVEhSRVNIMiAmJiBlcnIxL2VycjAgPiBJQ1BfQlJFQUtfTE9PUF9FUlJPUl9SQVRJT19USFJFU0gpIGJyZWFrO1xuICAgIGlmIChsID09PSBJQ1BfTUFYX0xPT1ApIGJyZWFrO1xuXG4gICAgZXJyMCA9IGVycjE7XG5cbiAgICBjb25zdCBkVSA9IFtdO1xuICAgIGNvbnN0IGFsbEpfVV9TID0gW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCB3b3JsZENvb3Jkcy5sZW5ndGg7IG4rKykge1xuICAgICAgaWYgKGlzUm9idXN0TW9kZSAmJiBFW25dID4gSzIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IEpfVV9TID0gX2dldEpfVV9TKHttb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtLCBtb2RlbFZpZXdUcmFuc2Zvcm0sIHByb2plY3Rpb25UcmFuc2Zvcm0sIHdvcmxkQ29vcmQ6IHdvcmxkQ29vcmRzW25dfSk7XG5cbiAgICAgIGlmIChpc1JvYnVzdE1vZGUpIHtcbiAgICAgICAgY29uc3QgVyA9ICgxLjAgLSBFW25dL0syKSooMS4wIC0gRVtuXS9LMik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19UUkFDSyAmJiBpc1JvYnVzdE1vZGUpIHtcbiAgICAgICAgICBjb25zdCBkciA9IHdpbmRvdy5kZWJ1Z01hdGNoLmljcF9yb2J1c3Rbd2luZG93LmRlYnVnLmljcHJvYnVzdEluZGV4XVtsXTtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiaWNwIFdcIiwgVywgZHIuVyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI7IGorKykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBKX1VfU1tqXVtpXSAqPSBXO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkVS5wdXNoKFtkeHNbbl0gKiBXXSk7XG4gICAgICAgIGRVLnB1c2goW2R5c1tuXSAqIFddKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRVLnB1c2goW2R4c1tuXV0pO1xuICAgICAgICBkVS5wdXNoKFtkeXNbbl1dKTtcbiAgICAgIH1cblxuICAgICAgLy9jb25zb2xlLmxvZyhcIkpfVV9TXCIsIEpfVV9TLCBkZWJ1Z0NvbnRlbnQuaWNwX0pfVV9TW2xdW25dKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSl9VX1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWxsSl9VX1MucHVzaChKX1VfU1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19UUkFDSyAmJiBpc1JvYnVzdE1vZGUpIHtcbiAgICAgIGNvbnN0IGRyID0gd2luZG93LmRlYnVnTWF0Y2guaWNwX3JvYnVzdFt3aW5kb3cuZGVidWcuaWNwcm9idXN0SW5kZXhdW2xdO1xuICAgICAgLy9jb25zb2xlLmxvZyhcImljcCBkdVwiLCBkVSwgZHIuZFUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfTUFUQ0gpIHtcbiAgICAgIGlmICghd2luZG93LmNtcEFycmF5KGRVLCB3aW5kb3cuZGVidWdNYXRjaC5pY3BfZFVbbF0sIDAuMDAxKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIklOQ09SUkVDVCBJQ1AgZFVcIiwgbCwgZFUsIHdpbmRvdy5kZWJ1Z01hdGNoLmljcF9kVVtsXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfTUFUQ0gpIHtcbiAgICAgIGNvbnN0IGRKVVMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2luZG93LmRlYnVnTWF0Y2guaWNwX0pfVV9TW2xdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRKVVMucHVzaCh3aW5kb3cuZGVidWdNYXRjaC5pY3BfSl9VX1NbbF1baV1bMF0pO1xuICAgICAgICBkSlVTLnB1c2god2luZG93LmRlYnVnTWF0Y2guaWNwX0pfVV9TW2xdW2ldWzFdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF3aW5kb3cuY21wMkRBcnJheShhbGxKX1VfUywgZEpVUywgMC4wMDEpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSU5DT1JSRUNUIElDUCBKX1VfU1wiLCBsLCBhbGxKX1VfUywgZEpVUyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZFMgPSBfZ2V0RGVsdGFTKHtkVSwgSl9VX1M6IGFsbEpfVV9TfSk7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19NQVRDSCkge1xuICAgICAgaWYgKCF3aW5kb3cuY21wQXJyYXkoZFMsIHdpbmRvdy5kZWJ1Z01hdGNoLmljcF9kU1tsXSwgMC4wMDEpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSU5DT1JSRUNUIElDUCBkU1wiLCBsLCBkUywgd2luZG93LmRlYnVnTWF0Y2guaWNwX2RTW2xdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZFMgPT09IG51bGwpIGJyZWFrO1xuICAgIG1vZGVsVmlld1RyYW5zZm9ybSA9IF91cGRhdGVNb2RlbFZpZXdUcmFuc2Zvcm0oe21vZGVsVmlld1RyYW5zZm9ybSwgZFN9KTtcbiAgfVxuICByZXR1cm4ge21vZGVsVmlld1RyYW5zZm9ybSwgZXJyOiBlcnIxfTtcbn1cblxuX3VwZGF0ZU1vZGVsVmlld1RyYW5zZm9ybSA9ICh7bW9kZWxWaWV3VHJhbnNmb3JtLCBkU30pID0+IHtcbiAgY29uc3QgcSA9IFtdO1xuICBsZXQgcmEgPSBkU1swXSAqIGRTWzBdICsgZFNbMV0gKiBkU1sxXSArIGRTWzJdICogZFNbMl07XG4gIGlmKCByYSA8IDAuMDAwMDAxICkge1xuICAgIHFbMF0gPSAxLjA7XG4gICAgcVsxXSA9IDAuMDtcbiAgICBxWzJdID0gMC4wO1xuICAgIHFbM10gPSAwLjA7XG4gIH0gZWxzZSB7XG4gICAgcmEgPSBNYXRoLnNxcnQocmEpO1xuICAgIHFbMF0gPSBkU1swXSAvIHJhO1xuICAgIHFbMV0gPSBkU1sxXSAvIHJhO1xuICAgIHFbMl0gPSBkU1syXSAvIHJhO1xuICAgIHFbM10gPSByYTtcbiAgfVxuICBxWzRdID0gZFNbM107XG4gIHFbNV0gPSBkU1s0XTtcbiAgcVs2XSA9IGRTWzVdO1xuXG4gIGNvbnN0IGNyYSA9IE1hdGguY29zKHFbM10pO1xuICBjb25zdCBvbmVfY3JhID0gMS4wIC0gY3JhO1xuICBjb25zdCBzcmEgPSBNYXRoLnNpbihxWzNdKTtcbiAgY29uc3QgbWF0ID0gW1tdLFtdLFtdXTtcblxuICBtYXRbMF1bMF0gPSBxWzBdKnFbMF0qb25lX2NyYSArIGNyYTtcbiAgbWF0WzBdWzFdID0gcVswXSpxWzFdKm9uZV9jcmEgLSBxWzJdKnNyYTtcbiAgbWF0WzBdWzJdID0gcVswXSpxWzJdKm9uZV9jcmEgKyBxWzFdKnNyYTtcbiAgbWF0WzBdWzNdID0gcVs0XTtcbiAgbWF0WzFdWzBdID0gcVsxXSpxWzBdKm9uZV9jcmEgKyBxWzJdKnNyYTtcbiAgbWF0WzFdWzFdID0gcVsxXSpxWzFdKm9uZV9jcmEgKyBjcmE7XG4gIG1hdFsxXVsyXSA9IHFbMV0qcVsyXSpvbmVfY3JhIC0gcVswXSpzcmE7XG4gIG1hdFsxXVszXSA9IHFbNV07XG4gIG1hdFsyXVswXSA9IHFbMl0qcVswXSpvbmVfY3JhIC0gcVsxXSpzcmE7XG4gIG1hdFsyXVsxXSA9IHFbMl0qcVsxXSpvbmVfY3JhICsgcVswXSpzcmE7XG4gIG1hdFsyXVsyXSA9IHFbMl0qcVsyXSpvbmVfY3JhICsgY3JhO1xuICBtYXRbMl1bM10gPSBxWzZdO1xuXG4gIGNvbnN0IG1hdDIgPSBbW10sW10sW11dO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKyApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKyApIHtcbiAgICAgIG1hdDJbal1baV0gPSBtb2RlbFZpZXdUcmFuc2Zvcm1bal1bMF0gKiBtYXRbMF1baV1cbiAgICAgICAgICAgICAgICAgICArIG1vZGVsVmlld1RyYW5zZm9ybVtqXVsxXSAqIG1hdFsxXVtpXVxuICAgICAgICAgICAgICAgICAgICsgbW9kZWxWaWV3VHJhbnNmb3JtW2pdWzJdICogbWF0WzJdW2ldO1xuICAgIH1cbiAgICBtYXQyW2pdWzNdICs9IG1vZGVsVmlld1RyYW5zZm9ybVtqXVszXTtcbiAgfVxuICByZXR1cm4gbWF0Mjtcbn1cblxuX2dldERlbHRhUyA9ICh7ZFUsIEpfVV9TfSkgPT4ge1xuICBjb25zdCBKID0gbmV3IE1hdHJpeChKX1VfUyk7XG4gIGNvbnN0IFUgPSBuZXcgTWF0cml4KGRVKTtcblxuICBjb25zdCBKVCA9IEoudHJhbnNwb3NlKCk7XG4gIGNvbnN0IEpUSiA9IEpULm1tdWwoSik7XG4gIGNvbnN0IEpUVSA9IEpULm1tdWwoVSk7XG5cbiAgbGV0IEpUSkludjtcbiAgdHJ5IHtcbiAgICBKVEpJbnYgPSBpbnZlcnNlKEpUSik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IFMgPSBKVEpJbnYubW11bChKVFUpO1xuICByZXR1cm4gUy50bzFEQXJyYXkoKTtcbn1cblxuX2dldEpfVV9TID0gKHttb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtLCBtb2RlbFZpZXdUcmFuc2Zvcm0sIHByb2plY3Rpb25UcmFuc2Zvcm0sIHdvcmxkQ29vcmR9KSA9PiB7XG4gIGNvbnN0IFQgPSBtb2RlbFZpZXdUcmFuc2Zvcm07XG4gIGNvbnN0IHt4LCB5LCB6fSA9IHdvcmxkQ29vcmQ7XG5cbiAgY29uc3QgdSA9IGFwcGx5TW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybShtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtLCB4LCB5LCB6KTtcbiAgLy9jb25zb2xlLmxvZyhcInVcIiwgdSk7XG4gIC8vaWYgKE1hdGguYWJzKHUueikgPCAwLjAwMDAwMSkgcmV0dXJuIG51bGw7XG5cbiAgY29uc3QgejIgPSB1LnogKiB1Lno7XG4gIGNvbnN0IEpfVV9YYyA9IFtbXSxbXV07XG4gIEpfVV9YY1swXVswXSA9IChwcm9qZWN0aW9uVHJhbnNmb3JtWzBdWzBdICogdS56IC0gcHJvamVjdGlvblRyYW5zZm9ybVsyXVswXSAqIHUueCkgLyB6MjtcbiAgSl9VX1hjWzBdWzFdID0gKHByb2plY3Rpb25UcmFuc2Zvcm1bMF1bMV0gKiB1LnogLSBwcm9qZWN0aW9uVHJhbnNmb3JtWzJdWzFdICogdS54KSAvIHoyO1xuICBKX1VfWGNbMF1bMl0gPSAocHJvamVjdGlvblRyYW5zZm9ybVswXVsyXSAqIHUueiAtIHByb2plY3Rpb25UcmFuc2Zvcm1bMl1bMl0gKiB1LngpIC8gejI7XG4gIEpfVV9YY1sxXVswXSA9IChwcm9qZWN0aW9uVHJhbnNmb3JtWzFdWzBdICogdS56IC0gcHJvamVjdGlvblRyYW5zZm9ybVsyXVswXSAqIHUueSkgLyB6MjtcbiAgSl9VX1hjWzFdWzFdID0gKHByb2plY3Rpb25UcmFuc2Zvcm1bMV1bMV0gKiB1LnogLSBwcm9qZWN0aW9uVHJhbnNmb3JtWzJdWzFdICogdS55KSAvIHoyO1xuICBKX1VfWGNbMV1bMl0gPSAocHJvamVjdGlvblRyYW5zZm9ybVsxXVsyXSAqIHUueiAtIHByb2plY3Rpb25UcmFuc2Zvcm1bMl1bMl0gKiB1LnkpIC8gejI7XG5cbiAgY29uc3QgSl9YY19TID0gW1xuICAgIFtUWzBdWzJdICogeSAtIFRbMF1bMV0gKiB6LCBUWzBdWzBdICogeiAtIFRbMF1bMl0gKiB4LCBUWzBdWzFdICogeCAtIFRbMF1bMF0gKiB5LCBUWzBdWzBdLCBUWzBdWzFdLCBUWzBdWzJdXSxcbiAgICBbVFsxXVsyXSAqIHkgLSBUWzFdWzFdICogeiwgVFsxXVswXSAqIHogLSBUWzFdWzJdICogeCwgVFsxXVsxXSAqIHggLSBUWzFdWzBdICogeSwgVFsxXVswXSwgVFsxXVsxXSwgVFsxXVsyXV0sXG4gICAgW1RbMl1bMl0gKiB5IC0gVFsyXVsxXSAqIHosIFRbMl1bMF0gKiB6IC0gVFsyXVsyXSAqIHgsIFRbMl1bMV0gKiB4IC0gVFsyXVswXSAqIHksIFRbMl1bMF0sIFRbMl1bMV0sIFRbMl1bMl1dLFxuICBdO1xuXG4gIC8vY29uc29sZS5sb2coXCJKX1hjX1NcIiwgSl9YY19TLCAnLS12cy0tJywgJzAuJywgZGVidWdDb250ZW50LmljcF9KX1hjX1NbMF0sICcxLicsIGRlYnVnQ29udGVudC5pY3BfSl9YY19TWzFdKTtcbiAgLy9jb25zb2xlLmxvZyhcIkpfVV9YY1wiLCBKX1VfWGMsICctLXZzLS0nLCAnMC4nLCBkZWJ1Z0NvbnRlbnQuaWNwX0pfVV9YY1swXSwgJzEuJywgZGVidWdDb250ZW50LmljcF9KX1VfWGNbMV0pO1xuXG4gIGNvbnN0IEpfVV9TID0gW1tdLCBbXV07XG4gIGZvciAobGV0IGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgIEpfVV9TW2pdW2ldID0gMC4wO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCAzOyBrKysgKSB7XG4gICAgICAgIEpfVV9TW2pdW2ldICs9IEpfVV9YY1tqXVtrXSAqIEpfWGNfU1trXVtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIEpfVV9TO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVmaW5lSG9tb2dyYXBoeVxufVxuIiwiLypcbmNvbnN0IGdldFByb2plY3Rpb25UcmFuc2Zvcm0gPSAoKSA9PiB7XG4gIC8vIFRPRE86IG5vbi1oYXJkY29kZWQgY2FtZXJhIG1hdHJpeD9cbiAgLy8gICAgIFtmeCAgcyBjeF1cbiAgLy8gSyA9IFsgMCBmeCBjeV1cbiAgLy8gICAgIFsgMCAgMCAgMV1cbiAgY29uc3QgS0RhdGEgPSBbXG4gICAgWyAzMDQuNjgyNzA0NTkzMzUwMjUsIDAsIDE2MS43MjM5NTMyNDcwNzAzXSxcbiAgICBbIDAsIDMwMy4yNjA2MTE4MDE1NTM3LCAxMTguODAzMjY4NDMyNjE3MTldLFxuICAgIFsgMCwgMCwgMS4wXVxuICBdO1xuICByZXR1cm4gS0RhdGE7XG59XG4qL1xuXG5jb25zdCBidWlsZE1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm0gPSAocHJvamVjdGlvblRyYW5zZm9ybSwgbW9kZWxWaWV3VHJhbnNmb3JtKSA9PiB7XG4gIGNvbnN0IG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm0gPSBbW10sW10sW11dO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKyApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybVtqXVtpXSA9IHByb2plY3Rpb25UcmFuc2Zvcm1bal1bMF0gKiBtb2RlbFZpZXdUcmFuc2Zvcm1bMF1baV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBwcm9qZWN0aW9uVHJhbnNmb3JtW2pdWzFdICogbW9kZWxWaWV3VHJhbnNmb3JtWzFdW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgcHJvamVjdGlvblRyYW5zZm9ybVtqXVsyXSAqIG1vZGVsVmlld1RyYW5zZm9ybVsyXVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm07XG59XG5cbmNvbnN0IGFwcGx5TW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybSA9IChtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtLCB4LCB5LCB6KSA9PiB7XG4gIGNvbnN0IHV4ID0gbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybVswXVswXSAqIHggKyBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzBdWzFdICogeVxuICAgICArIG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1bMF1bMl0gKiB6ICsgbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybVswXVszXTtcbiAgY29uc3QgdXkgPSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzFdWzBdICogeCArIG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1bMV1bMV0gKiB5XG4gICAgICsgbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybVsxXVsyXSAqIHogKyBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzFdWzNdO1xuICBjb25zdCB1eiAgPSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzJdWzBdICogeCArIG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1bMl1bMV0gKiB5XG4gICAgICsgbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybVsyXVsyXSAqIHogKyBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzJdWzNdO1xuICByZXR1cm4ge3g6IHV4LCB5OiB1eSwgejogdXp9O1xufVxuXG5jb25zdCBjb21wdXRlU2NyZWVuQ29vcmRpYXRlID0gKG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm0sIHgsIHksIHopID0+IHtcbiAgY29uc3Qge3g6IHV4LCB5OiB1eSwgejogdXp9ID0gYXBwbHlNb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtKG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm0sIHgsIHksIHopO1xuICAvL2NvbnNvbGUubG9nKFwieCwgeSwgelwiLCB1eCwgdXksIHV6KTtcbiAgaWYoIE1hdGguYWJzKHV6KSA8IDAuMDAwMDAxICkgcmV0dXJuIG51bGw7XG4gIHJldHVybiB7eDogdXgvdXosIHk6IHV5L3V6fTtcbn1cblxuY29uc3Qgc2NyZWVuVG9NYXJrZXJDb29yZGluYXRlID0gKG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm0sIHN4LCBzeSkgPT4ge1xuICBjb25zdCBjMTEgPSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzJdWzBdICogc3ggLSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzBdWzBdO1xuICBjb25zdCBjMTIgPSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzJdWzFdICogc3ggLSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzBdWzFdO1xuICBjb25zdCBjMjEgPSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzJdWzBdICogc3kgLSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzFdWzBdO1xuICBjb25zdCBjMjIgPSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzJdWzFdICogc3kgLSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzFdWzFdO1xuICBjb25zdCBiMSAgPSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzBdWzNdIC0gbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybVsyXVszXSAqIHN4O1xuICBjb25zdCBiMiAgPSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtWzFdWzNdIC0gbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybVsyXVszXSAqIHN5O1xuXG4gIGNvbnN0IG0gPSBjMTEgKiBjMjIgLSBjMTIgKiBjMjE7XG4gIHJldHVybiB7XG4gICAgeDogKGMyMiAqIGIxIC0gYzEyICogYjIpIC8gbSxcbiAgICB5OiAoYzExICogYjIgLSBjMjEgKiBiMSkgLyBtXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNjcmVlblRvTWFya2VyQ29vcmRpbmF0ZSxcbiAgLy9nZXRQcm9qZWN0aW9uVHJhbnNmb3JtLFxuICBidWlsZE1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm0sXG4gIGFwcGx5TW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybSxcbiAgY29tcHV0ZVNjcmVlbkNvb3JkaWF0ZVxufVxuIiwiY29uc3Qge3Jlc2l6ZX0gPSByZXF1aXJlKFwiLi91dGlscy9pbWFnZXMuanNcIik7XG5cbi8vY29uc3QgREVGQVVMVF9EUEkgPSA3MjtcbmNvbnN0IERFRkFVTFRfRFBJID0gMTtcbmNvbnN0IE1JTl9JTUFHRV9QSVhFTF9TSVpFID0gMjg7XG5cbi8vIHJldHVybiBsaXN0IG9mIHtkYXRhLCB3aWR0aCwgaGVpZ2h0LCBkcGl9XG5jb25zdCBidWlsZEltYWdlTGlzdCA9IChpbnB1dEltYWdlKSA9PiB7XG4gIGNvbnN0IGRwaSA9IERFRkFVTFRfRFBJO1xuICBjb25zdCBtaW5EcGkgPSBNYXRoLmZsb29yKDEuMCAqIE1JTl9JTUFHRV9QSVhFTF9TSVpFIC8gTWF0aC5taW4oaW5wdXRJbWFnZS53aWR0aCwgaW5wdXRJbWFnZS5oZWlnaHQpICogZHBpICogMTAwMCkgLyAxMDAwO1xuICBjb25zdCBkcGlMaXN0ID0gW107XG5cbiAgbGV0IGMgPSBtaW5EcGk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgZHBpTGlzdC5wdXNoKGMpO1xuICAgIGMgKj0gTWF0aC5wb3coMi4wLCAxLjAvMy4wKTtcbiAgICBjID0gTWF0aC5mcm91bmQoYyk7IC8vIGNhbiByZW1vdmUgdGhpcyBsaW5lIGluIHByb2R1Y3Rpb24uIHRyeWluZyB0byByZXByb2R1Y2UgdGhlIHNhbWUgcmVzdWx0IGFzIGFydG9vbGtpdCwgd2hpY2ggdXNlIGZsb2F0LlxuICAgIGlmIChjID49IGRwaSAqIDAuOTUpIHtcbiAgICAgIGMgPSBkcGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgZHBpTGlzdC5wdXNoKGMpO1xuICBkcGlMaXN0LnJldmVyc2UoKTtcblxuICBjb25zdCBpbWFnZUxpc3QgPSBbXTsgLy8gbGlzdCBvZiB7ZGF0YTogW3dpZHRoIHggaGVpZ2h0XSwgd2lkdGgsIGhlaWdodH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcGlMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdyA9IGlucHV0SW1hZ2Uud2lkdGggKiBkcGlMaXN0W2ldIC8gZHBpO1xuICAgIGNvbnN0IGggPSBpbnB1dEltYWdlLmhlaWdodCAqIGRwaUxpc3RbaV0gLyBkcGk7XG4gICAgaW1hZ2VMaXN0LnB1c2goT2JqZWN0LmFzc2lnbihyZXNpemUoe2ltYWdlOiBpbnB1dEltYWdlLCByYXRpbzogZHBpTGlzdFtpXS9kcGl9KSwge2RwaTogZHBpTGlzdFtpXX0pKTtcbiAgfVxuXG4gIC8vcmV0dXJuIFtpbWFnZUxpc3RbMF1dO1xuXG4gIHJldHVybiBpbWFnZUxpc3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBidWlsZEltYWdlTGlzdFxufVxuIiwiY29uc3Qge3Jlc2l6ZX0gPSByZXF1aXJlKFwiLi91dGlscy9pbWFnZXMuanNcIik7XG5jb25zdCB7YnVpbGRJbWFnZUxpc3R9ID0gcmVxdWlyZSgnLi9pbWFnZS1saXN0LmpzJyk7XG5jb25zdCB7TWF0Y2hlcn0gPSByZXF1aXJlKCcuL21hdGNoaW5nL21hdGNoZXIuanMnKTtcbi8vY29uc3Qge1RyYWNrZXI6IFRyYWNrZXJ9ID0gcmVxdWlyZSgnLi90cmFja2luZy90cmFja2VyLmpzJyk7XG5jb25zdCB7VHJhY2tlcjogVHJhY2tlcn0gPSByZXF1aXJlKCcuL3RyYWNraW5nR1BVL3RyYWNrZXIuanMnKTtcbmNvbnN0IHtlc3RpbWF0ZUhvbW9ncmFwaHl9ID0gcmVxdWlyZSgnLi9pY3AvZXN0aW1hdGVfaG9tb2dyYXBoeS5qcycpO1xuY29uc3Qge3JlZmluZUhvbW9ncmFwaHl9ID0gcmVxdWlyZSgnLi9pY3AvcmVmaW5lX2hvbW9ncmFwaHknKTtcblxuY2xhc3MgSW1hZ2VUYXJnZXQge1xuICBjb25zdHJ1Y3Rvcih7cHJvamVjdGlvblRyYW5zZm9ybSwgaW1hZ2VMaXN0LCBtYXRjaGluZ0RhdGEsIHRyYWNraW5nRGF0YSwgdGFyZ2V0SW1hZ2V9KSB7XG4gICAgdGhpcy5pbWFnZUxpc3QgPSBpbWFnZUxpc3Q7XG4gICAgdGhpcy5tYXRjaGluZ0RhdGEgPSBtYXRjaGluZ0RhdGE7XG4gICAgdGhpcy50cmFja2luZ0RhdGEgPSB0cmFja2luZ0RhdGE7XG4gICAgdGhpcy50YXJnZXRJbWFnZSA9IHRhcmdldEltYWdlO1xuICAgIHRoaXMucHJvamVjdGlvblRyYW5zZm9ybSA9IHByb2plY3Rpb25UcmFuc2Zvcm07XG5cbiAgICB0aGlzLm1hdGNoZXIgPSBuZXcgTWF0Y2hlcihtYXRjaGluZ0RhdGEpO1xuICAgIHRoaXMudHJhY2tlciA9IG5ldyBUcmFja2VyKHRyYWNraW5nRGF0YSwgaW1hZ2VMaXN0LCBwcm9qZWN0aW9uVHJhbnNmb3JtKTtcbiAgICB0aGlzLmlzVHJhY2tpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHNldHVwUXVlcnkocXVlcnlXaWR0aCwgcXVlcnlIZWlnaHQpIHtcbiAgICB0aGlzLnF1ZXJ5V2lkdGggPSBxdWVyeVdpZHRoO1xuICAgIHRoaXMucXVlcnlIZWlnaHQgPSBxdWVyeUhlaWdodDtcbiAgICB0aGlzLnRyYWNrZXIuc2V0dXBRdWVyeShxdWVyeVdpZHRoLCBxdWVyeUhlaWdodCk7XG4gIH1cblxuICBtYXRjaChmZWF0dXJlUG9pbnRzKSB7XG4gICAgY29uc3QgbWF0Y2hSZXN1bHQgPSB0aGlzLm1hdGNoZXIubWF0Y2hEZXRlY3Rpb24odGhpcy5xdWVyeVdpZHRoLCB0aGlzLnF1ZXJ5SGVpZ2h0LCBmZWF0dXJlUG9pbnRzKTtcbiAgICBpZiAobWF0Y2hSZXN1bHQgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3Qge3NjcmVlbkNvb3Jkcywgd29ybGRDb29yZHN9ID0gbWF0Y2hSZXN1bHQ7XG5cbiAgICBjb25zdCBpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtID0gZXN0aW1hdGVIb21vZ3JhcGh5KHtzY3JlZW5Db29yZHMsIHdvcmxkQ29vcmRzLCBwcm9qZWN0aW9uVHJhbnNmb3JtOiB0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm19KTtcbiAgICBjb25zb2xlLmxvZyhcImluaXRpYWwgbWF0Y2hlZCBtb2RlbCB2aWV3IHRyYW5zZm9ybVwiLCBpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtKTtcblxuICAgIGlmIChpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAvL3JldHVybiBpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtO1xuXG4gICAgLy8gVE9ETzogbWF5YmUgZG9uJ3QgdGhpcyByZWZpbmVIb21vZ3JhcGh5LiByZXN1bHQgc2VlbXMgd29yc2Ugd2hlbiB0aGUgZGV0ZWN0ZWQgc2l6ZSBpcyBiaWdcbiAgICBjb25zdCB7bW9kZWxWaWV3VHJhbnNmb3JtOiByZWZpbmVkTW9kZWxWaWV3VHJhbnNmb3JtLCBlcnJ9ID0gcmVmaW5lSG9tb2dyYXBoeSh7aW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybSwgcHJvamVjdGlvblRyYW5zZm9ybTogdGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtLCB3b3JsZENvb3Jkcywgc2NyZWVuQ29vcmRzfSk7XG5cbiAgICB0aGlzLmlzVHJhY2tpbmcgPSB0cnVlO1xuICAgIHRoaXMudHJhY2tlci5kZXRlY3RlZChyZWZpbmVkTW9kZWxWaWV3VHJhbnNmb3JtKTtcbiAgfVxuXG4gIHRyYWNrKGlucHV0KSB7XG4gICAgY29uc3QgdXBkYXRlZE1vZGVsVmlld1RyYW5zZm9ybSA9IHRoaXMudHJhY2tlci50cmFjayhpbnB1dCk7XG4gICAgaWYgKHVwZGF0ZWRNb2RlbFZpZXdUcmFuc2Zvcm0gPT09IG51bGwpIHtcbiAgICAgIHRoaXMuaXNUcmFja2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlZE1vZGVsVmlld1RyYW5zZm9ybTtcbiAgfVxuXG4gIGR1bW15UnVuKGlucHV0KSB7XG4gICAgdGhpcy50cmFja2VyLmRldGVjdGVkKFtbMCwwLDAsMF0sIFswLDAsMCwwXSwgWzAsMCwwLDBdXSk7XG4gICAgdGhpcy50cmFja2VyLnRyYWNrKGlucHV0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSW1hZ2VUYXJnZXQsXG59XG4iLCIvLyBGYXN0IGNvbXB1dGF0aW9uIG9uIG51bWJlciBvZiBiaXQgc2V0c1xuLy8gUmVmOiBodHRwczovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9+c2VhbmRlci9iaXRoYWNrcy5odG1sI0NvdW50Qml0c1NldFBhcmFsbGVsXG5jb25zdCBjb21wdXRlID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3Qge3YxLCB2Mn0gPSBvcHRpb25zO1xuICBsZXQgZCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgeCA9ICh2MVtpXSBeIHYyW2ldKSA+Pj4gMDtcbiAgICBkICs9IGJpdENvdW50KHgpO1xuICB9XG4gIHJldHVybiBkO1xufVxuXG5jb25zdCBiaXRDb3VudCA9ICh2KSA9PiB7XG4gIHZhciBjID0gdiAtICgodiA+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICBjID0gKChjID4+IDIpICYgMHgzMzMzMzMzMykgKyAoYyAmIDB4MzMzMzMzMzMpO1xuICBjID0gKChjID4+IDQpICsgYykgJiAweDBGMEYwRjBGO1xuICBjID0gKChjID4+IDgpICsgYykgJiAweDAwRkYwMEZGO1xuICBjID0gKChjID4+IDE2KSArIGMpICYgMHgwMDAwRkZGRjtcbiAgcmV0dXJuIGM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wdXRlXG59O1xuIiwiY29uc3Qge2NvbXB1dGU6IGhhbW1pbmdDb21wdXRlfSA9IHJlcXVpcmUoJy4vaGFtbWluZy1kaXN0YW5jZS5qcycpO1xuY29uc3Qge2NyZWF0ZVJhbmRvbWl6ZXJ9ID0gcmVxdWlyZSgnLi4vdXRpbHMvcmFuZG9taXplci5qcycpO1xuXG5jb25zdCBNSU5fRkVBVFVSRV9QRVJfTk9ERSA9IDE2O1xuY29uc3QgTlVNX0FTU0lHTk1FTlRfSFlQT1RIRVNFUyA9ICAxMjg7XG5jb25zdCBOVU1fQ0VOVEVSUyA9IDg7XG5cbi8vIGttZWRvaWRzIGNsdXN0ZXJpbmcgb2YgcG9pbnRzLCB3aXRoIGhhbW1pbmcgZGlzdGFuY2Ugb2YgRlJFQUsgZGVzY3JpcHRvclxuLy9cbi8vIG5vZGUgPSB7XG4vLyAgIGlzTGVhZjogYm9vbCxcbi8vICAgY2hpbGRyZW46IFtdLCBsaXN0IG9mIGNoaWxkcmVuIG5vZGVcbi8vICAgcG9pbnRJbmRleGVzOiBbXSwgbGlzdCBvZiBpbnQsIHBvaW50IGluZGV4ZXNcbi8vICAgY2VudGVyUG9pbnRJbmRleDogaW50XG4vLyB9XG5jb25zdCBidWlsZCA9ICh7cG9pbnRzfSkgPT4ge1xuICBjb25zdCBwb2ludEluZGV4ZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBwb2ludEluZGV4ZXMucHVzaChpKTtcbiAgfVxuXG4gIGNvbnN0IHJhbmRvbWl6ZXIgPSBjcmVhdGVSYW5kb21pemVyKCk7XG5cbiAgY29uc3Qgcm9vdE5vZGUgPSBfYnVpbGQoe3BvaW50czogcG9pbnRzLCBwb2ludEluZGV4ZXM6IHBvaW50SW5kZXhlcywgY2VudGVyUG9pbnRJbmRleDogbnVsbCwgcmFuZG9taXplcn0pO1xuICByZXR1cm4ge3Jvb3ROb2RlfTtcbn1cblxuLy8gcmVjdXJzaXZlIGJ1aWxkIGhpZXJhcmNoeSBjbHVzdGVyc1xuY29uc3QgX2J1aWxkID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3Qge3BvaW50cywgcG9pbnRJbmRleGVzLCBjZW50ZXJQb2ludEluZGV4LCByYW5kb21pemVyfSA9IG9wdGlvbnM7XG5cbiAgbGV0IGlzTGVhZiA9IGZhbHNlO1xuXG4gIGlmIChwb2ludEluZGV4ZXMubGVuZ3RoIDw9IE5VTV9DRU5URVJTIHx8IHBvaW50SW5kZXhlcy5sZW5ndGggPD0gTUlOX0ZFQVRVUkVfUEVSX05PREUpIHtcbiAgICBpc0xlYWYgPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgY2x1c3RlcnMgPSB7fTtcbiAgaWYgKCFpc0xlYWYpIHtcbiAgICAvLyBjb21wdXRlIGNsdXN0ZXJzXG4gICAgY29uc3QgYXNzaWdubWVudCA9IF9jb21wdXRlS01lZG9pZHMoe3BvaW50cywgcG9pbnRJbmRleGVzLCByYW5kb21pemVyfSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzc2lnbm1lbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjbHVzdGVyc1twb2ludEluZGV4ZXNbYXNzaWdubWVudFtpXV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2x1c3RlcnNbcG9pbnRJbmRleGVzW2Fzc2lnbm1lbnRbaV1dXSA9IFtdO1xuICAgICAgfVxuICAgICAgY2x1c3RlcnNbcG9pbnRJbmRleGVzW2Fzc2lnbm1lbnRbaV1dXS5wdXNoKHBvaW50SW5kZXhlc1tpXSk7XG4gICAgfVxuICB9XG4gIGlmIChPYmplY3Qua2V5cyhjbHVzdGVycykubGVuZ3RoID09PSAxKSB7XG4gICAgaXNMZWFmID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgY2VudGVyUG9pbnRJbmRleDogY2VudGVyUG9pbnRJbmRleFxuICB9XG5cbiAgaWYgKGlzTGVhZikge1xuICAgIG5vZGUubGVhZiA9IHRydWU7XG4gICAgbm9kZS5wb2ludEluZGV4ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZS5wb2ludEluZGV4ZXMucHVzaChwb2ludEluZGV4ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8vIHJlY3Vyc2l2ZSBidWlsZCBjaGlsZHJlblxuICBub2RlLmxlYWYgPSBmYWxzZTtcbiAgbm9kZS5jaGlsZHJlbiA9IFtdO1xuXG4gIE9iamVjdC5rZXlzKGNsdXN0ZXJzKS5mb3JFYWNoKChjZW50ZXJJbmRleCkgPT4ge1xuICAgIG5vZGUuY2hpbGRyZW4ucHVzaChfYnVpbGQoe3BvaW50czogcG9pbnRzLCBwb2ludEluZGV4ZXM6IGNsdXN0ZXJzW2NlbnRlckluZGV4XSwgY2VudGVyUG9pbnRJbmRleDogY2VudGVySW5kZXgsIHJhbmRvbWl6ZXJ9KSk7XG4gIH0pO1xuICByZXR1cm4gbm9kZTtcbn1cblxuX2NvbXB1dGVLTWVkb2lkcyA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtwb2ludHMsIHBvaW50SW5kZXhlcywgcmFuZG9taXplcn0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IHJhbmRvbVBvaW50SW5kZXhlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHJhbmRvbVBvaW50SW5kZXhlcy5wdXNoKGkpO1xuICB9XG5cbiAgbGV0IGJlc3RTdW1EID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gIGxldCBiZXN0QXNzaWdubWVudEluZGV4ID0gLTE7XG5cbiAgY29uc3QgYXNzaWdubWVudHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBOVU1fQVNTSUdOTUVOVF9IWVBPVEhFU0VTOyBpKyspIHtcbiAgICByYW5kb21pemVyLmFycmF5U2h1ZmZsZSh7YXJyOiByYW5kb21Qb2ludEluZGV4ZXMsIHNhbXBsZVNpemU6IE5VTV9DRU5URVJTfSk7XG5cbiAgICBsZXQgc3VtRCA9IDA7XG4gICAgY29uc3QgYXNzaWdubWVudCA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcG9pbnRJbmRleGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBsZXQgYmVzdEQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgTlVNX0NFTlRFUlM7IGsrKykge1xuICAgICAgICBjb25zdCBjZW50ZXJJbmRleCA9IHBvaW50SW5kZXhlc1tyYW5kb21Qb2ludEluZGV4ZXNba11dO1xuICAgICAgICBjb25zdCBkID0gaGFtbWluZ0NvbXB1dGUoe3YxOiBwb2ludHNbcG9pbnRJbmRleGVzW2pdXS5kZXNjcmlwdG9ycywgdjI6IHBvaW50c1tjZW50ZXJJbmRleF0uZGVzY3JpcHRvcnN9KTtcbiAgICAgICAgaWYgKGQgPCBiZXN0RCkge1xuICAgICAgICAgIGFzc2lnbm1lbnRbal0gPSByYW5kb21Qb2ludEluZGV4ZXNba107XG4gICAgICAgICAgYmVzdEQgPSBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdW1EICs9IGJlc3REO1xuICAgIH1cbiAgICBhc3NpZ25tZW50cy5wdXNoKGFzc2lnbm1lbnQpO1xuXG4gICAgaWYgKHN1bUQgPCBiZXN0U3VtRCkge1xuICAgICAgYmVzdFN1bUQgPSBzdW1EO1xuICAgICAgYmVzdEFzc2lnbm1lbnRJbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhc3NpZ25tZW50c1tiZXN0QXNzaWdubWVudEluZGV4XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJ1aWxkLFxufTtcblxuIiwiY29uc3Qge2NyZWF0ZVJhbmRvbWl6ZXJ9ID0gcmVxdWlyZSgnLi4vdXRpbHMvcmFuZG9taXplci5qcycpO1xuY29uc3Qge3F1YWRyaWxhdGVyYWxDb252ZXgsIG1hdHJpeEludmVyc2UzMywgc21hbGxlc3RUcmlhbmdsZUFyZWEsIG11bHRpcGx5UG9pbnRIb21vZ3JhcGh5SW5ob21vZ2Vub3VzLCBjaGVja1RocmVlUG9pbnRzQ29uc2lzdGVudCwgY2hlY2tGb3VyUG9pbnRzQ29uc2lzdGVudCwgZGV0ZXJtaW5hbnR9ID0gcmVxdWlyZSgnLi4vdXRpbHMvZ2VvbWV0cnkuanMnKTtcblxuY29uc3QgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMDAwMTtcbmNvbnN0IFNRUlQyID0gMS40MTQyMTM1NjIzNzMwOTUwNDg4MDtcbmNvbnN0IEhPTU9HUkFQSFlfREVGQVVMVF9DQVVDSFlfU0NBTEUgPSAwLjAxO1xuY29uc3QgSE9NT0dSQVBIWV9ERUZBVUxUX05VTV9IWVBPVEhFU0VTID0gMTAyNDtcbmNvbnN0IEhPTU9HUkFQSFlfREVGQVVMVF9NQVhfVFJJQUxTID0gMTA2NDtcbmNvbnN0IEhPTU9HUkFQSFlfREVGQVVMVF9DSFVOS19TSVpFID0gNTA7XG5cbi8vIHRlc3RQb2ludHMgaXMgZm91ciBjb3JuZXJzIG9mIGtleWZyYW1lXG5jb25zdCBjb21wdXRlSG9tb2dyYXBoeSA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtzcmNQb2ludHMsIGRzdFBvaW50cywga2V5ZnJhbWV9ID0gb3B0aW9ucztcblxuICBjb25zdCB0ZXN0UG9pbnRzID0gW1xuICAgIFswLCAwXSxcbiAgICBba2V5ZnJhbWUud2lkdGgsIDBdLFxuICAgIFtrZXlmcmFtZS53aWR0aCwga2V5ZnJhbWUuaGVpZ2h0XSxcbiAgICBbMCwga2V5ZnJhbWUuaGVpZ2h0XVxuICBdXG5cbiAgY29uc3Qgc2FtcGxlU2l6ZSA9IDQ7IC8vIHVzZSBmb3VyIHBvaW50cyB0byBjb21wdXRlIGhvbW9ncmFwaHlcbiAgaWYgKHNyY1BvaW50cy5sZW5ndGggPCBzYW1wbGVTaXplKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCBzY2FsZSA9IEhPTU9HUkFQSFlfREVGQVVMVF9DQVVDSFlfU0NBTEU7XG4gIGNvbnN0IG9uZU92ZXJTY2FsZTIgPSAxLjAgLyAoc2NhbGUgKiBzY2FsZSk7XG4gIGNvbnN0IGNodWNrU2l6ZSA9IE1hdGgubWluKEhPTU9HUkFQSFlfREVGQVVMVF9DSFVOS19TSVpFLCBzcmNQb2ludHMubGVuZ3RoKTtcblxuICBjb25zdCByYW5kb21pemVyID0gY3JlYXRlUmFuZG9taXplcigpO1xuXG4gIGNvbnN0IHBlcm0gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcmNQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBwZXJtW2ldID0gaTtcbiAgfVxuXG4gIHJhbmRvbWl6ZXIuYXJyYXlTaHVmZmxlKHthcnI6IHBlcm0sIHNhbXBsZVNpemU6IHBlcm0ubGVuZ3RofSk7XG5cbiAgLy8gYnVpbGQgbnVtZXJvdXMgaHlwb3RoZXNlcyBieSByYW5kb21pbmcgZHJhdyBmb3VyIHBvaW50c1xuICAvLyBUT0RPOiBvcHRpbWl6ZTogaWYgbnVtYmVyIG9mIHBvaW50cyBpcyBsZXNzIHRoYW4gY2VydGFpbiBudW1iZXIsIGNhbiBicnV0ZSBmb3JjZSBhbGwgY29tYmluYXRpb25zXG4gIGxldCB0cmlhbCA9IDA7XG4gIGNvbnN0IEhzID0gW107XG4gIHdoaWxlICh0cmlhbCA8IEhPTU9HUkFQSFlfREVGQVVMVF9NQVhfVFJJQUxTICYmIEhzLmxlbmd0aCA8IEhPTU9HUkFQSFlfREVGQVVMVF9OVU1fSFlQT1RIRVNFUykge1xuXG4gICAgcmFuZG9taXplci5hcnJheVNodWZmbGUoe2FycjogcGVybSwgc2FtcGxlU2l6ZTogc2FtcGxlU2l6ZX0pO1xuXG4gICAgdHJpYWwgKz0xO1xuXG4gICAgaWYgKCFjaGVja0ZvdXJQb2ludHNDb25zaXN0ZW50KFxuICAgICAgc3JjUG9pbnRzW3Blcm1bMF1dLCBzcmNQb2ludHNbcGVybVsxXV0sIHNyY1BvaW50c1twZXJtWzJdXSwgc3JjUG9pbnRzW3Blcm1bM11dLFxuICAgICAgZHN0UG9pbnRzW3Blcm1bMF1dLCBkc3RQb2ludHNbcGVybVsxXV0sIGRzdFBvaW50c1twZXJtWzJdXSwgZHN0UG9pbnRzW3Blcm1bM11dKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgSCA9IF9zb2x2ZUhvbW9ncmFwaHlGb3VyUG9pbnRzKHtcbiAgICAgIHNyY1BvaW50czogW3NyY1BvaW50c1twZXJtWzBdXSwgc3JjUG9pbnRzW3Blcm1bMV1dLCBzcmNQb2ludHNbcGVybVsyXV0sIHNyY1BvaW50c1twZXJtWzNdXV0sXG4gICAgICBkc3RQb2ludHM6IFtkc3RQb2ludHNbcGVybVswXV0sIGRzdFBvaW50c1twZXJtWzFdXSwgZHN0UG9pbnRzW3Blcm1bMl1dLCBkc3RQb2ludHNbcGVybVszXV1dLFxuICAgIH0pO1xuXG4gICAgaWYgKEggPT09IG51bGwpIGNvbnRpbnVlO1xuXG4gICAgaWYoIV9jaGVja0hvbW9ncmFwaHlQb2ludHNHZW9tZXRyaWNhbGx5Q29uc2lzdGVudCh7SCwgdGVzdFBvaW50c30pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBIcy5wdXNoKEgpO1xuICB9XG5cbiAgaWYgKEhzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgLy8gcGljayB0aGUgYmVzdCBoeXBvdGhlc2lzXG4gIGNvbnN0IGh5cG90aGVzZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBIcy5sZW5ndGg7IGkrKykge1xuICAgIGh5cG90aGVzZXMucHVzaCh7XG4gICAgICBIOiBIc1tpXSxcbiAgICAgIGNvc3Q6IDBcbiAgICB9KVxuICB9XG5cbiAgbGV0IGN1ckNodWNrU2l6ZSA9IGNodWNrU2l6ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcmNQb2ludHMubGVuZ3RoICYmIGh5cG90aGVzZXMubGVuZ3RoID4gMjsgaSArPSBjdXJDaHVja1NpemUpIHtcbiAgICBjdXJDaHVja1NpemUgPSBNYXRoLm1pbihjaHVja1NpemUsIHNyY1BvaW50cy5sZW5ndGggLSBpKTtcbiAgICBsZXQgY2h1Y2tFbmQgPSBpICsgY3VyQ2h1Y2tTaXplO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBoeXBvdGhlc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICBmb3IgKGxldCBrID0gaTsgayA8IGNodWNrRW5kOyBrKyspIHtcbiAgICAgICAgY29uc3QgY29zdCA9IF9jYXVjaHlQcm9qZWN0aXZlUmVwcm9qZWN0aW9uQ29zdCh7SDogaHlwb3RoZXNlc1tqXS5ILCBzcmNQb2ludDogc3JjUG9pbnRzW2tdLCBkc3RQb2ludDogZHN0UG9pbnRzW2tdLCBvbmVPdmVyU2NhbGUyfSk7XG4gICAgICAgIGh5cG90aGVzZXNbal0uY29zdCArPSBjb3N0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGh5cG90aGVzZXMuc29ydCgoaDEsIGgyKSA9PiB7cmV0dXJuIGgxLmNvc3QgLSBoMi5jb3N0fSk7XG4gICAgaHlwb3RoZXNlcy5zcGxpY2UoLU1hdGguZmxvb3IoKGh5cG90aGVzZXMubGVuZ3RoKzEpLzIpKTsgLy8ga2VlcCB0aGUgYmVzdCBoYWxmXG4gIH1cblxuICBsZXQgYmVzdEluZGV4ID0gMDtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBoeXBvdGhlc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGh5cG90aGVzZXNbaV0uY29zdCA8IGh5cG90aGVzZXNbYmVzdEluZGV4XS5jb3N0KSBiZXN0SW5kZXggPSBpO1xuICB9XG5cbiAgY29uc3QgZmluYWxIID0gX25vcm1hbGl6ZUhvbW9ncmFwaHkoe2luSDogaHlwb3RoZXNlc1tiZXN0SW5kZXhdLkh9KTtcblxuICBpZiAoIV9jaGVja0hldXJpc3RpY3Moe0g6IGZpbmFsSCwgdGVzdFBvaW50cywga2V5ZnJhbWV9KSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBmaW5hbEg7XG59XG5cbmNvbnN0IF9jaGVja0hldXJpc3RpY3MgPSAoe0gsIHRlc3RQb2ludHMsIGtleWZyYW1lfSkgPT4ge1xuICBjb25zdCBISW52ID0gbWF0cml4SW52ZXJzZTMzKEgsIDAuMDAwMDEpO1xuICAvLyBjb25zb2xlLmxvZyhcImZpbmFsIEggSW52OiBcIiwgSEludik7XG4gIGlmIChISW52ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgY29uc3QgbXAgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRlc3RQb2ludHMubGVuZ3RoOyBpKyspIHsgLy8gNCB0ZXN0IHBvaW50cywgY29ybmVyIG9mIGtleWZyYW1lXG4gICAgbXAucHVzaChtdWx0aXBseVBvaW50SG9tb2dyYXBoeUluaG9tb2dlbm91cyh0ZXN0UG9pbnRzW2ldLCBISW52KSk7XG4gIH1cbiAgY29uc3Qgc21hbGxBcmVhID0gc21hbGxlc3RUcmlhbmdsZUFyZWEobXBbMF0sIG1wWzFdLCBtcFsyXSwgbXBbM10pO1xuXG4gIGlmIChzbWFsbEFyZWEgPCBrZXlmcmFtZS53aWR0aCAqIGtleWZyYW1lLmhlaWdodCAqIDAuMDAwMSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghcXVhZHJpbGF0ZXJhbENvbnZleChtcFswXSwgbXBbMV0sIG1wWzJdLCBtcFszXSkpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgX25vcm1hbGl6ZUhvbW9ncmFwaHkgPSAoe2luSH0pID0+IHtcbiAgY29uc3Qgb25lT3ZlciA9IDEuMCAvIGluSFs4XTtcblxuICBjb25zdCBIID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgSFtpXSA9IGluSFtpXSAqIG9uZU92ZXI7XG4gIH1cbiAgSFs4XSA9IDEuMDtcbiAgcmV0dXJuIEg7XG59XG5cbmNvbnN0IF9jYXVjaHlQcm9qZWN0aXZlUmVwcm9qZWN0aW9uQ29zdCA9ICh7SCwgc3JjUG9pbnQsIGRzdFBvaW50LCBvbmVPdmVyU2NhbGUyfSkgPT4ge1xuICBjb25zdCB4ID0gbXVsdGlwbHlQb2ludEhvbW9ncmFwaHlJbmhvbW9nZW5vdXMoc3JjUG9pbnQsIEgpO1xuICBjb25zdCBmID1bXG4gICAgeFswXSAtIGRzdFBvaW50WzBdLFxuICAgIHhbMV0gLSBkc3RQb2ludFsxXVxuICBdO1xuICByZXR1cm4gTWF0aC5sb2coMSArIChmWzBdKmZbMF0rZlsxXSpmWzFdKSAqIG9uZU92ZXJTY2FsZTIpO1xufVxuXG5jb25zdCBfY2hlY2tIb21vZ3JhcGh5UG9pbnRzR2VvbWV0cmljYWxseUNvbnNpc3RlbnQgPSAoe0gsIHRlc3RQb2ludHN9KSA9PiB7XG4gIGNvbnN0IG1hcHBlZFBvaW50cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRlc3RQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBwZWRQb2ludHNbaV0gPSBtdWx0aXBseVBvaW50SG9tb2dyYXBoeUluaG9tb2dlbm91cyh0ZXN0UG9pbnRzW2ldLCBIKTtcbiAgICAvL2NvbnNvbGUubG9nKFwibWFwXCIsIHRlc3RQb2ludHNbaV0sIG1hcHBlZFBvaW50c1tpXSwgSCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXN0UG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaTEgPSBpO1xuICAgIGNvbnN0IGkyID0gKGkrMSkgJSB0ZXN0UG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCBpMyA9IChpKzIpICUgdGVzdFBvaW50cy5sZW5ndGg7XG4gICAgaWYgKCFjaGVja1RocmVlUG9pbnRzQ29uc2lzdGVudChcbiAgICAgIHRlc3RQb2ludHNbaTFdLCB0ZXN0UG9pbnRzW2kyXSwgdGVzdFBvaW50c1tpM10sXG4gICAgICBtYXBwZWRQb2ludHNbaTFdLCBtYXBwZWRQb2ludHNbaTJdLCBtYXBwZWRQb2ludHNbaTNdKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBDb25kaXRpb24gZm91ciAyRCBwb2ludHMgc3VjaCB0aGF0IHRoZSBtZWFuIGlzIHplcm8gYW5kIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gaXMgc3FydCgyKS5cbmNvbnN0IF9jb25kaXRpb240UG9pbnRzMmQgPSAoe3gxLCB4MiwgeDMsIHg0fSkgPT4ge1xuICBjb25zdCBtdSA9IFtdO1xuICBjb25zdCBkMSA9IFtdO1xuICBjb25zdCBkMiA9IFtdO1xuICBjb25zdCBkMyA9IFtdO1xuICBjb25zdCBkNCA9IFtdO1xuXG4gIG11WzBdID0gKHgxWzBdK3gyWzBdK3gzWzBdK3g0WzBdKS80O1xuICBtdVsxXSA9ICh4MVsxXSt4MlsxXSt4M1sxXSt4NFsxXSkvNDtcblxuICBkMVswXSA9IHgxWzBdLW11WzBdO1xuICBkMVsxXSA9IHgxWzFdLW11WzFdO1xuICBkMlswXSA9IHgyWzBdLW11WzBdO1xuICBkMlsxXSA9IHgyWzFdLW11WzFdO1xuICBkM1swXSA9IHgzWzBdLW11WzBdO1xuICBkM1sxXSA9IHgzWzFdLW11WzFdO1xuICBkNFswXSA9IHg0WzBdLW11WzBdO1xuICBkNFsxXSA9IHg0WzFdLW11WzFdO1xuXG4gIGNvbnN0IGRzMSA9IE1hdGguc3FydChkMVswXSpkMVswXStkMVsxXSpkMVsxXSk7XG4gIGNvbnN0IGRzMiA9IE1hdGguc3FydChkMlswXSpkMlswXStkMlsxXSpkMlsxXSk7XG4gIGNvbnN0IGRzMyA9IE1hdGguc3FydChkM1swXSpkM1swXStkM1sxXSpkM1sxXSk7XG4gIGNvbnN0IGRzNCA9IE1hdGguc3FydChkNFswXSpkNFswXStkNFsxXSpkNFsxXSk7XG4gIGNvbnN0IGQgPSAoZHMxK2RzMitkczMrZHM0KS80O1xuXG4gIGlmIChkID09IDApIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IHMgPSAoMS4wL2QpKlNRUlQyO1xuXG4gIGNvbnN0IHhwMSA9IFtdO1xuICBjb25zdCB4cDIgPSBbXTtcbiAgY29uc3QgeHAzID0gW107XG4gIGNvbnN0IHhwNCA9IFtdO1xuXG4gIHhwMVswXSA9IGQxWzBdKnM7XG4gIHhwMVsxXSA9IGQxWzFdKnM7XG4gIHhwMlswXSA9IGQyWzBdKnM7XG4gIHhwMlsxXSA9IGQyWzFdKnM7XG4gIHhwM1swXSA9IGQzWzBdKnM7XG4gIHhwM1sxXSA9IGQzWzFdKnM7XG4gIHhwNFswXSA9IGQ0WzBdKnM7XG4gIHhwNFsxXSA9IGQ0WzFdKnM7XG5cbiAgcmV0dXJuIHt4cDEsIHhwMiwgeHAzLCB4cDQsIHMsIHQ6IG11fTtcbn1cblxuY29uc3QgX3NvbHZlSG9tb2dyYXBoeUZvdXJQb2ludHMgPSAoe3NyY1BvaW50cywgZHN0UG9pbnRzfSkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkRFQlVHX01BVENIKSB7XG4gICAgd2luZG93LmRlYnVnLmhvbW9ncmFwaHlJbmRleCArPSAxO1xuICAgIGNvbnN0IGRIb21vZ3JhcGh5ID0gd2luZG93LmRlYnVnTWF0Y2gucXVlcnlrZXlmcmFtZXNbd2luZG93LmRlYnVnLnF1ZXJ5a2V5ZnJhbWVJbmRleF0uaG9tb2dyYXBoeVt3aW5kb3cuZGVidWcuaG9tb2dyYXBoeUluZGV4XTtcbiAgICBjb25zdCB7eDEsIHgyLCB4MywgeDQsIHhwMSwgeHAyLCB4cDMsIHhwNH0gPSBkSG9tb2dyYXBoeTtcbiAgICBjb25zdCBsMSA9IFtzcmNQb2ludHNbMF0sc3JjUG9pbnRzWzFdLHNyY1BvaW50c1syXSxzcmNQb2ludHNbM10sZHN0UG9pbnRzWzBdLGRzdFBvaW50c1sxXSxkc3RQb2ludHNbMl0sZHN0UG9pbnRzWzNdXTtcbiAgICBjb25zdCBsMiA9IFt4MSwgeDIsIHgzLCB4NCwgeHAxLCB4cDIsIHhwMywgeHA0XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGwxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXdpbmRvdy5jbXAobDFbaV1bMF0sIGwyW2ldWzBdKSB8fCAhd2luZG93LmNtcChsMVtpXVsxXSwgbDJbaV1bMV0pKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdJTkNPUlJFQ1QgaG9tb2dyYXBoeSBwb2ludHMnLCB3aW5kb3cuZGVidWcuaG9tb2dyYXBoeUluZGV4LCBpLCBsMVtpXSwgbDJbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlczEgPSBfY29uZGl0aW9uNFBvaW50czJkKHt4MTogc3JjUG9pbnRzWzBdLCB4Mjogc3JjUG9pbnRzWzFdLCB4Mzogc3JjUG9pbnRzWzJdLCB4NDogc3JjUG9pbnRzWzNdfSk7XG5cbiAgaWYgKHJlczEgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfTUFUQ0gpIHtcbiAgICBjb25zdCBkSG9tb2dyYXBoeSA9IHdpbmRvdy5kZWJ1Z01hdGNoLnF1ZXJ5a2V5ZnJhbWVzW3dpbmRvdy5kZWJ1Zy5xdWVyeWtleWZyYW1lSW5kZXhdLmhvbW9ncmFwaHlbd2luZG93LmRlYnVnLmhvbW9ncmFwaHlJbmRleF07XG4gICAgY29uc3Qge3gxcCwgeDJwLCB4M3AsIHg0cCwgdCwgc30gPSBkSG9tb2dyYXBoeTtcbiAgICBjb25zdCBsMSA9IFtyZXMxLnhwMSwgcmVzMS54cDIsIHJlczEueHAzLCByZXMxLnhwNCwgcmVzMS50XTtcbiAgICBjb25zdCBsMiA9IFt4MXAsIHgycCwgeDNwLCB4NHAsIHRdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghd2luZG93LmNtcChsMVtpXVswXSwgbDJbaV1bMF0pIHx8ICF3aW5kb3cuY21wKGwxW2ldWzFdLCBsMltpXVsxXSkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0lOQ09SUkVDVCBob21vZ3JhcGh5IHJlczEnLCB3aW5kb3cuZGVidWcuaG9tb2dyYXBoeUluZGV4LCBpLCBsMVtpXSwgbDJbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXdpbmRvdy5jbXAocmVzMS5zLCBzKSkge1xuICAgICAgY29uc29sZS5sb2coJ0lOQ09SUkVDVCBob21vZ3JhcGh5IHJlczEgUycsIHdpbmRvdy5kZWJ1Zy5ob21vZ3JhcGh5SW5kZXgsIHJlczEucywgcyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVzMiA9IF9jb25kaXRpb240UG9pbnRzMmQoe3gxOiBkc3RQb2ludHNbMF0sIHgyOiBkc3RQb2ludHNbMV0sIHgzOiBkc3RQb2ludHNbMl0sIHg0OiBkc3RQb2ludHNbM119KTtcbiAgaWYgKHJlczIgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfTUFUQ0gpIHtcbiAgICBjb25zdCBkSG9tb2dyYXBoeSA9IHdpbmRvdy5kZWJ1Z01hdGNoLnF1ZXJ5a2V5ZnJhbWVzW3dpbmRvdy5kZWJ1Zy5xdWVyeWtleWZyYW1lSW5kZXhdLmhvbW9ncmFwaHlbd2luZG93LmRlYnVnLmhvbW9ncmFwaHlJbmRleF07XG4gICAgY29uc3Qge3hwMXAsIHhwMnAsIHhwM3AsIHhwNHAsIHRwLCBzcH0gPSBkSG9tb2dyYXBoeTtcbiAgICBjb25zdCBsMSA9IFtyZXMyLnhwMSwgcmVzMi54cDIsIHJlczIueHAzLCByZXMyLnhwNCwgcmVzMi50XTtcbiAgICBjb25zdCBsMiA9IFt4cDFwLCB4cDJwLCB4cDNwLCB4cDRwLCB0cF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsMS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCF3aW5kb3cuY21wKGwxW2ldWzBdLCBsMltpXVswXSkgfHwgIXdpbmRvdy5jbXAobDFbaV1bMV0sIGwyW2ldWzFdKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnSU5DT1JSRUNUIGhvbW9ncmFwaHkgcmVzMScsIHdpbmRvdy5kZWJ1Zy5ob21vZ3JhcGh5SW5kZXgsIGksIGwxW2ldLCBsMltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghd2luZG93LmNtcChyZXMyLnMsIHNwKSkge1xuICAgICAgY29uc29sZS5sb2coJ0lOQ09SUkVDVCBob21vZ3JhcGh5IHJlczEgUycsIHdpbmRvdy5kZWJ1Zy5ob21vZ3JhcGh5SW5kZXgsIGksIHJlczIucywgc3ApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IEhuID0gX3NvbHZlSG9tb2dyYXBoeTRQb2ludHNJbmhvbW9nZW5vdXMoe1xuICAgIHgxOiByZXMxLnhwMSwgeDI6IHJlczEueHAyLCB4MzogcmVzMS54cDMsIHg0OiByZXMxLnhwNCxcbiAgICB4cDE6IHJlczIueHAxLCB4cDI6IHJlczIueHAyLCB4cDM6IHJlczIueHAzLCB4cDQ6IHJlczIueHA0LFxuICB9KTtcblxuICBpZiAoSG4gPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIGlmIChNYXRoLmFicyhkZXRlcm1pbmFudChIbikpIDwgMC4wMDAwMSkgcmV0dXJuIG51bGw7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19NQVRDSCkge1xuICAgIGNvbnN0IGRIb21vZ3JhcGh5ID0gd2luZG93LmRlYnVnTWF0Y2gucXVlcnlrZXlmcmFtZXNbd2luZG93LmRlYnVnLnF1ZXJ5a2V5ZnJhbWVJbmRleF0uaG9tb2dyYXBoeVt3aW5kb3cuZGVidWcuaG9tb2dyYXBoeUluZGV4XTtcbiAgICBjb25zdCBkSG4gPSBkSG9tb2dyYXBoeS5IbjtcbiAgICBpZiAoIXdpbmRvdy5jbXBBcnJheShIbiwgZEhuLCAwLjAwMSkpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiSU5DT1JSRUNUIEhuXCIsIHdpbmRvdy5kZWJ1Zy5xdWVyeWtleWZyYW1lSW5kZXgsIHdpbmRvdy5kZWJ1Zy5ob21vZ3JhcGh5SW5kZXgsIEhuLCBkSG4pO1xuICAgIH1cbiAgICBjb25zdCBkRGV0SCA9IHdpbmRvdy5kZWJ1Z01hdGNoLnF1ZXJ5a2V5ZnJhbWVzW3dpbmRvdy5kZWJ1Zy5xdWVyeWtleWZyYW1lSW5kZXhdLmhvbW9ncmFwaHlbd2luZG93LmRlYnVnLmhvbW9ncmFwaHlJbmRleF0uZGV0SDtcbiAgICBpZiAoIXdpbmRvdy5jbXAoZGV0ZXJtaW5hbnQoSG4pLCBkRGV0SCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiSU5DT1JSRUNUIGRldGVybWluYW50XCIsIGRldGVybWluYW50KEhuKSwgZERldEgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IEggPSBfZGVub21hbGl6ZUhvbW9ncmFwaHkoe0g6IEhuLCBzOiByZXMxLnMsIHQ6IHJlczEudCwgc3A6IHJlczIucywgdHA6IHJlczIudH0pO1xuXG4gIHJldHVybiBIO1xufVxuXG4vLyBkZW5vcm1hbGl6ZSBob21vZ3JhcGh5XG4vLyBIcCA9IGludihUcCkqSCpUXG5jb25zdCBfZGVub21hbGl6ZUhvbW9ncmFwaHkgPSAoe0gsIHMsIHQsIHNwLCB0cH0pID0+IHtcbiAgY29uc3QgYSA9IEhbNl0qdHBbMF07XG4gIGNvbnN0IGIgPSBIWzddKnRwWzBdO1xuICBjb25zdCBjID0gSFswXS9zcDtcbiAgY29uc3QgZCA9IEhbMV0vc3A7XG4gIGNvbnN0IGFwYyA9IGErYztcbiAgY29uc3QgYnBkID0gYitkO1xuXG4gIGNvbnN0IGUgPSBIWzZdKnRwWzFdO1xuICBjb25zdCBmID0gSFs3XSp0cFsxXTtcbiAgY29uc3QgZyA9IEhbM10vc3A7XG4gIGNvbnN0IGggPSBIWzRdL3NwO1xuICBjb25zdCBlcGcgPSBlK2c7XG4gIGNvbnN0IGZwaCA9IGYraDtcblxuICBjb25zdCBzdHggPSBzKnRbMF07XG4gIGNvbnN0IHN0eSA9IHMqdFsxXTtcblxuICBjb25zdCBIcCA9IFtdO1xuICBIcFswXSA9IHMqYXBjO1xuICBIcFsxXSA9IHMqYnBkO1xuICBIcFsyXSA9IEhbOF0qdHBbMF0gKyBIWzJdL3NwIC0gc3R4KmFwYyAtIHN0eSpicGQ7XG5cbiAgSHBbM10gPSBzKmVwZztcbiAgSHBbNF0gPSBzKmZwaDtcbiAgSHBbNV0gPSBIWzhdKnRwWzFdICsgSFs1XS9zcCAtIHN0eCplcGcgLSBzdHkqZnBoO1xuXG4gIEhwWzZdID0gSFs2XSpzO1xuICBIcFs3XSA9IEhbN10qcztcbiAgSHBbOF0gPSBIWzhdIC0gSHBbNl0qdFswXSAtIEhwWzddKnRbMV07XG5cbiAgcmV0dXJuIEhwO1xufTtcblxuLy8gY2FuIHNvbWVvbmUgdmVyaWZ5IHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIFFSIGRlY29tcG9zaXRpb24/XG5jb25zdCBfc29sdmVIb21vZ3JhcGh5NFBvaW50c0luaG9tb2dlbm91cyA9ICh7eDEsIHgyLCB4MywgeDQsIHhwMSwgeHAyLCB4cDMsIHhwNH0pID0+IHtcbiAgY29uc3QgeExpc3QgPSBbeDEsIHgyLCB4MywgeDRdO1xuICBjb25zdCB4cExpc3QgPSBbeHAxLCB4cDIsIHhwMywgeHA0XTtcblxuICBjb25zdCBBID0gW107IC8vIDggeCA5XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDE4O1xuICAgIGNvbnN0IHggPSB4TGlzdFtpXTtcbiAgICBjb25zdCB4cCA9IHhwTGlzdFtpXTtcbiAgICBBW29mZnNldCswXSA9IC14WzBdO1xuICAgIEFbb2Zmc2V0KzFdID0gLXhbMV07XG4gICAgQVtvZmZzZXQrMl0gPSAtMTtcbiAgICBBW29mZnNldCszXSA9IDA7XG4gICAgQVtvZmZzZXQrNF0gPSAwO1xuICAgIEFbb2Zmc2V0KzVdID0gMDtcbiAgICBBW29mZnNldCs2XSA9IHhwWzBdKnhbMF07XG4gICAgQVtvZmZzZXQrN10gPSB4cFswXSp4WzFdO1xuICAgIEFbb2Zmc2V0KzhdID0geHBbMF07XG4gICAgQVtvZmZzZXQrOV0gPSAwO1xuICAgIEFbb2Zmc2V0KzEwXSA9IDA7XG4gICAgQVtvZmZzZXQrMTFdID0gMDtcbiAgICBBW29mZnNldCsxMl0gPSAteFswXTtcbiAgICBBW29mZnNldCsxM10gPSAteFsxXTtcbiAgICBBW29mZnNldCsxNF0gPSAtMTtcbiAgICBBW29mZnNldCsxNV0gPSB4cFsxXSp4WzBdO1xuICAgIEFbb2Zmc2V0KzE2XSA9IHhwWzFdKnhbMV07XG4gICAgQVtvZmZzZXQrMTddID0geHBbMV07XG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkRFQlVHX01BVENIKSB7XG4gICAgY29uc3QgZEEgPSB3aW5kb3cuZGVidWdNYXRjaC5xdWVyeWtleWZyYW1lc1t3aW5kb3cuZGVidWcucXVlcnlrZXlmcmFtZUluZGV4XS5ob21vZ3JhcGh5W3dpbmRvdy5kZWJ1Zy5ob21vZ3JhcGh5SW5kZXhdLkE7XG4gICAgaWYgKCF3aW5kb3cuY21wQXJyYXkoQSwgZEEpKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIklOQ09SUkVDVCBBXCIsIHdpbmRvdy5kZWJ1Zy5xdWVyeWtleWZyYW1lSW5kZXgsIHdpbmRvdy5kZWJ1Zy5ob21vZ3JhcGh5SW5kZXgsIEEsIGRBKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBRID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNzI7IGkrKykge1xuICAgIFFbaV0gPSBBW2ldO1xuICB9XG5cbiAgLy8gc29sdmUgeCBmb3IgQXg9MCB3aXRoIFFSIGRlY29tcG9zaXRpb24gd2l0aCBHcmFtLVNjaG1pZHRcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgODsgcm93KyspIHtcbiAgICBpZiAocm93ID4gMCkge1xuICAgICAgZm9yIChsZXQgaiA9IHJvdzsgaiA8IDg7IGorKykge1xuICAgICAgICAvLyBwcm9qZWN0IGEgdmVjdG9yIFwiYVwiIG9udG8gYSBub3JtYWxpemVkIGJhc2lzIHZlY3RvciBcImVcIi5cbiAgICAgICAgLy8geCA9IHggLSBkb3QoYSxlKSplXG5cbiAgICAgICAgbGV0IGQgPSAwOyAvLyBkb3QoYSwgZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICAgICAgZCArPSBRWyhyb3ctMSkgKiA5ICsgaV0gKiBBW2ogKiA5ICsgaV07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuICAgICAgICAgIFFbaiAqIDkgKyBpXSAtPSBkICogUVsgKHJvdy0xKSAqIDkgKyBpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBtYXhWYWx1ZSA9IC0xO1xuICAgIGxldCBtYXhSb3cgPSAtMTtcbiAgICBjb25zdCBzcyA9IFtdO1xuICAgIGZvciAobGV0IGogPSByb3c7IGogPCA4OyBqKyspIHtcbiAgICAgIHNzW2pdID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICAgIHNzW2pdICs9IChRW2oqOStpXSAqIFFbaio5K2ldKTtcbiAgICAgIH1cbiAgICAgIGlmIChzc1tqXSA+IG1heFZhbHVlKSB7XG4gICAgICAgIG1heFZhbHVlID0gc3Nbal07XG4gICAgICAgIG1heFJvdyA9IGo7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICggTWF0aC5hYnMoc3NbbWF4Um93XSkgPCBFUFNJTE9OKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gbm8gc29sdXRpb25cbiAgICB9XG5cbiAgICAvLyBzd2FwIGN1cnJlbnQgcm93IHdpdGggbWF4aW5kZXggcm93XG4gICAgaWYgKHJvdyAhPT0gbWF4Um93KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuICAgICAgICBsZXQgdG1wID0gQVtyb3cgKiA5ICsgaV07XG4gICAgICAgIEFbcm93ICogOSArIGldID0gQVttYXhSb3cgKiA5ICsgaV07XG4gICAgICAgIEFbbWF4Um93ICogOSArIGldID0gdG1wO1xuXG4gICAgICAgIGxldCB0bXAyID0gUVtyb3cgKiA5ICsgaV07XG4gICAgICAgIFFbcm93ICogOSArIGldID0gUVttYXhSb3cgKiA5ICsgaV07XG4gICAgICAgIFFbbWF4Um93ICogOSArIGldID0gdG1wMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuICAgICAgUVtyb3cgKiA5ICsgaV0gPSAxLjAgKiBRW3JvdyAqIDkgKyBpXSAvIE1hdGguc3FydChzc1ttYXhSb3ddKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkRFQlVHX01BVENIKSB7XG4gICAgY29uc3QgZFEgPSB3aW5kb3cuZGVidWdNYXRjaC5xdWVyeWtleWZyYW1lc1t3aW5kb3cuZGVidWcucXVlcnlrZXlmcmFtZUluZGV4XS5ob21vZ3JhcGh5W3dpbmRvdy5kZWJ1Zy5ob21vZ3JhcGh5SW5kZXhdLlE4O1xuICAgIGlmICghd2luZG93LmNtcEFycmF5KFEsIGRRLCAwLjAwMSkpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiSU5DT1JSRUNUIFE4XCIsIHdpbmRvdy5kZWJ1Zy5xdWVyeWtleWZyYW1lSW5kZXgsIHdpbmRvdy5kZWJ1Zy5ob21vZ3JhcGh5SW5kZXgsIFEsIGRRKTtcbiAgICB9XG4gIH1cblxuICAvLyBjb21wdXRlIHggZnJvbSBRXG4gIGNvbnN0IHcgPSBbXTtcbiAgY29uc3QgWCA9IFtdO1xuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCA5OyByb3crKykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICBYW3JvdyAqIDkgKyBpXSA9IChRW2ldICogLVFbcm93XSk7XG4gICAgfVxuICAgIFhbcm93ICogOSArIHJvd10gPSAxICsgWFtyb3cgKiA5ICsgcm93XTtcblxuICAgIGZvciAobGV0IGogPSAxOyBqIDwgODsgaisrKSB7XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICAgIFhbcm93ICogOSArIGldICs9IChRW2ogKiA5ICsgaV0gKiAtUVtqICogOSArIHJvd10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcbiAgICAgIHNzICs9IChYW3JvdyAqIDkgKyBpXSAqIFhbcm93ICogOSArIGldKTtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKHNzKSA8IEVQU0lMT04pIHtcbiAgICAgIHdbcm93XSA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB3W3Jvd10gPSBNYXRoLnNxcnQoc3MpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICBYW3JvdyAqIDkgKyBpXSA9IFhbcm93ICogOSArIGldIC8gd1tyb3ddO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfTUFUQ0gpIHtcbiAgICBjb25zdCBkWCA9IHdpbmRvdy5kZWJ1Z01hdGNoLnF1ZXJ5a2V5ZnJhbWVzW3dpbmRvdy5kZWJ1Zy5xdWVyeWtleWZyYW1lSW5kZXhdLmhvbW9ncmFwaHlbd2luZG93LmRlYnVnLmhvbW9ncmFwaHlJbmRleF0uWDtcbiAgICBjb25zdCBkdyA9IHdpbmRvdy5kZWJ1Z01hdGNoLnF1ZXJ5a2V5ZnJhbWVzW3dpbmRvdy5kZWJ1Zy5xdWVyeWtleWZyYW1lSW5kZXhdLmhvbW9ncmFwaHlbd2luZG93LmRlYnVnLmhvbW9ncmFwaHlJbmRleF0udztcbiAgICBpZiAoIXdpbmRvdy5jbXBBcnJheShYLCBkWCwgMC4wMSkpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiSU5DT1JSRUNUIFhcIiwgd2luZG93LmRlYnVnLnF1ZXJ5a2V5ZnJhbWVJbmRleCwgd2luZG93LmRlYnVnLmhvbW9ncmFwaHlJbmRleCwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShYKSksIGRYKTtcbiAgICB9XG4gICAgaWYgKCF3aW5kb3cuY21wQXJyYXkodywgZHcsIDAuMDEpKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIklOQ09SUkVDVCB3XCIsIHdpbmRvdy5kZWJ1Zy5xdWVyeWtleWZyYW1lSW5kZXgsIHdpbmRvdy5kZWJ1Zy5ob21vZ3JhcGh5SW5kZXgsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodykpLCBkdyk7XG4gICAgfVxuICB9XG5cbiAgbGV0IG1heFJvdyA9IC0xO1xuICBsZXQgbWF4VmFsdWUgPSAtMTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCA5OyBqKyspIHtcbiAgICBpZiAod1tqXSA+IG1heFZhbHVlKSB7XG4gICAgICBtYXhSb3cgPSBqO1xuICAgICAgbWF4VmFsdWUgPSB3W2pdO1xuICAgIH1cbiAgfVxuXG5cbiAgaWYgKG1heFZhbHVlID09IDApIHJldHVybiBudWxsOyAvLyBubyBzb2x1dGlvblxuXG4gIGNvbnN0IHggPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcbiAgICB4W2ldID0gWFttYXhSb3cgKiA5ICsgaV07XG4gIH1cblxuICByZXR1cm4geDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXB1dGVIb21vZ3JhcGh5LFxufVxuXG4iLCJjb25zdCBrSG91Z2hCaW5EZWx0YSA9IDE7XG5cbi8vIG1hdGhjZXMgW3F1ZXJ5cG9pbnRJbmRleDp4LCBrZXlwb2ludEluZGV4OiB4XVxuY29uc3QgY29tcHV0ZUhvdWdoTWF0Y2hlcyA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtrZXlwb2ludHMsIHF1ZXJ5cG9pbnRzLCBrZXl3aWR0aCwga2V5aGVpZ2h0LCBxdWVyeXdpZHRoLCBxdWVyeWhlaWdodCwgbWF0Y2hlc30gPSBvcHRpb25zO1xuXG4gIGNvbnN0IG1heFggPSBxdWVyeXdpZHRoICogMS4yO1xuICBjb25zdCBtaW5YID0gLW1heFg7XG4gIGNvbnN0IG1heFkgPSBxdWVyeWhlaWdodCAqIDEuMjtcbiAgY29uc3QgbWluWSA9IC1tYXhZO1xuICBjb25zdCBudW1BbmdsZUJpbnMgPSAxMjtcbiAgY29uc3QgbnVtU2NhbGVCaW5zID0gMTA7XG4gIGNvbnN0IG1pblNjYWxlID0gLTE7XG4gIGNvbnN0IG1heFNjYWxlID0gMTtcbiAgY29uc3Qgc2NhbGVLID0gMTAuMDtcbiAgY29uc3Qgc2NhbGVPbmVPdmVyTG9nSyA9IDEuMCAvIE1hdGgubG9nKHNjYWxlSyk7XG4gIGNvbnN0IG1heERpbSA9IE1hdGgubWF4KGtleXdpZHRoLCBrZXloZWlnaHQpO1xuICBjb25zdCBrZXljZW50ZXJYID0gTWF0aC5mbG9vcihrZXl3aWR0aCAvIDIpO1xuICBjb25zdCBrZXljZW50ZXJZID0gTWF0aC5mbG9vcihrZXloZWlnaHQgLyAyKTtcblxuICAvLyBjb21wdXRlIG51bVhCaW5zIGFuZCBudW1ZQmlucyBiYXNlZCBvbiBtYXRjaGVzXG4gIGNvbnN0IHByb2plY3RlZERpbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcXVlcnlzY2FsZSA9IHF1ZXJ5cG9pbnRzW21hdGNoZXNbaV0ucXVlcnlwb2ludEluZGV4XS5zY2FsZTtcbiAgICBjb25zdCBrZXlzY2FsZSA9IGtleXBvaW50c1ttYXRjaGVzW2ldLmtleXBvaW50SW5kZXhdLnNjYWxlO1xuICAgIGlmIChrZXlzY2FsZSA9PSAwKSBjb25zb2xlLmxvZyhcIkVSUk9SIGRpdmlkZSB6ZXJvXCIpO1xuICAgIGNvbnN0IHNjYWxlID0gcXVlcnlzY2FsZSAvIGtleXNjYWxlO1xuICAgIHByb2plY3RlZERpbXMucHVzaCggc2NhbGUgKiBtYXhEaW0gKTtcbiAgfVxuXG4gIC8vIFRPRE8gb3B0aW1pemUgbWVkaWFuXG4gIC8vICAgd2VpcmQuIG1lZGlhbiBzaG91bGQgYmUgW01hdGguZmxvb3IocHJvamVjdGVkRGltcy5sZW5ndGgvMikgLSAxXSA/XG4gIHByb2plY3RlZERpbXMuc29ydCgoYTEsIGEyKSA9PiB7cmV0dXJuIGExIC0gYTJ9KTtcbiAgY29uc3QgbWVkaWFuUHJvamVjdGVkRGltID0gcHJvamVjdGVkRGltc1sgTWF0aC5mbG9vcihwcm9qZWN0ZWREaW1zLmxlbmd0aC8yKSAtIChwcm9qZWN0ZWREaW1zLmxlbmd0aCUyPT0wPzE6MCkgLTEgXTtcblxuICBjb25zdCBiaW5TaXplID0gMC4yNSAqIG1lZGlhblByb2plY3RlZERpbTtcbiAgY29uc3QgbnVtWEJpbnMgPSBNYXRoLm1heCg1LCBNYXRoLmNlaWwoKG1heFggLSBtaW5YKSAvIGJpblNpemUpKTtcbiAgY29uc3QgbnVtWUJpbnMgPSBNYXRoLm1heCg1LCBNYXRoLmNlaWwoKG1heFkgLSBtaW5ZKSAvIGJpblNpemUpKTtcblxuICBjb25zdCBudW1YWUJpbnMgPSBudW1YQmlucyAqIG51bVlCaW5zO1xuICBjb25zdCBudW1YWUFuZ2xlQmlucyA9IG51bVhZQmlucyAqIG51bUFuZ2xlQmlucztcblxuICAvLyBkbyB2b3RpbmdcbiAgY29uc3QgcXVlcnlwb2ludFZhbGlkcyA9IFtdO1xuICBjb25zdCBxdWVyeXBvaW50QmluTG9jYXRpb25zID0gW107XG4gIGNvbnN0IHZvdGVzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHF1ZXJ5cG9pbnQgPSBxdWVyeXBvaW50c1ttYXRjaGVzW2ldLnF1ZXJ5cG9pbnRJbmRleF07XG4gICAgY29uc3Qga2V5cG9pbnQgPSBrZXlwb2ludHNbbWF0Y2hlc1tpXS5rZXlwb2ludEluZGV4XTtcblxuICAgIGNvbnN0IHt4LCB5LCBzY2FsZSwgYW5nbGV9ID0gX21hcENvcnJlc3BvbmRlbmNlKHtxdWVyeXBvaW50LCBrZXlwb2ludCwga2V5Y2VudGVyWCwga2V5Y2VudGVyWSwgc2NhbGVPbmVPdmVyTG9nS30pO1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgdm90ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICBpZiAoeCA8IG1pblggfHwgeCA+PSBtYXhYIHx8IHkgPCBtaW5ZIHx8IHkgPj0gbWF4WSB8fCBhbmdsZSA8PSAtTWF0aC5QSSB8fCBhbmdsZSA+IE1hdGguUEkgfHwgc2NhbGUgPCBtaW5TY2FsZSB8fCBzY2FsZSA+PSBtYXhTY2FsZSkge1xuICAgICAgcXVlcnlwb2ludFZhbGlkc1tpXSA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbWFwIHByb3BlcnRpZXMgdG8gYmluc1xuICAgIGxldCBmYmluWCA9IG51bVhCaW5zICogKHggLSBtaW5YKSAvIChtYXhYIC0gbWluWCk7XG4gICAgbGV0IGZiaW5ZID0gbnVtWUJpbnMgKiAoeSAtIG1pblkpIC8gKG1heFkgLSBtaW5ZKTtcbiAgICBsZXQgZmJpbkFuZ2xlID0gbnVtQW5nbGVCaW5zICogKGFuZ2xlICsgTWF0aC5QSSkgLyAoMi4wICogTWF0aC5QSSk7XG4gICAgbGV0IGZiaW5TY2FsZSA9IG51bVNjYWxlQmlucyAqIChzY2FsZSAtIG1pblNjYWxlKSAvIChtYXhTY2FsZSAtIG1pblNjYWxlKTtcblxuICAgIHF1ZXJ5cG9pbnRCaW5Mb2NhdGlvbnNbaV0gPSB7YmluWDogZmJpblgsIGJpblk6IGZiaW5ZLCBiaW5BbmdsZTogZmJpbkFuZ2xlLCBiaW5TY2FsZTogZmJpblNjYWxlfTtcblxuICAgIGxldCBiaW5YID0gTWF0aC5mbG9vcihmYmluWCAtIDAuNSk7XG4gICAgbGV0IGJpblkgPSBNYXRoLmZsb29yKGZiaW5ZIC0gMC41KTtcbiAgICBsZXQgYmluU2NhbGUgPSBNYXRoLmZsb29yKGZiaW5TY2FsZSAtIDAuNSk7XG4gICAgbGV0IGJpbkFuZ2xlID0gKE1hdGguZmxvb3IoZmJpbkFuZ2xlIC0gMC41KSArIG51bUFuZ2xlQmlucykgJSBudW1BbmdsZUJpbnM7XG5cbiAgICAvLyBjaGVjayBjYW4gdm90ZSBhbGwgMTYgYmluc1xuICAgIGlmIChiaW5YIDwgMCB8fCBiaW5YICsgMSA+PSBudW1YQmlucyB8fCBiaW5ZIDwgMCB8fCBiaW5ZICsgMSA+PSBudW1ZQmlucyB8fCBiaW5TY2FsZSA8IDAgfHwgYmluU2NhbGUgKzEgPj0gbnVtU2NhbGVCaW5zKSB7XG4gICAgICBxdWVyeXBvaW50VmFsaWRzW2ldID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBkeCA9IDA7IGR4IDwgMjsgZHgrKykge1xuICAgICAgbGV0IGJpblgyID0gYmluWCArIGR4O1xuXG4gICAgICBmb3IgKGxldCBkeSA9IDA7IGR5IDwgMjsgZHkrKykge1xuICAgICAgICBsZXQgYmluWTIgPSBiaW5ZICsgZHk7XG5cbiAgICAgICAgZm9yIChsZXQgZGFuZ2xlID0gMDsgZGFuZ2xlIDwgMjsgZGFuZ2xlKyspIHtcbiAgICAgICAgICBsZXQgYmluQW5nbGUyID0gKGJpbkFuZ2xlICsgZGFuZ2xlKSAlIG51bUFuZ2xlQmlucztcblxuICAgICAgICAgIGZvciAobGV0IGRzY2FsZSA9IDA7IGRzY2FsZSA8IDI7IGRzY2FsZSsrKSB7XG4gICAgICAgICAgICBsZXQgYmluU2NhbGUyID0gYmluU2NhbGUgKyBkc2NhbGU7XG5cbiAgICAgICAgICAgIGNvbnN0IGJpbkluZGV4ID0gYmluWDIgKyBiaW5ZMiAqIG51bVhCaW5zICsgYmluQW5nbGUyICogbnVtWFlCaW5zICsgYmluU2NhbGUyICogbnVtWFlBbmdsZUJpbnM7XG5cbiAgICAgICAgICAgIGlmICh2b3Rlc1tiaW5JbmRleF0gPT09IHVuZGVmaW5lZCkgdm90ZXNbYmluSW5kZXhdID0gMDtcbiAgICAgICAgICAgIHZvdGVzW2JpbkluZGV4XSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBxdWVyeXBvaW50VmFsaWRzW2ldID0gdHJ1ZTtcbiAgfVxuXG4gIGxldCBtYXhWb3RlcyA9IDA7XG4gIGxldCBtYXhWb3RlSW5kZXggPSAtMTtcbiAgT2JqZWN0LmtleXModm90ZXMpLmZvckVhY2goKGluZGV4KSA9PiB7XG4gICAgaWYgKHZvdGVzW2luZGV4XSA+IG1heFZvdGVzKSB7XG4gICAgICBtYXhWb3RlcyA9IHZvdGVzW2luZGV4XTtcbiAgICAgIG1heFZvdGVJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKG1heFZvdGVzIDwgMykgcmV0dXJuIFtdO1xuXG4gIC8vIGdldCBiYWNrIGJpbnMgZnJvbSB2b3RlIGluZGV4XG4gIGNvbnN0IGJpblggPSBNYXRoLmZsb29yKCgobWF4Vm90ZUluZGV4ICUgbnVtWFlBbmdsZUJpbnMpICUgbnVtWFlCaW5zKSAlIG51bVhCaW5zKTtcbiAgY29uc3QgYmluWSA9IE1hdGguZmxvb3IoKCgobWF4Vm90ZUluZGV4IC0gYmluWCkgJSBudW1YWUFuZ2xlQmlucykgJSBudW1YWUJpbnMpIC8gbnVtWEJpbnMpO1xuICBjb25zdCBiaW5BbmdsZSA9IE1hdGguZmxvb3IoKChtYXhWb3RlSW5kZXggLSBiaW5YIC0gKGJpblkgKiBudW1YQmlucykpICUgbnVtWFlBbmdsZUJpbnMpIC8gbnVtWFlCaW5zKTtcbiAgY29uc3QgYmluU2NhbGUgPSBNYXRoLmZsb29yKChtYXhWb3RlSW5kZXggLSBiaW5YIC0gKGJpblkgKiBudW1YQmlucykgLSAoYmluQW5nbGUgKiBudW1YWUJpbnMpKSAvIG51bVhZQW5nbGVCaW5zKTtcblxuICAvL2NvbnNvbGUubG9nKFwiaG91Z2ggdm90ZWQ6IFwiLCB7YmluWCwgYmluWSwgYmluQW5nbGUsIGJpblNjYWxlLCBtYXhWb3RlSW5kZXh9KTtcblxuICBjb25zdCBob3VnaE1hdGNoZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFxdWVyeXBvaW50VmFsaWRzW2ldKSBjb250aW51ZTtcblxuICAgIGNvbnN0IHF1ZXJ5QmlucyA9IHF1ZXJ5cG9pbnRCaW5Mb2NhdGlvbnNbaV07XG4gICAgLy8gY29tcHV0ZSBiaW4gZGlmZmVyZW5jZVxuICAgIGNvbnN0IGRpc3RCaW5YID0gTWF0aC5hYnMocXVlcnlCaW5zLmJpblggLSAoYmluWCswLjUpKTtcbiAgICBpZiAoZGlzdEJpblggPj0ga0hvdWdoQmluRGVsdGEpIGNvbnRpbnVlO1xuXG4gICAgY29uc3QgZGlzdEJpblkgPSBNYXRoLmFicyhxdWVyeUJpbnMuYmluWSAtIChiaW5ZKzAuNSkpO1xuICAgIGlmIChkaXN0QmluWSA+PSBrSG91Z2hCaW5EZWx0YSkgY29udGludWU7XG5cbiAgICBjb25zdCBkaXN0QmluU2NhbGUgPSBNYXRoLmFicyhxdWVyeUJpbnMuYmluU2NhbGUgLSAoYmluU2NhbGUrMC41KSk7XG4gICAgaWYgKGRpc3RCaW5TY2FsZSA+PSBrSG91Z2hCaW5EZWx0YSkgY29udGludWU7XG5cbiAgICBjb25zdCB0ZW1wID0gTWF0aC5hYnMocXVlcnlCaW5zLmJpbkFuZ2xlIC0gKGJpbkFuZ2xlKzAuNSkpO1xuICAgIGNvbnN0IGRpc3RCaW5BbmdsZSA9IE1hdGgubWluKHRlbXAsIG51bUFuZ2xlQmlucyAtIHRlbXApO1xuICAgIGlmIChkaXN0QmluQW5nbGUgPj0ga0hvdWdoQmluRGVsdGEpIGNvbnRpbnVlO1xuXG4gICAgaG91Z2hNYXRjaGVzLnB1c2gobWF0Y2hlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGhvdWdoTWF0Y2hlcztcbn1cblxuY29uc3QgX21hcENvcnJlc3BvbmRlbmNlID0gKHtxdWVyeXBvaW50LCBrZXlwb2ludCwga2V5Y2VudGVyWCwga2V5Y2VudGVyWSwgc2NhbGVPbmVPdmVyTG9nS30pID0+IHtcbiAgLy8gbWFwIGFuZ2xlIHRvICgtcGksIHBpXVxuICBsZXQgYW5nbGUgPSBxdWVyeXBvaW50LmFuZ2xlIC0ga2V5cG9pbnQuYW5nbGU7XG4gIGlmIChhbmdsZSA8PSAtTWF0aC5QSSkgYW5nbGUgKz0gMipNYXRoLlBJO1xuICBlbHNlIGlmIChhbmdsZSA+IE1hdGguUEkpIGFuZ2xlIC09IDIqTWF0aC5QSTtcblxuICBjb25zdCBzY2FsZSA9IHF1ZXJ5cG9pbnQuc2NhbGUgLyBrZXlwb2ludC5zY2FsZTtcblxuICAvLyAyeDIgc2ltaWxhcml0eVxuICBjb25zdCBjb3MgPSBzY2FsZSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgY29uc3Qgc2luID0gc2NhbGUgKiBNYXRoLnNpbihhbmdsZSk7XG4gIGNvbnN0IFMgPSBbY29zLCAtc2luLCBzaW4sIGNvc107XG5cbiAgY29uc3QgdHAgPSBbXG4gICAgU1swXSAqIGtleXBvaW50LngyRCArIFNbMV0gKiBrZXlwb2ludC55MkQsXG4gICAgU1syXSAqIGtleXBvaW50LngyRCArIFNbM10gKiBrZXlwb2ludC55MkRcbiAgXTtcbiAgY29uc3QgdHggPSBxdWVyeXBvaW50LngyRCAtIHRwWzBdO1xuICBjb25zdCB0eSA9IHF1ZXJ5cG9pbnQueTJEIC0gdHBbMV07XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBTWzBdICoga2V5Y2VudGVyWCArIFNbMV0gKiBrZXljZW50ZXJZICsgdHgsXG4gICAgeTogU1syXSAqIGtleWNlbnRlclggKyBTWzNdICoga2V5Y2VudGVyWSArIHR5LFxuICAgIGFuZ2xlOiBhbmdsZSxcbiAgICBzY2FsZTogTWF0aC5sb2coc2NhbGUpICogc2NhbGVPbmVPdmVyTG9nS1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wdXRlSG91Z2hNYXRjaGVzXG59XG5cbiIsImNvbnN0IHtidWlsZDogaGllcmFyY2hpY2FsQ2x1c3RlcmluZ0J1aWxkfSA9IHJlcXVpcmUoJy4vaGllcmFyY2hpY2FsLWNsdXN0ZXJpbmcuanMnKTtcbmNvbnN0IHttYXRjaH0gPSByZXF1aXJlKCcuL21hdGNoaW5nJyk7XG5cbmNvbnN0IFBZUkFNSURfTlVNX1NDQUxFU19QRVJfT0NUQVZFUyA9IDM7XG5jb25zdCBQWVJBTUlEX01JTl9TSVpFID0gODtcblxuY2xhc3MgTWF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKG1hdGNoaW5nRGF0YSkge1xuICAgIHRoaXMua2V5ZnJhbWVzID0gbWF0Y2hpbmdEYXRhO1xuICB9XG5cbiAgbWF0Y2hEZXRlY3Rpb24ocXVlcnlXaWR0aCwgcXVlcnlIZWlnaHQsIGZlYXR1cmVQb2ludHMpIHtcbiAgICBjb25zdCBxdWVyeXBvaW50cyA9IFtdO1xuICAgIGNvbnN0IGRwaSA9IDEuMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZlYXR1cmVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHF1ZXJ5cG9pbnRzLnB1c2goe1xuICAgICAgICB4MkQ6IGZlYXR1cmVQb2ludHNbaV0ueCxcbiAgICAgICAgeTJEOiBmZWF0dXJlUG9pbnRzW2ldLnksXG4gICAgICAgIHgzRDogKGZlYXR1cmVQb2ludHNbaV0ueCArIDAuNSkgLyBkcGksXG4gICAgICAgIHkzRDogKChxdWVyeUhlaWdodC0wLjUpIC0gZmVhdHVyZVBvaW50c1tpXS55KSAvIGRwaSxcbiAgICAgICAgYW5nbGU6IGZlYXR1cmVQb2ludHNbaV0uYW5nbGUsXG4gICAgICAgIHNjYWxlOiBmZWF0dXJlUG9pbnRzW2ldLnNpZ21hLFxuICAgICAgICBtYXhpbWE6IGZlYXR1cmVQb2ludHNbaV0uc2NvcmUgPiAwLFxuICAgICAgICBkZXNjcmlwdG9yczogZmVhdHVyZVBvaW50c1tpXS5kZXNjcmlwdG9yc1xuICAgICAgfSlcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbWF0Y2goe2tleWZyYW1lczogdGhpcy5rZXlmcmFtZXMsIHF1ZXJ5cG9pbnRzOiBxdWVyeXBvaW50cywgcXVlcnl3aWR0aDogcXVlcnlXaWR0aCwgcXVlcnloZWlnaHQ6IHF1ZXJ5SGVpZ2h0fSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBzY3JlZW5Db29yZHMgPSBbXTtcbiAgICBjb25zdCB3b3JsZENvb3JkcyA9IFtdO1xuICAgIGNvbnN0IGtleWZyYW1lID0gdGhpcy5rZXlmcmFtZXNbcmVzdWx0LmtleWZyYW1lSW5kZXhdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lm1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHF1ZXJ5cG9pbnRJbmRleCA9IHJlc3VsdC5tYXRjaGVzW2ldLnF1ZXJ5cG9pbnRJbmRleDtcbiAgICAgIGNvbnN0IGtleXBvaW50SW5kZXggPSByZXN1bHQubWF0Y2hlc1tpXS5rZXlwb2ludEluZGV4O1xuICAgICAgc2NyZWVuQ29vcmRzLnB1c2goe1xuICAgICAgICB4OiBxdWVyeXBvaW50c1txdWVyeXBvaW50SW5kZXhdLngyRCxcbiAgICAgICAgeTogcXVlcnlwb2ludHNbcXVlcnlwb2ludEluZGV4XS55MkQsXG4gICAgICB9KVxuICAgICAgd29ybGRDb29yZHMucHVzaCh7XG4gICAgICAgIHg6IGtleWZyYW1lLnBvaW50c1trZXlwb2ludEluZGV4XS54M0QsXG4gICAgICAgIHk6IGtleWZyYW1lLnBvaW50c1trZXlwb2ludEluZGV4XS55M0QsXG4gICAgICAgIHo6IDAsXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7c2NyZWVuQ29vcmRzLCB3b3JsZENvb3Jkc307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1hdGNoZXJcbn1cbiIsImNvbnN0IFRpbnlRdWV1ZSA9IHJlcXVpcmUoJ3RpbnlxdWV1ZScpLmRlZmF1bHQ7XG5jb25zdCB7Y29tcHV0ZTogaGFtbWluZ0NvbXB1dGV9ID0gcmVxdWlyZSgnLi9oYW1taW5nLWRpc3RhbmNlLmpzJyk7XG5jb25zdCB7Y29tcHV0ZUhvdWdoTWF0Y2hlc30gPSByZXF1aXJlKCcuL2hvdWdoLmpzJyk7XG5jb25zdCB7Y29tcHV0ZUhvbW9ncmFwaHl9ID0gcmVxdWlyZSgnLi9ob21vZ3JhcGh5LmpzJyk7XG5jb25zdCB7bXVsdGlwbHlQb2ludEhvbW9ncmFwaHlJbmhvbW9nZW5vdXMsIG1hdHJpeEludmVyc2UzM30gPSByZXF1aXJlKCcuLi91dGlscy9nZW9tZXRyeS5qcycpO1xuXG5jb25zdCBJTkxJRVJfVEhSRVNIT0xEID0gMztcbi8vY29uc3QgTUlOX05VTV9JTkxJRVJTID0gODsgIC8vZGVmYXVsdFxuY29uc3QgTUlOX05VTV9JTkxJRVJTID0gNjtcbmNvbnN0IENMVVNURVJfTUFYX1BPUCA9IDg7XG5jb25zdCBIQU1NSU5HX1RIUkVTSE9MRCA9IDAuNztcblxuLy8gbWF0Y2ggbGlzdCBvZiBxdWVycG9pbnRzIGFnYWluc3QgcHJlLWJ1aWx0IGxpc3Qgb2Yga2V5ZnJhbWVzXG5jb25zdCBtYXRjaCA9ICh7a2V5ZnJhbWVzLCBxdWVyeXBvaW50cywgcXVlcnl3aWR0aCwgcXVlcnloZWlnaHR9KSA9PiB7XG4gIGxldCByZXN1bHQgPSBudWxsO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5ZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbG9nVGltZShcInNtXCIraSk7XG5cbiAgICBjb25zdCBrZXlmcmFtZSA9IGtleWZyYW1lc1tpXTtcbiAgICBjb25zdCBrZXlwb2ludHMgPSBrZXlmcmFtZS5wb2ludHM7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkRFQlVHX01BVENIKSB7XG4gICAgICB3aW5kb3cuZGVidWcucXVlcnlrZXlmcmFtZUluZGV4ID0gaTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19USU1FKSB7XG4gICAgICB2YXIgX3N0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcXVlcnlwb2ludHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0ga2V5ZnJhbWUucG9pbnRzQ2x1c3Rlci5yb290Tm9kZTtcbiAgICAgIGNvbnN0IHF1ZXJ5cG9pbnQgPSBxdWVyeXBvaW50c1tqXTtcbiAgICAgIGNvbnN0IGtleXBvaW50SW5kZXhlcyA9IFtdO1xuICAgICAgY29uc3QgcXVldWUgPSBuZXcgVGlueVF1ZXVlKFtdLCAoYTEsIGEyKSA9PiB7cmV0dXJuIGExLmQgLSBhMi5kfSk7XG5cbiAgICAgIF9xdWVyeSh7bm9kZTogcm9vdE5vZGUsIGtleXBvaW50cywgcXVlcnlwb2ludCwgcXVldWUsIGtleXBvaW50SW5kZXhlcywgbnVtUG9wOiAwfSk7XG5cbiAgICAgIGxldCBiZXN0SW5kZXggPSAtMTtcbiAgICAgIGxldCBiZXN0RDEgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgIGxldCBiZXN0RDIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblxuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBrZXlwb2ludEluZGV4ZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgY29uc3Qga2V5cG9pbnQgPSBrZXlwb2ludHNba2V5cG9pbnRJbmRleGVzW2tdXTtcbiAgICAgICAgaWYgKGtleXBvaW50Lm1heGltYSAhPSBxdWVyeXBvaW50Lm1heGltYSkgY29udGludWU7XG5cbiAgICAgICAgY29uc3QgZCA9IGhhbW1pbmdDb21wdXRlKHt2MToga2V5cG9pbnQuZGVzY3JpcHRvcnMsIHYyOiBxdWVyeXBvaW50LmRlc2NyaXB0b3JzfSk7XG4gICAgICAgIGlmIChkIDwgYmVzdEQxKSB7XG4gICAgICAgICAgYmVzdEQyID0gYmVzdEQxO1xuICAgICAgICAgIGJlc3REMSA9IGQ7XG4gICAgICAgICAgYmVzdEluZGV4ID0ga2V5cG9pbnRJbmRleGVzW2tdO1xuICAgICAgICB9IGVsc2UgaWYgKGQgPCBiZXN0RDIpIHtcbiAgICAgICAgICBiZXN0RDIgPSBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYmVzdEluZGV4ICE9PSAtMSAmJiAoYmVzdEQyID09PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCAoMS4wICogYmVzdEQxIC8gYmVzdEQyKSA8IEhBTU1JTkdfVEhSRVNIT0xEKSkge1xuICAgICAgICBtYXRjaGVzLnB1c2goe3F1ZXJ5cG9pbnRJbmRleDogaiwga2V5cG9pbnRJbmRleDogYmVzdEluZGV4fSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfTUFUQ0gpIHtcbiAgICAgICAgaWYgKCF3aW5kb3cuZGVidWcucXVlcnlNYXRjaEluZGV4KSB3aW5kb3cuZGVidWcucXVlcnlNYXRjaEluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgZE1hdGNoID0gd2luZG93LmRlYnVnTWF0Y2gubWF0Y2hlc1t3aW5kb3cuZGVidWcucXVlcnlNYXRjaEluZGV4XTtcbiAgICAgICAgaWYgKGJlc3RJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBpZiAoZE1hdGNoICYmIGRNYXRjaC5iZXN0SW5kZXggIT09IDIxNDc0ODM2NDcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSU5DT1JSRUNUIHF1ZXJ5IG1hdGNoXCIsIGJlc3REMSwgYmVzdEQyLCBiZXN0SW5kZXgsICd2cycsIGRNYXRjaC5maXJzdEJlc3QsIGRNYXRjaC5zZWNvbmRCZXN0LCBkTWF0Y2guYmVzdEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGJlc3RJbmRleCAhPT0gZE1hdGNoLmJlc3RJbmRleCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJJTkNPUlJFQ1QgcXVlcnkgbWF0Y2hcIiwgYmVzdEQxLCBiZXN0RDIsIGJlc3RJbmRleCwgJ3ZzJywgZE1hdGNoLmZpcnN0QmVzdCwgZE1hdGNoLnNlY29uZEJlc3QsIGRNYXRjaC5iZXN0SW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuZGVidWcucXVlcnlNYXRjaEluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9nVGltZShcImVtXCIraSk7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkRFQlVHX1RJTUUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdleGVjIHRpbWUgdW50aWwgZmlyc3QgbWF0Y2g6ICcsIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gX3N0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkRFQlVHX01BVENIKSB7XG4gICAgICBjb25zdCBkTWF0Y2hlcyA9IHdpbmRvdy5kZWJ1Z01hdGNoLnF1ZXJ5a2V5ZnJhbWVzW2ldLm1hdGNoZXMxO1xuICAgICAgY29uc29sZS5sb2coXCJtYXRjaGVzIDFcIiwgbWF0Y2hlcy5sZW5ndGgsIGRNYXRjaGVzLmxlbmd0aCk7XG4gICAgICBpZiAobWF0Y2hlcy5sZW5ndGggIT09IGRNYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIklOQ09SUkVDVCBtYXRjaGVzMSBsZW5ndGhcIik7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG1hdGNoZXNbaV0ucXVlcnlwb2ludEluZGV4ICE9PSBkTWF0Y2hlc1tpXS5pbnMgfHwgbWF0Y2hlc1tpXS5rZXlwb2ludEluZGV4ICE9PSBkTWF0Y2hlc1tpXS5yZXMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIklOQ09SUkVDVCBtYXRjaGVzMVwiLCBpLCBtYXRjaGVzW2ldLCBkTWF0Y2hlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPCBNSU5fTlVNX0lOTElFUlMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGhvdWdoTWF0Y2hlcyA9IGNvbXB1dGVIb3VnaE1hdGNoZXMoe1xuICAgICAga2V5cG9pbnRzOiBrZXlmcmFtZS5wb2ludHMsXG4gICAgICBxdWVyeXBvaW50cyxcbiAgICAgIGtleXdpZHRoOiBrZXlmcmFtZS53aWR0aCxcbiAgICAgIGtleWhlaWdodDoga2V5ZnJhbWUuaGVpZ2h0LFxuICAgICAgcXVlcnl3aWR0aCxcbiAgICAgIHF1ZXJ5aGVpZ2h0LFxuICAgICAgbWF0Y2hlcyxcbiAgICB9KTtcblxuICAgIGxvZ1RpbWUoXCJobVwiK2kpO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19USU1FKSB7XG4gICAgICBjb25zb2xlLmxvZygnZXhlYyB0aW1lIHVudGlsIGZpcnN0IGhvdWdoIG1hdGNoOiAnLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIF9zdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19NQVRDSCkge1xuICAgICAgY29uc3QgZE1hdGNoZXMgPSB3aW5kb3cuZGVidWdNYXRjaC5xdWVyeWtleWZyYW1lc1tpXS5ob3VnaE1hdGNoZXMxO1xuICAgICAgY29uc29sZS5sb2coXCJob3VnaCBtYXRjaGVzIDFcIiwgaG91Z2hNYXRjaGVzLmxlbmd0aCwgZE1hdGNoZXMubGVuZ3RoKTtcbiAgICAgIGlmIChob3VnaE1hdGNoZXMubGVuZ3RoICE9PSBkTWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJTkNPUlJFQ1QgbWF0Y2hlczEgbGVuZ3RoXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3VnaE1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhvdWdoTWF0Y2hlc1tpXS5xdWVyeXBvaW50SW5kZXggIT09IGRNYXRjaGVzW2ldLmlucyB8fCBob3VnaE1hdGNoZXNbaV0ua2V5cG9pbnRJbmRleCAhPT0gZE1hdGNoZXNbaV0ucmVzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJJTkNPUlJFQ1QgbWF0Y2hlczFcIiwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzcmNQb2ludHMgPSBbXTtcbiAgICBjb25zdCBkc3RQb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvdWdoTWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcXVlcnlwb2ludCA9IHF1ZXJ5cG9pbnRzW2hvdWdoTWF0Y2hlc1tpXS5xdWVyeXBvaW50SW5kZXhdO1xuICAgICAgY29uc3Qga2V5cG9pbnQgPSBrZXlwb2ludHNbaG91Z2hNYXRjaGVzW2ldLmtleXBvaW50SW5kZXhdO1xuICAgICAgc3JjUG9pbnRzLnB1c2goWyBrZXlwb2ludC54MkQsIGtleXBvaW50LnkyRCBdKTtcbiAgICAgIGRzdFBvaW50cy5wdXNoKFsgcXVlcnlwb2ludC54MkQsIHF1ZXJ5cG9pbnQueTJEIF0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfTUFUQ0gpIHtcbiAgICAgIHdpbmRvdy5kZWJ1Zy5ob21vZ3JhcGh5SW5kZXggPSAtMTsgLy8gKzEgYXQgc3RhcnRcbiAgICB9XG5cbiAgICBjb25zdCBIID0gY29tcHV0ZUhvbW9ncmFwaHkoe1xuICAgICAgc3JjUG9pbnRzLFxuICAgICAgZHN0UG9pbnRzLFxuICAgICAga2V5ZnJhbWUsXG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkRFQlVHX1RJTUUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdleGVjIHRpbWUgdW50aWwgZmlyc3QgSG9tb2dyYXBoeTogJywgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBfc3RhcnQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfTUFUQ0gpIHtcbiAgICAgIGNvbnN0IGRIID0gd2luZG93LmRlYnVnTWF0Y2gucXVlcnlrZXlmcmFtZXNbaV0uSDE7XG4gICAgICBpZiAoIXdpbmRvdy5jbXBBcnJheShILCBkSCwgMC4wMDEpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSU5DT1JSRUNUIEgxXCIsIGksIEgsIGRIKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoSCA9PT0gbnVsbCkgY29udGludWU7XG5cbiAgICBjb25zdCBpbmxpZXJNYXRjaGVzID0gX2ZpbmRJbmxpZXJNYXRjaGVzKHtcbiAgICAgIHF1ZXJ5cG9pbnRzLFxuICAgICAga2V5cG9pbnRzOiBrZXlmcmFtZS5wb2ludHMsXG4gICAgICBILFxuICAgICAgbWF0Y2hlczogaG91Z2hNYXRjaGVzLFxuICAgICAgdGhyZXNob2xkOiBJTkxJRVJfVEhSRVNIT0xEXG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkRFQlVHX1RJTUUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdleGVjIHRpbWUgdW50aWwgZmlyc3QgaW5saWVyIG1hdGNoZXM6ICcsIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gX3N0YXJ0KTtcbiAgICB9XG5cbiAgICAvL2NvbnNvbGUubG9nKFwiaW5saWVyTWF0Y2hlc1wiLCBpbmxpZXJNYXRjaGVzKTtcblxuICAgIGlmIChpbmxpZXJNYXRjaGVzLmxlbmd0aCA8IE1JTl9OVU1fSU5MSUVSUykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19NQVRDSCkge1xuICAgICAgY29uc3QgZE1hdGNoZXMgPSB3aW5kb3cuZGVidWdNYXRjaC5xdWVyeWtleWZyYW1lc1tpXS5pbmxpZXJNYXRjaGVzMTtcbiAgICAgIGNvbnNvbGUubG9nKFwiaW5saWVyIG1hdGNoZXMgMVwiLCBpbmxpZXJNYXRjaGVzLmxlbmd0aCwgZE1hdGNoZXMubGVuZ3RoKTtcbiAgICAgIGlmIChpbmxpZXJNYXRjaGVzLmxlbmd0aCAhPT0gZE1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSU5DT1JSRUNUIGlubGllck1hdGNoZXMxIGxlbmd0aFwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5saWVyTWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5saWVyTWF0Y2hlc1tpXS5xdWVyeXBvaW50SW5kZXggIT09IGRNYXRjaGVzW2ldLmlucyB8fCBpbmxpZXJNYXRjaGVzW2ldLmtleXBvaW50SW5kZXggIT09IGRNYXRjaGVzW2ldLnJlcykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiSU5DT1JSRUNUIGlubGllck1hdGNoZXMxXCIsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZG8gYW5vdGhlciBsb29wIG9mIG1hdGNoIHVzaW5nIHRoZSBob21vZ3JhcGh5XG4gICAgY29uc3QgSEludiA9IG1hdHJpeEludmVyc2UzMyhILCAwLjAwMDAxKTtcbiAgICBjb25zdCBkVGhyZXNob2xkMiA9IDEwICogMTA7XG4gICAgY29uc3QgbWF0Y2hlczIgPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHF1ZXJ5cG9pbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBxdWVyeXBvaW50ID0gcXVlcnlwb2ludHNbal07XG4gICAgICBjb25zdCBtYXBxdWVyeXBvaW50ID0gbXVsdGlwbHlQb2ludEhvbW9ncmFwaHlJbmhvbW9nZW5vdXMoW3F1ZXJ5cG9pbnQueDJELCBxdWVyeXBvaW50LnkyRF0sIEhJbnYpO1xuXG4gICAgICBsZXQgYmVzdEluZGV4ID0gLTE7XG4gICAgICBsZXQgYmVzdEQxID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICBsZXQgYmVzdEQyID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwga2V5cG9pbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGNvbnN0IGtleXBvaW50ID0ga2V5cG9pbnRzW2tdO1xuICAgICAgICBpZiAoa2V5cG9pbnQubWF4aW1hICE9IHF1ZXJ5cG9pbnQubWF4aW1hKSBjb250aW51ZTtcblxuICAgICAgICAvLyBjaGVjayBkaXN0YW5jZSB0aHJlc2hvbGRcbiAgICAgICAgY29uc3QgZDIgPSAoa2V5cG9pbnQueDJEIC0gbWFwcXVlcnlwb2ludFswXSkgKiAoa2V5cG9pbnQueDJEIC0gbWFwcXVlcnlwb2ludFswXSlcbiAgICAgICAgICAgICAgICAgICsgKGtleXBvaW50LnkyRCAtIG1hcHF1ZXJ5cG9pbnRbMV0pICogKGtleXBvaW50LnkyRCAtIG1hcHF1ZXJ5cG9pbnRbMV0pO1xuICAgICAgICBpZiAoZDIgPiBkVGhyZXNob2xkMikgY29udGludWU7XG5cbiAgICAgICAgY29uc3QgZCA9IGhhbW1pbmdDb21wdXRlKHt2MToga2V5cG9pbnQuZGVzY3JpcHRvcnMsIHYyOiBxdWVyeXBvaW50LmRlc2NyaXB0b3JzfSk7XG4gICAgICAgIGlmIChkIDwgYmVzdEQxKSB7XG4gICAgICAgICAgYmVzdEQyID0gYmVzdEQxO1xuICAgICAgICAgIGJlc3REMSA9IGQ7XG4gICAgICAgICAgYmVzdEluZGV4ID0gaztcbiAgICAgICAgfSBlbHNlIGlmIChkIDwgYmVzdEQyKSB7XG4gICAgICAgICAgYmVzdEQyID0gZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYmVzdEluZGV4ICE9PSAtMSAmJiAoYmVzdEQyID09PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCAoMS4wICogYmVzdEQxIC8gYmVzdEQyKSA8IEhBTU1JTkdfVEhSRVNIT0xEKSkge1xuICAgICAgICBtYXRjaGVzMi5wdXNoKHtxdWVyeXBvaW50SW5kZXg6IGosIGtleXBvaW50SW5kZXg6IGJlc3RJbmRleH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfVElNRSkge1xuICAgICAgY29uc29sZS5sb2coJ2V4ZWMgdGltZSB1bnRpbCBzZWNvbmQgbWF0Y2hlczogJywgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBfc3RhcnQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfTUFUQ0gpIHtcbiAgICAgIGNvbnN0IGRNYXRjaGVzID0gd2luZG93LmRlYnVnTWF0Y2gucXVlcnlrZXlmcmFtZXNbaV0ubWF0Y2hlczI7XG4gICAgICBjb25zb2xlLmxvZyhcIm1hdGNoZXMgMlwiLCBtYXRjaGVzMi5sZW5ndGgsIGRNYXRjaGVzLmxlbmd0aCk7XG4gICAgICBpZiAobWF0Y2hlczIubGVuZ3RoICE9PSBkTWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJTkNPUlJFQ1QgbWF0Y2hlczIgbGVuZ3RoXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzMi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobWF0Y2hlczJbaV0ucXVlcnlwb2ludEluZGV4ICE9PSBkTWF0Y2hlc1tpXS5pbnMgfHwgbWF0Y2hlczJbaV0ua2V5cG9pbnRJbmRleCAhPT0gZE1hdGNoZXNbaV0ucmVzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJJTkNPUlJFQ1QgbWF0Y2hlczJcIiwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBob3VnaE1hdGNoZXMyID0gY29tcHV0ZUhvdWdoTWF0Y2hlcyh7XG4gICAgICBrZXlwb2ludHM6IGtleWZyYW1lLnBvaW50cyxcbiAgICAgIHF1ZXJ5cG9pbnRzLFxuICAgICAga2V5d2lkdGg6IGtleWZyYW1lLndpZHRoLFxuICAgICAga2V5aGVpZ2h0OiBrZXlmcmFtZS5oZWlnaHQsXG4gICAgICBxdWVyeXdpZHRoLFxuICAgICAgcXVlcnloZWlnaHQsXG4gICAgICBtYXRjaGVzOiBtYXRjaGVzMixcbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfVElNRSkge1xuICAgICAgY29uc29sZS5sb2coJ2V4ZWMgdGltZSB1bnRpbCBzZWNvbmQgaG91Z2ggbWF0Y2hlczogJywgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBfc3RhcnQpO1xuICAgIH1cblxuICAgIGNvbnN0IHNyY1BvaW50czIgPSBbXTtcbiAgICBjb25zdCBkc3RQb2ludHMyID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3VnaE1hdGNoZXMyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBxdWVyeXBvaW50ID0gcXVlcnlwb2ludHNbaG91Z2hNYXRjaGVzMltpXS5xdWVyeXBvaW50SW5kZXhdO1xuICAgICAgY29uc3Qga2V5cG9pbnQgPSBrZXlwb2ludHNbaG91Z2hNYXRjaGVzMltpXS5rZXlwb2ludEluZGV4XTtcbiAgICAgIHNyY1BvaW50czIucHVzaChbIGtleXBvaW50LngyRCwga2V5cG9pbnQueTJEIF0pO1xuICAgICAgZHN0UG9pbnRzMi5wdXNoKFsgcXVlcnlwb2ludC54MkQsIHF1ZXJ5cG9pbnQueTJEIF0pO1xuICAgIH1cblxuICAgIGNvbnN0IEgyID0gY29tcHV0ZUhvbW9ncmFwaHkoe1xuICAgICAgc3JjUG9pbnRzOiBzcmNQb2ludHMyLFxuICAgICAgZHN0UG9pbnRzOiBkc3RQb2ludHMyLFxuICAgICAga2V5ZnJhbWVcbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuREVCVUdfTUFUQ0gpIHtcbiAgICAgIGNvbnN0IGRIID0gd2luZG93LmRlYnVnTWF0Y2gucXVlcnlrZXlmcmFtZXNbaV0uSDI7XG4gICAgICBpZiAoIXdpbmRvdy5jbXBBcnJheShIMiwgZEgsIDAuMDAwMSkpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJTkNPUlJFQ1QgSDJcIiwgaSwgSDIsIGRIKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkRFQlVHX1RJTUUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdleGVjIHRpbWUgdW50aWwgc2Vjb25kIGhvbW9ncmFwaHk6ICcsIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gX3N0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAoSDIgPT09IG51bGwpIGNvbnRpbnVlO1xuXG4gICAgY29uc3QgaW5saWVyTWF0Y2hlczIgPSBfZmluZElubGllck1hdGNoZXMoe1xuICAgICAgcXVlcnlwb2ludHMsXG4gICAgICBrZXlwb2ludHM6IGtleWZyYW1lLnBvaW50cyxcbiAgICAgIEg6IEgyLFxuICAgICAgbWF0Y2hlczogaG91Z2hNYXRjaGVzMixcbiAgICAgIHRocmVzaG9sZDogSU5MSUVSX1RIUkVTSE9MRFxuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ERUJVR19NQVRDSCkge1xuICAgICAgY29uc3QgZE1hdGNoZXMgPSB3aW5kb3cuZGVidWdNYXRjaC5xdWVyeWtleWZyYW1lc1tpXS5pbmxpZXJNYXRjaGVzMjtcbiAgICAgIGNvbnNvbGUubG9nKFwiaW5saWVyIG1hdGNoZXMgMlwiLCBpbmxpZXJNYXRjaGVzMi5sZW5ndGgsIGRNYXRjaGVzLmxlbmd0aCk7XG4gICAgICBpZiAoaW5saWVyTWF0Y2hlczIubGVuZ3RoICE9PSBkTWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJTkNPUlJFQ1QgaW5saWVyTWF0Y2hlczIgbGVuZ3RoXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmxpZXJNYXRjaGVzMi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5saWVyTWF0Y2hlczJbaV0ucXVlcnlwb2ludEluZGV4ICE9PSBkTWF0Y2hlc1tpXS5pbnMgfHwgaW5saWVyTWF0Y2hlczJbaV0ua2V5cG9pbnRJbmRleCAhPT0gZE1hdGNoZXNbaV0ucmVzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJJTkNPUlJFQ1QgaW5saWVyTWF0Y2hlczJcIiwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkRFQlVHX1RJTUUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdleGVjIHRpbWUgdW50aWwgc2Vjb25kIGlubGllciBtYXRjaGVzOiAnLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIF9zdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKGlubGllck1hdGNoZXMyLmxlbmd0aCA8IE1JTl9OVU1fSU5MSUVSUykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQubWF0Y2hlcy5sZW5ndGggPCBpbmxpZXJNYXRjaGVzMi5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAga2V5ZnJhbWVJbmRleDogaSxcbiAgICAgICAgbWF0Y2hlczogaW5saWVyTWF0Y2hlczIsXG4gICAgICAgIEg6IEgyLFxuICAgICAgfVxuICAgIH1cblxuICAgIGxvZ1RpbWUoXCJtYXRoY2luZyBlbmRcIitpKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBfcXVlcnkgPSAoe25vZGUsIGtleXBvaW50cywgcXVlcnlwb2ludCwgcXVldWUsIGtleXBvaW50SW5kZXhlcywgbnVtUG9wfSkgPT4ge1xuICBpZiAobm9kZS5sZWFmKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnBvaW50SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cG9pbnRJbmRleGVzLnB1c2gobm9kZS5wb2ludEluZGV4ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBkaXN0YW5jZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICBjb25zdCBjZW50ZXJQb2ludEluZGV4ID0gY2hpbGROb2RlLmNlbnRlclBvaW50SW5kZXg7XG4gICAgY29uc3QgZCA9IGhhbW1pbmdDb21wdXRlKHt2MToga2V5cG9pbnRzW2NlbnRlclBvaW50SW5kZXhdLmRlc2NyaXB0b3JzLCB2MjogcXVlcnlwb2ludC5kZXNjcmlwdG9yc30pO1xuICAgIGRpc3RhbmNlcy5wdXNoKGQpO1xuICB9XG5cbiAgbGV0IG1pbkQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgbWluRCA9IE1hdGgubWluKG1pbkQsIGRpc3RhbmNlc1tpXSk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZGlzdGFuY2VzW2ldICE9PSBtaW5EKSB7XG4gICAgICBxdWV1ZS5wdXNoKHtub2RlOiBub2RlLmNoaWxkcmVuW2ldLCBkOiBkaXN0YW5jZXNbaV19KTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGRpc3RhbmNlc1tpXSA9PT0gbWluRCkge1xuICAgICAgX3F1ZXJ5KHtub2RlOiBub2RlLmNoaWxkcmVuW2ldLCBrZXlwb2ludHMsIHF1ZXJ5cG9pbnQsIHF1ZXVlLCBrZXlwb2ludEluZGV4ZXMsIG51bVBvcH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChudW1Qb3AgPCBDTFVTVEVSX01BWF9QT1AgJiYgcXVldWUubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHtub2RlLCBkfSA9IHF1ZXVlLnBvcCgpO1xuICAgIG51bVBvcCArPSAxO1xuICAgIF9xdWVyeSh7bm9kZSwga2V5cG9pbnRzLCBxdWVyeXBvaW50LCBxdWV1ZSwga2V5cG9pbnRJbmRleGVzLCBudW1Qb3B9KTtcbiAgfVxufTtcblxuY29uc3QgX2ZpbmRJbmxpZXJNYXRjaGVzID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3Qge2tleXBvaW50cywgcXVlcnlwb2ludHMsIEgsIG1hdGNoZXMsIHRocmVzaG9sZH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IHRocmVzaG9sZDIgPSB0aHJlc2hvbGQgKiB0aHJlc2hvbGQ7XG5cbiAgY29uc3QgZ29vZE1hdGNoZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcXVlcnlwb2ludCA9IHF1ZXJ5cG9pbnRzW21hdGNoZXNbaV0ucXVlcnlwb2ludEluZGV4XTtcbiAgICBjb25zdCBrZXlwb2ludCA9IGtleXBvaW50c1ttYXRjaGVzW2ldLmtleXBvaW50SW5kZXhdO1xuICAgIGNvbnN0IG1wID0gbXVsdGlwbHlQb2ludEhvbW9ncmFwaHlJbmhvbW9nZW5vdXMoW2tleXBvaW50LngyRCwga2V5cG9pbnQueTJEXSwgSCk7XG4gICAgY29uc3QgZDIgPSAobXBbMF0gLSBxdWVyeXBvaW50LngyRCkgKiAobXBbMF0gLSBxdWVyeXBvaW50LngyRCkgKyAobXBbMV0gLSBxdWVyeXBvaW50LnkyRCkgKiAobXBbMV0gLSBxdWVyeXBvaW50LnkyRCk7XG4gICAgaWYgKGQyIDw9IHRocmVzaG9sZDIpIHtcbiAgICAgIGdvb2RNYXRjaGVzLnB1c2goIG1hdGNoZXNbaV0gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdvb2RNYXRjaGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWF0Y2hcbn1cbiIsImNvbnN0IHtyZWZpbmVIb21vZ3JhcGh5fSA9IHJlcXVpcmUoJy4uL2ljcC9yZWZpbmVfaG9tb2dyYXBoeS5qcycpO1xuY29uc3Qge0dQVX0gPSByZXF1aXJlKCdncHUuanMnKTtcblxuY29uc3QgQVIyX0RFRkFVTFRfU0VBUkNIX0ZFQVRVUkVfTlVNID0gMTY7XG5jb25zdCBBUjJfREVGQVVMVF9UUyA9IDY7XG5jb25zdCBBUjJfU0VBUkNIX1NJWkUgPSA2O1xuXG5jb25zdCBBUjJfU0lNX1RIUkVTSCA9IDAuNTsgLy8gZGVmYXVsdFxuLy9jb25zdCBBUjJfU0lNX1RIUkVTSCA9IDAuMjsgLy8gMC41IGlzIGRlZmF1bHQuIDAuMiBmb3IgZGVidWdcblxuY29uc3QgQVIyX1RSQUNLSU5HX1RIUkVTSCA9IDUuMDsgLy8gZGVmYXVsdFxuLy9jb25zdCBBUjJfVFJBQ0tJTkdfVEhSRVNIID0gMTAwOyAvL1xuXG5jb25zdCBQUkVWX0tFRVAgPSAzO1xuXG5jbGFzcyBUcmFja2VyIHtcbiAgY29uc3RydWN0b3IodHJhY2tpbmdEYXRhLCBpbWFnZUxpc3QsIHByb2plY3Rpb25UcmFuc2Zvcm0pIHtcbiAgICB0aGlzLmdwdSA9IG5ldyBHUFUoKTtcbiAgICB0aGlzLl9pbml0aWFsaXplR1BVKHRoaXMuZ3B1KTtcblxuICAgIHRoaXMuZmVhdHVyZVNldHMgPSB0cmFja2luZ0RhdGE7XG4gICAgdGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtQ1BVID0gcHJvamVjdGlvblRyYW5zZm9ybTtcbiAgICB0aGlzLmxhc3RNb2RlbFZpZXdUcmFuc2Zvcm1DUFUgPSBudWxsO1xuXG4gICAgdGhpcy5mZWF0dXJlUG9pbnRzID0gdGhpcy5fYnVpbGRGZWF0dXJlUG9pbnRzKHRoaXMuZmVhdHVyZVNldHMpO1xuXG4gICAgY29uc3Qge2ltYWdlUGl4ZWxzLCBpbWFnZVByb3BlcnRpZXN9ID0gdGhpcy5fY29tYmluZUltYWdlTGlzdChpbWFnZUxpc3QpO1xuICAgIHRoaXMuaW1hZ2VQaXhlbHMgPSBpbWFnZVBpeGVscztcbiAgICB0aGlzLmltYWdlUHJvcGVydGllcyA9IGltYWdlUHJvcGVydGllczsgLy8gWyBbd2lkdGgsIGhlaWdodCwgZHBpXSBdXG5cbiAgICB0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm0gPSB0aGlzLl9pbml0aWFsaXplUHJvamVjdGlvblRyYW5zZm9ybShwcm9qZWN0aW9uVHJhbnNmb3JtKTtcblxuICAgIHRoaXMudmlkZW9LZXJuZWwgPSBudWxsO1xuICAgIHRoaXMuZGV0ZWN0ZWRLZXJuZWwgPSBudWxsO1xuICAgIHRoaXMudXBkYXRlUHJldlJlc3VsdHNLZXJuZWwgPSBudWxsO1xuICAgIHRoaXMua2VybmVscyA9IFtdO1xuICB9XG5cbiAgX2luaXRpYWxpemVQcm9qZWN0aW9uVHJhbnNmb3JtKHByb2plY3Rpb25UcmFuc2Zvcm0pIHtcbiAgICBjb25zdCBrZXJuZWwgPSB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGFbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgfSwge1xuICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICBvdXRwdXQ6IFs0LCAzXVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbChwcm9qZWN0aW9uVHJhbnNmb3JtKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX2luaXRpYWxpemVHUFUoZ3B1KSB7XG4gICAgZ3B1LmFkZEZ1bmN0aW9uKGZ1bmN0aW9uIGNvbXB1dGVTY3JlZW5Db29yZGlhdGUobW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybXMsIHQsIHgsIHksIHopIHtcbiAgICAgIGNvbnN0IHV4ID0gbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybXNbdF1bMF1bMF0gKiB4ICsgbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybXNbdF1bMF1bMV0gKiB5XG4gICAgICAgICArIG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1zW3RdWzBdWzJdICogeiArIG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1zW3RdWzBdWzNdO1xuICAgICAgY29uc3QgdXkgPSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3Jtc1t0XVsxXVswXSAqIHggKyBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3Jtc1t0XVsxXVsxXSAqIHlcbiAgICAgICAgICsgbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybXNbdF1bMV1bMl0gKiB6ICsgbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybXNbdF1bMV1bM107XG4gICAgICBjb25zdCB1eiA9IG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1zW3RdWzJdWzBdICogeCArIG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1zW3RdWzJdWzFdICogeVxuICAgICAgICAgKyBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3Jtc1t0XVsyXVsyXSAqIHogKyBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3Jtc1t0XVsyXVszXTtcbiAgICAgIGlmKCBNYXRoLmFicyh1eikgPCAwLjAwMDAwMSApIHJldHVybiBbMCwgMCwgMF07XG4gICAgICAvLyBmaXJzdCBudW1iZXIgaW5kaWNhdGVzIGhhcyB2YWxpZCByZXN1bHRcbiAgICAgIHJldHVybiBbMSwgdXgvdXosIHV5L3V6XTtcbiAgICB9KTtcblxuICAgIGdwdS5hZGRGdW5jdGlvbihmdW5jdGlvbiBzY3JlZW5Ub01hcmtlckNvb3JkaW5hdGUobW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybSwgdCwgc3gsIHN5KSB7XG4gICAgICBjb25zdCBjMTEgPSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtW3RdWzJdWzBdICogc3ggLSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtW3RdWzBdWzBdO1xuICAgICAgY29uc3QgYzEyID0gbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybVt0XVsyXVsxXSAqIHN4IC0gbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybVt0XVswXVsxXTtcbiAgICAgIGNvbnN0IGMyMSA9IG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1bdF1bMl1bMF0gKiBzeSAtIG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1bdF1bMV1bMF07XG4gICAgICBjb25zdCBjMjIgPSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtW3RdWzJdWzFdICogc3kgLSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtW3RdWzFdWzFdO1xuICAgICAgY29uc3QgYjEgID0gbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybVt0XVswXVszXSAtIG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1bdF1bMl1bM10gKiBzeDtcbiAgICAgIGNvbnN0IGIyICA9IG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1bdF1bMV1bM10gLSBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtW3RdWzJdWzNdICogc3k7XG5cbiAgICAgIGNvbnN0IG0gPSBjMTEgKiBjMjIgLSBjMTIgKiBjMjE7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAoYzIyICogYjEgLSBjMTIgKiBiMikgLyBtLFxuICAgICAgICAoYzExICogYjIgLSBjMjEgKiBiMSkgLyBtXG4gICAgICBdXG4gICAgfSk7XG5cbiAgICBncHUuYWRkRnVuY3Rpb24oZnVuY3Rpb24gZ2V0VmVjdG9yQW5nbGUocDEsIHAyKSB7XG4gICAgICBjb25zdCBsID0gTWF0aC5zcXJ0KCAocDJbMF0tcDFbMF0pKihwMlswXS1wMVswXSkgKyAocDJbMV0tcDFbMV0pKihwMlsxXS1wMVsxXSkgKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIChwMlsxXSAtIHAxWzFdKSAvIGwsIC8vc2luXG4gICAgICAgIChwMlswXSAtIHAxWzBdKSAvIGwgIC8vY29zXG4gICAgICBdO1xuICAgIH0pO1xuXG4gICAgZ3B1LmFkZEZ1bmN0aW9uKGZ1bmN0aW9uIGdldFRyaWFuZ2xlQXJlYShwMSwgcDIsIHAzKSB7XG4gICAgICBjb25zdCB4MSA9IHAyWzBdIC0gcDFbMF07XG4gICAgICBjb25zdCB5MSA9IHAyWzFdIC0gcDFbMV07XG4gICAgICBjb25zdCB4MiA9IHAzWzBdIC0gcDFbMF07XG4gICAgICBjb25zdCB5MiA9IHAzWzFdIC0gcDFbMV07XG4gICAgICBjb25zdCBzID0gMS4wICogKHgxICogeTIgLSB4MiAqIHkxKSAvIDIuMDtcbiAgICAgIHJldHVybiBNYXRoLmFicyhzKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21iaW5lSW1hZ2VMaXN0KGltYWdlTGlzdCkge1xuICAgIGxldCB0b3RhbFBpeGVsID0gMDtcbiAgICBsZXQgcHJvcGVydGllc0RhdGEgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvcGVydGllc0RhdGEucHVzaChbaW1hZ2VMaXN0W2ldLndpZHRoLCBpbWFnZUxpc3RbaV0uaGVpZ2h0LCB0b3RhbFBpeGVsLCBpbWFnZUxpc3RbaV0uZHBpXSk7XG4gICAgICB0b3RhbFBpeGVsICs9IGltYWdlTGlzdFtpXS53aWR0aCAqIGltYWdlTGlzdFtpXS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdEtlcm5lbCA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9LCB7XG4gICAgICBvdXRwdXQ6IFt0b3RhbFBpeGVsXSxcbiAgICAgIHBpcGVsaW5lOiB0cnVlXG4gICAgfSk7XG4gICAgbGV0IGNvbWJpbmVkID0gaW5pdEtlcm5lbCgpO1xuICAgIC8vaW5pdEtlcm5lbC5kZXN0cm95KCk7XG5cbiAgICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gICAgbGV0IGVuZEluZGV4ID0gMDtcbiAgICBjb25zdCBrZXJuZWxzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVuZEluZGV4ID0gc3RhcnRJbmRleCArIGltYWdlTGlzdFtpXS53aWR0aCAqIGltYWdlTGlzdFtpXS5oZWlnaHQ7XG5cbiAgICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihkYXRhLCBpbWFnZURhdGEpIHtcbiAgICAgICAgY29uc3Qge3N0YXJ0SW5kZXgsIGVuZEluZGV4fSA9IHRoaXMuY29uc3RhbnRzO1xuICAgICAgICBpZiAodGhpcy50aHJlYWQueCA8IHN0YXJ0SW5kZXggfHwgdGhpcy50aHJlYWQueCA+PSBlbmRJbmRleCkgcmV0dXJuIGRhdGFbdGhpcy50aHJlYWQueF07XG4gICAgICAgIHJldHVybiBpbWFnZURhdGFbdGhpcy50aHJlYWQueCAtIHN0YXJ0SW5kZXhdO1xuICAgICAgfSwge1xuICAgICAgICBjb25zdGFudHM6IHtzdGFydEluZGV4LCBlbmRJbmRleH0sXG4gICAgICAgIG91dHB1dDogW3RvdGFsUGl4ZWxdLFxuICAgICAgICBwaXBlbGluZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjb21iaW5lZCA9IGtlcm5lbChjb21iaW5lZCwgaW1hZ2VMaXN0W2ldLmRhdGEpO1xuICAgICAga2VybmVscy5wdXNoKGtlcm5lbCk7XG4gICAgICBzdGFydEluZGV4ID0gZW5kSW5kZXg7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW1hZ2VMaXN0Lmxlbmd0aC0xOyBpKyspIHtcbiAgICAgIC8va2VybmVsc1tpXS5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvcGVydGllc0tlcm5lbCA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZGF0YVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICB9LCB7XG4gICAgICBvdXRwdXQ6IFtwcm9wZXJ0aWVzRGF0YVswXS5sZW5ndGgsIHByb3BlcnRpZXNEYXRhLmxlbmd0aF0sXG4gICAgICBwaXBlbGluZTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzS2VybmVsKHByb3BlcnRpZXNEYXRhKTtcbiAgICAvL2RpbWVuc2lvbktlcm5lbC5kZXN0cm95KCk7XG4gICAgcmV0dXJuIHtpbWFnZVBpeGVsczogY29tYmluZWQsIGltYWdlUHJvcGVydGllczogcHJvcGVydGllc307XG4gIH1cblxuICAvLyBmaXJzdCBkaW1lbnNpb246IFt4LCB5LCBsZXZlbCBpbmRleCwgbWF4ZHBpLCBtaW5kcGldXG4gIF9idWlsZEZlYXR1cmVQb2ludHMoZmVhdHVyZVNldHMpIHtcbiAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZlYXR1cmVTZXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBtYXhkcGkgPSBmZWF0dXJlU2V0c1tqXS5tYXhkcGk7XG4gICAgICBjb25zdCBtaW5kcGkgPSBmZWF0dXJlU2V0c1tqXS5taW5kcGk7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGZlYXR1cmVTZXRzW2pdLmNvb3Jkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICBjb25zdCB7bXgsIG15fSA9IGZlYXR1cmVTZXRzW2pdLmNvb3Jkc1trXTtcbiAgICAgICAgcG9pbnRzLnB1c2goW214LCBteSwgaiwgbWF4ZHBpLCBtaW5kcGldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qga2VybmVsID0gdGhpcy5ncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkYXRhW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgIH0sIHtcbiAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgb3V0cHV0OiBbNSwgcG9pbnRzLmxlbmd0aF1cbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBrZXJuZWwocG9pbnRzKTtcbiAgICAvL2tlcm5lbC5kZXN0cm95KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGRldGVjdGVkKG1vZGVsVmlld1RyYW5zZm9ybSkge1xuICAgIHRoaXMubGFzdE1vZGVsVmlld1RyYW5zZm9ybUNQVSA9IG1vZGVsVmlld1RyYW5zZm9ybTtcblxuICAgIGlmICh0aGlzLmRldGVjdGVkS2VybmVsID09PSBudWxsKSB7XG4gICAgICBjb25zdCBidWlsZE1vZGVsVmlldyA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgfSwge1xuICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgb3V0cHV0OiBbNCwgMywgUFJFVl9LRUVQXVxuICAgICAgfSk7XG4gICAgICBjb25zdCBidWlsZE1vZGVsVmlld1Byb2plY3Rpb24gPSB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24obW9kZWxWaWV3VHJhbnNmb3JtLCBwcm9qZWN0aW9uVHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IGogPSB0aGlzLnRocmVhZC55O1xuICAgICAgICBjb25zdCBpID0gdGhpcy50aHJlYWQueDtcbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb25UcmFuc2Zvcm1bal1bMF0gKiBtb2RlbFZpZXdUcmFuc2Zvcm1bMF1baV1cbiAgICAgICAgICAgICArIHByb2plY3Rpb25UcmFuc2Zvcm1bal1bMV0gKiBtb2RlbFZpZXdUcmFuc2Zvcm1bMV1baV1cbiAgICAgICAgICAgICArIHByb2plY3Rpb25UcmFuc2Zvcm1bal1bMl0gKiBtb2RlbFZpZXdUcmFuc2Zvcm1bMl1baV07XG4gICAgICB9LCB7XG4gICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICBvdXRwdXQ6IFs0LCAzLCBQUkVWX0tFRVBdXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJ1aWxkRmVhdHVyZUluZGV4ZXMgPSB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0sIHtcbiAgICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICAgIG91dHB1dDogW0FSMl9ERUZBVUxUX1NFQVJDSF9GRUFUVVJFX05VTSwgUFJFVl9LRUVQXVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZGV0ZWN0ZWRLZXJuZWwgPSBbYnVpbGRNb2RlbFZpZXcsIGJ1aWxkTW9kZWxWaWV3UHJvamVjdGlvbiwgYnVpbGRGZWF0dXJlSW5kZXhlc107XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2TW9kZWxWaWV3VHJhbnNmb3JtcyA9IHRoaXMuZGV0ZWN0ZWRLZXJuZWxbMF0obW9kZWxWaWV3VHJhbnNmb3JtKTtcbiAgICB0aGlzLnByZXZNb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtcyA9IHRoaXMuZGV0ZWN0ZWRLZXJuZWxbMV0obW9kZWxWaWV3VHJhbnNmb3JtLCB0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm0pO1xuICAgIHRoaXMucHJldlNlbGVjdGVkRmVhdHVyZUluZGV4ZXMgPSB0aGlzLmRldGVjdGVkS2VybmVsWzJdKCk7XG4gIH1cblxuICBfdXBkYXRlUHJldlJlc3VsdHMobW9kZWxWaWV3VHJhbnNmb3JtLCBzZWxlY3Rpb24pIHtcbiAgICB0aGlzLmxhc3RNb2RlbFZpZXdUcmFuc2Zvcm1DUFUgPSBtb2RlbFZpZXdUcmFuc2Zvcm07XG5cbiAgICBpZiAodGhpcy51cGRhdGVQcmV2UmVzdWx0c0tlcm5lbCA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgYnVpbGRNb2RlbFZpZXcgPSB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24obW9kZWxWaWV3VHJhbnNmb3JtcywgbmV3TW9kZWxWaWV3VHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0aGlzLnRocmVhZC56ID09PSAwKSByZXR1cm4gbmV3TW9kZWxWaWV3VHJhbnNmb3JtW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgICByZXR1cm4gbW9kZWxWaWV3VHJhbnNmb3Jtc1t0aGlzLnRocmVhZC56LTFdW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgfSwge1xuICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgb3V0cHV0OiBbNCwgMywgUFJFVl9LRUVQXVxuICAgICAgfSk7XG4gICAgICBjb25zdCBidWlsZE1vZGVsVmlld1Byb2plY3Rpb24gPSB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24obW9kZWxWaWV3UHJvamV0aW9uVHJhbnNmb3JtcywgbmV3TW9kZWxWaWV3VHJhbnNmb3JtLCBwcm9qZWN0aW9uVHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0aGlzLnRocmVhZC56ID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgaiA9IHRoaXMudGhyZWFkLnk7XG4gICAgICAgICAgY29uc3QgaSA9IHRoaXMudGhyZWFkLng7XG4gICAgICAgICAgcmV0dXJuIHByb2plY3Rpb25UcmFuc2Zvcm1bal1bMF0gKiBuZXdNb2RlbFZpZXdUcmFuc2Zvcm1bMF1baV1cbiAgICAgICAgICAgICAgICsgcHJvamVjdGlvblRyYW5zZm9ybVtqXVsxXSAqIG5ld01vZGVsVmlld1RyYW5zZm9ybVsxXVtpXVxuICAgICAgICAgICAgICAgKyBwcm9qZWN0aW9uVHJhbnNmb3JtW2pdWzJdICogbmV3TW9kZWxWaWV3VHJhbnNmb3JtWzJdW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2RlbFZpZXdQcm9qZXRpb25UcmFuc2Zvcm1zW3RoaXMudGhyZWFkLnotMV1bdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICB9LCB7XG4gICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICBvdXRwdXQ6IFs0LCAzLCBQUkVWX0tFRVBdXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJ1aWxkRmVhdHVyZUluZGV4ZXMgPSB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oZmVhdHVyZUluZGV4ZXMsIG5ld1NlbGVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy50aHJlYWQueSA9PT0gMCkge1xuICAgICAgICAgIGlmIChuZXdTZWxlY3Rpb25bdGhpcy50aHJlYWQueF1bNV0gPiB0aGlzLmNvbnN0YW50cy5zaW1UaHJlc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdTZWxlY3Rpb25bdGhpcy50aHJlYWQueF1bMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmVhdHVyZUluZGV4ZXNbdGhpcy50aHJlYWQueS0xXVt0aGlzLnRocmVhZC54XTtcbiAgICAgIH0sIHtcbiAgICAgICAgY29uc3RhbnRzOiB7c2ltVGhyZXNoOiBBUjJfU0lNX1RIUkVTSH0sXG4gICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICBvdXRwdXQ6IFtBUjJfREVGQVVMVF9TRUFSQ0hfRkVBVFVSRV9OVU0sIFBSRVZfS0VFUF1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjbG9uZU1vZGVsVmlldyA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihtb2RlbFZpZXdUcmFuc2Zvcm1zKSB7XG4gICAgICAgIHJldHVybiBtb2RlbFZpZXdUcmFuc2Zvcm1zW3RoaXMudGhyZWFkLnpdW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgfSwge1xuICAgICAgICBwaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgb3V0cHV0OiBbNCwgMywgUFJFVl9LRUVQXVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNsb25lTW9kZWxWaWV3UHJvamVjdGlvbiA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3Jtcykge1xuICAgICAgICByZXR1cm4gbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybXNbdGhpcy50aHJlYWQuel1bdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICB9LCB7XG4gICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICBvdXRwdXQ6IFs0LCAzLCBQUkVWX0tFRVBdXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY2xvbmVGZWF0dXJlSW5kZXhlcyA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihmZWF0dXJlSW5kZXhlcykge1xuICAgICAgICByZXR1cm4gZmVhdHVyZUluZGV4ZXNbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICB9LCB7XG4gICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICBvdXRwdXQ6IFtBUjJfREVGQVVMVF9TRUFSQ0hfRkVBVFVSRV9OVU0sIFBSRVZfS0VFUF1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnVwZGF0ZVByZXZSZXN1bHRzS2VybmVsID0gW2J1aWxkTW9kZWxWaWV3LCBidWlsZE1vZGVsVmlld1Byb2plY3Rpb24sIGJ1aWxkRmVhdHVyZUluZGV4ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lTW9kZWxWaWV3LCBjbG9uZU1vZGVsVmlld1Byb2plY3Rpb24sIGNsb25lRmVhdHVyZUluZGV4ZXNdO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1ByZXZNb2RlbFZpZXdUcmFuc2Zvcm1zID0gdGhpcy51cGRhdGVQcmV2UmVzdWx0c0tlcm5lbFswXSh0aGlzLnByZXZNb2RlbFZpZXdUcmFuc2Zvcm1zLCBtb2RlbFZpZXdUcmFuc2Zvcm0pO1xuICAgIGNvbnN0IG5ld1ByZXZNb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtcyA9IHRoaXMudXBkYXRlUHJldlJlc3VsdHNLZXJuZWxbMV0odGhpcy5wcmV2TW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybXMsIG1vZGVsVmlld1RyYW5zZm9ybSwgdGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtKTtcbiAgICBjb25zdCBuZXdQcmV2U2VsZWN0ZWRGZWF0dXJlSW5kZXhlcyA9IHRoaXMudXBkYXRlUHJldlJlc3VsdHNLZXJuZWxbMl0odGhpcy5wcmV2U2VsZWN0ZWRGZWF0dXJlSW5kZXhlcywgc2VsZWN0aW9uKTtcblxuICAgIC8vIGdwdS5qcyBkb2Vzbid0IGFsbG93IGlucHV0IGFuZCBvdXRwdXQgYXJlIHNhbWUgdGV4dHVyZSBpbiBwaXBlbGluZS4gYW55IGJldHRlciB3YXk/XG4gICAgdGhpcy5wcmV2TW9kZWxWaWV3VHJhbnNmb3JtcyA9IHRoaXMudXBkYXRlUHJldlJlc3VsdHNLZXJuZWxbM10obmV3UHJldk1vZGVsVmlld1RyYW5zZm9ybXMpO1xuICAgIHRoaXMucHJldk1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1zID0gdGhpcy51cGRhdGVQcmV2UmVzdWx0c0tlcm5lbFs0XShuZXdQcmV2TW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybXMpO1xuICAgIHRoaXMucHJldlNlbGVjdGVkRmVhdHVyZUluZGV4ZXMgPSB0aGlzLnVwZGF0ZVByZXZSZXN1bHRzS2VybmVsWzVdKG5ld1ByZXZTZWxlY3RlZEZlYXR1cmVJbmRleGVzKTtcbiAgfVxuXG4gIHNldHVwUXVlcnkocXVlcnlXaWR0aCwgcXVlcnlIZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gcXVlcnlXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHF1ZXJ5SGVpZ2h0O1xuICB9XG5cbiAgdHJhY2sodmlkZW8pIHtcbiAgICBpZiAodGhpcy52aWRlb0tlcm5lbCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy52aWRlb0tlcm5lbCA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbih2aWRlb0ZyYW1lKSB7XG4gICAgICAgIGNvbnN0IHBpeGVsID0gdmlkZW9GcmFtZVt0aGlzLmNvbnN0YW50cy5oZWlnaHQtMS1NYXRoLmZsb29yKHRoaXMudGhyZWFkLnggLyB0aGlzLmNvbnN0YW50cy53aWR0aCldW3RoaXMudGhyZWFkLnggJSB0aGlzLmNvbnN0YW50cy53aWR0aF07XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKChwaXhlbFswXSArIHBpeGVsWzFdICsgcGl4ZWxbMl0pICogMjU1IC8gMyk7XG4gICAgICB9LCB7XG4gICAgICAgIGNvbnN0YW50czoge3dpZHRoOiB0aGlzLndpZHRoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0fSxcbiAgICAgICAgb3V0cHV0OiBbdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0XSxcbiAgICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICB9KVxuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJbWFnZSA9IHRoaXMudmlkZW9LZXJuZWwodmlkZW8pO1xuXG4gICAgdGhpcy5rZXJuZWxJbmRleCA9IDA7IC8vIHJlc2V0IGtlcm5lbEluZGV4XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IHRoaXMuX2NvbXB1dGVDYW5kaWRhdGVzKCk7XG5cbiAgICBjb25zdCBjYW5kaWRhdGVUeXBlcyA9IGNhbmRpZGF0ZXMucmVzdWx0O1xuICAgIGNvbnN0IGNhbmRpZGF0ZVNYcyA9IGNhbmRpZGF0ZXMuc2F2ZVNYO1xuICAgIGNvbnN0IGNhbmRpZGF0ZVNZcyA9IGNhbmRpZGF0ZXMuc2F2ZVNZO1xuXG4gICAgLy8gc2VsZWN0IGZlYXR1cmUgb25lIGJ5IG9uZVxuICAgIGxldCBpID0gMDtcbiAgICBsZXQgbnVtID0gMDtcbiAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5faW5pdGlhbGl6ZVNlbGVjdGlvbigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQVIyX0RFRkFVTFRfU0VBUkNIX0ZFQVRVUkVfTlVNOyBpKyspIHtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGVkID0gdGhpcy5fc2VsZWN0Q2FuZGlkYXRlKHNlbGVjdGlvbiwgY2FuZGlkYXRlVHlwZXMsIGNhbmRpZGF0ZVNYcywgY2FuZGlkYXRlU1lzKTtcbiAgICAgIGNvbnN0IG1hcHBlZFRhcmdldFBvc2l0aW9uID0gdGhpcy5fbWFwQ2FuZGlkYXRlKHRhcmdldEltYWdlLCBuZXdTZWxlY3RlZCk7XG4gICAgICBzZWxlY3Rpb24gPSB0aGlzLl9jb21iaW5lU2VsZWN0aW9uKHNlbGVjdGlvbiwgaSwgbmV3U2VsZWN0ZWQsIG1hcHBlZFRhcmdldFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvL3ZhciBfc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAvL2NvbnN0IG1vZGVsVmlld1RyYW5zZm9ybXMgPSB0aGlzLnByZXZNb2RlbFZpZXdUcmFuc2Zvcm1zLnRvQXJyYXkoKTtcbiAgICAvL2NvbnNvbGUubG9nKFwicHJldk1vZGVsVmlld1RyYW5zZm9ybXMgdG9hcnJheVwiLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIF9zdGFydCk7XG4gICAgLy9jb25zb2xlLmxvZyhcInByZXZNb2RlbFZpZXdUcmFuc2Zvcm1zXCIsIHRoaXMucHJldk1vZGVsVmlld1RyYW5zZm9ybXMsIG1vZGVsVmlld1RyYW5zZm9ybXMpO1xuICAgIC8vY29uc3QgbW9kZWxWaWV3VHJhbnNmb3JtID0gbW9kZWxWaWV3VHJhbnNmb3Jtc1swXTtcblxuICAgIC8vdmFyIF9zdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGNvbnN0IGZpbmFsU2VsZWN0aW9uID0gc2VsZWN0aW9uLnRvQXJyYXkoKTtcbiAgICAvL2NvbnNvbGUubG9nKFwiZmluYWxTZWxlY3Rpb24gdG9hcnJheVwiLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIF9zdGFydCk7XG4gICAgLy9jb25zb2xlLmxvZyhcImZpbmFsU2VsZWN0aW9uXCIsIHNlbGVjdGlvbiwgZmluYWxTZWxlY3Rpb24pO1xuXG4gICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmluYWxTZWxlY3Rpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChmaW5hbFNlbGVjdGlvbltpXVswXSAhPT0gLTEgJiYgZmluYWxTZWxlY3Rpb25baV1bNV0gPiBBUjJfU0lNX1RIUkVTSCkge1xuICAgICAgICBzZWxlY3RlZEZlYXR1cmVzLnB1c2goe1xuICAgICAgICAgIHBvczJEOiB7eDogZmluYWxTZWxlY3Rpb25baV1bM10sIHk6IGZpbmFsU2VsZWN0aW9uW2ldWzRdfSxcbiAgICAgICAgICBwb3MzRDoge3g6IGZpbmFsU2VsZWN0aW9uW2ldWzFdLCB5OiBmaW5hbFNlbGVjdGlvbltpXVsyXSwgejogMH0sXG4gICAgICAgICAgc2ltOiBmaW5hbFNlbGVjdGlvbltpXVs1XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy9jb25zb2xlLmxvZygnc2VsZWN0ZWQgZmVhdHVyZXMnLCBzZWxlY3RlZEZlYXR1cmVzKTtcbiAgICBpZiAoc2VsZWN0ZWRGZWF0dXJlcy5sZW5ndGggPCA0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0cmFuc2xhdGUgYW5kIHJ1biBpbiBHUFVcbiAgICBjb25zdCBtb2RlbFZpZXdUcmFuc2Zvcm0gPSB0aGlzLmxhc3RNb2RlbFZpZXdUcmFuc2Zvcm1DUFU7XG4gICAgY29uc3QgcHJvamVjdGlvblRyYW5zZm9ybSA9IHRoaXMucHJvamVjdGlvblRyYW5zZm9ybUNQVTtcblxuICAgIGNvbnN0IGlubGllclByb2JzID0gWzEuMCwgMC44LCAwLjYsIDAuNCwgMC4wXTtcbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgbmV3TW9kZWxWaWV3VHJhbnNmb3JtID0gbW9kZWxWaWV3VHJhbnNmb3JtO1xuICAgIGxldCBmaW5hbE1vZGVsVmlld1RyYW5zZm9ybSA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmxpZXJQcm9icy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHJldCA9IF9jb21wdXRlVXBkYXRlZFRyYW4oe21vZGVsVmlld1RyYW5zZm9ybTogbmV3TW9kZWxWaWV3VHJhbnNmb3JtLCBzZWxlY3RlZEZlYXR1cmVzLCBwcm9qZWN0aW9uVHJhbnNmb3JtLCBpbmxpZXJQcm9iOiBpbmxpZXJQcm9ic1tpXX0pO1xuICAgICAgZXJyID0gcmV0LmVycjtcbiAgICAgIG5ld01vZGVsVmlld1RyYW5zZm9ybSA9IHJldC5uZXdNb2RlbFZpZXdUcmFuc2Zvcm07XG4gICAgICAvL2NvbnNvbGUubG9nKFwiX2NvbXB1dGVVcGRhdGVkVHJhblwiLCBlcnIpXG5cbiAgICAgIGlmIChlcnIgPCBBUjJfVFJBQ0tJTkdfVEhSRVNIKSB7XG4gICAgICAgIGZpbmFsTW9kZWxWaWV3VHJhbnNmb3JtID0gbmV3TW9kZWxWaWV3VHJhbnNmb3JtO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmluYWxNb2RlbFZpZXdUcmFuc2Zvcm0gPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgdGhpcy5fdXBkYXRlUHJldlJlc3VsdHMoZmluYWxNb2RlbFZpZXdUcmFuc2Zvcm0sIGZpbmFsU2VsZWN0aW9uKTtcblxuICAgIHJldHVybiBmaW5hbE1vZGVsVmlld1RyYW5zZm9ybTtcbiAgfVxuXG4gIC8vIGZpcnN0IGRpbWVuc2lvbjogW2ZlYXR1cmVJbmRleCwgbXgsIG15LCBpeCwgaXksIHNpbWlsYXJpdHldXG4gIF9pbml0aWFsaXplU2VsZWN0aW9uKCkge1xuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBrZXJuZWwgPSB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0sIHtcbiAgICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICAgIG91dHB1dDogWzYsIEFSMl9ERUZBVUxUX1NFQVJDSF9GRUFUVVJFX05VTV1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5rZXJuZWxzLnB1c2goa2VybmVsKTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsID0gdGhpcy5rZXJuZWxzW3RoaXMua2VybmVsSW5kZXgrK107XG4gICAgcmV0dXJuIGtlcm5lbCgpO1xuICB9XG5cbiAgX2NvbWJpbmVTZWxlY3Rpb24oc2VsZWN0aW9uLCBzZWxlY3Rpb25JbmRleCwgbmV3U2VsZWN0ZWQsIG1hcHBlZFRhcmdldFBvc2l0aW9uKSB7XG4gICAgaWYgKHRoaXMua2VybmVsSW5kZXggPT09IHRoaXMua2VybmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbihzZWxlY3Rpb24sIG5ld1NlbGVjdGVkLCBmZWF0dXJlUG9pbnRzLCBtYXBwZWRUYXJnZXRQb3NpdGlvbikge1xuICAgICAgICBjb25zdCB7c2VsZWN0aW9uSW5kZXh9ID0gdGhpcy5jb25zdGFudHM7XG4gICAgICAgIGlmICh0aGlzLnRocmVhZC55ICE9PSBzZWxlY3Rpb25JbmRleCkgcmV0dXJuIHNlbGVjdGlvblt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcblxuICAgICAgICBpZiAodGhpcy50aHJlYWQueCA9PT0gMCkgcmV0dXJuIG5ld1NlbGVjdGVkWzBdO1xuICAgICAgICBpZiAodGhpcy50aHJlYWQueCA9PT0gMSkgcmV0dXJuIGZlYXR1cmVQb2ludHNbbmV3U2VsZWN0ZWRbMF1dWzBdO1xuICAgICAgICBpZiAodGhpcy50aHJlYWQueCA9PT0gMikgcmV0dXJuIGZlYXR1cmVQb2ludHNbbmV3U2VsZWN0ZWRbMF1dWzFdO1xuICAgICAgICBpZiAodGhpcy50aHJlYWQueCA9PT0gMykgcmV0dXJuIG1hcHBlZFRhcmdldFBvc2l0aW9uWzBdO1xuICAgICAgICBpZiAodGhpcy50aHJlYWQueCA9PT0gNCkgcmV0dXJuIG1hcHBlZFRhcmdldFBvc2l0aW9uWzFdO1xuICAgICAgICBpZiAodGhpcy50aHJlYWQueCA9PT0gNSkgcmV0dXJuIG1hcHBlZFRhcmdldFBvc2l0aW9uWzJdO1xuICAgICAgfSwge1xuICAgICAgICBjb25zdGFudHM6IHtzZWxlY3Rpb25JbmRleH0sXG4gICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICBvdXRwdXQ6IFs2LCBBUjJfREVGQVVMVF9TRUFSQ0hfRkVBVFVSRV9OVU1dXG4gICAgICB9KTtcbiAgICAgIHRoaXMua2VybmVscy5wdXNoKGtlcm5lbCk7XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVsc1t0aGlzLmtlcm5lbEluZGV4KytdO1xuICAgIHJldHVybiBrZXJuZWwoc2VsZWN0aW9uLCBuZXdTZWxlY3RlZCwgdGhpcy5mZWF0dXJlUG9pbnRzLCBtYXBwZWRUYXJnZXRQb3NpdGlvbik7XG4gIH1cblxuICBfbWFwQ2FuZGlkYXRlKHRhcmdldEltYWdlLCBuZXdTZWxlY3RlZCkge1xuICAgIGNvbnN0IHRlbXBsYXRlT25lU2l6ZSA9IEFSMl9ERUZBVUxUX1RTO1xuICAgIGNvbnN0IHRlbXBsYXRlU2l6ZSA9IHRlbXBsYXRlT25lU2l6ZSAqIDIgKyAxO1xuICAgIGNvbnN0IHNlYXJjaE9uZVNpemUgPSBBUjJfU0VBUkNIX1NJWkU7XG4gICAgY29uc3Qgc2VhcmNoU2l6ZSA9IHNlYXJjaE9uZVNpemUgKiAyICsgMTtcblxuICAgIGlmICh0aGlzLmtlcm5lbEluZGV4ID09PSB0aGlzLmtlcm5lbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBrID0gdGhpcy5ncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGltYWdlUGl4ZWxzLCBpbWFnZVByb3BlcnRpZXMsIGZlYXR1cmVQb2ludHMsIG5ld1NlbGVjdGVkLCBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtcywgbW9kZWxWaWV3VHJhbnNmb3Jtcykge1xuICAgICAgICBjb25zdCB7dGVtcGxhdGVPbmVTaXplfSA9IHRoaXMuY29uc3RhbnRzO1xuXG4gICAgICAgIGNvbnN0IGZlYXR1cmVJbmRleCA9IG5ld1NlbGVjdGVkWzBdO1xuICAgICAgICBjb25zdCBpID0gdGhpcy50aHJlYWQueDtcbiAgICAgICAgY29uc3QgaiA9IHRoaXMudGhyZWFkLnk7XG5cbiAgICAgICAgY29uc3QgbXggPSBmZWF0dXJlUG9pbnRzW2ZlYXR1cmVJbmRleF1bMF07XG4gICAgICAgIGNvbnN0IG15ID0gZmVhdHVyZVBvaW50c1tmZWF0dXJlSW5kZXhdWzFdO1xuICAgICAgICBjb25zdCBsZXZlbCA9IGZlYXR1cmVQb2ludHNbZmVhdHVyZUluZGV4XVsyXTtcblxuICAgICAgICBjb25zdCB1ID0gY29tcHV0ZVNjcmVlbkNvb3JkaWF0ZShtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtcywgMCwgbXgsIG15LCAwKTtcbiAgICAgICAgY29uc3Qgc3ggPSBNYXRoLmZsb29yKHVbMV0gKyAwLjUpO1xuICAgICAgICBjb25zdCBzeSA9IE1hdGguZmxvb3IodVsyXSArIDAuNSk7XG5cbiAgICAgICAgY29uc3Qgc3gyID0gc3ggKyAoaSAtIHRlbXBsYXRlT25lU2l6ZSk7XG4gICAgICAgIGNvbnN0IHN5MiA9IHN5ICsgKGogLSB0ZW1wbGF0ZU9uZVNpemUpO1xuXG4gICAgICAgIGNvbnN0IG0gPSBzY3JlZW5Ub01hcmtlckNvb3JkaW5hdGUobW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybXMsIDAsIHN4Miwgc3kyKTtcbiAgICAgICAgY29uc3QgbXgyID0gbVswXTtcbiAgICAgICAgY29uc3QgbXkyID0gbVsxXTtcblxuICAgICAgICBjb25zdCBpbWFnZVdpZHRoID0gaW1hZ2VQcm9wZXJ0aWVzW2xldmVsXVswXTtcbiAgICAgICAgY29uc3QgaW1hZ2VIZWlnaHQgPSBpbWFnZVByb3BlcnRpZXNbbGV2ZWxdWzFdO1xuICAgICAgICBjb25zdCBpbWFnZVBpeGVsT2Zmc2V0ID0gaW1hZ2VQcm9wZXJ0aWVzW2xldmVsXVsyXTtcbiAgICAgICAgY29uc3QgaW1hZ2VEUEkgPSBpbWFnZVByb3BlcnRpZXNbbGV2ZWxdWzNdO1xuXG4gICAgICAgIGNvbnN0IGl4ID0gTWF0aC5mbG9vcihteDIgKiBpbWFnZURQSSArIDAuNSk7XG4gICAgICAgIGNvbnN0IGl5ID0gTWF0aC5mbG9vcihpbWFnZUhlaWdodCAtIG15MiAqIGltYWdlRFBJICsgMC41KTtcblxuICAgICAgICBpZiAoaXggPCAwIHx8IGl4ID49IGltYWdlV2lkdGgpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl5IDwgMCB8fCBpeSA+PSBpbWFnZUhlaWdodCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1hZ2VQaXhlbHNbaW1hZ2VQaXhlbE9mZnNldCArIGl5ICogaW1hZ2VXaWR0aCArIGl4XTtcbiAgICAgIH0sIHtcbiAgICAgICAgY29uc3RhbnRzOiB7dGVtcGxhdGVPbmVTaXplfSxcbiAgICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICAgIG91dHB1dDogW3RlbXBsYXRlU2l6ZSwgdGVtcGxhdGVTaXplXVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGsyID0gdGhpcy5ncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGZlYXR1cmVQb2ludHMsIG5ld1NlbGVjdGVkLCBtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3Jtcykge1xuICAgICAgICBjb25zdCBwcmV2S2VlcCA9IHRoaXMuY29uc3RhbnRzLnByZXZLZWVwO1xuXG4gICAgICAgIGNvbnN0IGZlYXR1cmVJbmRleCA9IG5ld1NlbGVjdGVkWzBdO1xuICAgICAgICBjb25zdCBteCA9IGZlYXR1cmVQb2ludHNbZmVhdHVyZUluZGV4XVswXTtcbiAgICAgICAgY29uc3QgbXkgPSBmZWF0dXJlUG9pbnRzW2ZlYXR1cmVJbmRleF1bMV07XG5cbiAgICAgICAgaWYgKHRoaXMudGhyZWFkLnkgPT09IDApIHtcbiAgICAgICAgICBjb25zdCB1ID0gY29tcHV0ZVNjcmVlbkNvb3JkaWF0ZShtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtcywgdGhpcy50aHJlYWQueSwgbXgsIG15LCAwKTtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih1W3RoaXMudGhyZWFkLngrMV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGhyZWFkLnkgPT09IDEpIHtcbiAgICAgICAgICBjb25zdCB1MSA9IGNvbXB1dGVTY3JlZW5Db29yZGlhdGUobW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybXMsIHRoaXMudGhyZWFkLnktMSwgbXgsIG15LCAwKTtcbiAgICAgICAgICBjb25zdCB1ID0gY29tcHV0ZVNjcmVlbkNvb3JkaWF0ZShtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtcywgdGhpcy50aHJlYWQueSwgbXgsIG15LCAwKTtcbiAgICAgICAgICBpZiAodVswXSA9PT0gdTFbMF0gJiYgdVsxXSA9PT0gdTFbMV0pIHJldHVybiAtMTtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigyICogdTFbdGhpcy50aHJlYWQueCsxXSAtIHVbdGhpcy50aHJlYWQueCsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdTEgPSBjb21wdXRlU2NyZWVuQ29vcmRpYXRlKG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1zLCB0aGlzLnRocmVhZC55LTIsIG14LCBteSwgMCk7XG4gICAgICAgICAgY29uc3QgdTIgPSBjb21wdXRlU2NyZWVuQ29vcmRpYXRlKG1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1zLCB0aGlzLnRocmVhZC55LTEsIG14LCBteSwgMCk7XG4gICAgICAgICAgY29uc3QgdSA9IGNvbXB1dGVTY3JlZW5Db29yZGlhdGUobW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybXMsIHRoaXMudGhyZWFkLnksIG14LCBteSwgMCk7XG4gICAgICAgICAgaWYgKHVbMF0gPT09IHUyWzBdICYmIHVbMV0gPT09IHUyWzFdKSByZXR1cm4gLTE7XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoMyAqIHUxW3RoaXMudGhyZWFkLngrMV0gLSAzICogdTJbdGhpcy50aHJlYWQueCsxXSArIHVbdGhpcy50aHJlYWQueCsxXSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgY29uc3RhbnRzOiB7cHJldktlZXA6IFBSRVZfS0VFUH0sXG4gICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICBvdXRwdXQ6IFsyLCBQUkVWX0tFRVBdXG4gICAgICB9KTtcblxuICAgICAgLy8gY29tcHV0ZSBzaW1pbGFydGl5IHdpdGggdGVtcGxhdGUgb2YgYWxsIG5laWdoYm91ciBwb2ludHMgd2l0aGluIHNlYXJjaCBwb2ludHNcbiAgICAgIGNvbnN0IGszID0gdGhpcy5ncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKHRhcmdldEltYWdlLCBzZWFyY2hQb2ludHMsIHRlbSkge1xuICAgICAgICBjb25zdCB7c2VhcmNoT25lU2l6ZSwgdGVtcGxhdGVTaXplLCB0ZW1wbGF0ZU9uZVNpemUsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHR9ID0gdGhpcy5jb25zdGFudHM7XG5cbiAgICAgICAgaWYgKHNlYXJjaFBvaW50c1t0aGlzLnRocmVhZC56XVswXSA9PT0gLTEpIHJldHVybiAtMTtcblxuICAgICAgICBjb25zdCBweCA9IHNlYXJjaFBvaW50c1t0aGlzLnRocmVhZC56XVswXSAtIHNlYXJjaE9uZVNpemUgKyB0aGlzLnRocmVhZC54O1xuICAgICAgICBjb25zdCBweSA9IHNlYXJjaFBvaW50c1t0aGlzLnRocmVhZC56XVsxXSAtIHNlYXJjaE9uZVNpemUgKyB0aGlzLnRocmVhZC55O1xuICAgICAgICBpZiAocHggPCAwIHx8IHB4ID49IHRhcmdldFdpZHRoKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChweSA8IDAgfHwgcHkgPj0gdGFyZ2V0SGVpZ2h0KSByZXR1cm4gLTE7XG5cbiAgICAgICAgbGV0IHN1bVBvaW50ID0gMDtcbiAgICAgICAgbGV0IHN1bVBvaW50U3F1YXJlID0gMDtcbiAgICAgICAgbGV0IHN1bVRlbXBsYXRlID0gMDtcbiAgICAgICAgbGV0IHN1bVRlbXBsYXRlU3F1YXJlID0gMDtcbiAgICAgICAgbGV0IHN1bVBvaW50VGVtcGxhdGUgPSAwO1xuICAgICAgICBsZXQgdmFsaWRDb3VudCA9IDA7XG4gICAgICAgIGxldCB0ZW1wbGF0ZVZhbGlkQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRlbXBsYXRlU2l6ZTsgaisrKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wbGF0ZVNpemU7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRlbVtqXVtpXSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgY29uc3QgcHkyID0gcHkgLSB0ZW1wbGF0ZU9uZVNpemUgKyBqO1xuICAgICAgICAgICAgICBjb25zdCBweDIgPSBweCAtIHRlbXBsYXRlT25lU2l6ZSArIGk7XG5cbiAgICAgICAgICAgICAgc3VtVGVtcGxhdGUgKz0gdGVtW2pdW2ldO1xuICAgICAgICAgICAgICBzdW1UZW1wbGF0ZVNxdWFyZSArPSB0ZW1bal1baV0gKiB0ZW1bal1baV07XG4gICAgICAgICAgICAgIHRlbXBsYXRlVmFsaWRDb3VudCArPSAxO1xuXG4gICAgICAgICAgICAgIGlmIChweDIgPj0gMCAmJiBweDIgPCB0YXJnZXRXaWR0aCAmJiBweTIgPj0wICYmIHB5MiA8IHRhcmdldEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHZhbGlkQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICBzdW1Qb2ludCArPSB0YXJnZXRJbWFnZVtweTIgKiB0YXJnZXRXaWR0aCArIHB4Ml07XG4gICAgICAgICAgICAgICAgc3VtUG9pbnRTcXVhcmUgKz0gdGFyZ2V0SW1hZ2VbcHkyICogdGFyZ2V0V2lkdGggKyBweDJdICogdGFyZ2V0SW1hZ2VbcHkyICogdGFyZ2V0V2lkdGggKyBweDJdO1xuICAgICAgICAgICAgICAgIHN1bVBvaW50VGVtcGxhdGUgKz0gdGFyZ2V0SW1hZ2VbcHkyICogdGFyZ2V0V2lkdGggKyBweDJdICogdGVtW2pdW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IG1heWJlIGp1c3Qgc3VtIHRlbXBsYXRlIG9ubHkgd2hlbiBwb2ludCBpcyBhbHNvIHZhbGlkP1xuICAgICAgICBzdW1Qb2ludFRlbXBsYXRlIC09IHN1bVBvaW50ICogc3VtVGVtcGxhdGUgLyB0ZW1wbGF0ZVZhbGlkQ291bnQ7XG5cbiAgICAgICAgY29uc3QgcG9pbnRWYXIgPSBNYXRoLnNxcnQoc3VtUG9pbnRTcXVhcmUgLSBzdW1Qb2ludCAqIHN1bVBvaW50IC8gdGVtcGxhdGVWYWxpZENvdW50KTtcbiAgICAgICAgaWYgKHBvaW50VmFyID09IDApIHJldHVybiAtMTtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVWYXIgPSBNYXRoLnNxcnQoc3VtVGVtcGxhdGVTcXVhcmUgLSBzdW1UZW1wbGF0ZSAqIHN1bVRlbXBsYXRlIC8gdGVtcGxhdGVWYWxpZENvdW50KTtcbiAgICAgICAgY29uc3QgY29WYXIgPSBzdW1Qb2ludFRlbXBsYXRlIC8gdGVtcGxhdGVWYXIgLyBwb2ludFZhcjtcblxuICAgICAgICByZXR1cm4gY29WYXI7XG4gICAgICB9LCB7XG4gICAgICAgIGNvbnN0YW50czoge1xuICAgICAgICAgIHNlYXJjaE9uZVNpemUsXG4gICAgICAgICAgdGVtcGxhdGVTaXplLFxuICAgICAgICAgIHRlbXBsYXRlT25lU2l6ZSxcbiAgICAgICAgICB0YXJnZXRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICB0YXJnZXRIZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICBvdXRwdXQ6IFtzZWFyY2hTaXplLCBzZWFyY2hTaXplLCBQUkVWX0tFRVBdLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGs0ID0gdGhpcy5ncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKHNlYXJjaFBvaW50cywgY29WYXJzKSB7XG4gICAgICAgIGNvbnN0IHtwcmV2S2VlcCwgc2VhcmNoT25lU2l6ZSwgc2VhcmNoU2l6ZX0gPSB0aGlzLmNvbnN0YW50cztcblxuICAgICAgICBsZXQgbWF4ID0gLTE7XG4gICAgICAgIGxldCBtYXhJbmRleEkgPSAtMTtcbiAgICAgICAgbGV0IG1heEluZGV4SiA9IC0xO1xuICAgICAgICBsZXQgbWF4SW5kZXhLID0gLTE7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcHJldktlZXA7IGsrKykge1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VhcmNoU2l6ZTsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlYXJjaFNpemU7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoY29WYXJzW2tdW2pdW2ldID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gY29WYXJzW2tdW2pdW2ldO1xuICAgICAgICAgICAgICAgIG1heEluZGV4SSA9IGk7XG4gICAgICAgICAgICAgICAgbWF4SW5kZXhKID0gajtcbiAgICAgICAgICAgICAgICBtYXhJbmRleEsgPSBrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXggPT09IC0xKSByZXR1cm4gLTE7XG5cbiAgICAgICAgaWYgKHRoaXMudGhyZWFkLnggPT09IDApIHJldHVybiBzZWFyY2hQb2ludHNbbWF4SW5kZXhLXVswXSAtIHNlYXJjaE9uZVNpemUgKyBtYXhJbmRleEk7XG4gICAgICAgIGlmICh0aGlzLnRocmVhZC54ID09PSAxKSByZXR1cm4gc2VhcmNoUG9pbnRzW21heEluZGV4S11bMV0gLSBzZWFyY2hPbmVTaXplICsgbWF4SW5kZXhKO1xuICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgfSwge1xuICAgICAgICBjb25zdGFudHM6IHtcbiAgICAgICAgICBwcmV2S2VlcDogUFJFVl9LRUVQLFxuICAgICAgICAgIHNlYXJjaE9uZVNpemUsXG4gICAgICAgICAgc2VhcmNoU2l6ZSxcbiAgICAgICAgfSxcbiAgICAgICAgcGlwZWxpbmU6IHRydWUsXG4gICAgICAgIG91dHB1dDogWzNdLCAvLyBbeCwgeSwgY29WYXJdXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5rZXJuZWxzLnB1c2goW2ssIGsyLCBrMywgazRdKTtcbiAgICB9O1xuICAgIGNvbnN0IGtlcm5lbHMgPSB0aGlzLmtlcm5lbHNbdGhpcy5rZXJuZWxJbmRleCsrXTtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGtlcm5lbHNbMF0odGhpcy5pbWFnZVBpeGVscywgdGhpcy5pbWFnZVByb3BlcnRpZXMsIHRoaXMuZmVhdHVyZVBvaW50cywgbmV3U2VsZWN0ZWQsIHRoaXMucHJldk1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1zLCB0aGlzLnByZXZNb2RlbFZpZXdUcmFuc2Zvcm1zKTtcblxuICAgIGNvbnN0IHNlYXJjaFBvaW50cyA9IGtlcm5lbHNbMV0odGhpcy5mZWF0dXJlUG9pbnRzLCBuZXdTZWxlY3RlZCwgdGhpcy5wcmV2TW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybXMpO1xuICAgIGNvbnN0IGNvVmFycyA9IGtlcm5lbHNbMl0odGFyZ2V0SW1hZ2UsIHNlYXJjaFBvaW50cywgdGVtcGxhdGUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbHNbM10oc2VhcmNoUG9pbnRzLCBjb1ZhcnMpO1xuICAgIC8vY29uc29sZS5sb2coXCJ0ZW1wbGF0ZVwiLCB0ZW1wbGF0ZS50b0FycmF5KCkpO1xuICAgIC8vY29uc29sZS5sb2coXCJzZWFyY2ggcG9pbnRzXCIsIEpTT04uc3RyaW5naWZ5KHNlYXJjaFBvaW50cy50b0FycmF5KCkpKTtcbiAgICAvL2NvbnNvbGUubG9nKFwiY29WYXJzXCIsIGNvVmFycy50b0FycmF5KCkpO1xuICAgIC8vY29uc29sZS5sb2coXCJyZXN1bHRcIiwgcmVzdWx0LnRvQXJyYXkoKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF9zZWxlY3RDYW5kaWRhdGUoc2VsZWN0aW9uLCBjYW5kaWRhdGVUeXBlcywgY2FuZGlkYXRlU1hzLCBjYW5kaWRhdGVTWXMpIHtcbiAgICBpZiAodGhpcy5rZXJuZWxJbmRleCA9PT0gdGhpcy5rZXJuZWxzLmxlbmd0aCkge1xuICAgICAgY29uc3Qga2VybmVsID0gdGhpcy5ncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKHNlbGVjdGlvbiwgY2FuZGlkYXRlVHlwZXMsIGNhbmRpZGF0ZVNYcywgY2FuZGlkYXRlU1lzLCBwcmV2U2VsZWN0ZWRGZWF0dXJlSW5kZXhlcykge1xuICAgICAgICBjb25zdCB7cHJldktlZXAsIHNlbGVjdGlvbkxlbmd0aCwgY2FuZGlkYXRlTGVuZ3RoLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCBzaW1UaHJlc2hvbGR9ID0gdGhpcy5jb25zdGFudHM7XG5cbiAgICAgICAgbGV0IHNlbGVjdGVkMSA9IC0xO1xuICAgICAgICBsZXQgc2VsZWN0ZWQyID0gLTE7XG4gICAgICAgIGxldCBzZWxlY3RlZDMgPSAtMTtcbiAgICAgICAgbGV0IHNlbGVjdGVkNCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGlvbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbltpXVswXSAhPT0gLTEgJiYgc2VsZWN0aW9uW2ldWzVdID4gc2ltVGhyZXNob2xkKSB7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZDEgPT09IC0xKSBzZWxlY3RlZDEgPSBzZWxlY3Rpb25baV1bMF07XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3RlZDIgPT09IC0xKSBzZWxlY3RlZDIgPSBzZWxlY3Rpb25baV1bMF07XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3RlZDMgPT09IC0xKSBzZWxlY3RlZDMgPSBzZWxlY3Rpb25baV1bMF07XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3RlZDQgPT09IC0xKSBzZWxlY3RlZDQgPSBzZWxlY3Rpb25baV1bMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkMSA9PT0gLTEpIHtcbiAgICAgICAgICBsZXQgZG1heDEgPSAwLjA7XG4gICAgICAgICAgbGV0IGluZGV4MSA9IC0xO1xuICAgICAgICAgIGxldCBkbWF4MiA9IDAuMDtcbiAgICAgICAgICBsZXQgaW5kZXgyID0gLTE7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbmRpZGF0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlVHlwZXNbaV0gIT09IDApIHtcbiAgICAgICAgICAgICAgbGV0IHVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWxlY3Rpb25MZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25bal1bMF0gPT09IGkpIHVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdXNlZFxuICAgICAgICAgICAgICAgICYmIGNhbmRpZGF0ZVNYc1tpXSA+PSB0YXJnZXRXaWR0aC84ICYmIGNhbmRpZGF0ZVNYc1tpXSA8PSB0YXJnZXRXaWR0aCAqIDcgLyA4XG4gICAgICAgICAgICAgICAgJiYgY2FuZGlkYXRlU1lzW2ldID49IHRhcmdldEhlaWdodC84ICYmIGNhbmRpZGF0ZVNZc1tpXSA8PSB0YXJnZXRIZWlnaHQgKiA3IC8gOCkge1xuXG4gICAgICAgICAgICAgICAgLy8gZGlzdGFuY2NlIGZyb20gY2VudGVyXG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IChjYW5kaWRhdGVTWHNbaV0gLSB0YXJnZXRXaWR0aC8yKSAqIChjYW5kaWRhdGVTWHNbaV0gLSB0YXJnZXRXaWR0aC8yKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoY2FuZGlkYXRlU1lzW2ldIC0gdGFyZ2V0SGVpZ2h0LzIpICogKGNhbmRpZGF0ZVNZc1tpXSAtIHRhcmdldEhlaWdodC8yKTtcblxuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGVUeXBlc1tpXSA9PT0gMSAmJiBkID4gZG1heDEpIHtcbiAgICAgICAgICAgICAgICAgIGRtYXgxID0gZDtcbiAgICAgICAgICAgICAgICAgIGluZGV4MSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZVR5cGVzW2ldID09PSAyICYmIGQgPiBkbWF4Mikge1xuICAgICAgICAgICAgICAgICAgZG1heDIgPSBkO1xuICAgICAgICAgICAgICAgICAgaW5kZXgyID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZGV4MSAhPT0gLTEpIHJldHVybiBpbmRleDE7XG4gICAgICAgICAgaWYgKGluZGV4MiAhPT0gLTEpIHJldHVybiBpbmRleDI7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkMiA9PT0gLTEpIHtcbiAgICAgICAgICBsZXQgZG1heDEgPSAwLjA7XG4gICAgICAgICAgbGV0IGluZGV4MSA9IC0xO1xuICAgICAgICAgIGxldCBkbWF4MiA9IDAuMDtcbiAgICAgICAgICBsZXQgaW5kZXgyID0gLTE7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbmRpZGF0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlVHlwZXNbaV0gIT09IDApIHtcbiAgICAgICAgICAgICAgbGV0IHVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWxlY3Rpb25MZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25bal1bMF0gPT09IGkpIHVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdXNlZFxuICAgICAgICAgICAgICAgICYmIGNhbmRpZGF0ZVNYc1tpXSA+PSB0YXJnZXRXaWR0aC84ICYmIGNhbmRpZGF0ZVNYc1tpXSA8PSB0YXJnZXRXaWR0aCAqIDcgLyA4XG4gICAgICAgICAgICAgICAgJiYgY2FuZGlkYXRlU1lzW2ldID49IHRhcmdldEhlaWdodC84ICYmIGNhbmRpZGF0ZVNZc1tpXSA8PSB0YXJnZXRIZWlnaHQgKiA3IC8gOCkge1xuXG4gICAgICAgICAgICAgICAgLy8gZGlzdGFuY2NlIGZyb20gc2VsZWN0aW9uIG9uZVxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSAoY2FuZGlkYXRlU1hzW2ldIC0gY2FuZGlkYXRlU1hzW3NlbGVjdGVkMV0pICogKGNhbmRpZGF0ZVNYc1tpXSAtIGNhbmRpZGF0ZVNYc1tzZWxlY3RlZDFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoY2FuZGlkYXRlU1lzW2ldIC0gY2FuZGlkYXRlU1lzW3NlbGVjdGVkMV0pICogKGNhbmRpZGF0ZVNZc1tpXSAtIGNhbmRpZGF0ZVNZc1tzZWxlY3RlZDFdKTtcblxuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGVUeXBlc1tpXSA9PT0gMSAmJiBkID4gZG1heDEpIHtcbiAgICAgICAgICAgICAgICAgIGRtYXgxID0gZDtcbiAgICAgICAgICAgICAgICAgIGluZGV4MSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZVR5cGVzW2ldID09PSAyICYmIGQgPiBkbWF4Mikge1xuICAgICAgICAgICAgICAgICAgZG1heDIgPSBkO1xuICAgICAgICAgICAgICAgICAgaW5kZXgyID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZGV4MSAhPT0gLTEpIHJldHVybiBpbmRleDE7XG4gICAgICAgICAgaWYgKGluZGV4MiAhPT0gLTEpIHJldHVybiBpbmRleDI7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkMyA9PT0gLTEpIHtcbiAgICAgICAgICBsZXQgZG1heDEgPSAwLjA7XG4gICAgICAgICAgbGV0IGluZGV4MSA9IC0xO1xuICAgICAgICAgIGxldCBkbWF4MiA9IDAuMDtcbiAgICAgICAgICBsZXQgaW5kZXgyID0gLTE7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbmRpZGF0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlVHlwZXNbaV0gIT09IDApIHtcbiAgICAgICAgICAgICAgbGV0IHVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWxlY3Rpb25MZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25bal1bMF0gPT09IGkpIHVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdXNlZFxuICAgICAgICAgICAgICAgICYmIGNhbmRpZGF0ZVNYc1tpXSA+PSB0YXJnZXRXaWR0aC84ICYmIGNhbmRpZGF0ZVNYc1tpXSA8PSB0YXJnZXRXaWR0aCAqIDcgLyA4XG4gICAgICAgICAgICAgICAgJiYgY2FuZGlkYXRlU1lzW2ldID49IHRhcmdldEhlaWdodC84ICYmIGNhbmRpZGF0ZVNZc1tpXSA8PSB0YXJnZXRIZWlnaHQgKiA3IC8gOCkge1xuXG4gICAgICAgICAgICAgICAgLy8gZmFyZXN0IGZyb20gdGhlIGZpcnN0IHR3bz9cbiAgICAgICAgICAgICAgICBsZXQgZCA9IChjYW5kaWRhdGVTWHNbaV0gLSBjYW5kaWRhdGVTWHNbc2VsZWN0ZWQxXSkgKiAoY2FuZGlkYXRlU1lzW3NlbGVjdGVkMl0gLSBjYW5kaWRhdGVTWXNbc2VsZWN0ZWQxXSlcbiAgICAgICAgICAgICAgICAgICAgICAtIChjYW5kaWRhdGVTWXNbaV0gLSBjYW5kaWRhdGVTWXNbc2VsZWN0ZWQxXSkgKiAoY2FuZGlkYXRlU1hzW3NlbGVjdGVkMl0gLSBjYW5kaWRhdGVTWHNbc2VsZWN0ZWQxXSk7XG4gICAgICAgICAgICAgICAgZCA9IGQgKiBkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVR5cGVzW2ldID09PSAxICYmIGQgPiBkbWF4MSkge1xuICAgICAgICAgICAgICAgICAgZG1heDEgPSBkO1xuICAgICAgICAgICAgICAgICAgaW5kZXgxID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlVHlwZXNbaV0gPT09IDIgJiYgZCA+IGRtYXgyKSB7XG4gICAgICAgICAgICAgICAgICBkbWF4MiA9IGQ7XG4gICAgICAgICAgICAgICAgICBpbmRleDIgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5kZXgxICE9PSAtMSkgcmV0dXJuIGluZGV4MTtcbiAgICAgICAgICBpZiAoaW5kZXgyICE9PSAtMSkgcmV0dXJuIGluZGV4MjtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0ZWQ0ID09PSAtMSkge1xuICAgICAgICAgIGNvbnN0IHBvczAgPSBbY2FuZGlkYXRlU1hzW3NlbGVjdGVkMV0sIGNhbmRpZGF0ZVNZc1tzZWxlY3RlZDFdXTtcbiAgICAgICAgICBjb25zdCBwb3MxID0gW2NhbmRpZGF0ZVNYc1tzZWxlY3RlZDJdLCBjYW5kaWRhdGVTWXNbc2VsZWN0ZWQyXV07XG4gICAgICAgICAgY29uc3QgcG9zMiA9IFtjYW5kaWRhdGVTWHNbc2VsZWN0ZWQzXSwgY2FuZGlkYXRlU1lzW3NlbGVjdGVkM11dO1xuXG4gICAgICAgICAgY29uc3QgW3Ayc2luLCBwMmNvc10gPSBnZXRWZWN0b3JBbmdsZShwb3MwLCBwb3MxKTtcbiAgICAgICAgICBjb25zdCBbcDNzaW4sIHAzY29zXSA9IGdldFZlY3RvckFuZ2xlKHBvczAsIHBvczIpO1xuXG4gICAgICAgICAgbGV0IGRtYXgxID0gMC4wO1xuICAgICAgICAgIGxldCBpbmRleDEgPSAtMTtcbiAgICAgICAgICBsZXQgZG1heDIgPSAwLjA7XG4gICAgICAgICAgbGV0IGluZGV4MiA9IC0xO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FuZGlkYXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGVUeXBlc1tpXSAhPT0gMCkge1xuICAgICAgICAgICAgICBsZXQgdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNlbGVjdGlvbkxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbltqXVswXSA9PT0gaSkgdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF1c2VkXG4gICAgICAgICAgICAgICAgJiYgY2FuZGlkYXRlU1hzW2ldID49IHRhcmdldFdpZHRoLzggJiYgY2FuZGlkYXRlU1hzW2ldIDw9IHRhcmdldFdpZHRoICogNyAvIDhcbiAgICAgICAgICAgICAgICAmJiBjYW5kaWRhdGVTWXNbaV0gPj0gdGFyZ2V0SGVpZ2h0LzggJiYgY2FuZGlkYXRlU1lzW2ldIDw9IHRhcmdldEhlaWdodCAqIDcgLyA4KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjUG9zID0gW2NhbmRpZGF0ZVNYc1tpXSwgY2FuZGlkYXRlU1lzW2ldXTtcbiAgICAgICAgICAgICAgICBjb25zdCBbcDRzaW4sIHA0Y29zXSA9IGdldFZlY3RvckFuZ2xlKHBvczAsIGNQb3MpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHExID0gWy0xLCAtMV07XG4gICAgICAgICAgICAgICAgbGV0IHIxID0gWy0xLCAtMV07XG4gICAgICAgICAgICAgICAgbGV0IHIyID0gWy0xLCAtMV07XG4gICAgICAgICAgICAgICAgaWYoKChwM3NpbipwMmNvcyAtIHAzY29zKnAyc2luKSA+PSAwLjApICYmICgocDRzaW4qcDJjb3MgLSBwNGNvcypwMnNpbikgPj0gMC4wKSkge1xuICAgICAgICAgICAgICAgICAgaWYoIHA0c2luKnAzY29zIC0gcDRjb3MqcDNzaW4gPj0gMC4wICkge1xuICAgICAgICAgICAgICAgICAgICBxMSA9IHBvczE7IHIxID0gcG9zMjsgcjIgPSBjUG9zO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHExID0gcG9zMTsgcjEgPSBjUG9zOyByMiA9IHBvczI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoKChwNHNpbipwM2NvcyAtIHA0Y29zKnAzc2luKSA+PSAwLjApICYmICgocDJzaW4qcDNjb3MgLSBwMmNvcypwM3NpbikgPj0gMC4wKSkge1xuICAgICAgICAgICAgICAgICAgaWYoIHA0c2luKnAyY29zIC0gcDRjb3MqcDJzaW4gPj0gMC4wICkge1xuICAgICAgICAgICAgICAgICAgICBxMSA9IHBvczI7IHIxID0gcG9zMTsgcjIgPSBjUG9zO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHExID0gcG9zMjsgcjEgPSBjUG9zOyByMiA9IHBvczE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoKChwMnNpbipwNGNvcyAtIHAyY29zKnA0c2luKSA+PSAwLjApICYmICgocDNzaW4qcDRjb3MgLSBwM2NvcypwNHNpbikgPj0gMC4wKSkge1xuICAgICAgICAgICAgICAgICAgaWYoIHAzc2luKnAyY29zIC0gcDNjb3MqcDJzaW4gPj0gMC4wICkge1xuICAgICAgICAgICAgICAgICAgICBxMSA9IGNQb3M7IHIxID0gcG9zMTsgcjIgPSBwb3MyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHExID0gY1BvczsgcjEgPSBwb3MyOyByMiA9IHBvczE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IGdldFRyaWFuZ2xlQXJlYShwb3MwLCBxMSwgcjEpXG4gICAgICAgICAgICAgICAgICAgICAgICArIGdldFRyaWFuZ2xlQXJlYShwb3MwLCByMSwgcjIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVR5cGVzW2ldID09PSAxICYmIGQgPiBkbWF4MSkge1xuICAgICAgICAgICAgICAgICAgZG1heDEgPSBkO1xuICAgICAgICAgICAgICAgICAgaW5kZXgxID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlVHlwZXNbaV0gPT09IDIgJiYgZCA+IGRtYXgyKSB7XG4gICAgICAgICAgICAgICAgICBkbWF4MiA9IGQ7XG4gICAgICAgICAgICAgICAgICBpbmRleDIgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5kZXgxICE9PSAtMSkgcmV0dXJuIGluZGV4MTtcbiAgICAgICAgICBpZiAoaW5kZXgyICE9PSAtMSkgcmV0dXJuIGluZGV4MjtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gdXNlIHByZXZpb3VzIHNlbGVjdGVkIGZlYXR1cmVzXG4gICAgICAgICAgLy9mb3IgKGxldCBwID0gMDsgcCA8IHByZXZLZWVwOyBwKyspIHtcbiAgICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IDE7IHArKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb25MZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBmZWF0dXJlSW5kZXggPSBwcmV2U2VsZWN0ZWRGZWF0dXJlSW5kZXhlc1twXVtpXTtcbiAgICAgICAgICAgICAgaWYgKGZlYXR1cmVJbmRleCAhPT0gLTEgJiYgY2FuZGlkYXRlVHlwZXNbZmVhdHVyZUluZGV4XSA9PT0gMSkgeyAvLyBwcmVmZXIgY2FuZGlkYXRlIHR5cGUgMSBvdmVyIDJcbiAgICAgICAgICAgICAgICBsZXQgdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VsZWN0aW9uTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25bal1bMF0gPT09IGZlYXR1cmVJbmRleCkgdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdXNlZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBtYXliZSBzZWxlY3QgcmFuZG9tIGJldHRlcj9cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbmRpZGF0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlVHlwZXNbaV0gPT09IDEpIHsgLy8gcHJlZmVyIGNhbmRpZGF0ZSB0eXBlIDEgb3ZlciAyXG4gICAgICAgICAgICAgIGxldCB1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VsZWN0aW9uTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uW2pdWzBdID09PSBpKSB1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXVzZWQpIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0sIHtcbiAgICAgICAgY29uc3RhbnRzOiB7XG4gICAgICAgICAgcHJldktlZXA6IFBSRVZfS0VFUCxcbiAgICAgICAgICBzaW1UaHJlc2hvbGQ6IEFSMl9TSU1fVEhSRVNILFxuICAgICAgICAgIHNlbGVjdGlvbkxlbmd0aDogQVIyX0RFRkFVTFRfU0VBUkNIX0ZFQVRVUkVfTlVNLFxuICAgICAgICAgIGNhbmRpZGF0ZUxlbmd0aDogY2FuZGlkYXRlU1hzLm91dHB1dFswXSxcbiAgICAgICAgICB0YXJnZXRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICB0YXJnZXRIZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIHBpcGVsaW5lOiB0cnVlLFxuICAgICAgICBvdXRwdXQ6IFsxXVxuICAgICAgfSk7XG4gICAgICB0aGlzLmtlcm5lbHMucHVzaChrZXJuZWwpO1xuICAgIH1cbiAgICBjb25zdCBrZXJuZWwgPSB0aGlzLmtlcm5lbHNbdGhpcy5rZXJuZWxJbmRleCsrXTtcbiAgICBjb25zdCBuZXdTZWxlY3RlZCA9IGtlcm5lbChzZWxlY3Rpb24sIGNhbmRpZGF0ZVR5cGVzLCBjYW5kaWRhdGVTWHMsIGNhbmRpZGF0ZVNZcywgdGhpcy5wcmV2U2VsZWN0ZWRGZWF0dXJlSW5kZXhlcyk7XG4gICAgcmV0dXJuIG5ld1NlbGVjdGVkO1xuICB9XG5cbiAgLy8gIGZpcnN0IGRpbWVuc2lvbiBbbGV2ZWwsIHN4LCBzeSwgbXgsIG15XVxuICBfY29tcHV0ZUNhbmRpZGF0ZXMoKSB7XG4gICAgaWYgKHRoaXMua2VybmVsSW5kZXggPT09IHRoaXMua2VybmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbE1hcCh7XG4gICAgICAgIHNhdmVTWDogZnVuY3Rpb24oYSkge3JldHVybiBhfSxcbiAgICAgICAgc2F2ZVNZOiBmdW5jdGlvbihhKSB7cmV0dXJuIGF9LFxuICAgICAgfSwgZnVuY3Rpb24oZmVhdHVyZVBvaW50cywgbW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybXMsIG1vZGVsVmlld1RyYW5zZm9ybXMpIHtcbiAgICAgICAgY29uc3Qge3RhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHR9ID0gdGhpcy5jb25zdGFudHM7XG4gICAgICAgIGNvbnN0IG14ID0gZmVhdHVyZVBvaW50c1t0aGlzLnRocmVhZC54XVswXTtcbiAgICAgICAgY29uc3QgbXkgPSBmZWF0dXJlUG9pbnRzW3RoaXMudGhyZWFkLnhdWzFdO1xuICAgICAgICBjb25zdCBsZXZlbCA9IGZlYXR1cmVQb2ludHNbdGhpcy50aHJlYWQueF1bMl07XG4gICAgICAgIGNvbnN0IG1heGRwaSA9IGZlYXR1cmVQb2ludHNbdGhpcy50aHJlYWQueF1bM107XG4gICAgICAgIGNvbnN0IG1pbmRwaSA9IGZlYXR1cmVQb2ludHNbdGhpcy50aHJlYWQueF1bNF07XG5cbiAgICAgICAgLy8gY29tcHV0ZSBzY3JlZW4gY29vcmRpbmF0ZVxuICAgICAgICBjb25zdCB1ID0gY29tcHV0ZVNjcmVlbkNvb3JkaWF0ZShtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtcywgMCwgbXgsIG15LCAwKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSB1WzBdO1xuICAgICAgICBpZiAodmFsaWQgPT09IDApIHJldHVybiAtMTtcblxuICAgICAgICBjb25zdCBzeCA9IHVbMV07XG4gICAgICAgIGNvbnN0IHN5ID0gdVsyXTtcblxuICAgICAgICBpZiAoc3ggPCAwIHx8IHN4ID49IHRhcmdldFdpZHRoKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChzeSA8IDAgfHwgc3kgPj0gdGFyZ2V0SGVpZ2h0KSByZXR1cm4gLTE7XG5cbiAgICAgICAgY29uc3QgdmRpciA9IFswLCAwLCAwXTtcbiAgICAgICAgdmRpclswXSA9IG1vZGVsVmlld1RyYW5zZm9ybXNbMF1bMF1bMF0gKiBteFxuICAgICAgICAgICAgICAgICsgbW9kZWxWaWV3VHJhbnNmb3Jtc1swXVswXVsxXSAqIG15XG4gICAgICAgICAgICAgICAgKyBtb2RlbFZpZXdUcmFuc2Zvcm1zWzBdWzBdWzNdO1xuICAgICAgICB2ZGlyWzFdID0gbW9kZWxWaWV3VHJhbnNmb3Jtc1swXVsxXVswXSAqIG14XG4gICAgICAgICAgICAgICAgKyBtb2RlbFZpZXdUcmFuc2Zvcm1zWzBdWzFdWzFdICogbXlcbiAgICAgICAgICAgICAgICArIG1vZGVsVmlld1RyYW5zZm9ybXNbMF1bMV1bM107XG4gICAgICAgIHZkaXJbMl0gPSBtb2RlbFZpZXdUcmFuc2Zvcm1zWzBdWzJdWzBdICogbXhcbiAgICAgICAgICAgICAgICArIG1vZGVsVmlld1RyYW5zZm9ybXNbMF1bMl1bMV0gKiBteVxuICAgICAgICAgICAgICAgICsgbW9kZWxWaWV3VHJhbnNmb3Jtc1swXVsyXVszXTtcbiAgICAgICAgY29uc3QgdmxlbiA9IE1hdGguc3FydCh2ZGlyWzBdKnZkaXJbMF0gKyB2ZGlyWzFdKnZkaXJbMV0gKyB2ZGlyWzJdKnZkaXJbMl0pO1xuICAgICAgICB2ZGlyWzBdIC89IHZsZW47XG4gICAgICAgIHZkaXJbMV0gLz0gdmxlbjtcbiAgICAgICAgdmRpclsyXSAvPSB2bGVuO1xuICAgICAgICBjb25zdCB2ZGlyVmFsdWUgPSB2ZGlyWzBdKm1vZGVsVmlld1RyYW5zZm9ybXNbMF1bMF1bMl0gKyB2ZGlyWzFdKm1vZGVsVmlld1RyYW5zZm9ybXNbMF1bMV1bMl0gKyB2ZGlyWzJdKm1vZGVsVmlld1RyYW5zZm9ybXNbMF1bMl1bMl07XG5cbiAgICAgICAgaWYgKHZkaXJWYWx1ZSA+IC0wLjEpIHJldHVybiAtMTtcblxuICAgICAgICAvLyBnZXQgcmVzb2x1dGlvblxuICAgICAgICBjb25zdCB1MSA9IGNvbXB1dGVTY3JlZW5Db29yZGlhdGUobW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybXMsIDAsIG14KzEwLCBteSwgMCk7XG4gICAgICAgIGNvbnN0IHUyID0gY29tcHV0ZVNjcmVlbkNvb3JkaWF0ZShtb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtcywgMCwgbXgsIG15KzEwLCAwKTtcbiAgICAgICAgY29uc3QgZDEgPSAodTFbMV0gLSB1WzFdKSAqICh1MVsxXSAtIHVbMV0pICsgKHUxWzJdIC0gdVsyXSkgKiAodTFbMl0gLSB1WzJdKTtcbiAgICAgICAgY29uc3QgZDIgPSAodTJbMV0gLSB1WzFdKSAqICh1MlsxXSAtIHVbMV0pICsgKHUyWzJdIC0gdVsyXSkgKiAodTJbMl0gLSB1WzJdKTtcbiAgICAgICAgLy8gMTAgcGl4ZWwgaW4gbWFya2VyIC0+IGQgbW0gaW4gc2NyZWVuIChzY3JlZW4gc2NhbGUgaW4gbW0pXG4gICAgICAgIGNvbnN0IGRwaSA9IFswLCAwXTtcbiAgICAgICAgaWYgKGQxIDwgZDIpIHtcbiAgICAgICAgICBkcGlbMF0gPSBNYXRoLnNxcnQoZDIpIC8gMTA7XG4gICAgICAgICAgZHBpWzFdID0gTWF0aC5zcXJ0KGQxKSAvIDEwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRwaVswXSA9IE1hdGguc3FydChkMSkgLyAxMDtcbiAgICAgICAgICBkcGlbMV0gPSBNYXRoLnNxcnQoZDIpIC8gMTA7XG4gICAgICAgIH1cblxuICAgICAgICBzYXZlU1godVsxXSk7XG4gICAgICAgIHNhdmVTWSh1WzJdKTtcblxuICAgICAgICBpZiAoZHBpWzFdIDw9IG1heGRwaSAmJiBkcGlbMV0gPj0gbWluZHBpKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoZHBpWzFdIDw9IG1heGRwaSAqIDIgJiYgZHBpWzFdID49IG1pbmRwaSAvIDIpIHtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sIHtcbiAgICAgICAgY29uc3RhbnRzOiB7dGFyZ2V0V2lkdGg6IHRoaXMud2lkdGgsIHRhcmdldEhlaWdodDogdGhpcy5oZWlnaHR9LFxuICAgICAgICBvdXRwdXQ6IFt0aGlzLmZlYXR1cmVQb2ludHMub3V0cHV0WzFdXSxcbiAgICAgICAgcGlwZWxpbmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5rZXJuZWxzLnB1c2goa2VybmVsKTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsID0gdGhpcy5rZXJuZWxzW3RoaXMua2VybmVsSW5kZXgrK107XG4gICAgcmV0dXJuIGtlcm5lbCh0aGlzLmZlYXR1cmVQb2ludHMsIHRoaXMucHJldk1vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm1zLCB0aGlzLnByZXZNb2RlbFZpZXdUcmFuc2Zvcm1zKTtcbiAgfVxufVxuXG5jb25zdCBfY29tcHV0ZVVwZGF0ZWRUcmFuID0gKHttb2RlbFZpZXdUcmFuc2Zvcm0sIHByb2plY3Rpb25UcmFuc2Zvcm0sIHNlbGVjdGVkRmVhdHVyZXMsIGlubGllclByb2J9KSA9PiB7XG4gIGxldCBkeCA9IDA7XG4gIGxldCBkeSA9IDA7XG4gIGxldCBkeiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0ZWRGZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgIGR4ICs9IHNlbGVjdGVkRmVhdHVyZXNbaV0ucG9zM0QueDtcbiAgICBkeSArPSBzZWxlY3RlZEZlYXR1cmVzW2ldLnBvczNELnk7XG4gICAgZHogKz0gc2VsZWN0ZWRGZWF0dXJlc1tpXS5wb3MzRC56O1xuICB9XG4gIGR4IC89IHNlbGVjdGVkRmVhdHVyZXMubGVuZ3RoO1xuICBkeSAvPSBzZWxlY3RlZEZlYXR1cmVzLmxlbmd0aDtcbiAgZHogLz0gc2VsZWN0ZWRGZWF0dXJlcy5sZW5ndGg7XG5cbiAgY29uc3Qgd29ybGRDb29yZHMgPSBbXTtcbiAgY29uc3Qgc2NyZWVuQ29vcmRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0ZWRGZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgIHNjcmVlbkNvb3Jkcy5wdXNoKHt4OiBzZWxlY3RlZEZlYXR1cmVzW2ldLnBvczJELngsIHk6IHNlbGVjdGVkRmVhdHVyZXNbaV0ucG9zMkQueX0pO1xuICAgIHdvcmxkQ29vcmRzLnB1c2goe3g6IHNlbGVjdGVkRmVhdHVyZXNbaV0ucG9zM0QueCAtIGR4LCB5OiBzZWxlY3RlZEZlYXR1cmVzW2ldLnBvczNELnkgLSBkeSwgejogc2VsZWN0ZWRGZWF0dXJlc1tpXS5wb3MzRC56IC0gZHp9KTtcbiAgfVxuXG4gIGNvbnN0IGRpZmZNb2RlbFZpZXdUcmFuc2Zvcm0gPSBbW10sW10sW11dO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBkaWZmTW9kZWxWaWV3VHJhbnNmb3JtW2pdW2ldID0gbW9kZWxWaWV3VHJhbnNmb3JtW2pdW2ldO1xuICAgIH1cbiAgfVxuICBkaWZmTW9kZWxWaWV3VHJhbnNmb3JtWzBdWzNdID0gbW9kZWxWaWV3VHJhbnNmb3JtWzBdWzBdICogZHggKyBtb2RlbFZpZXdUcmFuc2Zvcm1bMF1bMV0gKiBkeSArIG1vZGVsVmlld1RyYW5zZm9ybVswXVsyXSAqIGR6ICsgbW9kZWxWaWV3VHJhbnNmb3JtWzBdWzNdO1xuICBkaWZmTW9kZWxWaWV3VHJhbnNmb3JtWzFdWzNdID0gbW9kZWxWaWV3VHJhbnNmb3JtWzFdWzBdICogZHggKyBtb2RlbFZpZXdUcmFuc2Zvcm1bMV1bMV0gKiBkeSArIG1vZGVsVmlld1RyYW5zZm9ybVsxXVsyXSAqIGR6ICsgbW9kZWxWaWV3VHJhbnNmb3JtWzFdWzNdO1xuICBkaWZmTW9kZWxWaWV3VHJhbnNmb3JtWzJdWzNdID0gbW9kZWxWaWV3VHJhbnNmb3JtWzJdWzBdICogZHggKyBtb2RlbFZpZXdUcmFuc2Zvcm1bMl1bMV0gKiBkeSArIG1vZGVsVmlld1RyYW5zZm9ybVsyXVsyXSAqIGR6ICsgbW9kZWxWaWV3VHJhbnNmb3JtWzJdWzNdO1xuXG4gIGxldCByZXQ7XG4gIGlmIChpbmxpZXJQcm9iIDwgMSkge1xuICAgICByZXQgPSByZWZpbmVIb21vZ3JhcGh5KHtpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtOiBkaWZmTW9kZWxWaWV3VHJhbnNmb3JtLCBwcm9qZWN0aW9uVHJhbnNmb3JtLCB3b3JsZENvb3Jkcywgc2NyZWVuQ29vcmRzLCBpc1JvYnVzdE1vZGU6IHRydWUsIGlubGllclByb2J9KTtcbiAgfSBlbHNlIHtcbiAgICAgcmV0ID0gcmVmaW5lSG9tb2dyYXBoeSh7aW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybTogZGlmZk1vZGVsVmlld1RyYW5zZm9ybSwgcHJvamVjdGlvblRyYW5zZm9ybSwgd29ybGRDb29yZHMsIHNjcmVlbkNvb3JkcywgaXNSb2J1c3RNb2RlOiBmYWxzZX0pO1xuICB9XG5cbiAgY29uc3QgbmV3TW9kZWxWaWV3VHJhbnNmb3JtID0gW1tdLFtdLFtdXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgbmV3TW9kZWxWaWV3VHJhbnNmb3JtW2pdW2ldID0gcmV0Lm1vZGVsVmlld1RyYW5zZm9ybVtqXVtpXTtcbiAgICB9XG4gIH1cbiAgbmV3TW9kZWxWaWV3VHJhbnNmb3JtWzBdWzNdID0gcmV0Lm1vZGVsVmlld1RyYW5zZm9ybVswXVszXSAtIHJldC5tb2RlbFZpZXdUcmFuc2Zvcm1bMF1bMF0gKiBkeCAtIHJldC5tb2RlbFZpZXdUcmFuc2Zvcm1bMF1bMV0gKiBkeSAtIHJldC5tb2RlbFZpZXdUcmFuc2Zvcm1bMF1bMl0gKiBkejtcbiAgbmV3TW9kZWxWaWV3VHJhbnNmb3JtWzFdWzNdID0gcmV0Lm1vZGVsVmlld1RyYW5zZm9ybVsxXVszXSAtIHJldC5tb2RlbFZpZXdUcmFuc2Zvcm1bMV1bMF0gKiBkeCAtIHJldC5tb2RlbFZpZXdUcmFuc2Zvcm1bMV1bMV0gKiBkeSAtIHJldC5tb2RlbFZpZXdUcmFuc2Zvcm1bMV1bMl0gKiBkejtcbiAgbmV3TW9kZWxWaWV3VHJhbnNmb3JtWzJdWzNdID0gcmV0Lm1vZGVsVmlld1RyYW5zZm9ybVsyXVszXSAtIHJldC5tb2RlbFZpZXdUcmFuc2Zvcm1bMl1bMF0gKiBkeCAtIHJldC5tb2RlbFZpZXdUcmFuc2Zvcm1bMl1bMV0gKiBkeSAtIHJldC5tb2RlbFZpZXdUcmFuc2Zvcm1bMl1bMl0gKiBkejtcblxuXG4gIHJldHVybiB7ZXJyOiByZXQuZXJyLCBuZXdNb2RlbFZpZXdUcmFuc2Zvcm19O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRyYWNrZXIsXG59XG4iLCIvLyBjaGVjayB3aGljaCBzaWRlIHBvaW50IEMgb24gdGhlIGxpbmUgZnJvbSBBIHRvIEJcbmNvbnN0IGxpbmVQb2ludFNpZGUgPSAoQSwgQiwgQykgPT4ge1xuICByZXR1cm4gKChCWzBdLUFbMF0pKihDWzFdLUFbMV0pLShCWzFdLUFbMV0pKihDWzBdLUFbMF0pKTtcbn1cblxuLy8gc3JjUG9pbnRzLCBkc3RQb2ludHM6IGFycmF5IG9mIGZvdXIgZWxlbWVudHMgW3gsIHldXG5jb25zdCBjaGVja0ZvdXJQb2ludHNDb25zaXN0ZW50ID0gKHgxLCB4MiwgeDMsIHg0LCB4MXAsIHgycCwgeDNwLCB4NHApID0+IHtcbiAgaWYgKChsaW5lUG9pbnRTaWRlKHgxLCB4MiwgeDMpID4gMCkgIT09IChsaW5lUG9pbnRTaWRlKHgxcCwgeDJwLCB4M3ApID4gMCkpIHJldHVybiBmYWxzZTtcbiAgaWYgKChsaW5lUG9pbnRTaWRlKHgyLCB4MywgeDQpID4gMCkgIT09IChsaW5lUG9pbnRTaWRlKHgycCwgeDNwLCB4NHApID4gMCkpIHJldHVybiBmYWxzZTtcbiAgaWYgKChsaW5lUG9pbnRTaWRlKHgzLCB4NCwgeDEpID4gMCkgIT09IChsaW5lUG9pbnRTaWRlKHgzcCwgeDRwLCB4MXApID4gMCkpIHJldHVybiBmYWxzZTtcbiAgaWYgKChsaW5lUG9pbnRTaWRlKHg0LCB4MSwgeDIpID4gMCkgIT09IChsaW5lUG9pbnRTaWRlKHg0cCwgeDFwLCB4MnApID4gMCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmNvbnN0IGNoZWNrVGhyZWVQb2ludHNDb25zaXN0ZW50ID0gKHgxLCB4MiwgeDMsIHgxcCwgeDJwLCB4M3ApID0+IHtcbiAgaWYgKChsaW5lUG9pbnRTaWRlKHgxLCB4MiwgeDMpID4gMCkgIT09IChsaW5lUG9pbnRTaWRlKHgxcCwgeDJwLCB4M3ApID4gMCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmNvbnN0IGRldGVybWluYW50ID0gKEEpID0+IHtcbiAgY29uc3QgQzEgPSAgQVs0XSAqIEFbOF0gLSBBWzVdICogQVs3XTtcbiAgY29uc3QgQzIgPSAgQVszXSAqIEFbOF0gLSBBWzVdICogQVs2XTtcbiAgY29uc3QgQzMgPSAgQVszXSAqIEFbN10gLSBBWzRdICogQVs2XTtcbiAgcmV0dXJuIEFbMF0gKiBDMSAtIEFbMV0gKiBDMiArIEFbMl0gKiBDMztcbn1cblxuY29uc3QgbWF0cml4SW52ZXJzZTMzID0gKEEsIHRocmVzaG9sZCkgPT4ge1xuICBjb25zdCBkZXQgPSBkZXRlcm1pbmFudChBKTtcbiAgaWYgKE1hdGguYWJzKGRldCkgPD0gdGhyZXNob2xkKSByZXR1cm4gbnVsbDtcbiAgY29uc3Qgb25lT3ZlciA9IDEuMCAvIGRldDtcblxuICBjb25zdCBCID0gW1xuICAgIChBWzRdICogQVs4XSAtIEFbNV0gKiBBWzddKSAqIG9uZU92ZXIsXG4gICAgKEFbMl0gKiBBWzddIC0gQVsxXSAqIEFbOF0pICogb25lT3ZlcixcbiAgICAoQVsxXSAqIEFbNV0gLSBBWzJdICogQVs0XSkgKiBvbmVPdmVyLFxuICAgIChBWzVdICogQVs2XSAtIEFbM10gKiBBWzhdKSAqIG9uZU92ZXIsXG4gICAgKEFbMF0gKiBBWzhdIC0gQVsyXSAqIEFbNl0pICogb25lT3ZlcixcbiAgICAoQVsyXSAqIEFbM10gLSBBWzBdICogQVs1XSkgKiBvbmVPdmVyLFxuICAgIChBWzNdICogQVs3XSAtIEFbNF0gKiBBWzZdKSAqIG9uZU92ZXIsXG4gICAgKEFbMV0gKiBBWzZdIC0gQVswXSAqIEFbN10pICogb25lT3ZlcixcbiAgICAoQVswXSAqIEFbNF0gLSBBWzFdICogQVszXSkgKiBvbmVPdmVyLFxuICBdO1xuICByZXR1cm4gQjtcbn1cblxuY29uc3QgbWF0cml4TXVsMzMgPSAoQSwgQikgPT4ge1xuICBjb25zdCBDID0gW107XG4gIENbMF0gPSBBWzBdKkJbMF0gKyBBWzFdKkJbM10gKyBBWzJdKkJbNl07XG4gIENbMV0gPSBBWzBdKkJbMV0gKyBBWzFdKkJbNF0gKyBBWzJdKkJbN107XG4gIENbMl0gPSBBWzBdKkJbMl0gKyBBWzFdKkJbNV0gKyBBWzJdKkJbOF07XG4gIENbM10gPSBBWzNdKkJbMF0gKyBBWzRdKkJbM10gKyBBWzVdKkJbNl07XG4gIENbNF0gPSBBWzNdKkJbMV0gKyBBWzRdKkJbNF0gKyBBWzVdKkJbN107XG4gIENbNV0gPSBBWzNdKkJbMl0gKyBBWzRdKkJbNV0gKyBBWzVdKkJbOF07XG4gIENbNl0gPSBBWzZdKkJbMF0gKyBBWzddKkJbM10gKyBBWzhdKkJbNl07XG4gIENbN10gPSBBWzZdKkJbMV0gKyBBWzddKkJbNF0gKyBBWzhdKkJbN107XG4gIENbOF0gPSBBWzZdKkJbMl0gKyBBWzddKkJbNV0gKyBBWzhdKkJbOF07XG4gIHJldHVybiBDO1xufVxuXG5jb25zdCBtdWx0aXBseVBvaW50SG9tb2dyYXBoeUluaG9tb2dlbm91cyA9ICh4LCBIKSA9PiB7XG4gIGNvbnN0IHcgPSBIWzZdKnhbMF0gKyBIWzddKnhbMV0gKyBIWzhdO1xuICBjb25zdCB4cCA9IFtdO1xuICB4cFswXSA9IChIWzBdKnhbMF0gKyBIWzFdKnhbMV0gKyBIWzJdKS93O1xuICB4cFsxXSA9IChIWzNdKnhbMF0gKyBIWzRdKnhbMV0gKyBIWzVdKS93O1xuICByZXR1cm4geHA7XG59XG5cbmNvbnN0IHNtYWxsZXN0VHJpYW5nbGVBcmVhID0gKHgxLCB4MiwgeDMsIHg0KSA9PiB7XG4gIGNvbnN0IHYxMiA9IF92ZWN0b3IoeDIsIHgxKTtcbiAgY29uc3QgdjEzID0gX3ZlY3Rvcih4MywgeDEpO1xuICBjb25zdCB2MTQgPSBfdmVjdG9yKHg0LCB4MSk7XG4gIGNvbnN0IHYzMiA9IF92ZWN0b3IoeDIsIHgzKTtcbiAgY29uc3QgdjM0ID0gX3ZlY3Rvcih4NCwgeDMpO1xuICBjb25zdCBhMSA9IF9hcmVhT2ZUcmlhbmdsZSh2MTIsIHYxMyk7XG4gIGNvbnN0IGEyID0gX2FyZWFPZlRyaWFuZ2xlKHYxMywgdjE0KTtcbiAgY29uc3QgYTMgPSBfYXJlYU9mVHJpYW5nbGUodjEyLCB2MTQpO1xuICBjb25zdCBhNCA9IF9hcmVhT2ZUcmlhbmdsZSh2MzIsIHYzNCk7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1pbihNYXRoLm1pbihhMSwgYTIpLCBhMyksIGE0KTtcbn1cblxuLy8gY2hlY2sgaWYgZm91ciBwb2ludHMgZm9ybSBhIGNvbnZleCBxdWFkcmlsYXRlcm5hbC5cbi8vIGFsbCBmb3VyIGNvbWJpbmF0aW9ucyBzaG91bGQgaGF2ZSBzYW1lIHNpZ25cbmNvbnN0IHF1YWRyaWxhdGVyYWxDb252ZXggPSAoeDEsIHgyLCB4MywgeDQpID0+IHtcbiAgY29uc3QgZmlyc3QgPSBsaW5lUG9pbnRTaWRlKHgxLCB4MiwgeDMpIDw9IDA7XG4gIGlmICggKGxpbmVQb2ludFNpZGUoeDIsIHgzLCB4NCkgPD0gMCkgIT09IGZpcnN0KSByZXR1cm4gZmFsc2U7XG4gIGlmICggKGxpbmVQb2ludFNpZGUoeDMsIHg0LCB4MSkgPD0gMCkgIT09IGZpcnN0KSByZXR1cm4gZmFsc2U7XG4gIGlmICggKGxpbmVQb2ludFNpZGUoeDQsIHgxLCB4MikgPD0gMCkgIT09IGZpcnN0KSByZXR1cm4gZmFsc2U7XG5cbiAgLy9pZiAobGluZVBvaW50U2lkZSh4MSwgeDIsIHgzKSA8PSAwKSByZXR1cm4gZmFsc2U7XG4gIC8vaWYgKGxpbmVQb2ludFNpZGUoeDIsIHgzLCB4NCkgPD0gMCkgcmV0dXJuIGZhbHNlO1xuICAvL2lmIChsaW5lUG9pbnRTaWRlKHgzLCB4NCwgeDEpIDw9IDApIHJldHVybiBmYWxzZTtcbiAgLy9pZiAobGluZVBvaW50U2lkZSh4NCwgeDEsIHgyKSA8PSAwKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCBfdmVjdG9yID0gKGEsIGIpID0+IHtcbiAgcmV0dXJuIFtcbiAgICBhWzBdIC0gYlswXSxcbiAgICBhWzFdIC0gYlsxXVxuICBdXG59XG5cbmNvbnN0IF9hcmVhT2ZUcmlhbmdsZSA9ICh1LCB2KSA9PiB7XG4gIGNvbnN0IGEgPSB1WzBdKnZbMV0gLSB1WzFdKnZbMF07XG4gIHJldHVybiBNYXRoLmFicyhhKSAqIDAuNTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1hdHJpeEludmVyc2UzMyxcbiAgbWF0cml4TXVsMzMsXG4gIHF1YWRyaWxhdGVyYWxDb252ZXgsXG4gIHNtYWxsZXN0VHJpYW5nbGVBcmVhLFxuICBtdWx0aXBseVBvaW50SG9tb2dyYXBoeUluaG9tb2dlbm91cyxcbiAgY2hlY2tUaHJlZVBvaW50c0NvbnNpc3RlbnQsXG4gIGNoZWNrRm91clBvaW50c0NvbnNpc3RlbnQsXG4gIGRldGVybWluYW50XG59XG5cbiIsIi8vIHNpbXBsZXIgdmVyc2lvbiBvZiB1cHNhbXBsaW5nLiBiZXR0ZXIgcGVyZm9ybWFuY2VcbmNvbnN0IF91cHNhbXBsZUJpbGluZWFyID0gKHtpbWFnZSwgcGFkT25lV2lkdGgsIHBhZE9uZUhlaWdodH0pID0+IHtcbiAgY29uc3Qge3dpZHRoLCBoZWlnaHQsIGRhdGF9ID0gaW1hZ2U7XG4gIGNvbnN0IGRzdFdpZHRoID0gaW1hZ2Uud2lkdGggKiAyICsgKHBhZE9uZVdpZHRoPzE6MCk7XG4gIGNvbnN0IGRzdEhlaWdodCA9IGltYWdlLmhlaWdodCAqIDIgKyAocGFkT25lSGVpZ2h0PzE6MCk7XG4gIGNvbnN0IHRlbXAgPSBuZXcgRmxvYXQzMkFycmF5KGRzdFdpZHRoICogZHN0SGVpZ2h0KTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhlaWdodDsgaisrKSB7XG4gICAgICBjb25zdCB2ID0gMC4yNSAqIGRhdGFbaiAqIHdpZHRoICsgaV07XG4gICAgICBjb25zdCBpaSA9IE1hdGguZmxvb3IoaS8yKTtcbiAgICAgIGNvbnN0IGpqID0gTWF0aC5mbG9vcihqLzIpO1xuICAgICAgY29uc3QgcG9zID0gTWF0aC5mbG9vcihqLzIpICogZHN0V2lkdGggKyBNYXRoLmZsb29yKGkvMik7XG4gICAgICB0ZW1wW3Bvc10gKz0gdjtcbiAgICAgIHRlbXBbcG9zKzFdICs9IHY7XG4gICAgICB0ZW1wW3Bvcytkc3RXaWR0aF0gKz0gdjtcbiAgICAgIHRlbXBbcG9zK2RzdFdpZHRoKzFdICs9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiB7ZGF0YTogdGVtcCwgd2lkdGg6IGRzdFdpZHRoLCBoZWlnaHQ6IGRzdEhlaWdodH07XG59XG5cbi8vIGFydG9vbGtpdCB2ZXJzaW9uLiBzbG93ZXIuIGlzIGl0IG5lY2Vzc2FyeT9cbmNvbnN0IHVwc2FtcGxlQmlsaW5lYXIgPSAoe2ltYWdlLCBwYWRPbmVXaWR0aCwgcGFkT25lSGVpZ2h0fSkgPT4ge1xuICBjb25zdCB7d2lkdGgsIGhlaWdodCwgZGF0YX0gPSBpbWFnZTtcblxuICBjb25zdCBkc3RXaWR0aCA9IGltYWdlLndpZHRoICogMiArIChwYWRPbmVXaWR0aD8xOjApO1xuICBjb25zdCBkc3RIZWlnaHQgPSBpbWFnZS5oZWlnaHQgKiAyICsgKHBhZE9uZUhlaWdodD8xOjApO1xuXG4gIGNvbnN0IHRlbXAgPSBuZXcgRmxvYXQzMkFycmF5KGRzdFdpZHRoICogZHN0SGVpZ2h0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkc3RXaWR0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2kgPSAwLjUgKiBpIC0gMC4yNTtcbiAgICBsZXQgc2kwID0gTWF0aC5mbG9vcihzaSk7XG4gICAgbGV0IHNpMSA9IE1hdGguY2VpbChzaSk7XG4gICAgaWYgKHNpMCA8IDApIHNpMCA9IDA7IC8vIGJvcmRlclxuICAgIGlmIChzaTEgPj0gd2lkdGgpIHNpMSA9IHdpZHRoIC0gMTsgLy8gYm9yZGVyXG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRzdEhlaWdodDsgaisrKSB7XG4gICAgICBjb25zdCBzaiA9IDAuNSAqIGogLSAwLjI1O1xuICAgICAgbGV0IHNqMCA9IE1hdGguZmxvb3Ioc2opO1xuICAgICAgbGV0IHNqMSA9IE1hdGguY2VpbChzaik7XG4gICAgICBpZiAoc2owIDwgMCkgc2owID0gMDsgLy8gYm9yZGVyXG4gICAgICBpZiAoc2oxID49IGhlaWdodCkgc2oxID0gaGVpZ2h0IC0gMTsgLy9ib3JkZXJcblxuICAgICAgY29uc3QgdmFsdWUgPSAoc2kxIC0gc2kpICogKHNqMSAtIHNqKSAqIGRhdGFbIHNqMCAqIHdpZHRoICsgc2kwIF0gK1xuICAgICAgICAgICAgICAgICAgICAoc2kxIC0gc2kpICogKHNqIC0gc2owKSAqIGRhdGFbIHNqMSAqIHdpZHRoICsgc2kwIF0gK1xuICAgICAgICAgICAgICAgICAgICAoc2kgLSBzaTApICogKHNqMSAtIHNqKSAqIGRhdGFbIHNqMCAqIHdpZHRoICsgc2kxIF0gK1xuICAgICAgICAgICAgICAgICAgICAoc2kgLSBzaTApICogKHNqIC0gc2owKSAqIGRhdGFbIHNqMSAqIHdpZHRoICsgc2kxIF07XG5cbiAgICAgIHRlbXBbaiAqIGRzdFdpZHRoICsgaV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge2RhdGE6IHRlbXAsIHdpZHRoOiBkc3RXaWR0aCwgaGVpZ2h0OiBkc3RIZWlnaHR9O1xufVxuXG5jb25zdCBkb3duc2FtcGxlQmlsaW5lYXIgPSAoe2ltYWdlfSkgPT4ge1xuICBjb25zdCB7ZGF0YSwgd2lkdGgsIGhlaWdodH0gPSBpbWFnZTtcblxuICBjb25zdCBkc3RXaWR0aCA9IE1hdGguZmxvb3Iod2lkdGggLyAyKTtcbiAgY29uc3QgZHN0SGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQgLyAyKTtcblxuICBjb25zdCB0ZW1wID0gbmV3IEZsb2F0MzJBcnJheShkc3RXaWR0aCAqIGRzdEhlaWdodCk7XG4gIGNvbnN0IG9mZnNldHMgPSBbMCwgMSwgd2lkdGgsIHdpZHRoKzFdO1xuXG4gIGZvciAobGV0IGogPSAwOyBqIDwgZHN0SGVpZ2h0OyBqKyspIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRzdFdpZHRoOyBpKyspIHtcbiAgICAgIGxldCBzcmNQb3MgPSBqKjIgKiB3aWR0aCArIGkqMjtcbiAgICAgIGxldCB2YWx1ZSA9IDAuMDtcbiAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgb2Zmc2V0cy5sZW5ndGg7IGQrKykge1xuICAgICAgICB2YWx1ZSArPSBkYXRhW3NyY1Bvcysgb2Zmc2V0c1tkXV07XG4gICAgICB9XG4gICAgICB2YWx1ZSAqPSAwLjI1O1xuICAgICAgdGVtcFtqKmRzdFdpZHRoK2ldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB7ZGF0YTogdGVtcCwgd2lkdGg6IGRzdFdpZHRoLCBoZWlnaHQ6IGRzdEhlaWdodH07XG59XG5cbmNvbnN0IHJlc2l6ZSA9ICh7aW1hZ2UsIHJhdGlvfSkgPT4ge1xuICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQoaW1hZ2Uud2lkdGggKiByYXRpbyk7XG4gIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQoaW1hZ2UuaGVpZ2h0ICogcmF0aW8pO1xuXG4gIC8vY29uc3QgaW1hZ2VEYXRhID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCk7XG4gIGNvbnN0IGltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgbGV0IHNpMSA9IE1hdGgucm91bmQoMS4wICogaSAvIHJhdGlvKTtcbiAgICBsZXQgc2kyID0gTWF0aC5yb3VuZCgxLjAgKiAoaSsxKSAvIHJhdGlvKSAtIDE7XG4gICAgaWYgKHNpMiA+PSBpbWFnZS53aWR0aCkgc2kyID0gaW1hZ2Uud2lkdGggLSAxO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBoZWlnaHQ7IGorKykge1xuICAgICAgbGV0IHNqMSA9IE1hdGgucm91bmQoMS4wICogaiAvIHJhdGlvKTtcbiAgICAgIGxldCBzajIgPSBNYXRoLnJvdW5kKDEuMCAqIChqKzEpIC8gcmF0aW8pIC0gMTtcbiAgICAgIGlmIChzajIgPj0gaW1hZ2UuaGVpZ2h0KSBzajIgPSBpbWFnZS5oZWlnaHQgLSAxO1xuXG4gICAgICBsZXQgc3VtID0gMDtcbiAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICBmb3IgKGxldCBpaSA9IHNpMTsgaWkgPD0gc2kyOyBpaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGpqID0gc2oxOyBqaiA8PSBzajI7IGpqKyspIHtcbiAgICAgICAgICBzdW0gKz0gKDEuMCAqIGltYWdlLmRhdGFbamogKiBpbWFnZS53aWR0aCArIGlpXSk7XG4gICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW1hZ2VEYXRhW2ogKiB3aWR0aCArIGldID0gTWF0aC5mbG9vcihzdW0gLyBjb3VudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7ZGF0YTogaW1hZ2VEYXRhLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRvd25zYW1wbGVCaWxpbmVhcixcbiAgdXBzYW1wbGVCaWxpbmVhcixcbiAgcmVzaXplLFxufVxuXG4iLCJjb25zdCBtUmFuZFNlZWQgPSAxMjM0O1xuXG5jb25zdCBjcmVhdGVSYW5kb21pemVyID0gKCkgPT4ge1xuICBjb25zdCByYW5kb21pemVyID0ge1xuICAgIHNlZWQ6IG1SYW5kU2VlZCxcblxuICAgIGFycmF5U2h1ZmZsZShvcHRpb25zKSB7XG4gICAgICBjb25zdCB7YXJyLCBzYW1wbGVTaXplfSA9IG9wdGlvbnM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZVNpemU7IGkrKykge1xuXG4gICAgICAgIHRoaXMuc2VlZCA9ICgyMTQwMTMgKiB0aGlzLnNlZWQgKyAyNTMxMDExKSAlICgxIDw8IDMxKTtcbiAgICAgICAgbGV0IGsgPSAodGhpcy5zZWVkID4+IDE2KSAmIDB4N2ZmZjtcbiAgICAgICAgayA9IGsgJSBhcnIubGVuZ3RoO1xuXG4gICAgICAgIGxldCB0bXAgPSBhcnJbaV07XG4gICAgICAgIGFycltpXSA9IGFycltrXTtcbiAgICAgICAgYXJyW2tdID0gdG1wO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBuZXh0SW50KG1heFZhbHVlKSB7XG4gICAgICB0aGlzLnNlZWQgPSAoMjE0MDEzICogdGhpcy5zZWVkICsgMjUzMTAxMSkgJSAoMSA8PCAzMSk7XG4gICAgICBsZXQgayA9ICh0aGlzLnNlZWQgPj4gMTYpICYgMHg3ZmZmO1xuICAgICAgayA9IGsgJSBtYXhWYWx1ZTtcbiAgICAgIHJldHVybiBrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmFuZG9taXplcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZVJhbmRvbWl6ZXJcbn1cbiIsImNvbnN0IHtDb250cm9sbGVyfSA9IHJlcXVpcmUoJy4vY29udHJvbGxlcicpO1xuY29uc3Qge0NvbXBpbGVyfSA9IHJlcXVpcmUoJy4vY29tcGlsZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuTUlOREFSID0ge1xuICBDb250cm9sbGVyLFxuICBDb21waWxlclxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==